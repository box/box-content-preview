(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory(require("THREE"));
	else if(typeof define === 'function' && define.amd)
		define("Box3D", ["THREE"], factory);
	else if(typeof exports === 'object')
		exports["Box3D"] = factory(require("THREE"));
	else
		root["Box3D"] = factory(root["THREE"]);
})(this, function(__WEBPACK_EXTERNAL_MODULE_1__) {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 262);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony export (immutable) */ __webpack_exports__["__extends"] = __extends;
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "__assign", function() { return __assign; });
/* harmony export (immutable) */ __webpack_exports__["__rest"] = __rest;
/* harmony export (immutable) */ __webpack_exports__["__decorate"] = __decorate;
/* harmony export (immutable) */ __webpack_exports__["__param"] = __param;
/* harmony export (immutable) */ __webpack_exports__["__metadata"] = __metadata;
/* harmony export (immutable) */ __webpack_exports__["__awaiter"] = __awaiter;
/* harmony export (immutable) */ __webpack_exports__["__generator"] = __generator;
/* harmony export (immutable) */ __webpack_exports__["__exportStar"] = __exportStar;
/* harmony export (immutable) */ __webpack_exports__["__values"] = __values;
/* harmony export (immutable) */ __webpack_exports__["__read"] = __read;
/* harmony export (immutable) */ __webpack_exports__["__spread"] = __spread;
/* harmony export (immutable) */ __webpack_exports__["__asyncGenerator"] = __asyncGenerator;
/* harmony export (immutable) */ __webpack_exports__["__asyncDelegator"] = __asyncDelegator;
/* harmony export (immutable) */ __webpack_exports__["__asyncValues"] = __asyncValues;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
}

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
}

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
}

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
}

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
}

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
}

function __exportStar(m, exports) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}

function __values(o) {
    var m = typeof Symbol === "function" && o[Symbol.iterator], i = 0;
    if (m) return m.call(o);
    return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
};

function __read(o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};

function __spread() {
    for (var ar = [], i = 0; i < arguments.length; i++)
        ar = ar.concat(__read(arguments[i]));
    return ar;
};

function __asyncGenerator(thisArg, _arguments, generator) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var g = generator.apply(thisArg, _arguments || []), q = [], c, i;
    return i = { next: verb("next"), "throw": verb("throw"), "return": verb("return") }, i[Symbol.asyncIterator] = function () { return this; }, i;
    function verb(n) { return function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]), next(); }); }; }
    function next() { if (!c && q.length) resume((c = q.shift())[0], c[1]); }
    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(c[3], e); } }
    function step(r) { r.done ? settle(c[2], r) : r.value[0] === "yield" ? settle(c[2], { value: r.value[1], done: false }) : Promise.resolve(r.value[1]).then(r.value[0] === "delegate" ? delegate : fulfill, reject); }
    function delegate(r) { step(r.done ? r : { value: ["yield", r.value], done: false }); }
    function fulfill(value) { resume("next", value); }
    function reject(value) { resume("throw", value); }
    function settle(f, v) { c = void 0, f(v), next(); }
};

function __asyncDelegator(o) {
    var i = { next: verb("next"), "throw": verb("throw", function (e) { throw e; }), "return": verb("return", function (v) { return { value: v, done: true }; }) };
    return o = __asyncValues(o), i[Symbol.iterator] = function () { return this; }, i;
    function verb(n, f) { return function (v) { return { value: ["delegate", (o[n] || f).call(o, v)], done: false }; }; }
};

function __asyncValues(o) {
    if (!Symbol.asyncIterator) throw new TypeError("Symbol.asyncIterator is not defined.");
    var m = o[Symbol.asyncIterator];
    return m ? m.call(o) : typeof __values === "function" ? __values(o) : o[Symbol.iterator]();
};

/***/ }),
/* 1 */
/***/ (function(module, exports) {

module.exports = __WEBPACK_EXTERNAL_MODULE_1__;

/***/ }),
/* 2 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-unused-variable */
var RuntimeEvents_1 = __webpack_require__(27);
var functions_1 = __webpack_require__(5);
var BaseObject_1 = __webpack_require__(10);
var classComposer_1 = __webpack_require__(46);
/** Events bound to the component object */
var selfEvents = [
    { event: 'startup', method: 'onStartupInternal', skippable: false },
    { event: 'shutdown', method: 'onShutdownInternal', skippable: false },
    { event: 'awake', method: 'onAwake', skippable: true },
    { event: 'attributesChanged', method: 'onAttributesChanged', skippable: true }
];
/** Events bound to the attached entity object */
var entityEvents = [
    { event: 'load', method: 'onEntityLoaded', testMethod: 'isLoaded', skippable: true },
    { event: 'loadBase', method: 'onEntityReady', testMethod: 'isBaseLoaded', skippable: true },
    { event: 'loadDependencies', method: 'onDependenciesLoaded', testMethod: 'isDependenciesLoaded', skippable: true }
];
/** Events bound to the attached engine object */
var engineEventMap = [
    { event: 'preUpdate', method: 'onPreUpdate', skippable: true },
    { event: 'update', method: 'onUpdate', skippable: true },
    { event: 'postUpdate', method: 'onPostUpdate', skippable: true },
    { event: 'preRender', method: 'onPreRender', skippable: true },
    { event: 'render', method: 'onRender', skippable: true },
    { event: 'postRender', method: 'onPostRender', skippable: true },
    { event: 'preRenderView', method: 'onPreRenderView', skippable: true },
    { event: 'postRenderView', method: 'onPostRenderView', skippable: true },
    { event: 'blur', method: 'onSuspend', skippable: true },
    { event: 'focus', method: 'onResume', skippable: true }
];
exports.baseComponentMixins = classComposer_1.default({}, [RuntimeEvents_1.default]);
/**
 * The base class for all components.
 */
var BaseComponent = (function (_super) {
    tslib_1.__extends(BaseComponent, _super);
    /**
     * Creates an instance of BaseComponent.
     */
    function BaseComponent() {
        var _this = _super.call(this) || this;
        /** Internal reference to input component, if it exists. */
        _this.input = undefined;
        _this.bindSelfEvents();
        return _this;
    }
    /**
     * Get the unique ID of this component
     * @returns The ID of this component
     */
    BaseComponent.prototype.getId = function () {
        return this.id;
    };
    /**
     * Get the index of this component in the entity's component list.
     * @returns The index of this component.
     */
    BaseComponent.prototype.getIndex = function () {
        return this.getEntity().components.indexOf(this);
    };
    /**
     * Get the name for this component
     * @returns The name of this component
     */
    BaseComponent.prototype.getName = function () {
        return this.name;
    };
    /**
     * Get the script asset for this component
     * @returns The script asset
     */
    BaseComponent.prototype.getScriptAsset = function () {
        return this.getEngine().getAssetById(this.getScriptId());
    };
    /**
     * Get the script name of this component
     * @returns The script name
     */
    BaseComponent.prototype.getScriptName = function () {
        return this.getScriptAsset().getName();
    };
    /**
     * Get the script id of this component.
     * @returns The script id
     */
    BaseComponent.prototype.getScriptId = function () {
        return this.scriptId;
    };
    /**
     * Return the complete set of attribute values for this component, including inherited values
     * (from a prefab) and default values, if not overridden.
     * @returns All attribute values.
     */
    BaseComponent.prototype.getAttributes = function () {
        var _this = this;
        var scriptAttributes = this.getScriptAsset().getProperty('attributes');
        return functions_1.map(scriptAttributes, function (_attr, name) { return _this.getAttribute(name); });
    };
    /**
     * Return the complete set of previous attribute values for this component, including
     * inherited values (from a prefab) and default values, if not overridden.
     * @returns All previous attribute values.
     */
    BaseComponent.prototype.getPreviousAttributes = function () {
        var _this = this;
        var scriptAttributes = this.getScriptAsset().getProperty('attributes');
        return functions_1.map(scriptAttributes, function (_attr, name) { return _this.getPreviousAttribute(name); });
    };
    /**
     * Set the specified attribute to the specified value.
     * @param attrib          The attribute name
     * @param value           The new value for the attribute.
     * @param [silent=false]  Suppress change event.
     */
    BaseComponent.prototype.setAttribute = function (attrib, value, _silent) {
        var changes = {
            attributes: (_a = {},
                _a[attrib] = functions_1.deepClone(value),
                _a)
        };
        var dispatcher = this.getEngine().entityDispatcher;
        dispatcher.dispatchComponentChanged(this.entity.id, this.getIndex(), changes);
        var _a;
    };
    /**
     * Set the specified attributes on the component.
     * @param attributes      An object containing attribute names as keys and their
     * corresponding values.
     * @param [silent=false]  Suppress change event.
     */
    BaseComponent.prototype.setAttributes = function (attributes, _silent) {
        var changes = {
            attributes: functions_1.deepClone(attributes)
        };
        var dispatcher = this.getEngine().entityDispatcher;
        dispatcher.dispatchComponentChanged(this.entity.id, this.getIndex(), changes);
    };
    /**
     * Get the value of the specified attribute.
     * @param attribName  The attribute name
     * @returns           The saved attribute value.
     */
    BaseComponent.prototype.getAttribute = function (attribName) {
        // Look for the attribute in this component
        var entity = this.getEntity();
        var compDesc = entity.getComponentDescriptorById(this.getId());
        if (compDesc.attributes.hasOwnProperty(attribName)) {
            return compDesc.attributes[attribName];
        }
        else if (entity instanceof BaseObject_1.default) {
            // Otherwise, look in the entity's prefab for the attribute value.
            var prefabObj = entity.getPrefabObject();
            if (prefabObj) {
                var prefComp = prefabObj.getComponentById(this.getId());
                if (prefComp) {
                    return prefComp.getAttribute(attribName);
                }
            }
        }
        // If we didn't find an override value, return the default for this attribute.
        return this.getScriptAsset().getAttributeDefault(attribName);
    };
    /**
     * Get the previous value of the specified attribute.
     * @param attribName  The attribute name
     * @returns           The previous attribute value.
     */
    BaseComponent.prototype.getPreviousAttribute = function (attribName) {
        // Look for the attribute in this component
        var entity = this.getEntity();
        var compDesc = entity.getPreviousComponentDescriptorById(this.getId());
        if (compDesc && compDesc.attributes.hasOwnProperty(attribName)) {
            return compDesc.attributes[attribName];
        }
        else if (entity instanceof BaseObject_1.default) {
            // Otherwise, look in the entity's prefab for the attribute value.
            var prefabObj = entity.getPrefabObject();
            if (prefabObj) {
                var prefComp = prefabObj.getComponentById(this.getId());
                if (prefComp) {
                    return prefComp.getPreviousAttribute(attribName);
                }
            }
        }
        // If we didn't find an override value, return the default for this attribute.
        return this.getScriptAsset().getAttributeDefault(attribName);
    };
    /**
     * Returns the BaseEntity that the component is attached to
     * @returns The BaseEntity which this component is attached to.
     */
    BaseComponent.prototype.getEntity = function () {
        return this.entity;
    };
    /**
     * Returns the engine that the component is running in.
     * @returns The engine.
     */
    BaseComponent.prototype.getEngine = function () {
        return this.entity.engine;
    };
    /**
     * Enables the component. Fires an 'enable' event on the component and calls
     * the component's 'onEnable' function.
     */
    BaseComponent.prototype.enable = function () {
        if (!this.enabled) {
            this.enabled = true;
            this.onEnable();
            this.trigger('enable');
        }
    };
    /**
     * Disables the component. Fires a 'disable' event on the component and calls
     * the component's 'onDisable' function.
     */
    BaseComponent.prototype.disable = function () {
        if (this.enabled) {
            this.enabled = false;
            this.onDisable();
            this.trigger('disable');
        }
    };
    /**
     * Disables the component if it was enabled. Enables the component if it was disabled.
     */
    BaseComponent.prototype.toggle = function () {
        if (this.enabled) {
            this.disable();
        }
        else {
            this.enable();
        }
    };
    /**
     * Register a dependent entity on the entity that owns this component.
     * @param entity An entity that is required by this component.
     */
    BaseComponent.prototype.registerDependency = function (entity) {
        this.getEntity().registerDependency(entity);
    };
    /**
     * Unregister a dependent entity on the entity that owns this component.
     * @param entity The entity to unregister.
     */
    BaseComponent.prototype.unregisterDependency = function (entity) {
        this.getEntity().unregisterDependency(entity);
    };
    /**
     * Check whether the component is enabled or not.
     * @returns Whether the component is enabled or not.
     */
    BaseComponent.prototype.isEnabled = function () {
        return this.enabled;
    };
    /**
     * Check if runtimeData exists.
     * @returns Whether or not the runtimeData object exists.
     */
    BaseComponent.prototype.hasRuntimeData = function () {
        return !!(this.entity && this.entity.runtimeData);
    };
    /**
     * Returns the three.js data attached to the entity.
     * @returns The three.js data for the entity.
     */
    BaseComponent.prototype.getRuntimeData = function () {
        return this.entity.runtimeData;
    };
    /**
     * Returns the global event system.
     * @returns The global RuntimeEvents instance.
     */
    BaseComponent.prototype.getGlobalEvents = function () {
        return this.entity.engine.globalEvents;
    };
    /**
     * Returns the Box3D rendering component currently being used by the Box3D engine.
     * @returns The Renderer component.
     */
    BaseComponent.prototype.getRenderer = function () {
        return this.getEngine().getRenderer();
    };
    /**
     * Returns the WebGLRenderer currently being used by the Box3D engine.
     * @returns The THREE.WebGLRenderer object.
     */
    BaseComponent.prototype.getThreeRenderer = function () {
        var renderer = this.getEngine().getRenderer();
        if (renderer) {
            return renderer.threeRenderer;
        }
        return null;
    };
    /**
     * Returns the Input handler being used by the object's engine
     * @returns The input controller component
     */
    BaseComponent.prototype.getInput = function () {
        if (!this.input) {
            var application = this.getEngine().getApplication();
            this.input = application.getComponentByScriptName('Input');
        }
        return this.input;
    };
    /**
     * Returns the object at the top of the hierarchy that this component's entity
     * is a part of. If this component's entity is a non-prefab asset, this will return null.
     * @returns the root object
     */
    BaseComponent.prototype.getRootObject = function () {
        if (this.entity instanceof BaseObject_1.default) {
            return this.entity.getRootObject();
        }
        return null;
    };
    /**
     * Returns the THREE.Object3D at the top of the hierarchy that this component's entity
     * is a part of. If this component's entity is a non-prefab asset, this will return null.
     * @returns the THREE.Object3D object
     */
    BaseComponent.prototype.getRootThreeObject = function () {
        if (this.entity instanceof BaseObject_1.default) {
            var rootObject = this.entity.getRootObject();
            return rootObject ? rootObject.runtimeData : null;
        }
        return null;
    };
    /** Forces the component to remove and re-add itself */
    BaseComponent.prototype.reload = function () {
        var scriptId = this.getScriptId();
        var attributes = this.getEntity()
            .getComponentDescriptor(function (component) { return component.scriptId === scriptId; }).attributes;
        var name = this.getName();
        this.getEntity().removeComponent(this);
        this.getEntity().addComponent(scriptId, attributes, name);
    };
    /**
     * Called when the component is first created.
     */
    BaseComponent.prototype.onAwake = function () {
        // nothing
    };
    /**
     * Called after the entity that this component is attached to starts to load.
     */
    BaseComponent.prototype.onStartup = function () {
        // nothing
    };
    /**
     * Called when the component or entity is unloaded
     */
    BaseComponent.prototype.onShutdown = function () {
        // nothing
    };
    /**
     * Called immediately before onUpdate.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onPreUpdate = function (delta) {
        // nothing
    };
    /**
     * Main update.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onUpdate = function (delta) {
        // nothing
    };
    /**
     * Called immediately after onUpdate.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onPostUpdate = function (delta) {
        // nothing
    };
    /**
     * Called just before rendering a frame.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onPreRender = function (delta) {
        // nothing
    };
    /**
     * Called at the time of rendering a frame.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onRender = function (delta) {
        // nothing
    };
    /**
     * Called immediately after rendering a frame.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onPostRender = function (delta) {
        // nothing
    };
    /**
     * Called just before rendering a view from each camera. Use this to run view-specific logic.
     * @param scene   The scene that is being rendered.
     * @param camera  The camera that is being rendered from.
     */
    BaseComponent.prototype.onPreRenderView = function (scene, camera) {
        // nothing
    };
    /**
     * Called just after rendering a view from each camera. Use this to run view-specific logic.
     * @param scene   The scene that is being rendered.
     * @param camera  The camera that is being rendered from.
     */
    BaseComponent.prototype.onPostRenderView = function (scene, camera) {
        // nothing
    };
    /** Called when the application loses focus */
    BaseComponent.prototype.onSuspend = function () {
        // nothing
    };
    /** Called when the application regains focus */
    BaseComponent.prototype.onResume = function () {
        // nothing
    };
    /**
     * Called when a component's attribute values change.
     * @param changes An array containing the names of all the attributes whose values
     *                have changed.
     */
    BaseComponent.prototype.onAttributesChanged = function (changes) {
        // nothing
    };
    /**
     * Called when the entity's runtime data (three.js data) is created and ready to use.
     * Note that all of the entity's children and dependencies (like materials, textures, etc.)
     * may not yet be loaded.
     */
    BaseComponent.prototype.onEntityReady = function () {
        // nothing
    };
    /** Called when the entity is completely loaded, including all of its dependencies. */
    BaseComponent.prototype.onEntityLoaded = function () {
        // nothing
    };
    /**
     * Called when all dependencies of the entity are loaded, including all of its children
     * and dependencies like textures, geometry, etc.
     */
    BaseComponent.prototype.onDependenciesLoaded = function () {
        // nothing
    };
    /** Called when component is enabled. */
    BaseComponent.prototype.onEnable = function () {
        // nothing
    };
    /** Called when component is disabled. */
    BaseComponent.prototype.onDisable = function () {
        // nothing
    };
    /** Internal startup, binds events and then calls user startup. */
    BaseComponent.prototype.onStartupInternal = function () {
        var _this = this;
        // Bind the component to engine events.
        engineEventMap.forEach(function (eventDef) {
            return _this.eventBindHelper(_this.getEngine(), eventDef);
        });
        // Bind the component to entity events.
        entityEvents.forEach(function (eventDef) {
            return _this.eventBindHelper(_this.getEntity(), eventDef);
        });
        this.onStartup();
        if (this.isEnabled()) {
            this.onEnable();
        }
    };
    /** Internal shutdown, unbind events and then calls user shutdown. */
    BaseComponent.prototype.onShutdownInternal = function () {
        // Unbind any events that we are listening to
        this.stopListening();
        this.onShutdown();
        // Re-bind to own events
        this.bindSelfEvents();
    };
    /**
     * A helper method for binding to events based on an event definition.
     * @param target    The target object
     * @param eventDef  The event binding definition
     */
    BaseComponent.prototype.eventBindHelper = function (target, eventDef) {
        if (typeof this[eventDef.method] !== 'function') {
            return;
        }
        if (eventDef.skippable && this[eventDef.method] === BaseComponent.prototype[eventDef.method]) {
            return;
        }
        this.listenTo(target, eventDef.event, this[eventDef.method]);
        // If the event should already have been triggered, immediately
        // call the callback function.
        if (eventDef.testMethod) {
            if (target[eventDef.testMethod]()) {
                this[eventDef.method]();
            }
        }
    };
    /** Bind to the events triggered on the component event system. */
    BaseComponent.prototype.bindSelfEvents = function () {
        var _this = this;
        selfEvents.forEach(function (eventDef) { return _this.eventBindHelper(_this, eventDef); });
    };
    return BaseComponent;
}(exports.baseComponentMixins));
exports.default = BaseComponent;


/***/ }),
/* 3 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var log = __webpack_require__(258);
exports.default = log;


/***/ }),
/* 4 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Ajv = __webpack_require__(229);
var functions_1 = __webpack_require__(5);
var Logger_1 = __webpack_require__(3);
// These are common pre-requisites for the larger schemas.
var refSchemas = [
    'accessor.json',
    'animationChannel.json',
    'animationClip.json',
    'animationLayer.json',
    'audioRepresentation.json',
    'box3.json',
    'commonImageProperties.json',
    'dracoAttribute.json',
    'imageRepresentation.json',
    'meshAttribute.json',
    'meshPrimitive.json',
    'representation.json',
    'shaderConditions.json',
    'shaderParameter.json',
    'vector3.json',
    'vector4.json',
    'videoRepresentation.json'
];
// Mapping of Entity Class -> schema file
var schemaMapping = {
    AnimationAsset: 'animationAssetProperties.json',
    ApplicationAsset: 'applicationAssetProperties.json',
    AudioAsset: 'audioAssetProperties.json',
    BufferAsset: 'bufferAssetProperties.json',
    DocumentAsset: 'documentAssetProperties.json',
    DracoGeometryAsset: 'dracoGeometryAssetProperties.json',
    ImageAsset: 'imageAssetProperties.json',
    MaterialAsset: 'materialAssetProperties.json',
    MeshGeometryAsset: 'meshGeometryAssetProperties.json',
    PrefabAsset: 'prefabAssetProperties.json',
    PrimitiveGeometryAsset: 'primitiveGeometryAssetProperties.json',
    RenderTexture2DAsset: 'renderTexture2DAssetProperties.json',
    RenderTextureCubeAsset: 'renderTextureCubeAssetProperties.json',
    ScriptAsset: 'scriptAssetProperties.json',
    ShaderAsset: 'shaderAssetProperties.json',
    SkinAsset: 'skinAssetProperties.json',
    Texture2DAsset: 'texture2DAssetProperties.json',
    TextureCubeAsset: 'textureCubeAssetProperties.json',
    VideoAsset: 'videoAssetProperties.json',
    BoneObject: 'boneObjectProperties.json',
    CameraObject: 'cameraObjectProperties.json',
    LightObject: 'lightObjectProperties.json',
    MeshObject: 'meshObjectProperties.json',
    NodeObject: 'nodeObjectProperties.json',
    SceneObject: 'sceneObjectProperties.json'
};
var schemas = new Ajv({ useDefaults: true });
// Load and register the pre-requisite schemas.
functions_1.forEach(refSchemas, function (schemaName) {
    return schemas.addSchema(__webpack_require__(192)("./" + schemaName.replace('.json', '.ts')).default, schemaName);
});
// Load the per type schemas, caching in schemaSource by schema name.
var schemaSource = functions_1.values(schemaMapping).reduce(function (acc, schemaName) {
    acc[schemaName] = __webpack_require__(192)("./" + schemaName.replace('.json', '.ts')).default;
    return acc;
}, {});
// Register the loaded per type schemas.
functions_1.forEach(schemaSource, function (schema, schemaName) {
    schemas.addSchema(schema, schemaName);
});
/**
 * Gets the default properties for a specified schema.
 * @export
 * @param {string} schemaName
 * @returns {Object|Array}
 */
function getPropertyDefaultsForSchema(schemaName) {
    if (!schemaSource[schemaName] || !schemaSource[schemaName].properties) {
        throw new Error('Unknown schema: ' + schemaName);
    }
    var schema = schemas.getSchema(schemaName);
    var defaults = {};
    schema(defaults);
    return defaults;
}
exports.getPropertyDefaultsForSchema = getPropertyDefaultsForSchema;
/**
 * Gets separate, per-property validators for a given schema.
 * @export
 * @param {string} schemaName
 * @returns {Object}
 */
function getPropertyValidatorsForSchema(schemaName) {
    if (!schemaSource[schemaName] || !schemaSource[schemaName].properties) {
        throw new Error('Unknown schema: ' + schemaName);
    }
    return functions_1.map(schemaSource[schemaName].properties, function (schema, propertyName) {
        var computedName = schemaName + '-' + propertyName;
        var existingSchema = schemas.getSchema(computedName);
        if (!existingSchema) {
            schemas.addSchema(schema, computedName);
        }
        return existingSchema || schemas.getSchema(computedName);
    });
}
exports.getPropertyValidatorsForSchema = getPropertyValidatorsForSchema;
/**
 * Get the validator for a given schema.
 * @export
 * @param {string} schemaName
 * @returns {function}
 */
function getValidatorForSchema(schemaName) {
    return schemas.getSchema(schemaName);
}
exports.getValidatorForSchema = getValidatorForSchema;
/**
 * Attaches the validators and default properties to a given EntityConstructor.
 * @export
 * @param {string} name
 * @param {EntityConstructor<any>} constructor
 */
function addSchemas(name, constructor) {
    var schemaFile = schemaMapping[name];
    if (schemaFile) {
        constructor.validators = getPropertyValidatorsForSchema(schemaFile);
        constructor.defaults = getPropertyDefaultsForSchema(schemaFile);
    }
    else {
        Logger_1.default.warn("No schema file available for " + name);
        constructor.validators = {};
        constructor.defaults = {};
    }
}
exports.addSchemas = addSchemas;
exports.default = schemas;


/***/ }),
/* 5 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Returns a new Object with each element (el) of 'object' filled with the return
 * value of fn(el). This preserves the shape of 'object'. i.e. the data type and number
 * of elements of the return value is the same as 'object'.
 * @param {Object} object The object to run the mapping on. Can be an array or POJO
 * @return {Object} The mapped object.
 */
exports.map = function (object, fn, context) {
    if (object === undefined || object === null) {
        return;
    }
    if (Array.isArray(object)) {
        return object.map(fn);
    }
    return Object.keys(object).reduce(function (newObj, key) {
        newObj[key] = (context ? fn.bind(context) : fn)(object[key], key);
        return newObj;
    }, {});
};
/**
 * Iterates over a collection running the provided function for each element.
 * @param {Mixed} object The object or array to iterate.
 * @param {Function} fn The function to be called for each element.
 * @param {Mixed} [context] The context to be used when calling `fn`.
 * @returns {Void}
 */
exports.forEach = function (object, fn, context) {
    if (object === undefined || object === null) {
        return;
    }
    if (Array.isArray(object)) {
        return object.forEach(fn, context);
    }
    return Object.keys(object).forEach(function (key) {
        (context ? fn.bind(context) : fn)(object[key], key);
    });
};
/**
 * Returns an array of values from an object, effectively converting an object
 * into an array while discarding the keys.
 * @param {Object} object The object from which to extract the values.
 * @returns {Array} The array of values
 */
exports.values = function (object) {
    if (object === undefined || object === null) {
        return;
    }
    if (Array.isArray(object)) {
        return object;
    }
    return Object.keys(object).reduce(function (arr, key) {
        arr.push(object[key]);
        return arr;
    }, []);
};
/**
 * Returns a deep clone of the given data. This method doesn't copy
 * functions and is intended for POJO's and primitive types.
 * @param {mixed} json The data to clone.
 * @return {mixed} The cloned data.
 */
exports.deepClone = function (data) {
    switch (typeof data) {
        case 'object':
            return JSON.parse(JSON.stringify(data));
        case 'function':
            return undefined;
        default:
            return data;
    }
};
/**
 * Returns true if the values are equal down to one level of depth.
 * @return True iff the values are equal.
 */
exports.shallowEquals = function (value1, value2) {
    if (value1 === value2) {
        return true;
    }
    else if (typeof value1 !== 'object') {
        return false;
    }
    // If a property of value1 doesn't exist in value2 or isn't equal, return false.
    // Ditto for a property of value2.
    return !(Object.keys(value1).some(function (key) {
        return !value2.hasOwnProperty(key) || value1[key] !== value2[key];
    }) || Object.keys(value2).some(function (key) {
        return !value1.hasOwnProperty(key) || value1[key] !== value2[key];
    }));
};


/***/ }),
/* 6 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseEntity_1 = __webpack_require__(9);
/**
 * The base class asset.
 */
var BaseAsset = (function (_super) {
    tslib_1.__extends(BaseAsset, _super);
    function BaseAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    BaseAsset.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.on('triggerLoad', this.load, this);
    };
    /** @inheritdoc */
    BaseAsset.prototype.uninitialize = function () {
        this.off('triggerLoad', this.load, this);
        // Uninitialize this asset ( will force unload the asset and its children)
        _super.prototype.uninitialize.call(this);
    };
    /**
     * Returns the asset with the provided Id, if it exists.
     * @param assetId The ID of the asset
     * @returns       The asset or null if not found.
     */
    BaseAsset.prototype.getAssetById = function (assetId) {
        return this.engine.getAssetById(assetId);
    };
    /** @inheritdoc */
    BaseAsset.prototype.unload = function () {
        // abort xhr request associated with this
        this.abortRequests();
        _super.prototype.unload.call(this);
    };
    /** Destroys the asset and causes any instances of the asset to be removed. */
    BaseAsset.prototype.destroy = function () {
        this.engine.trigger(this.type + 'Deleted', this.id);
        this.engine.destroyAsset(this);
    };
    /** @inheritdoc */
    BaseAsset.prototype.clone = function (id) {
        var clonedAsset = _super.prototype.clone.call(this, id);
        clonedAsset.set('representations', this.get('representations'));
        return clonedAsset;
    };
    return BaseAsset;
}(BaseEntity_1.default));
/** @inheritdoc */
BaseAsset.events = {
    triggerLoad: {
        scope: 'local',
        params: [],
        action: true,
        category: 'Loading'
    }
};
exports.default = BaseAsset;


/***/ }),
/* 7 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseEntity_1 = __webpack_require__(40);
var baseAsset = tslib_1.__assign({}, baseEntity_1.default, { id: 'baseAsset', title: 'BaseAssetDef', properties: tslib_1.__assign({}, baseEntity_1.default.properties, { properties: {
            $ref: 'baseAssetProperties.json'
        }, representations: {
            type: 'array',
            description: 'Available representations for the asset.',
            items: {
                $ref: 'representation.json'
            }
        } }) });
exports.default = baseAsset;


/***/ }),
/* 8 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseEntityProperties_1 = __webpack_require__(41);
var baseAssetProperties = tslib_1.__assign({}, baseEntityProperties_1.default, { id: 'baseAssetProperties', title: 'BaseAssetPropertiesDef' });
exports.default = baseAssetProperties;


/***/ }),
/* 9 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-bitwise */
/* tslint:disable prefer-for-of */
/* tslint:disable max-file-line-count */
var uuid_1 = __webpack_require__(18);
var Logger_1 = __webpack_require__(3);
var RuntimeEvents_1 = __webpack_require__(27);
var DependencyRegistry_1 = __webpack_require__(199);
var ComponentRegistry_1 = __webpack_require__(198);
var ResourceLifecycle_1 = __webpack_require__(216);
var classComposer_1 = __webpack_require__(46);
var functions_1 = __webpack_require__(5);
exports.baseEntityMixins = classComposer_1.default({}, [
    ComponentRegistry_1.default,
    DependencyRegistry_1.default,
    RuntimeEvents_1.default,
    ResourceLifecycle_1.default
]);
var State;
(function (State) {
    State[State["Destroyed"] = 1] = "Destroyed";
    State[State["Pending"] = 2] = "Pending";
    State[State["InProgress"] = 4] = "InProgress";
    State[State["Partial"] = 8] = "Partial";
    State[State["Succeeded"] = 16] = "Succeeded";
    State[State["Aborted"] = 32] = "Aborted";
    State[State["Failed"] = 64] = "Failed";
})(State = exports.State || (exports.State = {}));
var StateType;
(function (StateType) {
    StateType[StateType["Base"] = 0] = "Base";
    StateType[StateType["Dependencies"] = 1] = "Dependencies";
})(StateType = exports.StateType || (exports.StateType = {}));
/**
 * The base class for all objects and assets in the engine.
 */
var BaseEntity = (function (_super) {
    tslib_1.__extends(BaseEntity, _super);
    /**
     * Creates an instance of BaseEntity.
     * @param jsonDesc  The json descriptor the this entity.
     * @param runtime   The engine instance that this entity belongs to.
     */
    function BaseEntity(jsonDesc, engine) {
        var _this = _super.call(this) || this;
        /** Events added to this entity by attached components. */
        _this.events = {};
        _this.engine = engine;
        // StateType.BASE, StateType.DEPENDENCIES
        _this.state = [State.Pending, State.Pending];
        _this.runtimeData = undefined;
        _this.sharedData = undefined;
        // TODO - id and type should be defined as getters that grab the value from
        // internal, private data.
        _this.id = jsonDesc.id;
        _this.type = jsonDesc.type;
        _this.sharedData = jsonDesc;
        return _this;
    }
    /**
     * Returns true if the given state indicates that loading is complete,
     * regardless of whether the load was successful or not.
     * @param state A state value to check against
     * @returns     True if the state indicates that loading is finished.
     */
    BaseEntity.checkLoadFinished = function (state) {
        var finishedState = State.Succeeded | State.Failed
            | State.Aborted;
        return !!(finishedState & state);
    };
    /**
     * Marks the loading state of the entity and updates any other entity's state if appropriate.
     * e.g. If an entity is loaded, the parent entity may need its children state set to loaded.
     * @param stateType The state type to mark. Values are from StateType.
     * @param state     The state to set. Values are from State.
     */
    BaseEntity.prototype.setState = function (stateType, state) {
        if (!state) {
            return;
        }
        var previousState = this.state[stateType];
        this.state[stateType] = state;
        switch (state) {
            case State.Pending:
                if (this.isUnloaded()) {
                    this.trigger('unload', this);
                }
                if (stateType === StateType.Dependencies && previousState !== state) {
                    this.trigger('loadStateChange', this);
                }
                break;
            case State.InProgress:
            case State.Partial:
                if (stateType === StateType.Dependencies && previousState !== state) {
                    this.trigger('loadStateChange', this);
                }
                break;
            case State.Succeeded:
            case State.Failed:
            case State.Aborted:
                // Fire the appropriate load event
                switch (stateType) {
                    case StateType.Base:
                        this.trigger('loadBase', this);
                        break;
                    case StateType.Dependencies:
                        this.trigger('loadDependencies', this);
                        break;
                    default:
                }
                if (previousState !== state) {
                    this.trigger('loadStateChange', this);
                }
                // If this entity isn't finished loading then it won't affect the parent's state.
                if (!this.isLoaded()) {
                    return;
                }
                this.trigger('load', this);
                break;
            default:
                throw Error("Unknown state " + state);
        }
    };
    /**
     * After entity creation and registration, initialize is called to setup event
     * bindings as well as create components and register dependencies. The reason
     * that 'initialize' is separate from creation is that dependencies (including
     * scripts) may not be created and registered at the time when the entity is.
     */
    BaseEntity.prototype.initialize = function () {
        this.on('change:properties', this.propertyChanged, this);
        this.on('startTimer', this.startTimer, this);
        this.initializeProperties();
        this.initializeComponents();
    };
    /**
     * Unbind events, unregister dependencies, cleanup components, etc.
     * Note that this is different than destroying an entity. Destroying an entity
     * is a public function and removes the entity from all engines. 'uninitialize'
     * should not be called outside of the engine.
     */
    BaseEntity.prototype.uninitialize = function () {
        // Stop listening to events bound with this.listenToOnce, this.listenTo, etc.
        this.stopListening();
        this.off('startTimer', this.startTimer, this);
        this.off('change:properties', this.propertyChanged, this);
        this.unregisterDependencies();
        this.unload();
        for (var i = 0; i < this.state.length; i++) {
            this.state[i] = State.Destroyed;
        }
        this.runtimeData = null;
    };
    /**
     * Called when an entity is initialized. This ensures that an event is triggered
     * for all the initial properties being set.
     */
    BaseEntity.prototype.initializeProperties = function () {
        var _this = this;
        var properties = this.getProperties();
        Object.keys(properties).forEach(function (key) {
            var value = properties[key];
            if (!_this.verifyProperty(key, value)) {
                Logger_1.default.warn("Property \"" + key + "\" on \"" + _this.constructor.name + "\" does not exist or has an " +
                    ("invalid value of \"" + JSON.stringify(value, null, 2) + "\"."));
            }
        });
        this.applyPropertiesUnloaded(properties);
    };
    /**
     * Get the name of the entity
     * @returns {String} The entity's name
     */
    BaseEntity.prototype.getName = function () {
        return this.getProperty('name');
    };
    /**
     * Get the "Scoped" ID for the entity. The sid is usually used for name references that must be
     * unique within the scope of a particular hierarchy. e.g. animations referencing bones by name,
     * etc. The scoped ID may not be unique across an entire asset (e.g. with more than one animating
     * character in a scene).
     * @returns {String} The entity's sId
     */
    BaseEntity.prototype.getSid = function () {
        return this.get('sid');
    };
    /**
     * Set the name of the entity
     * @param newName         The entity's new name
     * @param [silent=false]  Suppress change event.
     */
    BaseEntity.prototype.setName = function (newName, silent) {
        this.setProperty('name', newName, silent);
    };
    /**
     * Set the "Scoped" ID for the entity. The sid is usually used for name references that must be
     * unique within the scope of a particular hierarchy. e.g. animations referencing bones by name,
     * etc. The scoped ID may not be unique across an entire asset (e.g. with more than one animating
     * character in a scene).
     * @param newId           The entity's new scoped ID
     * @param [silent=false]  Suppress change event.
     */
    BaseEntity.prototype.setSid = function (newId, silent) {
        this.set('sid', newId, silent);
    };
    /**
     * Get an attribute value for the entity.
     * @param attrib  The name of the attribute
     * @returns       The attribute's value
     */
    BaseEntity.prototype.get = function (attrib) {
        return this.sharedData[attrib];
    };
    /**
     * Set an attribute value for the entity.
     * @param attrib  The name of the attribute
     * @param value   Value of attribute
     */
    BaseEntity.prototype.set = function (attrib, value, _silent) {
        this.engine.entityDispatcher.dispatchAttributeChanged(this.id, attrib, value);
    };
    /**
     * Delete an attribute value for the entity.
     * @param attrib          The name of the attribute
     * @param [silent=false]  Suppress change event.
     */
    BaseEntity.prototype.unset = function (attrib, _silent) {
        if (this.sharedData.hasOwnProperty(attrib)) {
            delete this.sharedData[attrib];
        }
        this.engine.entityDispatcher.dispatchAttributeChanged(this.id, attrib, undefined);
    };
    /**
     * Verifies a given property by name with the given value against the schema.
     * @param propertyName  The property name
     * @param value         The property value
     * @returns             Whether or not the property is valid
     */
    BaseEntity.prototype.verifyProperty = function (propertyName, value) {
        if (!this.constructor.validators[propertyName]) {
            Logger_1.default.warn("No validator available for property: " + propertyName);
            return false;
        }
        var validator = (this.constructor.validators[propertyName]);
        var result = validator(value);
        if (!result) {
            Logger_1.default.warn("Verification failed for value \"" + JSON.stringify(value) + "\" " +
                ("for property \"" + propertyName + "\""));
            var errors = validator.errors;
            if (errors && errors instanceof Array) {
                Logger_1.default.warn(errors && errors[0]);
            }
        }
        return result;
    };
    /**
     * Set a new or existing property for this object.
     * @param propertyName    Name of the property to set.
     * @param value           Value of the property.
     * @param [silent=false]  Suppress change event.
     */
    BaseEntity.prototype.setProperty = function (propertyName, value, silent) {
        if (this.verifyProperty(propertyName, value)) {
            // Dispatch change event
            this.engine.entityDispatcher.dispatchPropertyChanged(this.id, propertyName, value, silent);
        }
    };
    /**
     * Remove an existing property from this object.
     * @param propertyName    Name of the property to remove.
     * @param [silent=false]  Suppress change event.
     */
    BaseEntity.prototype.unsetProperty = function (propertyName, silent) {
        this.engine.entityDispatcher
            .dispatchPropertyChanged(this.id, propertyName, undefined, silent);
    };
    /**
     * Set multiple new or existing properties for this object at once. This merges with
     * existing properties
     * @param properties      Key-value pairs of properties.
     * @param [silent=false]  Suppress change event.
     */
    BaseEntity.prototype.setProperties = function (properties, silent) {
        // TODO - verify  property values against schema.
        this.engine.entityDispatcher.dispatchPropertiesChanged(this.id, properties, silent);
    };
    /**
     * Returns the property of the object given by 'propertyName'.
     * This function only looks on the local entity and won't return
     * inherited values.
     * @method getOwnProperty
     * @param propertyName  The name of the property.
     * @returns             The property value
     */
    BaseEntity.prototype.getOwnProperty = function (propertyName) {
        return this.sharedData.properties[propertyName];
    };
    /**
     * Returns the previous value of the property specified by 'propertyName'
     * @param propertyName  The name of the property.
     * @returns             The property's previous value
     */
    BaseEntity.prototype.getPreviousProperty = function (propertyName) {
        var value = this.sharedData.previousProperties[propertyName];
        if (value !== undefined) {
            return value;
        }
        return this.getDefaultProperty(propertyName);
    };
    /**
     * Returns all properties of the entity. This function only looks on the
     * local entity and won't return inherited values.
     * @returns The properties
     */
    BaseEntity.prototype.getOwnProperties = function () {
        return this.sharedData.properties;
    };
    /**
     * Copy the properties of the given object to this object, overwriting
     * any of the same name.
     * @param object          The object to copy properties from.
     * @param [silent=false]  Suppress change event.
     */
    BaseEntity.prototype.copyProperties = function (object, silent) {
        this.setProperties(object.getOwnProperties(), silent);
    };
    /**
     * Copy the properties of the given object to this object, leaving
     * any of the same name unmodified.
     * @param object          The object to copy properties from.
     * @param [silent=false]  Suppress change event.
     */
    BaseEntity.prototype.mergeProperties = function (object, silent) {
        this.setProperties(tslib_1.__assign({}, object.getOwnProperties(), this.sharedData.properties), silent);
    };
    /**
     * Returns the default property of the object given by 'propertyName'
     * @param propertyName  The name of the property.
     * @returns             The property value
     */
    BaseEntity.prototype.getDefaultProperty = function (propertyName) {
        return functions_1.deepClone(this.constructor.defaults[propertyName]);
    };
    /**
     * Returns the default properties of the object given by 'propertyName'
     * @returns List of default values, keyed by property name.
     */
    BaseEntity.prototype.getDefaultProperties = function () {
        return functions_1.deepClone(this.constructor.defaults);
    };
    /**
     * Returns the property value specified by 'propertyName'.
     * @param propertyName  The name of the property.
     * @returns             The property value
     */
    BaseEntity.prototype.getProperty = function (propertyName) {
        var localProperty = this.getOwnProperty(propertyName);
        if (localProperty !== undefined) {
            return localProperty;
        }
        return this.getDefaultProperty(propertyName);
    };
    /**
     * Revert the property to its default value.
     * @param propertyName Name of the property to revert to default.
     */
    BaseEntity.prototype.revertProperty = function (propertyName) {
        this.unsetProperty(propertyName);
    };
    /**
     * Returns all properties of the entity, including those inherited from
     * the entity's prefab.
     * @returns The properties
     */
    BaseEntity.prototype.getProperties = function () {
        var myProperties = this.getOwnProperties();
        var propertiesObj = this.getDefaultProperties();
        return Object.assign(propertiesObj, myProperties);
    };
    /**
     * Clones the entity.
     * @param [id]  The new ID for the clone.
     * @returns     The newly-created clone
     */
    BaseEntity.prototype.clone = function (id) {
        var clonedEntity = this.engine.createEntityByClass(this.engine.getEntityClass(this.getType()), this.getOwnProperties(), id || uuid_1.v4());
        clonedEntity.set('sid', this.get('sid'));
        clonedEntity.setComponents(this.getComponentDescriptors());
        return clonedEntity;
    };
    /**
     * get the three data associated with this entity
     * @returns The Three.JS data attached to this BaseEntity. Can be things
     *          like THREE.Material, THREE.Object3D, THREE.PointLight, etc.
     *          See threejs.org/docs/
     */
    BaseEntity.prototype.getRuntimeData = function () {
        if (!this.runtimeData) {
            this.load();
        }
        return this.runtimeData;
    };
    /**
     * If the condition for specified event is met, immediately calls the callback. Otherwise,
     * listens for the event to be fired and then calls it. Useful for more concise code.
     * @param eventName The name of the event to listen for
     * @param callback  The callback function to call when the event occurs
     * @param [context] The context that the callback will be called in. This needs
     *                  to be another BaseEntity or something that inherits from
     *                  RuntimeEvents.
     */
    BaseEntity.prototype.when = function (eventName, callback, context) {
        if (typeof callback === 'function') {
            if (eventName === 'load' && this.isLoaded() ||
                eventName === 'loadBase' && this.isBaseLoaded() ||
                eventName === 'loadDependencies' && this.isDependenciesLoaded()) {
                callback.call(context, this);
            }
            else {
                if (context) {
                    context.listenToOnce(this, eventName, callback);
                }
                else {
                    this.once(eventName, callback, context);
                }
            }
        }
    };
    /**
     * Loads the Three.JS data for this entity and all of its dependencies. The following events
     * will be fired during this process:
     * 'load' - fired when the entity is loaded and all dependencies are either loaded
     * or have encountered an error.
     * 'loadBase' - fired when the data for just the base entity is loaded, not including any
     * dependencies (materials, textures, etc.).
     * 'loadDependencies' - fired when all the dependencies (objects, animations, textures, etc.)
     * for an entity have been loaded.
     * @param [callback] This function gets called when the final 'load' event is
     * triggered.
     */
    BaseEntity.prototype.load = function (callback) {
        var _this = this;
        this.when('load', function () {
            if (typeof callback === 'function') {
                callback(_this);
            }
        }, this);
        // Load this object
        this.loadBase();
        this.loadDependencies();
        if (this.checkIfOwnDependenciesLoaded()) {
            this.setState(StateType.Dependencies, State.Succeeded);
        }
    };
    /**
     * Resets the entity back to a default state.
     */
    BaseEntity.prototype.reset = function () {
        // nothing
    };
    /**
     * Total up this entity's current downloaded data size. Includes all dependencies of this entity.
     * Specify a class of entity to filter the dependencies that are considered.
     * @param [entityType]  The class of entity that you want to filter by.
     * @returns             The number of bytes currently loaded for this entity.
     */
    BaseEntity.prototype.getDataSizeLoaded = function (entityType) {
        return this.getDataSize('getDataSizeLoadedSelf', entityType);
    };
    /**
     * Total up the number of bytes that need to be downloaded when loading this entity.
     * This includes all dependencies of this entity.
     * Specify a class of entity to filter the dependencies that are considered.
     * @param [entityType]  The class of entity that you want to filter by.
     * @returns             The number of total bytes that will need to be
     *                      downloaded for this entity.
     */
    BaseEntity.prototype.getDataSizeDownload = function (entityType) {
        return this.getDataSize('getDataSizeDownloadSelf', entityType);
    };
    /**
     * Total up the amount of memory that this entity will need when loaded. Includes all dependencies of this entity.
     * Specify a class of entity to filter the dependencies that are considered.
     * @param [entityType]  The class of entity that you want to filter by.
     * @returns             The number of bytes of memory needed for this entity.
     */
    BaseEntity.prototype.getDataSizeInMemory = function (entityType) {
        return this.getDataSize('getDataSizeInMemorySelf', entityType);
    };
    /**
     * Return the number of bytes that will be downloaded directly by this entity
     * (not by a dependency) when loading.
     * @returns The number of bytes that need to be downloaded by this entity.
     */
    BaseEntity.prototype.getDataSizeDownloadSelf = function () {
        return 0;
    };
    /**
     * Return the number of bytes of memory needed directly by this entity
     * (not by a dependency) after loading.
     * @returns The number of bytes of memory needed by this entity.
     */
    BaseEntity.prototype.getDataSizeInMemorySelf = function () {
        return 0;
    };
    /**
     * Return the number of bytes loaded directly by this entity (not by a dependency) so far.
     * @returns The number of bytes downloaded by this entity so far.
     */
    BaseEntity.prototype.getDataSizeLoadedSelf = function () {
        return 0;
    };
    /**
     * Load runtime data for this entity alone, not child entities or
     * dependencies. This method triggers 'loadBase' when complete.
     * Calling this method after loading is complete causes the
     * method to trigger 'loadBase' again.
     * @param [callback] Called when loading is complete
     */
    BaseEntity.prototype.loadBase = function (callback) {
        var _this = this;
        if (this.isBaseLoaded()) {
            this.trigger('loadBase', this);
            if (typeof callback === 'function') {
                callback(this);
            }
        }
        else if (this.isBaseUnloaded()) {
            this.once('loadBase', callback, this);
            this.setState(StateType.Base, State.InProgress);
            this.startComponents();
            this.createRuntimeData(function () {
                if (_this.isDestroyed()) {
                    return;
                }
                // Apply the initial set of properties.
                _this.applyPropertiesLoaded(_this.getProperties(), 'init');
                if (_this.state[StateType.Base] <= State.Succeeded) {
                    _this.setState(StateType.Base, State.Succeeded);
                }
            });
        }
    };
    /**
     * Reload runtime data for this entity. This should be called by
     * subclasses when they wish to change the runtimeData reference.
     * This method invokes loadBase() to reload runtime data, so
     * 'loadBase' is triggered upon completion.
     * @param [callback] Called when loading is complete
     */
    BaseEntity.prototype.reloadBase = function (callback) {
        this.stopComponents();
        this.setState(StateType.Base, State.Pending);
        this.loadBase(function () {
            if (typeof callback === 'function') {
                callback();
            }
        });
    };
    /**
     * Returns the percentage of data that has already been loaded by this object and its
     * hierarchy.
     * @returns The number of bytes of data.
     */
    BaseEntity.prototype.getLoadingProgress = function () {
        // If the entity is marked as loaded, always return 100%
        if (this.isLoaded()) {
            return 1.0;
        }
        // Otherwise, calculate the progress.
        var loaded = this.getDataSizeLoaded();
        var total = this.getDataSizeDownload();
        if (total) {
            // The load hasn't been flagged as finished so clamp the return at 99.99%
            return Math.min(loaded / total, 0.999999);
        }
        // For entities that are loading but have no download size, just return
        // their progress as 99%.
        return this.isUnloaded() ? 0.0 : 0.99;
    };
    /**
     * Unload the entity.
     */
    BaseEntity.prototype.unload = function () {
        this.stopComponents();
        this.setState(StateType.Base, State.Pending);
        this.setState(StateType.Dependencies, State.Pending);
        this.runtimeData = null;
    };
    /**
     * Returns true iff the entity is unloaded (ignoring dependencies).
     * @returns True iff the entity is unloaded.
     */
    BaseEntity.prototype.isUnloaded = function () {
        return State.Pending === (State.Pending & this.state[StateType.Base]);
    };
    /**
     * Returns true if the three.js data is finished loading, including
     * all dependencies in this entity's hierarchy. Note that
     * a true value only means that the load is finished, not that it was
     * necessarily completely successful.
     * @returns True, if loading is finished
     */
    BaseEntity.prototype.isLoaded = function () {
        var finishedState = State.Succeeded | State.Failed | State.Aborted;
        for (var i = 0; i < this.state.length; i++) {
            if (!(finishedState & this.state[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Returns true if any part of the loading of this entity failed. Note that
     * failure is distinct from abortion. For example, if an asset is unloaded or
     * destroyed during the load, the load is considered to be aborted, not failed.
     * @returns Whether the load failed or not.
     */
    BaseEntity.prototype.isLoadFailed = function () {
        for (var i = 0; i < this.state.length; i++) {
            if (State.Failed & this.state[i]) {
                return true;
            }
        }
        return false;
    };
    /**
     * Returns true if the three.js data is in the process of loading, including all dependencies
     * in this entity's hierarchy.
     * @returns True, if loaded
     */
    BaseEntity.prototype.isLoading = function () {
        var combinedState = 0;
        for (var i = 0; i < this.state.length; i++) {
            combinedState |= this.state[i];
        }
        return combinedState & State.InProgress ? true : false;
    };
    /**
     * Returns true if the three.js data for this entity is loaded. This does not include
     * any dependencies (like materials, textures, etc.) in this entity's hierarchy.
     * @returns True, if the base three.js object is loaded
     */
    BaseEntity.prototype.isBaseLoaded = function () {
        return BaseEntity.checkLoadFinished(this.state[StateType.Base]);
    };
    /**
     * Returns true if the three.js data for this entity is unloaded. This does not include
     * any dependencies (like materials, textures, etc.) in this entity's hierarchy.
     * @returns True, if the base three.js object is unloaded
     */
    BaseEntity.prototype.isBaseUnloaded = function () {
        return this.state[StateType.Base] === State.Pending;
    };
    /**
     * Returns true if this entity has been destroyed.
     * @returns True, if the entity has been destroyed
     */
    BaseEntity.prototype.isDestroyed = function () {
        return this.state[StateType.Base] === State.Destroyed;
    };
    /**
     * Returns true if the three.js data for all assets referenced by this entity are loaded.
     * i.e. materials, textures, animations, etc.
     * @returns True, if the dependencies are all loaded
     */
    BaseEntity.prototype.isDependenciesLoaded = function () {
        return BaseEntity.checkLoadFinished(this.state[StateType.Dependencies]);
    };
    /**
     * Returns true if the three.js data for all assets referenced by this entity are unloaded.
     * i.e. materials, textures, animations, etc.
     * @returns True, if the dependencies are all unloaded
     */
    BaseEntity.prototype.isDependenciesUnloaded = function () {
        return State.Pending === this.state[StateType.Dependencies];
    };
    /**
     * Update runtime data based on property changes. This method is called in
     * two situations: during initialization (just before 'loadBase' is
     * triggered), and for property changes that occur between 'loadBase' and
     * 'unload'. When called during initialization, *all* properties will be
     * listed in the changes parameter. When overriding this method, always call
     * the super implementation first.
     * @param changes The names of properties that have changed
     * @param reason  One of: 'init' or 'propertyChanged'
     */
    BaseEntity.prototype.applyPropertiesLoaded = function (_changes, _reason) {
        // nothing
    };
    /**
     * Update the settings for the object that don't require the Three.JS data to exist.
     * This method is called after loading an object and whenever there is a change event fired.
     * @param changes The names of properties that have changed
     */
    BaseEntity.prototype.applyPropertiesUnloaded = function (_changes) {
        // nothing
    };
    /**
     * Get the type of the entity
     * @returns The entity's type
     */
    BaseEntity.prototype.getType = function () {
        return this.get('type');
    };
    /**
     * Get the description of the entity
     * @returns The entity's description
     */
    BaseEntity.prototype.getDescription = function () {
        return this.get('description');
    };
    /**
     * Set the description of the entity
     * @param newDescription  The entity's new description
     */
    BaseEntity.prototype.setDescription = function (newDescription) {
        return this.set('description', newDescription);
    };
    /**
     * Registers a component event.
     * @param name        The name of the event.
     * @param parameters  An array of parameters for the event.
     * @param scope       The scope of the event.
     * @param boolean     Whether or not this is considered an "Action"
     * @param string      The Category for this event.
     * @param filter      A list of types that this event is applicable for.
     */
    BaseEntity.prototype.registerComponentEvent = function (name, parameters, scope, action, category, filter) {
        if (scope === 'other') {
            if (filter && filter.length) {
                for (var i = 0; i < filter.length; i++) {
                    var type = filter[i];
                    var typeClass = this.engine.getEntityClass(type);
                    typeClass.events[name] = {
                        params: parameters,
                        action: action,
                        category: category
                    };
                }
            }
            else {
                BaseEntity.events[name] = {
                    params: parameters,
                    action: action,
                    category: category
                };
            }
        }
        else {
            this.events[name] = {
                params: parameters,
                action: action,
                category: category
            };
        }
    };
    /**
     * Removes a component event.
     * @param name  The name of the event.
     * @param scope The scope of the event.
     */
    BaseEntity.prototype.removeComponentEvent = function (name, scope) {
        if (scope === 'other') {
            var nodeObjectClass = this.engine.getEntityClass('node');
            if (nodeObjectClass.prototype.events[name]) {
                delete nodeObjectClass.prototype.events[name];
            }
        }
        else {
            if (this.events[name]) {
                delete this.events[name];
            }
        }
    };
    /**
     * Get a list of all events available on this entity.
     * @returns All of the available events.
     */
    BaseEntity.prototype.getEvents = function () {
        var events = {};
        Object.assign(events, events, this.events);
        var proto = Object.getPrototypeOf(this);
        while (proto) {
            if (proto.hasOwnProperty('events')) {
                Object.assign(events, events, proto.events);
            }
            proto = Object.getPrototypeOf(proto);
        }
        return events;
    };
    /**
     * Create runtime data for this entity. Upon successful completion,
     * call getRuntimeData() to retrieve the runtime data. Sub-classes should
     * override this method to initialize their runtime data.
     * @param [callback] Called when the runtime data is available
     */
    BaseEntity.prototype.createRuntimeData = function (callback) {
        // Default implementation invokes the callback.
        callback();
    };
    /**
     * Run through this entity's dependencies and total up the return value from the provided
     * function. This is used to calculate the data size of an entity and is called from the
     * specific public data size functions.
     * @param fnName        The name of the function to call on each entity.
     * @param [entityType]  The class of entity that you want to filter by.
     */
    BaseEntity.prototype.getDataSize = function (fnName, entityType) {
        // Get all dependencies
        var dependencies = this.getDependencies();
        return dependencies.reduce(function (total, dep) {
            if (entityType && !(dep instanceof entityType)) {
                return total;
            }
            return total + dep[fnName]();
        }, this[fnName]());
    };
    /**
     * Called when the entity's properties change and the object needs to be
     * updated to reflect the changes.
     * @param properties An object containing changed properties
     */
    BaseEntity.prototype.propertyChanged = function (properties) {
        if (BaseEntity.checkLoadFinished(this.state[StateType.Base])) {
            this.applyPropertiesLoaded(properties, 'propertyChanged');
        }
        this.applyPropertiesUnloaded(properties);
    };
    /**
     * Starts the timer.
     * @param time The amount of time until the endTimer event will be triggered.
     */
    BaseEntity.prototype.startTimer = function (time) {
        var _this = this;
        var elapsedTime = 0.0;
        var updateTimer = function (delta) {
            elapsedTime += delta;
            if (elapsedTime >= time) {
                _this.engine.off('update', updateTimer, _this);
                _this.trigger('endTimer');
            }
        };
        this.engine.on('update', updateTimer, this);
    };
    return BaseEntity;
}(exports.baseEntityMixins));
/** A mapping of event name to event descriptor of supported events by this entity type. */
BaseEntity.events = {
    load: {
        params: [],
        action: false,
        category: 'Loading'
    },
    loadBase: {
        params: [],
        action: false,
        category: 'Loading'
    },
    loadDependencies: {
        params: [],
        action: false,
        category: 'Loading'
    },
    startTimer: {
        params: [{
                name: 'time',
                description: 'The time (in seconds) that will elapse before the \'endTimer\' event ' +
                    'will be fired.',
                type: 'f',
                default: 5.0
            }],
        action: true,
        category: 'General'
    },
    endTimer: {
        params: [],
        action: false,
        category: 'General'
    }
};
/** A mapping of property names to validator functions */
BaseEntity.validators = {};
/** A mapping of property name to default value for properties on this entity type. */
BaseEntity.defaults = {};
exports.default = BaseEntity;


/***/ }),
/* 10 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-file-line-count */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseEntity_1 = __webpack_require__(9);
var BaseObject = (function (_super) {
    tslib_1.__extends(BaseObject, _super);
    function BaseObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    BaseObject.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.on('setVisible', this.setVisible, this);
        this.on('setInvisible', this.setInvisible, this);
        this.on('toggleVisibility', this.toggleVisibility, this);
        this.on('change:children', this.onChildrenChanged, this);
    };
    /** @inheritdoc */
    BaseObject.prototype.uninitialize = function () {
        this.off('setVisible', this.setVisible, this);
        this.off('setInvisible', this.setInvisible, this);
        this.off('toggleVisibility', this.toggleVisibility, this);
        this.off('change:children', this.onChildrenChanged, this);
        this.uninitPrefabBindings();
        _super.prototype.uninitialize.call(this);
    };
    /**
     * Returns the top-object (the root) of this object's hierarchy.
     * @returns The root object of this hierarchy.
     */
    BaseObject.prototype.getRootObject = function () {
        var parent = this.getParentObject();
        if (parent) {
            return parent.getRootObject();
        }
        return this;
    };
    /**
     * Reset the transform of the object from its internal data. i.e. If you have modified the Three.js
     * object data directly, you can call reset to return the transform to the state stored in the
     * Box3D entity.
     */
    BaseObject.prototype.reset = function () {
        if (!this.runtimeData) {
            return;
        }
        this.runtimeData.position.copy(this.getPosition());
        this.runtimeData.quaternion.copy(this.getQuaternion());
        this.runtimeData.scale.copy(this.getScale());
    };
    /** @inheritdoc */
    BaseObject.prototype.createRuntimeData = function (callback) {
        // Default implementation creates a THREE.Object3D.
        this.runtimeData = new THREE.Object3D();
        this.runtimeData.name = this.getRuntimeName();
        callback();
    };
    /**
     * Clones the object.
     * @param id        The new ID for the clone.
     * @param recursive If true, clone will also clone the entire hierarchy under
     * this object.
     * @returns         The newly-created clone
     */
    BaseObject.prototype.clone = function (_id, recursive) {
        if (recursive === void 0) { recursive = true; }
        // FIXME, does id even get used???
        var clonedObject = _super.prototype.clone.call(this);
        clonedObject.set('parentId', null);
        clonedObject.set('prefabAssetId', this.get('prefabAssetId'));
        clonedObject.set('prefabObjectId', this.get('prefabObjectId'));
        if (recursive) {
            var children = this.getChildren();
            children.forEach(function (child) {
                var newChild = child.clone(undefined, recursive);
                clonedObject.addChild(newChild);
            });
            // Only copy the prefab links if the top-level of the instance is being copied
            // If the top-level is copied, set the flag so that recursive calls will copy links.
            if (this.isInstanceTop()) {
                clonedObject.set('prefabInstanceId', clonedObject.id);
                clonedObject.traverse(function (obj) {
                    obj.set('prefabInstanceId', clonedObject.id);
                });
            }
        }
        return clonedObject;
    };
    /**
     * Align an object relative to a position. This uses the object's bounding box.
     * @param newPosition The position to work relative to.
     * @param [alignment] An object of the form { x: x, y: y, z: z} where the
     *                    values for x, y and z are between -1 and +1 and specify
     *                    how the object is aligned to the edges of the model. e.g.
     *                    { x: 0, y: -1, z: 0 } will align the bottom, centre of the
     *                    object to the specified position.
     */
    BaseObject.prototype.alignToPosition = function (newPosition, alignment) {
        var position = new THREE.Vector3(newPosition.x || 0, newPosition.y || 0, newPosition.z || 0);
        var quaternion = this.getQuaternion();
        var scale = this.getScale();
        var center = this.getCenter();
        var rotation = new THREE.Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
        var bounds = this.getBounds();
        var aabb = {};
        aabb.min = new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z);
        aabb.max = new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z);
        aabb.min.applyQuaternion(rotation);
        aabb.max.applyQuaternion(rotation);
        var offset = new THREE.Vector3(center.x, center.y, center.z);
        offset.applyQuaternion(rotation);
        aabb.min.multiply(scale);
        aabb.max.multiply(scale);
        offset.multiply(scale);
        if (alignment) {
            Object.keys(alignment).forEach(function (x) {
                var newMin = Math.min(aabb.min[x], aabb.max[x]);
                var newMax = Math.max(aabb.min[x], aabb.max[x]);
                var align = alignment[x] * 0.5 + 0.5;
                position[x] -= ((1.0 - align) * newMin + align * newMax);
            });
        }
        this.setProperty('position', tslib_1.__assign({}, position));
    };
    /**
     * Get the position of the object
     * @param [outVector] Optional vector to write the result to. Passing this in will
     *                    avoid another THREE.Vector3 from being created.
     * @returns           The position of the object
     */
    BaseObject.prototype.getPosition = function (outVector) {
        var returnVector = outVector || new THREE.Vector3();
        returnVector.copy(this.getProperty('position'));
        return returnVector;
    };
    /**
     * Set the position of the object
     * @param x X-axis position
     * @param y Y-axis position
     * @param z Z-axis position
     */
    BaseObject.prototype.setPosition = function (x, y, z) {
        if (z === undefined) {
            throw new Error('Calling setPosition with invalid arguments. Expected ' +
                'setPosition( x, y, z ).');
        }
        this.setProperty('position', { x: x, y: y, z: z });
    };
    /**
     * Get the quaternion for the object
     * @returns The object's quaternion
     */
    BaseObject.prototype.getQuaternion = function (outQuaternion) {
        var quaternion = outQuaternion || new THREE.Quaternion();
        quaternion.copy(this.getProperty('quaternion'));
        return quaternion;
    };
    /**
     * Set the quaternion for the object
     * @param x X-component
     * @param y Y-component
     * @param z Z-component
     * @param w W-component
     */
    BaseObject.prototype.setQuaternion = function (x, y, z, w) {
        if (w === undefined) {
            throw new Error('Calling setQuaternion with invalid arguments. Expected ' +
                'setQuaternion( x, y, z, w ).');
        }
        this.setProperty('quaternion', { x: x, y: y, z: z, w: w });
    };
    /**
     * Get the current scale of the object
     * @param [outVector] Optional vector to write the result to. Passing this in will
     *                    avoid another THREE.Vector3 from being created.
     * @returns           A vector with the scale along each axis.
     */
    BaseObject.prototype.getScale = function (outVector) {
        var returnVector = outVector || new THREE.Vector3();
        returnVector.copy(this.getProperty('scale'));
        return returnVector;
    };
    /**
     * Set the scale on each axis
     * @param x Value to scale the x axis
     * @param y Value to scale the y axis
     * @param z Value to scale the z axis
     */
    BaseObject.prototype.setScale = function (x, y, z) {
        if (z === undefined) {
            throw new Error('Calling setScale with invalid arguments. Expected setScale( x, y, z ).');
        }
        this.setProperty('scale', { x: x, y: y, z: z });
    };
    /**
     * Get the center point of the object
     * @param [outVector] Optional vector to write the result to. Passing this in will
     *                    avoid another THREE.Vector3 from being created.
     * @returns           The center point of the object. if the object has no center,
     *                    it uses the center of the bounding box
     */
    BaseObject.prototype.getCenter = function (outVector) {
        var returnVector = outVector || new THREE.Vector3();
        var bb = this.getBounds();
        returnVector.copy(bb.min);
        returnVector.add(bb.max);
        returnVector.multiplyScalar(0.5);
        return returnVector;
    };
    /**
     * Set this object as visible. Any rendered object in its hierarchy will become visible.
     */
    BaseObject.prototype.setVisible = function () {
        this.setProperty('visible', true);
        this.engine.needsRender = true;
    };
    /**
     * Set this object as invisible. Any rendered object in its hierarchy will become invisible.
     */
    BaseObject.prototype.setInvisible = function () {
        this.setProperty('visible', false);
        this.engine.needsRender = true;
    };
    /**
     * Toggle the object's visibility. If it was invisible, it will become visible, etc.
     */
    BaseObject.prototype.toggleVisibility = function () {
        var visible = this.getProperty('visible') ? false : true;
        this.setProperty('visible', visible);
        this.engine.needsRender = true;
    };
    /** @inheritdoc */
    BaseObject.prototype.loadBase = function (callback) {
        _super.prototype.loadBase.call(this, callback);
        // Start listening to prefab change events.
        if (this.isInstance()) {
            this.initPrefabBindings();
        }
    };
    /** @inheritdoc */
    BaseObject.prototype.reloadBase = function (callback) {
        var _this = this;
        // Stop listening to prefab change events.
        if (this.isInstance()) {
            this.uninitPrefabBindings();
        }
        // Remove the old runtimeData from its parent.
        var parent = this.runtimeData && this.runtimeData.parent;
        if (parent) {
            parent.remove(this.runtimeData);
        }
        // Save the children!
        var children = this.runtimeData && this.runtimeData.children;
        _super.prototype.reloadBase.call(this, function () {
            // Add the new runtimeData to the parent.
            if (parent) {
                parent.add(_this.runtimeData);
            }
            if (children) {
                // Add the old children to the new object.
                children.forEach(function (child) { return _this.runtimeData.add(child); });
            }
            if (typeof callback === 'function') {
                callback();
            }
        });
    };
    /**
     * Unload the object.
     * @param recursive Unload entire hierarchy of objects. False by default.
     */
    BaseObject.prototype.unload = function (recursive) {
        var _this = this;
        if (recursive === void 0) { recursive = false; }
        // Remove the object from its parent
        if (this.runtimeData && this.runtimeData.parent) {
            this.runtimeData.parent.remove(this.runtimeData);
        }
        // Unload children
        if (recursive) {
            var children = this.getChildIds();
            children.forEach(function (id) {
                var childObj = _this.engine.getObjectById(id);
                if (childObj) {
                    childObj.unload(recursive);
                }
            });
        }
        _super.prototype.unload.call(this);
    };
    /**
     * Destroy the object and remove it from any hierarchy that it is part of.
     * This does not automatically destroy any children of this object but it does
     * disconnect them from the hierarchy.
     */
    BaseObject.prototype.destroy = function () {
        this.engine.destroyObjectById(this.id);
    };
    /**
     * Traverse this entity's hierarchy and call the given function for each of them.
     * @param fn        The function to call for each object. The function will be passed
     *                  two parameters. The first is the object and the second is the parent.
     */
    BaseObject.prototype.traverse = function (fn) {
        var _this = this;
        var children = this.getChildren();
        children.forEach(function (child) {
            fn(child, _this);
            child.traverse(fn);
        });
    };
    /**
     * Traverse this entity's hierarchy and call the given function for each of them.
     * @param fn            The function to call for each object. The function will be passed
     *                      two parameters. The first is the object and the second is the parent.
     *                      If the function returns a truthy value, the traverse will stop.
     * @returns             True if the traverse short-circuited. False otherwise.
     */
    BaseObject.prototype.traverseWhile = function (fn) {
        var _this = this;
        var children = this.getChildren();
        return children.some(function (child) {
            return fn(child, _this) || child.traverseWhile(fn);
        });
    };
    /**
     * Traverse this entity's hierarchy and call the given function for each of them.
     * @param fn            The function to call for each object. The function will be passed
     *                      two parameters. The first is the object and the second is the parent.
     *                      If the function returns a truthy value, the traversal will not continue
     *                      to the children of the object but will continue with the rest of the hierarchy instead.
     */
    BaseObject.prototype.traverseSome = function (fn) {
        var _this = this;
        var children = this.getChildren();
        children.forEach(function (child) {
            if (fn(child, _this)) {
                return;
            }
            child.traverseSome(fn);
        });
    };
    /**
     * Return an array of each ancestor of this object, starting with its parent.
     * @param [predicate] A function which returns 'true' or 'false' and
     *                    is used to filter results.
     * @returns           The array of ancestor objects
     */
    BaseObject.prototype.getAncestors = function (predicate) {
        var parent = this.getParentObject();
        if (!parent) {
            return [];
        }
        if (predicate && !predicate(parent)) {
            return parent.getAncestors(predicate);
        }
        return [parent].concat(parent.getAncestors(predicate));
    };
    /**
     * Traverse this entity's hierarchy and return an array containing all of the entities
     * satisfying the predicate function
     * @param [predicate] A function which returns 'true' or 'false'
     * @return            The matching entities
     */
    BaseObject.prototype.getDescendants = function (predicate) {
        var results = [];
        var all = typeof predicate !== 'function';
        this.traverse(function (e) {
            if (all || predicate(e)) {
                results.push(e);
            }
        });
        return results;
    };
    /**
     * Traverse this entity's hierarchy and return the first entity satisfying
     * the predicate function
     * @param predicate A function which returns 'true' or 'false'
     * @returns         The matching entities
     */
    BaseObject.prototype.getDescendant = function (predicate) {
        var all = typeof predicate !== 'function';
        var entity;
        this.traverseWhile(function (e) {
            if (!entity && (all || predicate(e))) {
                entity = e;
                return true;
            }
        });
        return entity;
    };
    /**
     * Returns the object with the provided Id, if it exists in this entity's hierarchy.
     * @param objectId  The ID of the object
     * @returns         The object or null if not found.
     */
    BaseObject.prototype.getDescendantById = function (objectId) {
        return this.getDescendant(function (e) { return e.id === objectId; });
    };
    /**
     * Returns the first object with the provided name that is found in this object's hierarchy.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @param objectName  The name of the object
     * @returns           The object, if found, or null if not found.
     */
    BaseObject.prototype.getDescendantByName = function (objectName) {
        return this.getDescendant(function (e) { return e.getName() === objectName; });
    };
    /**
     * Returns the first object with the provided type that is in this entity's hierarchy.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @param objectType  The type of the object
     * @returns           The object, if found, or null if not found.
     */
    BaseObject.prototype.getDescendantByType = function (objectType) {
        return this.getDescendant(function (e) { return e.type === objectType; });
    };
    /**
     * Returns the first object which is an instance of the provided class and is in this entity's hierarchy.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @param objectClass The class of the object to get.
     * @returns           The object, if found, or null if not found.
     */
    BaseObject.prototype.getDescendantByClass = function (objectClass) {
        return this.getDescendant(function (e) { return e instanceof objectClass; });
    };
    /**
     * Returns all objects with the provided type that are in this entity's hierarchy.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @param objectType  The type of the object
     * @returns           An array of all objects with the given name.
     */
    BaseObject.prototype.getDescendantsByType = function (objectType) {
        return this.getDescendants(function (e) { return e.type === objectType; });
    };
    /**
     * Returns all objects with the provided type that are in this entity's hierarchy.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @param objectClass The class of the objects to get.
     * @returns           An array of all objects of the given class.
     */
    BaseObject.prototype.getDescendantsByClass = function (objectClass) {
        return this.getDescendants(function (e) { return e instanceof objectClass; });
    };
    /**
     * Returns all objects with the provided name that are in this entity's hierarchy.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @param objectName  The name of the object
     * @returns           An array of all objects with the given name.
     */
    BaseObject.prototype.getDescendantsByName = function (objectName) {
        return this.getDescendants(function (e) { return e.getName() === objectName; });
    };
    /**
     * Returns the object if it is a direct child of this object.
     * @param objectId  The ID of the child to get
     * @returns         The child object, if it exists
     */
    BaseObject.prototype.getChildById = function (objectId) {
        if (this.sharedData.children.indexOf(objectId) !== -1) {
            return this.engine.getObjectById(objectId);
        }
        return null;
    };
    /**
     * Return the first direct child of this object that matches the given predicate function.
     * @param [predicate] A function which returns 'true' or 'false', used to determine
     *                    which entity to return.
     * @returns           The first matching object.
     */
    BaseObject.prototype.getChild = function (predicate) {
        var children = this.getChildren(predicate);
        return children.length ? children[0] : null;
    };
    /**
     * Return all direct children of this object that match the given predicate function.
     * @param [predicate] A function which returns 'true' or 'false', used to
     *                    determine which entities to return.
     * @returns           An array containing all the matching objects.
     */
    BaseObject.prototype.getChildren = function (predicate) {
        var _this = this;
        var children = this.getChildIds();
        var all = typeof predicate !== 'function';
        return children.filter(function (id) {
            var child = _this.getChildById(id);
            return child && (all || predicate(child));
        }).map(function (id) { return _this.engine.getObjectById(id); });
    };
    /**
     * Return all direct children of this object that match the given predicate function.
     * @param predicate A function which returns 'true' or 'false', used to
     *                  determine which entities to return.
     * @returns         An map from object ID's to all matching objects.
     */
    BaseObject.prototype.getChildrenMap = function (predicate) {
        var results = {};
        var children = this.getChildren(predicate);
        children.forEach(function (obj) {
            if (obj) {
                results[obj.id] = obj;
            }
        });
        return results;
    };
    /**
     * Returns the object that is the immediate parent of this one.
     * Returns null if this object doesn't have a parent. This will be
     * the case if the object is an asset or is orphaned.
     * @returns The parent object of this object.
     */
    BaseObject.prototype.getParentObject = function () {
        return this.engine.getObjectById(this.get('parentId'));
    };
    /**
     * Adds the specified object as a direct child of this object.
     * @param object    The object to add as a direct child of this object.
     * @param [silent]  Suppress change event. Defaults to false.
     */
    BaseObject.prototype.addChild = function (object, silent) {
        this.addChildById(object.id, silent);
    };
    /**
     * Adds the specified object as a direct child of this object.
     * @param objectId  The ID of the object to add as a direct child of this object.
     * @param silent    Suppress change event. Defaults to false.
     */
    BaseObject.prototype.addChildById = function (objectId, silent) {
        var object = this.engine.getObjectById(objectId);
        if (!object) {
            throw new Error("Can't find child object with id, " + objectId);
        }
        this.engine.entityDispatcher.dispatchChildAdded(this.id, objectId, silent);
    };
    /**
     * Removes the specified object as a direct child of this asset.
     * This does not delete (destroy) the object or unload it.
     * @param object    The object to add as a direct child of this object.
     * @param [silent]  Suppress change event. Defaults to false.
     */
    BaseObject.prototype.removeChild = function (object, silent) {
        this.removeChildById(object.id, silent);
    };
    /**
     * Removes the specified object as a direct child of this asset.
     * This does not delete (destroy) the object or unload it.
     * @param childId The ID of the child to be removed as a direct child of
     * this object.
     */
    BaseObject.prototype.removeChildById = function (childId, silent) {
        var child = this.getChildById(childId);
        if (!child) {
            throw new Error("Object, " + childId + ", is not a child of this object");
        }
        this.engine.entityDispatcher.dispatchChildRemoved(this.id, childId, silent);
    };
    /**
     * Return all ID's for the direct children of this object that match the given predicate
     * function.
     * @param [predicate] A function which returns 'true' or 'false', used to
     *                    determine which ID's to return.
     * @returns           An array containing all the matching child ID's.
     */
    BaseObject.prototype.getChildIds = function (predicate) {
        var all = typeof predicate !== 'function';
        if (all) {
            return this.sharedData.children.slice();
        }
        return this.sharedData.children.filter(function (id) { return predicate(id); });
    };
    /**
     * Set the entire set of children in one call.
     * @param newChildren Array of children ids to set.
     * @param silent      Suppress change event. Defaults to false.
     */
    BaseObject.prototype.setChildIds = function (newChildren, silent) {
        if (silent === void 0) { silent = false; }
        this.engine.entityDispatcher.dispatchChildChanged(this.id, newChildren, silent);
    };
    /**
     * Scale this object to a fixed size in the space of its parent. e.g. world space
     * @param size The size in units of the parent's space.
     */
    BaseObject.prototype.scaleToSize = function (size) {
        var aabb = {};
        var bb = this.getBounds();
        aabb.min = new THREE.Vector3(bb.min.x, bb.min.y, bb.min.z);
        aabb.max = new THREE.Vector3(bb.max.x, bb.max.y, bb.max.z);
        // Determine the mesh's scale and origin.
        var distance = aabb.min.distanceTo(aabb.max);
        var scale = size / distance;
        if (scale <= 0) {
            scale = 1.0;
        }
        this.setProperty('scale', {
            x: scale,
            y: scale,
            z: scale
        });
    };
    /**
     * Get the bounds for the hierarchy rooted at this object.
     * @param [outBounds] Optional Box3 to write the result to. Passing this in will
     *                    avoid another THREE.Box3 from being created.
     * @returns           The bounds of the hierarchy, in this object's local space.
     */
    BaseObject.prototype.getBounds = function (outBounds) {
        var bounds = this.getProperty('bounds');
        var returnBounds = outBounds || new THREE.Box3();
        if (bounds) {
            return returnBounds.set(bounds.min, bounds.max);
        }
        return this.computeBounds(returnBounds);
    };
    /**
     * Get the spherical bounds for the hierarchy rooted at this object.
     * @param [outBounds] Optional Sphere to write the result to. Passing this in will
     *                    avoid another THREE.Sphere from being created.
     * @returns           The spherical bounds of the hierarchy, in this object's local space.
     */
    BaseObject.prototype.getSphericalBounds = function (outBounds) {
        var returnBounds = outBounds || new THREE.Sphere();
        var bb = this.getBounds();
        // Use the center vector as a temp vector to calculate the radius and then
        // fill it with the actual center.
        returnBounds.radius = returnBounds.center.subVectors(bb.max, bb.min).multiplyScalar(0.5).length();
        returnBounds.center.addVectors(bb.max, bb.min).multiplyScalar(0.5);
        return returnBounds;
    };
    /**
     * Get the bounds of this object, but not its children.
     * @param [outBounds] Optional Box3 to write the result to. Passing this in will
     *                    avoid another THREE.Box3 from being created.
     * @returns           The bounds of this object.
     */
    BaseObject.prototype.getLocalBounds = function (outBounds) {
        var returnBounds = outBounds || new THREE.Box3();
        returnBounds.min.set(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        returnBounds.max.set(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        return returnBounds;
    };
    /**
     * Compute the bounds for the hierarchy rooted at this object.
     * @param [outBounds] Optional Box3 to write the result to. Passing this in will
     *                    avoid another THREE.Box3 from being created.
     * @returns           The bounds of the hierarchy in this object's local space.
     */
    BaseObject.prototype.computeBounds = function (outBounds) {
        var children = this.getChildren();
        var box = this.getLocalBounds(outBounds || new THREE.Box3());
        var xform = new THREE.Matrix4();
        children.forEach(function (child) {
            var childBox = child.computeBounds();
            if (childBox.isEmpty()) {
                return;
            }
            // Transform the child's bounds into its parent's space.
            xform.compose(child.getPosition(), child.getQuaternion(), child.getScale());
            childBox.applyMatrix4(xform);
            // Combine the child box with the others.
            box.union(childBox);
        });
        this.setProperty('bounds', {
            min: { x: box.min.x, y: box.min.y, z: box.min.z },
            max: { x: box.max.x, y: box.max.y, z: box.max.z }
        });
        return box;
    };
    /**
     * Returns the previous value of the property specified by 'propertyName'
     * @param propertyName  The name of the property.
     * @returns             The property's previous value
     */
    BaseObject.prototype.getPreviousProperty = function (propertyName) {
        var value = this.sharedData.previousProperties[propertyName];
        if (value !== undefined) {
            return value;
        }
        var prefabObj = this.getPrefabObject();
        if (prefabObj) {
            return prefabObj.getProperty(propertyName);
        }
        return this.getDefaultProperty(propertyName);
    };
    /**
     * Returns the property value specified by 'propertyName'.
     * @param propertyName  The name of the property.
     * @returns             The property value
     */
    BaseObject.prototype.getProperty = function (propertyName) {
        var localProperty = this.getOwnProperty(propertyName);
        if (localProperty !== undefined) {
            return localProperty;
        }
        var prefabProperty = this.getPrefabProperty(propertyName);
        if (prefabProperty) {
            return prefabProperty;
        }
        return this.getDefaultProperty(propertyName);
    };
    /**
     * Returns all properties of the entity, including those inherited from
     * the entity's prefab.
     * @returns The properties
     */
    BaseObject.prototype.getProperties = function () {
        var myProperties = this.getOwnProperties();
        var prefabObj = this.getPrefabObject();
        var defaultProps = this.getDefaultProperties();
        // If this object has a prefab, inherit the prefab's properties in the returned
        // structure.
        if (prefabObj) {
            var prefabObjProperties = prefabObj.getOwnProperties();
            return Object.assign(defaultProps, prefabObjProperties, myProperties);
        }
        else {
            return Object.assign(defaultProps, myProperties);
        }
    };
    // ************ Prefabs ***********
    /**
     * If this object is a prefab instance, return the top-level of the instance.
     * @returns The top-level object of the prefab instance.
     */
    BaseObject.prototype.getInstanceTop = function () {
        var prefabInstanceId = this.get('prefabInstanceId');
        if (prefabInstanceId) {
            return this.engine.getObjectById(prefabInstanceId);
        }
        else {
            return null;
        }
    };
    /**
     * Returns the object that stores the source data for this object.
     * @returns The asset where the source data for this object is stored.
     */
    BaseObject.prototype.getPrefabObject = function () {
        return this.engine.getObjectById(this.get('prefabObjectId'));
    };
    /**
     * Returns the property given by 'propertyName' for this entity's
     * prefab (if any).
     * @param propertyName  The name of the property.
     * @returns             The property value
     */
    BaseObject.prototype.getPrefabProperty = function (propertyName) {
        var prefabObj = this.getPrefabObject();
        if (prefabObj) {
            return prefabObj.getProperty(propertyName);
        }
        return undefined;
    };
    /**
     * Returns true if the object is an instance of a prefab asset.
     * @returns True if the object is an instance of a prefab object. false otherwise.
     */
    BaseObject.prototype.isInstance = function () {
        return !!this.get('prefabObjectId');
    };
    /**
     * Returns true if the object is the top-level of a prefab instance tree.
     * @returns True if and only if the object is the top level of a prefab instance.
     */
    BaseObject.prototype.isInstanceTop = function () {
        return this.get('prefabInstanceId') === this.id;
    };
    /**
     * Unlink this entity from its prefab. This will prevent it from receiving prefab
     * updates. By default, the entity's hierarchy is also unlinked.
     * Passing in 'recursive' as 'false' will prevent this.
     * @param [recursive] Whether or not to traverse children
     */
    BaseObject.prototype.breakPrefabLink = function (recursive) {
        if (recursive === void 0) { recursive = true; }
        if (!this.isInstance()) {
            throw new Error('breakPrefabLink: Can\'t call this on an entity that isn\'t an instance.');
        }
        if (recursive) {
            this.getChildren().forEach(function (child) {
                child.breakPrefabLink(recursive);
            });
        }
        this.uninitPrefabBindings();
        this.mergeProperties(this.getPrefabObject());
        // FIXME, this doesn't exist
        // this.mergeComponents(this.getPrefabObject());
        var changes = {};
        changes.prefabInstanceId = undefined;
        changes.prefabObjectId = undefined;
        changes.prefabAssetId = undefined;
        // FIXME this isn't an acceptable syntax for set anymore.
        // this.set(changes);
    };
    /** @inheritdoc */
    BaseObject.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (changes.hasOwnProperty('static')) {
            var isStatic = this.getProperty('static');
            this.runtimeData.matrixAutoUpdate = !isStatic;
            this.runtimeData.rotationAutoUpdate = !isStatic;
            if (isStatic) {
                this.runtimeData.matrixWorldNeedsUpdate = true;
                this.runtimeData.updateMatrix();
            }
        }
        if (changes.hasOwnProperty('visible')) {
            this.runtimeData.visible = this.getProperty('visible');
        }
        if (changes.hasOwnProperty('castShadow')) {
            this.runtimeData.castShadow = this.getProperty('castShadow');
        }
        if (changes.hasOwnProperty('receiveShadow')) {
            this.runtimeData.receiveShadow = this.getProperty('receiveShadow');
        }
        if (changes.hasOwnProperty('frustumCulled')) {
            this.runtimeData.frustumCulled = this.getProperty('frustumCulled');
        }
        // Transform updates
        if (changes.hasOwnProperty('position')) {
            var position = this.getPosition();
            this.runtimeData.position.set(position.x, position.y, position.z);
        }
        if (changes.hasOwnProperty('quaternion')) {
            var quaternion = this.getQuaternion();
            this.runtimeData.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
        }
        if (changes.hasOwnProperty('scale')) {
            var scale = this.getScale();
            this.runtimeData.scale.set(scale.x, scale.y, scale.z);
        }
    };
    /**
     * Get the name that should be assigned to the runtime object (i.e., this.runtimeData).
     * @returns The runtime name.
     */
    BaseObject.prototype.getRuntimeName = function () {
        return this.engine.getRuntimeName(this.getSid());
    };
    /**
     * If this object is an instance of another, we'll hook up the entity events
     * so that we can listen to changes to the source asset.
     */
    BaseObject.prototype.initPrefabBindings = function () {
        var prefabObject = this.getPrefabObject();
        if (prefabObject) {
            prefabObject.on('propertyChanges', this.onPrefabEntityChanged, this);
        }
    };
    /**
     * Disconnect this instance object from listening to changes on the source asset.
     */
    BaseObject.prototype.uninitPrefabBindings = function () {
        var prefabObject = this.getPrefabObject();
        if (prefabObject) {
            prefabObject.off('propertyChanges', this.onPrefabEntityChanged, this);
        }
    };
    /**
     * Called when the prefab object for this object instance has changed.
     */
    BaseObject.prototype.onPrefabEntityChanged = function () {
        Logger_1.default.warn('TODO - re-implement updating from prefab changes');
    };
    /**
     * Bound to the loadBase event for each child. This allows us to add the child
     * when it's loaded. We do this rather than using listenToOnce so that we can
     * handle cases of reloading.
     * @param child The child that has just loaded.
     */
    BaseObject.prototype.onChildLoaded = function (child) {
        var _this = this;
        this.when('loadBase', function () {
            _this.runtimeData.add(child.runtimeData);
            _this.engine.needsRender = true;
        });
    };
    /**
     * Called when the entity's children list changes. Handles linking
     * and unlinking children after changes made.
     * @param addedChildren   An array of newly-added child objects.
     * @param removedChildren An array of newly-removed child objects.
     */
    BaseObject.prototype.onChildrenChanged = function (addedChildren, removedChildren) {
        var _this = this;
        // Remove the children specified
        removedChildren.forEach(function (child) {
            if (!child) {
                return;
            }
            child.set('parentId', null);
            _this.unregisterDependency(child);
            _this.stopListening(child, 'loadBase', _this.onChildLoaded);
            // Handle case where the three.js child is already attached.
            if (_this.isBaseLoaded() && child.isBaseLoaded()) {
                _this.runtimeData.remove(child.runtimeData);
                _this.engine.needsRender = true;
            }
        });
        // Now, add children that should be added.
        addedChildren.forEach(function (child) {
            var oldParent = child.getParentObject();
            // If the object has a parent already, remove it from that parent.
            if (oldParent && oldParent.id !== _this.id) {
                // Remove the object from previous parent
                oldParent.removeChildById(child.id, true);
            }
            // Setting the parent id because this might not exist yet.
            child.set('parentId', _this.id);
            // Listen for when the child loads so that we can attach the three.js child.
            // Note that we don't listen for unload because the unloading code handles the
            // removal of the child.
            _this.listenTo(child, 'loadBase', _this.onChildLoaded);
            // Handle the cases where the three.js child can already be attached.
            if (child.isBaseLoaded()) {
                if (_this.isBaseLoaded()) {
                    _this.runtimeData.add(child.runtimeData);
                    _this.engine.needsRender = true;
                }
                else {
                    // We need to handle this case separately because, if the child is already loaded,
                    // it won't trigger 'onChildLoaded' again.
                    _this.when('loadBase', function () {
                        _this.runtimeData.add(child.runtimeData);
                        _this.engine.needsRender = true;
                    });
                }
            }
            _this.registerDependency(child);
        });
    };
    return BaseObject;
}(BaseEntity_1.default));
/** @inheritdoc */
BaseObject.events = {
    toggleVisibility: {
        params: [],
        action: true,
        category: 'Rendering'
    },
    setVisible: {
        params: [],
        action: true,
        category: 'Rendering'
    },
    setInvisible: {
        params: [],
        action: true,
        category: 'Rendering'
    }
};
exports.default = BaseObject;


/***/ }),
/* 11 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(6);
var Logger_1 = __webpack_require__(3);
/**
 * Available layouts for an image or texture.
 */
var ImageLayout;
(function (ImageLayout) {
    /** normal, the default. */
    ImageLayout[ImageLayout["Normal"] = 101] = "Normal";
    /** above-below */
    ImageLayout[ImageLayout["Stereo2dOverUnder"] = 102] = "Stereo2dOverUnder";
    /** below-above */
    ImageLayout[ImageLayout["Stereo2dUnderOver"] = 103] = "Stereo2dUnderOver";
    /** parallel-eyed */
    ImageLayout[ImageLayout["Stereo2dLeftRight"] = 104] = "Stereo2dLeftRight";
    /** cross-eyed */
    ImageLayout[ImageLayout["Stereo2dRightLeft"] = 105] = "Stereo2dRightLeft";
    ImageLayout[ImageLayout["StereoCubeHorizontal"] = 106] = "StereoCubeHorizontal";
})(ImageLayout = exports.ImageLayout || (exports.ImageLayout = {}));
/**
 * The base class for all image asset subtypes.
 */
var BaseImageAsset = (function (_super) {
    tslib_1.__extends(BaseImageAsset, _super);
    function BaseImageAsset() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Current number of loaded bytes
         * @type {number}
         */
        _this.loadedBytes = 0;
        return _this;
    }
    /**
     * Converts a format string into a THREE.PixelFormat.
     * @param format One of 'alpha', 'rgb', 'rgba', 'luminance', or 'luminanceAlpha'
     * @returns The mapped THREE.js constant.
     */
    BaseImageAsset.getThreeImageFormat = function (format) {
        switch (format) {
            case 'alpha': return THREE.AlphaFormat;
            case 'rgb': return THREE.RGBFormat;
            case 'rgba': return THREE.RGBAFormat;
            case 'luminance': return THREE.LuminanceFormat;
            case 'luminanceAlpha': return THREE.LuminanceAlphaFormat;
            default:
                Logger_1.default.warn("Unexpected format: " + format + ", defaulting to THREE.RGBFormat");
                return THREE.RGBFormat;
        }
    };
    /**
     * Converts an encoding string into a THREE.TextureEncoding or THREE.DepthPackingStrategies.
     * @param encoding One of 'linear', 'srgb', 'gamma', 'rgbe', 'logLuv', 'rgbm7', 'rgbm16',
     *                 'rgbd', 'depth' or 'rgbDepth'
     * @returns The mapped THREE.js constant.
     */
    BaseImageAsset.getThreeImageEncoding = function (encoding) {
        switch (encoding) {
            case 'linear': return THREE.LinearEncoding;
            case 'srgb': return THREE.sRGBEncoding;
            case 'gamma': return THREE.GammaEncoding;
            case 'rgbe': return THREE.RGBEEncoding;
            case 'logLuv': return THREE.LogLuvEncoding;
            case 'rgbm7': return THREE.RGBM7Encoding;
            case 'rgbm16': return THREE.RGBM16Encoding;
            case 'rgbd': return THREE.RGBDEncoding;
            // Depth packing strategies
            case 'depth': return THREE.BasicDepthPacking;
            case 'rgbaDepth': return THREE.RGBADepthPacking;
            default:
                Logger_1.default.warn("Unexpected format: " + encoding + ", defaulting to THREE.sRGBEncoding");
                return THREE.sRGBEncoding;
        }
    };
    /**
     * Converts a type string into a THREE.TextureDataType or THREE.PixelType.
     * @param type One of 'uByte', 'byte', 'short', 'uShort', 'int', 'uInt', 'float',
     *             'halfFloat', 'uShort4444', 'uShort5551' or 'uShort565'
     * @returns The mapped THREE.js constant.
     */
    BaseImageAsset.getThreeImageType = function (type) {
        switch (type) {
            case 'uByte': return THREE.UnsignedByteType;
            case 'byte': return THREE.ByteType;
            case 'short': return THREE.ShortType;
            case 'uShort': return THREE.UnsignedShortType;
            case 'int': return THREE.IntType;
            case 'uInt': return THREE.UnsignedIntType;
            case 'float': return THREE.FloatType;
            case 'halfFloat': return THREE.HalfFloatType;
            case 'uShort4444': return THREE.UnsignedShort4444Type;
            case 'uShort5551': return THREE.UnsignedShort5551Type;
            case 'uShort565': return THREE.UnsignedShort565Type;
            default:
                Logger_1.default.warn("Unexpected format: " + type + ", defaulting to THREE.UnsignedByteType");
                return THREE.UnsignedByteType;
        }
    };
    /**
     * Given an image format and type, calculate the number of bytes per pixel that it will
     * occupy in memory. Note that this only works for uncompressed images in memory.
     * @static
     * @public
     * @param {ImageFormatKey} format
     * @param {ImageTypeKey} dataType
     * @returns {number}
     * @memberOf BaseImageAsset
     */
    BaseImageAsset.getBytesPerPixel = function (format, dataType) {
        var channelSize = 0;
        switch (dataType) {
            case 'float':
            case 'uInt':
            case 'int':
                channelSize = 4;
                break;
            case 'halfFloat':
            case 'short':
            case 'uShort':
                channelSize = 2;
                break;
            case 'uByte':
            case 'byte':
                channelSize = 1;
                break;
            // The following types dictate the bpp directly.
            case 'uShort4444':
            case 'uShort5551':
            case 'uShort565':
                return 2;
            default:
                break;
        }
        return BaseImageAsset.getChannelCount(format) * channelSize;
    };
    /**
     * Given an image format, return the number of channels per pixel.
     * @public
     * @static
     * @param {ImageFormatKey} format
     * @returns {number}
     * @memberOf BaseImageAsset
     */
    BaseImageAsset.getChannelCount = function (format) {
        switch (format) {
            case 'alpha':
            case 'luminance':
                return 1;
            case 'luminanceAlpha':
                return 2;
            case 'rgb':
                return 3;
            case 'rgba':
                return 4;
            default:
                return 0;
        }
    };
    /** @inheritdoc */
    BaseImageAsset.prototype.unload = function () {
        this.loadedBytes = 0;
        _super.prototype.unload.call(this);
    };
    /**
     * Return the currently selected representation based on the image's properties.
     * @public
     * @returns {Representation}
     * @memberOf BaseImageAsset
     */
    BaseImageAsset.prototype.getChosenRepresentation = function () {
        return this.chosenRepresentation;
    };
    /**
     * Get the current encoding type for this image.
     * @returns The encoding type for this image.
     */
    BaseImageAsset.prototype.getEncoding = function () {
        // If we have an explicitly set encoding, treat it as an override.
        var encoding = this.getProperty('encoding');
        if (encoding) {
            return encoding;
        }
        // Otherwise, return the colorspace of the chosen representation.
        var rep = this.getChosenRepresentation();
        if (rep) {
            switch (rep.colorspace) {
                case 'rgb':
                case 'gray':
                    return 'linear';
                default:
                    return 'srgb';
            }
        }
        return 'srgb';
    };
    /**
     * Return the number of bytes loaded directly by this entity (not by a dependency) so far.
     * @method getDataSizeDownloadSelf
     * @protected
     * @returns {number} The number of bytes downloaded by this entity so far
     */
    BaseImageAsset.prototype.getDataSizeLoadedSelf = function () {
        return this.loadedBytes;
    };
    /** @inheritdoc */
    BaseImageAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        this.engine.trigger('imageChanged', this.id, changes);
    };
    /**
     * Return the number of color or luminance channels in the texture. An optional override lets
     * you query the value for a different pixel format.
     * @method getChannelCount
     * @public
     * @param {ImageFormatKey} overrideFormat Query the number of channels for a different pixel format
     * by specifying a format here.
     * @return {number} Returns the number of color or luminance channels in the texture.
     */
    BaseImageAsset.prototype.getChannelCount = function (overrideFormat) {
        var format = overrideFormat || this.getFormat();
        return BaseImageAsset.getChannelCount(format);
    };
    /**
     * Return the bytes per pixel of the final, uncompressed image.
     * Note that for in-memory-compressed images, this is not the same as the
     * amount of memory that the pixel consumes.
     * @param {ImageFormatKey} [overrideFormat] Query the bpp with a different image format.
     * @param {ImageTypeKey} [overrideType] Query the bpp with a different image type.
     * @returns {number}
     *
     * @memberOf ImageAsset
     */
    BaseImageAsset.prototype.getBytesPerPixel = function () {
        return BaseImageAsset.getBytesPerPixel(this.getFormat(), this.getDataType());
    };
    /**
     * Returns the pixel format of the image. e.g. THREE.RGBAFormat, THREE.LuminanceFormat, etc.
     * @method getFormat
     * @public
     * @return {ImageFormatKey} The image pixel format.
     */
    BaseImageAsset.prototype.getFormat = function () {
        return this.getProperty('format');
    };
    /**
     * Returns the data type of the texture. e.g. THREE.UnsignedByteType, THREE.FloatType, etc.
     * @method getDataType
     * @public
     * @return {ImageTypeKey} The texture pixel type.
     */
    BaseImageAsset.prototype.getDataType = function () {
        return this.getSupportedType(this.getProperty('type'));
    };
    /**
     * Returns the download size of this image using the current representation.
     * @method getDataSizeDownloadSelf
     * @return {number} The number of bytes of data.
     */
    BaseImageAsset.prototype.getDataSizeDownloadSelf = function () {
        if (this.chosenRepresentation) {
            return this.chosenRepresentation.contentLength;
        }
        // Return a non-zero value for now so that loading progress can go from 0 to 100%
        return 1;
    };
    /**
     * Given a data type for an image, check if it's supported by the current hardware
     * and modify and return the type as necessary. If the type is supported, the returned
     * value is the same as the type passed in.
     * @method getSupportedType
     * @public
     * @param  {String} type The data type that we want to check for support
     * @return {ImageTypeKey}      The data type closest to the one passed in that is supported
     * by the current hardware.
     */
    BaseImageAsset.prototype.getSupportedType = function (type) {
        var returnType = type;
        var renderer = this.engine.getThreeRenderer();
        var extensions = renderer.extensions;
        switch (type) {
            case 'float':
                if (extensions.get('OES_texture_float')) {
                    returnType = 'float';
                    break;
                }
            /* falls through */
            case 'halfFloat':
                if (extensions.get('OES_texture_half_float')) {
                    returnType = 'halfFloat';
                }
                else {
                    returnType = 'uByte';
                }
                break;
            default:
                returnType = type;
        }
        return returnType;
    };
    /**
     * Returns the anticipated number of mips that the loaded image should have, based on its size.
     * If mipmapping is disabled for this image, this method still returns the number of mips in the
     * full mip chain.
     * @method getMipCount
     * @public
     * @return {number} Returns the total number of mip levels used by this texture.
     */
    BaseImageAsset.prototype.getMipCount = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        var max = Math.max(width, height);
        return Math.floor(Math.log2(Math.max(max, 1))) + 1;
    };
    /**
     * Return whether the anticipated dimensions of the loaded image are powers of two
     * (e.g. 2^10 == 1024).
     * @method isPowerOfTwo
     * @public
     * @return {Boolean} True if the anticipated dimensions of the loaded image are powers of two.
     */
    BaseImageAsset.prototype.isPowerOfTwo = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        return THREE.Math.isPowerOfTwo(width) && THREE.Math.isPowerOfTwo(height);
    };
    /**
     * Returns the anticipated width of the loaded image.
     * @method getWidth
     * @public
     * @return {number} The image width.
     */
    BaseImageAsset.prototype.getWidth = function () {
        var width = this.getMaxRepresentationWidth();
        var maxSize = this.getMaxTextureSize();
        return Math.max(1, Math.min(maxSize, width));
    };
    /**
     * Returns the anticipated height of the loaded image.
     * @method getHeight
     * @public
     * @return {number} The image height.
     */
    BaseImageAsset.prototype.getHeight = function () {
        var height = this.getMaxRepresentationHeight();
        var maxSize = this.getMaxTextureSize();
        return Math.max(1, Math.min(maxSize, height));
    };
    /**
     * Get the largest width found for any representation of this image.
     * @protected
     * @returns {number}
     * @memberOf BaseImageAsset
     */
    BaseImageAsset.prototype.getMaxRepresentationWidth = function () {
        return 0;
    };
    /**
     * Get the largest height found for any representation of this image.
     * @protected
     * @returns {number}
     * @memberOf BaseImageAsset
     */
    BaseImageAsset.prototype.getMaxRepresentationHeight = function () {
        return 0;
    };
    /**
     * Returns the original width of the image.
     * @method getOriginalWidth
     * @public
     * @return {number} The original image width.
     */
    BaseImageAsset.prototype.getOriginalWidth = function () {
        return 0;
    };
    /**
     * Returns the original height of the image.
     * @method getOriginalHeight
     * @public
     * @return {number} The original image height.
     */
    BaseImageAsset.prototype.getOriginalHeight = function () {
        return 0;
    };
    /**
     * Returns the maximum texture size, taking into account the image type (e.g., 2D, cube, etc.).
     * @method getMaxTextureSize
     * @private
     * @return {number} The maximum texture size.
     */
    BaseImageAsset.prototype.getMaxTextureSize = function () {
        return Number.MAX_VALUE;
    };
    return BaseImageAsset;
}(BaseAsset_1.default));
exports.default = BaseImageAsset;


/***/ }),
/* 12 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LoadingEvent = {
    LOAD: 'load',
    STATE_CHANGE: 'state_change',
    CANCEL: 'cancel',
    ERROR: 'error',
    PROGRESS: 'progress',
    DONE: 'done'
};
exports.default = LoadingEvent;


/***/ }),
/* 13 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Iterates a collection of values, running the provided function for each item.
 * @param {array|object} values The input values.
 * @param {function} fn The function to run for each iteration.
 * @returns {void}
 */
function each(values, fn) {
  if (values === undefined || values === null) {
    return;
  }

  if (Array.isArray(values)) {
    return values.forEach(fn);
  }

  Object.keys(values).forEach(function(key) {
    fn(values[key], key);
  });
}

/**
 * Flattens an arbitrarily deep array of arrays and values.
 * @param {array} values The input array.
 * @returns {array} The flattened array.
 */
function flatten(values) {
  return Array.isArray(values) ? [].concat.apply([],
    values.map(function(item) {
      return flatten(item);
    })) : values;
}

/**
 * Indexes an array of objects by a given key which is present on those objects.
 * @param {array} values The input objects.
 * @param {string} key The key.
 * @returns {object} An object which maps the values of the given key to the related object.
 */
function indexBy(values, key) {
  return values.reduce(function(index, item) {
    index[item[key]] = item;
    return index;
  }, {});
}

/**
 * Maps the specified values using the specified mapping function and flattens
 * the results, removing nested arrays. This means that the mapping function can
 * be one-to-many.
 * @function flatMap
 * @param {Array} values The array of values to map.
 * @param {Function} fn The mapping function.
 * @returns {Array} The array of mapped values.
 */
function flatMap(values, fn) {
  return flatten(map(values, fn));
}

/**
 * The identity function.
 * @param {any} value The input.
 * @returns {any} The same value as the input.
 */
function identity(value) {
  return value;
}

/**
 * Iterates the given collection with the given function returning a new collection
 * with the same keys mapping to the result of the given function.
 * @param {array|object} values The input collection.
 * @param {function} fn The provided mapping function.
 * @returns {array|object} The mapped collection.
 */
function map(values, fn) {
  var mapped;

  if (values === undefined || values === null) {
    return values;
  }

  if (Array.isArray(values)) {
    return values.map(fn);
  }

  mapped = {};

  Object.keys(values).forEach(function(key) {
    mapped[key] = fn(values[key], key);
  });

  return mapped;
}

/**
 * Returns an object with a subset of the original keys.
 * @param {object} values The input object.
 * @param {array} keys The keys to omit from the object.
 * @returns {object} A new object based on the properties of the original, minus the omitted keys.
 */
function omit(values, keys) {
  return Object.keys(values).reduce(function(obj, key) {
    if (keys.indexOf(key) === -1) {
      obj[key] = values[key];
    }

    return obj;
  }, {});
}

module.exports = {
  each: each,
  flatMap: flatMap,
  flatten: flatten,
  identity: identity,
  indexBy: indexBy,
  map: map,
  omit: omit
};


/***/ }),
/* 14 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-bitwise */
/* tslint:disable max-file-line-count */
/* tslint:disable no-string-literal */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(6);
var functions_1 = __webpack_require__(5);
var Schemas_1 = __webpack_require__(4);
var convertToDefine_1 = __webpack_require__(219);
/**
 * Stand-in texture substituted while a real texture loads so that
 * the material can properly render in the meantime.
 */
var StandInTexture;
(function (StandInTexture) {
    StandInTexture[StandInTexture["STANDIN_TEXTURE_WHITE"] = 0] = "STANDIN_TEXTURE_WHITE";
    StandInTexture[StandInTexture["STANDIN_TEXTURE_WHITE_CUBE"] = 1] = "STANDIN_TEXTURE_WHITE_CUBE";
    StandInTexture[StandInTexture["STANDIN_TEXTURE_BLACK"] = 2] = "STANDIN_TEXTURE_BLACK";
    StandInTexture[StandInTexture["STANDIN_TEXTURE_BLACK_CUBE"] = 3] = "STANDIN_TEXTURE_BLACK_CUBE";
    StandInTexture[StandInTexture["STANDIN_TEXTURE_NORMAL"] = 4] = "STANDIN_TEXTURE_NORMAL";
})(StandInTexture = exports.StandInTexture || (exports.StandInTexture = {}));
/**
 * Converts a integer color value into a ColorRGB vector.
 * @param hex   The input color number
 * @param obj   An optional ColorRGB object which will have the result
 *              assigned to it, otherwise a new object will be created.
 * @returns     The converted color as ColorRGB
 */
function hexColorToVector(hex, obj) {
    var color = Math.floor(hex);
    var converted = obj ? obj : {
        r: (color >> 16 & 255) / 255,
        g: (color >> 8 & 255) / 255,
        b: (color & 255) / 255
    };
    return converted;
}
/**
 * An asset that holds geometry.
 */
var MaterialAsset = (function (_super) {
    tslib_1.__extends(MaterialAsset, _super);
    function MaterialAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    MaterialAsset.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.listenTo(this.engine, 'textureDeleted', this.onTextureDeleted);
    };
    /** @inheritdoc */
    MaterialAsset.prototype.uninitialize = function () {
        _super.prototype.uninitialize.call(this);
        this.stopListening(this.engine, 'textureDeleted', this.onTextureDeleted);
    };
    /** @inheritdoc */
    MaterialAsset.prototype.getProperty = function (propName) {
        var value = _super.prototype.getProperty.call(this, propName);
        if (value === undefined) {
            var shaderParams = this.getShader().getProperty('parameters');
            if (shaderParams[propName]) {
                value = shaderParams[propName].default;
            }
        }
        return value;
    };
    /** @inheritdoc */
    MaterialAsset.prototype.getDefaultProperties = function () {
        var values = _super.prototype.getDefaultProperties.call(this);
        var shaderParams = this.getShader().getProperty('parameters');
        Object.keys(shaderParams).forEach(function (paramName) {
            values[paramName] = shaderParams[paramName].default;
        });
        return values;
    };
    /** @inheritdoc */
    MaterialAsset.prototype.verifyProperty = function (propertyName, value) {
        if (propertyName === 'shader') {
            return _super.prototype.verifyProperty.call(this, propertyName, value);
        }
        return true;
    };
    /** @inheritdoc */
    MaterialAsset.prototype.setProperty = function (propertyName, value, silent) {
        if (propertyName === 'shader') {
            _super.prototype.setProperty.call(this, propertyName, value, silent);
        }
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        if (!shaderParams[propertyName]) {
            return;
        }
        var type = shaderParams[propertyName].type;
        var newValue;
        // Handle scalar values
        if (type === 't' && (typeof value === 'string' || value === null) ||
            type === 'f' && typeof value === 'number' ||
            type === 'b' && typeof value === 'boolean' ||
            type === 'i' && typeof value === 'number' && Math.round(value) === value ||
            type === 'opt' && shaderParams[propertyName].options.hasOwnProperty(value)) {
            newValue = value;
            // Handle colours
        }
        else if (type === 'c') {
            if (this.sharedData.properties.hasOwnProperty(propertyName) &&
                typeof this.sharedData.properties[propertyName] === 'object') {
                newValue = this.sharedData.properties[propertyName];
            }
            else {
                newValue = { r: 0.0, g: 0.0, b: 0.0 };
            }
            if (typeof value === 'string') {
                var hexValue = value;
                if (hexValue.slice(0, 2) !== '0x') {
                    hexValue = String(parseInt(hexValue, 10));
                    hexValue = '0x' + hexValue.toString();
                }
                hexColorToVector(parseInt(hexValue, 16), newValue);
            }
            else if (typeof value === 'number') {
                var clampedVal = Math.max(0, Math.max(0xffffff, value));
                hexColorToVector(clampedVal, newValue);
            }
            else if (value && typeof value.r === 'number' && typeof value.g === 'number' &&
                typeof value.b === 'number') {
                newValue.r = value.r;
                newValue.g = value.g;
                newValue.b = value.b;
                var min = shaderParams[propertyName].min;
                var max = shaderParams[propertyName].max;
                if (min !== undefined) {
                    newValue.r = Math.max(newValue.r, min);
                    newValue.g = Math.max(newValue.g, min);
                    newValue.b = Math.max(newValue.b, min);
                }
                if (max !== undefined) {
                    newValue.r = Math.min(newValue.r, max);
                    newValue.g = Math.min(newValue.g, max);
                    newValue.b = Math.min(newValue.b, max);
                }
            }
            // Handle vectors
        }
        else if (type.charAt(0) === 'v' && typeof value.x === 'number' &&
            typeof value.y === 'number') {
            if (this.sharedData.properties.hasOwnProperty(propertyName)) {
                newValue = this.sharedData.properties[propertyName];
            }
            else {
                newValue = {};
            }
            newValue.x = value.x;
            newValue.y = value.y;
            if (type === 'v3' && typeof value.z === 'number') {
                newValue.z = value.z;
            }
            else if (type === 'v4' && typeof value.z === 'number' &&
                typeof value.w === 'number') {
                newValue.z = value.z;
                newValue.w = value.w;
            }
        }
        else if (typeof value === 'undefined') {
            newValue = undefined;
        }
        else {
            Logger_1.default.error('Wrong type specified for ' + propertyName);
        }
        // Dispatch change event
        this.engine.entityDispatcher.dispatchPropertyChanged(this.id, propertyName, newValue, silent);
    };
    /**
     * Return a list of texture assets that this material currently uses.
     * This takes conditional logic for the individual parameters into account.
     * @returns The list of texture assets that this material currently uses.
     */
    MaterialAsset.prototype.getReferencedAssetsList = function (allowDuplicates) {
        var _this = this;
        var refTextures = [];
        var refTextureMap = {};
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        // Go through the parameters and see what textures are being used.
        functions_1.forEach(shaderParams, function (param, paramName) {
            var textureId;
            var textureAsset;
            if (param.type === 't') {
                if (_this.isParameterUsed(paramName)) {
                    textureId = _this.getProperty(paramName);
                }
                if (textureId) {
                    textureAsset = _this.engine.getAssetById(textureId);
                    if (!refTextureMap[textureId]) {
                        refTextureMap[textureId] = textureAsset;
                        refTextures.push(textureAsset);
                    }
                    else if (allowDuplicates) {
                        refTextures.push(textureAsset);
                    }
                }
            }
        });
        return refTextures;
    };
    /**
     * Get shader returns the shader asset associated with this material. This will return a default
     * shader if either the shader isn't specified in the material properties OR the specified shader
     * doesn't exist.
     * @returns The shader asset used to build this material asset.
     */
    MaterialAsset.prototype.getShader = function () {
        // Calling super to avoid an infinite loop because Material.getProperty will fallback to looking
        // in the shader for default property values.
        var shaderId = _super.prototype.getProperty.call(this, 'shader');
        // If the shader asset doesn't exist, get the default shader asset.
        if (!this.engine.getAssetById(shaderId)) {
            shaderId = this.getDefaultProperty('shader');
        }
        return this.engine.getAssetById(shaderId);
    };
    /**
     * Determines whether or not a parameter is editable.
     * @param name  The name of the parameter.
     * @returns     Whether or not the parameter is editable.
     */
    MaterialAsset.prototype.isParameterEditable = function (name) {
        var shader = this.getShader();
        if (!shader) {
            return false;
        }
        var shaderParams = shader.getProperty('parameters');
        if (!shaderParams[name]) {
            return false;
        }
        // If there are additional conditions for this parameter, test them.
        if (shaderParams[name].displayWhen) {
            return this.testParameterConditions(shaderParams[name].displayWhen);
        }
        return true;
    };
    /**
     * The an appropriate three.js texture to substitute for the given texture
     * and usage.
     * @param textureParamName  Name of the material param that the texture is assigned to.
     * @param textureUsage      Use for the texture. 'normal', 'bump' or anything else.
     * @returns                 The three.js texture object
     */
    MaterialAsset.prototype.getStandInTexture = function (textureParamName, textureUsage) {
        var texture = this.engine.getAssetById(this.getProperty(textureParamName));
        if (!texture) {
            return;
        }
        var standInTex;
        if (!textureUsage) {
            standInTex = texture.isCubeMap()
                ? StandInTexture.STANDIN_TEXTURE_WHITE_CUBE
                : StandInTexture.STANDIN_TEXTURE_WHITE;
        }
        else if (textureUsage === 'normal') {
            standInTex = StandInTexture.STANDIN_TEXTURE_NORMAL;
        }
        else if (textureUsage === 'bump') {
            standInTex = texture.isCubeMap()
                ? StandInTexture.STANDIN_TEXTURE_BLACK
                : StandInTexture.STANDIN_TEXTURE_BLACK_CUBE;
        }
        return this.engine.materialUtilities.getStandInTexture(standInTex);
    };
    /** @inheritdoc */
    MaterialAsset.prototype.unload = function () {
        var _this = this;
        // Stop listening to texture load events
        this.getDependencies().forEach(function (texture) { return _this.stopListening(texture, 'load'); });
        if (this.runtimeData) {
            this.engine.trigger('materialUnloaded', this.id);
            Logger_1.default.info(this.engine.getName() + ' - Unloading material, '
                + this.getName());
            for (var x in this.runtimeData) {
                if (this.runtimeData.hasOwnProperty(x)) {
                    this.runtimeData[x].dispose();
                    delete this.runtimeData[x];
                }
            }
            this.runtimeData = null;
            _super.prototype.unload.call(this);
        }
    };
    /** @inheritdoc */
    MaterialAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        var _this = this;
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (changes.hasOwnProperty('shader')) {
            var shaderAsset_1 = this.getShader();
            shaderAsset_1.when('load', function () {
                for (var x in MaterialAsset.materialObjectTypes) {
                    if (_this.runtimeData.hasOwnProperty(x)) {
                        var material = _this.runtimeData[x];
                        material.fragmentShader = shaderAsset_1.runtimeData.fragmentShader;
                        material.vertexShader = shaderAsset_1.runtimeData.vertexShader;
                        material.uniforms = THREE.UniformsUtils.clone(shaderAsset_1.runtimeData.uniforms);
                        _this.addSharedUniforms(material.uniforms);
                        for (var key in shaderAsset_1.runtimeData.renderParams) {
                            if (_this.runtimeData[x].hasOwnProperty(key)) {
                                if (_this.isParameterUsed(key)) {
                                    _this.runtimeData[x][key] = shaderAsset_1.runtimeData.renderParams[key];
                                }
                                else {
                                    delete _this.runtimeData[x][key];
                                }
                            }
                        }
                        _this.runtimeData[x].needsUpdate = true;
                        _this.updateMaterialDefines();
                        _this.updateShaderParameters(_this.getProperties());
                        _this.updateTransparency();
                        _this.updateDerivatives();
                        _this.engine.needsRender = true;
                    }
                }
            });
            if (shaderAsset_1.isUnloaded()) {
                shaderAsset_1.load();
            }
        }
        else {
            var shaderAsset = this.getShader();
            var shaderParams = shaderAsset.getProperty('parameters');
            var transparencyNeedsUpdate = false;
            var derivativesNeedsUpdate = false;
            var definesNeedUpdate = false;
            for (var p in changes) {
                if (changes.hasOwnProperty(p)) {
                    if (shaderParams[p]) {
                        if (shaderParams[p].transparency) {
                            transparencyNeedsUpdate = true;
                        }
                        if (typeof shaderParams[p].derivatives !== 'undefined') {
                            derivativesNeedsUpdate = true;
                        }
                        // If there are any parameters that are dependent on the value
                        // of this one, we'll need to break out and rebuild preprocessor
                        // defines.
                        if (shaderAsset.getDependentParameters(p).length || shaderParams[p].forceUpdate) {
                            definesNeedUpdate = true;
                            break;
                        }
                        this.updateShaderParameter(p);
                    }
                }
            }
            if (definesNeedUpdate) {
                this.updateMaterialDefines();
                this.updateShaderParameters(this.getProperties());
                // Merge defines with existing set and force materials to update.
                transparencyNeedsUpdate = true;
                derivativesNeedsUpdate = true;
            }
            if (transparencyNeedsUpdate) {
                this.updateTransparency();
            }
            if (derivativesNeedsUpdate) {
                this.updateDerivatives();
            }
            this.engine.needsRender = true;
        }
    };
    /** @inheritdoc */
    MaterialAsset.prototype.applyPropertiesUnloaded = function (changes) {
        var _this = this;
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var value;
        var prevValue;
        var dependenciesNeedUpdate = false;
        if (changes) {
            functions_1.forEach(changes, function (_param, key) {
                if (shaderParams[key]) {
                    // If a texture has changed, update the size of all objects that rely on this material.
                    if (shaderParams[key].type === 't') {
                        value = _this.getProperty(key);
                        prevValue = _this.getPreviousProperty(key);
                        // Only register the dependency if the parameter is actually being used.
                        if (_this.isParameterUsed(key)) {
                            if (prevValue !== value) {
                                _this.registerDependencyById(value);
                                _this.unregisterDependencyById(prevValue);
                            }
                            // If the parameter isn't currently used, we can't be absolutely sure whether it was
                            // previously used (and therefore previously registered) so just rebuild all of the
                            // dependencies.
                        }
                        else if (prevValue !== value) {
                            dependenciesNeedUpdate = true;
                        }
                    }
                    // If there are any parameters that are dependent on the value
                    // of this one, we'll need to rebuild dependencies
                    if (shaderAsset.getDependentParameters(key).length || shaderParams[key].forceUpdate) {
                        dependenciesNeedUpdate = true;
                    }
                }
            });
            if (dependenciesNeedUpdate) {
                this.resetDependencies();
            }
        }
    };
    /** @inheritdoc */
    MaterialAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        var shaderAsset = this.getShader();
        shaderAsset.when('load', function () {
            _this.runtimeData = {};
            Object.keys(MaterialAsset.materialObjectTypes).forEach(function (typeName) {
                var matParams = {};
                matParams.vertexShader = shaderAsset.runtimeData.vertexShader;
                matParams.fragmentShader = shaderAsset.runtimeData.fragmentShader;
                // Copy the uniforms from the source shader
                matParams.uniforms = THREE.UniformsUtils.clone(shaderAsset.runtimeData.uniforms);
                // Add the uniforms that are shared between all materials
                _this.addSharedUniforms(matParams.uniforms);
                _this.runtimeData[typeName] = new THREE.ShaderMaterial(matParams);
                _this.runtimeData[typeName].name = _this.getName();
                // Assign default renderParams for shader.
                for (var key in shaderAsset.runtimeData.renderParams) {
                    if (_this.runtimeData[typeName].hasOwnProperty(key)) {
                        if (_this.isParameterUsed(key)) {
                            _this.runtimeData[typeName][key] = shaderAsset.runtimeData.renderParams[key];
                        }
                        else {
                            delete _this.runtimeData[typeName][key];
                        }
                    }
                }
                var type = MaterialAsset.materialObjectTypes[typeName];
                // Assign override renderParams from material object type.
                functions_1.forEach(type, function (value, key) {
                    if (_this.runtimeData[typeName].hasOwnProperty(key)) {
                        _this.runtimeData[typeName][key] = value;
                    }
                });
            });
            // Rebuild list of preprocessor defines for each material type
            _this.updateMaterialDefines();
            // Done.
            callback();
        }, this);
        shaderAsset.load();
    };
    /**
     * Test whether the conditions specified for a parameter are satisfied or not. Performs
     * a logical AND on all properties in the given object
     * @param param       The parameter to test
     * @param conditions  Json object structure specifying the AND conditional
     * @returns           True if the result of the test is true
     */
    MaterialAsset.prototype.testParameterCondition = function (param, condition) {
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        if (!shaderParams[param]) {
            return false;
        }
        var value = this.getProperty(param);
        // If this parameter is a texture and is assigned a texture that no longer
        // exists, consider its value as null.
        if (shaderParams[param].type === 't') {
            if (!this.engine.getAssetById(value)) {
                value = null;
            }
        }
        for (var i in condition) {
            if (condition.hasOwnProperty(i)) {
                switch (i) {
                    case 'equals':
                        if (!functions_1.shallowEquals(value, condition[i])) {
                            return false;
                        }
                        break;
                    case 'notEquals':
                        if (functions_1.shallowEquals(value, condition[i])) {
                            return false;
                        }
                        break;
                    case 'equalsDefault':
                        if (!functions_1.shallowEquals(value, shaderParams[param].default)) {
                            return false;
                        }
                        break;
                    case 'notEqualsDefault':
                        if (functions_1.shallowEquals(value, shaderParams[param].default)) {
                            return false;
                        }
                        break;
                    default:
                        return false;
                }
            }
        }
        return true;
    };
    /**
     * Test whether the conditions specified for a parameter are satisfied or not. Performs
     * a logic AND on all properties in the given object
     * @param conditions  Json object structure specifying the AND conditional
     * @returns           True if the result of the test is true
     */
    MaterialAsset.prototype.testParameterConditions = function (conditions) {
        var result = true;
        // Loop through and test each conditional
        for (var i in conditions) {
            if (conditions.hasOwnProperty(i)) {
                if (i === 'or') {
                    if (!this.testParameterConditionsOr(conditions[i])) {
                        result = false;
                        break;
                    }
                }
                else if (!this.testParameterCondition(i, conditions[i])) {
                    result = false;
                    break;
                }
            }
        }
        return result;
    };
    /**
     * Test whether the conditions specified for a parameter are satisfied or not. Performs
     * a logic OR on all properties in the given object.
     * @param conditions  An array of shader conditions.
     * @returns           Whether or not the conditions are satisfied.
     */
    MaterialAsset.prototype.testParameterConditionsOr = function (conditions) {
        var result = false;
        // Loop through and test each conditional
        for (var _i = 0, conditions_1 = conditions; _i < conditions_1.length; _i++) {
            var i = conditions_1[_i];
            if (this.testParameterConditions(i)) {
                result = true;
                break;
            }
        }
        return result;
    };
    /**
     * Calculate and return all of the defines for this material based
     * on the conditions for each parameter.
     * @returns The defines for this material.
     */
    MaterialAsset.prototype.getPreprocessorDefines = function () {
        var _this = this;
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var defines = {};
        // Go through each parameter and build a list of defines
        functions_1.forEach(shaderParams, function (param, paramName) {
            var useDefines = false;
            if (param.enabledWhen) {
                // Handle conditional logic
                if (_this.testParameterConditions(param.enabledWhen)) {
                    useDefines = true;
                }
            }
            else if (!param.isRenderParam) {
                useDefines = true;
            }
            if (useDefines) {
                var defineName = convertToDefine_1.default(paramName);
                defines[defineName] = 0;
                if (param.type === 'opt') {
                    defines[defineName] = param.options[_this.getProperty(paramName)];
                }
                else if (param.type === 't') {
                    var texId = _this.getProperty(paramName);
                    var texture = _this.engine.getAssetById(texId);
                    var mipsDefine = defineName + '_NUM_MIPS';
                    if (texture) {
                        defines[mipsDefine] = texture.getMipCount();
                    }
                    else {
                        defines[mipsDefine] = 0;
                    }
                    if (texture) {
                        var modeDefine = defineName + '_MODE_' +
                            convertToDefine_1.default(texture.getProperty('projectionMode'));
                        defines[modeDefine] = 0;
                        var typeDefine = defineName + '_TYPE_' +
                            convertToDefine_1.default(texture.getProperty('mappingType'));
                        defines[typeDefine] = 0;
                        var encodingDefine = defineName + '_ENCODING_' +
                            convertToDefine_1.default(texture.getProperty('encoding'));
                        defines[encodingDefine] = 0;
                    }
                }
                if (param.defines) {
                    Object.assign(defines, param.defines);
                }
            }
        });
        return defines;
    };
    /**
     * Update the preprocessor defines for each three.js material object based on the
     * current material settings.
     */
    MaterialAsset.prototype.updateMaterialDefines = function () {
        var _this = this;
        var defines = this.getPreprocessorDefines();
        var matTypes = MaterialAsset.materialObjectTypes;
        Object.keys(matTypes).forEach(function (typeName) {
            var matDefines = tslib_1.__assign({}, defines);
            var matType = matTypes[typeName];
            if (matType.defines) {
                var defineNames = Object.keys(matType.defines);
                defineNames.forEach(function (name) {
                    matDefines[name] = matType.defines[name];
                });
            }
            _this.runtimeData[typeName].defines = matDefines;
            _this.runtimeData[typeName].needsUpdate = true;
        });
    };
    /**
     * Link up a uniform that is shared between materials
     * For now, just hardcode this for the 'time' uniform...
     * @param uniforms The shared uniforms object.
     */
    MaterialAsset.prototype.addSharedUniforms = function (uniforms) {
        uniforms['time'] = MaterialAsset.sharedUniforms['time'];
        uniforms['screenDimensions'] = MaterialAsset.sharedUniforms['screenDimensions'];
    };
    /**
     * Update the material state based on the provided parameter changes
     * @param changes Parameter values keyed by parameter name.
     */
    MaterialAsset.prototype.updateShaderParameters = function (changes) {
        var _this = this;
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        functions_1.forEach(changes, function (_value, key) {
            if (shaderParams[key]) {
                _this.updateShaderParameter(key);
            }
        });
    };
    /**
     * Rebuild a fresh list of dependencies for this material and re-register them.
     */
    MaterialAsset.prototype.resetDependencies = function () {
        var _this = this;
        this.unregisterDependencies();
        // Register fresh list of dependencies
        var textures = this.getReferencedAssetsList(true);
        textures.forEach(function (texAsset) { return _this.registerDependency(texAsset); });
    };
    /**
     * Determine whether or not to use derivatives and enable or disable the extension.
     */
    MaterialAsset.prototype.updateDerivatives = function () {
        var _this = this;
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var useDerivatives = false;
        functions_1.forEach(shaderParams, function (param, paramName) {
            if (param.derivatives && _this.isParameterUsed(paramName)) {
                useDerivatives = true;
            }
        });
        this.setExtension('derivatives', useDerivatives);
    };
    /**
     * Go through all the properties of the material that affect transparency and make
     * sure the 'transparent' flag in Three.JS is appropriately set.
     */
    MaterialAsset.prototype.updateTransparency = function () {
        var _this = this;
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var transparencyOn = false;
        for (var paramName in shaderParams) {
            if (shaderParams.hasOwnProperty(paramName)) {
                transparencyOn = this.testParameterTransparency(paramName);
                if (transparencyOn) {
                    break;
                }
            }
        }
        if (this.runtimeData) {
            Object.keys(MaterialAsset.materialObjectTypes).forEach(function (matObjType) {
                _this.runtimeData[matObjType].transparent = transparencyOn;
            });
        }
    };
    /**
     * Test whether transparency should be enabled based on the conditions
     * specified for the given parameter.
     * @param paramName The name of the parameter to check.
     * @returns         True if the value of the parameter should result in this
     *                  material being transparent (assuming that this parameter is
     *                  currently being used.)
     */
    MaterialAsset.prototype.testParameterTransparency = function (paramName) {
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var transparencyCondition;
        if (shaderParams.hasOwnProperty(paramName)) {
            transparencyCondition = shaderParams[paramName].transparency;
            if (transparencyCondition && this.isParameterUsed(paramName)) {
                if (transparencyCondition === 'LessThanOne') {
                    if (this.getProperty(paramName) < 1.0) {
                        return true;
                    }
                }
                else if (transparencyCondition === 'GreaterThanOne') {
                    if (this.getProperty(paramName) > 1.0) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    /**
     * Given a parameter name, determine whether it is currently being used
     * for this material, taking into account conditional logic for the parameter.
     * @param  {String}  name Parameter name
     * @returns {Boolean}     True if the parameter is being used in the current material.
     */
    MaterialAsset.prototype.isParameterUsed = function (name) {
        var shader = this.getShader();
        var shaderParams;
        var result = false;
        if (!shader) {
            return;
        }
        shaderParams = shader.getProperty('parameters');
        if (shaderParams[name]) {
            // If there are conditions for this parameter, test them.
            if (shaderParams[name].enabledWhen) {
                result = this.testParameterConditions(shaderParams[name].enabledWhen);
            }
            else {
                result = true;
            }
        }
        return result;
    };
    /**
     * Called when a texture asset referenced by this material is loaded. This function
     * assigns the texture to the materials uniforms list so that it's ready to use.
     * @param textureAsset The loaded texture asset.
     */
    MaterialAsset.prototype.onTextureLoaded = function (textureAsset) {
        var _this = this;
        // If the texture failed to load, the runtimeData will be empty
        // and we don't want to overwrite the stand-in texture assigned already.
        if (textureAsset.isLoadFailed()) {
            return;
        }
        var texture = textureAsset.getThreeTexture();
        if (!texture) {
            return;
        }
        // Go through list of params and find where this texture should be applied.
        var shaderAsset = this.getShader();
        if (!shaderAsset) {
            return;
        }
        var shaderParams = shaderAsset.getProperty('parameters');
        // Filter out only texture parameters that are in use by the material.
        var texParams = Object.keys(shaderParams).filter(function (paramName) {
            return shaderParams[paramName].type === 't'
                && _this.isParameterUsed(paramName)
                && _this.getProperty(paramName) === textureAsset.id;
        });
        // Set the uniform/renderParam for each texture.
        texParams.forEach(function (paramName) {
            _this.setThreeValue(paramName, texture);
        });
        // If the parameter changing always requires a shader recompile, do it.
        var forceUpdate = texParams.some(function (paramName) {
            return shaderParams[paramName].forceUpdate;
        });
        if (forceUpdate) {
            Object.keys(MaterialAsset.materialObjectTypes).forEach(function (matObjType) {
                _this.runtimeData[matObjType].needsUpdate = true;
            });
        }
        this.engine.needsRender = true;
    };
    /**
     * Update a uniform (or other type of parameter) for the Three.JS material from a key and
     * value pair. The key is checked against the material definition for the given type.
     * @param key Name of material param
     */
    MaterialAsset.prototype.updateShaderParameter = function (key) {
        var _this = this;
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var param = shaderParams[key];
        if (!param) {
            return;
        }
        var valueNeedsSetting = true;
        var value = this.getProperty(key);
        switch (param.type.charAt(0)) {
            case 't':
                {
                    var tex = this.engine.getAssetById(value);
                    if (tex && this.isParameterUsed(key)) {
                        // Don't set the value immediately. Let callback on texture load do it.
                        var prevTexId = this.getPreviousProperty(key);
                        if (prevTexId !== this.getProperty(key)) {
                            var prevTex = this.engine.getEntityById(prevTexId);
                            if (prevTex) {
                                this.stopListening(prevTex, 'load', this.onTextureLoaded);
                            }
                        }
                        // Unbind before binding to catch cases where this texture is already bound.
                        // This probably shouldn't be needed but will require a bit of a refactor to avoid.
                        this.stopListening(tex, 'load', this.onTextureLoaded);
                        this.listenTo(tex, 'load', this.onTextureLoaded);
                        // Assign the missing texture so that this material can render cleanly until
                        // the real texture loads.
                        value = this.getStandInTexture(key, param.textureUsage);
                        this.engine.needsRender = true;
                        // If the texture is completely unloaded, load it.
                        if (tex.isUnloaded()) {
                            tex.load();
                            // Otherwise, if the texture load is already completed, call the callback directly
                        }
                        else if (tex.isLoaded()) {
                            this.onTextureLoaded.call(this, tex);
                        }
                        // If the texture is already loaded, we don't want to set the stand-in texture.
                        if (tex.isLoaded()) {
                            valueNeedsSetting = false;
                        }
                    }
                    else {
                        value = null;
                    }
                }
                break;
            case 'b':
                if (param.animation && value) {
                    MaterialAsset.timeValueInUse = true;
                }
                value = value ? 1 : 0;
                break;
            case 'v':
                if (param.animation && (value.x || value.y || value.z || value.w)) {
                    MaterialAsset.timeValueInUse = true;
                }
                break;
            case 'o':
                value = param.options[value];
                break;
            default:
        }
        if (valueNeedsSetting) {
            this.setThreeValue(key, value);
        }
        // If the parameter changing always requires a material update, do it.
        if (param.forceUpdate) {
            Object.keys(MaterialAsset.materialObjectTypes).forEach(function (matObjType) {
                _this.runtimeData[matObjType].needsUpdate = true;
            });
        }
    };
    /**
     * Return the three.js material parameter/uniform value for the given shader
     * parameter and object type.
     * @param key         The name of the shader parameter
     * @param matObjType  The material object type to return the value from (e.g.
     *                    'static', 'skinned', etc.)
     * @returns           The value of the uniform/material parameter
     */
    MaterialAsset.prototype.getThreeValue = function (key, matObjType) {
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var param = shaderParams[key];
        var paramName = param.uniformName || key;
        var currentValue;
        if (param.isRenderParam) {
            currentValue = this.runtimeData[matObjType][paramName];
        }
        else if (param.isUniform) {
            var uniform = this.runtimeData[matObjType].uniforms[paramName];
            currentValue = uniform ? uniform.value : null;
        }
        if (param.type === 'c') {
            if (!currentValue) {
                currentValue = new THREE.Color(param.default.r, param.default.g, param.default.b);
            }
        }
        else if (param.type.charAt(0) === 'v') {
            if (!currentValue) {
                var defValue = param.default;
                switch (param.type.charAt(1)) {
                    case '4':
                        currentValue = new THREE.Vector4(defValue.x, defValue.y, defValue.z, defValue.w);
                        break;
                    case '3':
                        currentValue = new THREE.Vector3(defValue.x, defValue.y, defValue.z);
                        break;
                    case '2':
                        currentValue = new THREE.Vector2(defValue.x, defValue.y);
                        break;
                    default:
                }
            }
        }
        return currentValue;
    };
    /**
     * Set the uniform or material parameter on Three.js material objects
     * @param key   The name of the shader parameter
     * @param value The new value of the uniform/material parameter
     */
    MaterialAsset.prototype.setThreeValue = function (key, value) {
        var _this = this;
        if (!this.runtimeData) {
            return;
        }
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var param = shaderParams[key];
        var paramName = param.uniformName || key;
        Object.keys(MaterialAsset.materialObjectTypes).forEach(function (matObjType) {
            var currentValue = _this.getThreeValue(key, matObjType);
            if (param.type === 'c') {
                currentValue.setRGB(value.r, value.g, value.b);
            }
            else if (param.type.charAt(0) === 'v') {
                switch (param.type.charAt(1)) {
                    case '4':
                        currentValue.w = value.w;
                    /* falls through */
                    case '3':
                        currentValue.z = value.z;
                    /* falls through */
                    case '2':
                        currentValue.x = value.x;
                        currentValue.y = value.y;
                    /* falls through */
                    default:
                }
            }
            else if (param.type === 't') {
                // If the texture has changed substantially enough, we'll need to recompile the material.
                // Encoding type and mapping type result in different shader code.
                if (!currentValue || !value ||
                    currentValue.encoding !== value.encoding ||
                    currentValue.mapping !== value.mapping) {
                    _this.runtimeData[matObjType].needsUpdate = true;
                }
                currentValue = value;
            }
            else {
                currentValue = value;
            }
            if (param.isUniform) {
                var uniform = _this.runtimeData[matObjType].uniforms[paramName];
                if (!uniform) {
                    throw new Error("Trying to set non-existent uniform " + paramName);
                }
                uniform.value = currentValue;
            }
            if (param.isRenderParam) {
                _this.runtimeData[matObjType][paramName] = currentValue;
            }
        });
    };
    /**
     * Enable or disable the use of an extension.
     * @param key   The name of the extension eg: `derivatives`
     * @param value Whether or not to use this extension
     */
    MaterialAsset.prototype.setExtension = function (key, value) {
        var _this = this;
        if (this.runtimeData) {
            Object.keys(MaterialAsset.materialObjectTypes).forEach(function (matObjType) {
                if (_this.runtimeData[matObjType].extensions.hasOwnProperty(key)) {
                    _this.runtimeData[matObjType].extensions[key] = value;
                }
            });
        }
    };
    /**
     * Handle a texture being deleted/unregistered. If the texture is assigned to
     * any property, set that property to null.
     * @param textureId The ID of the texture that was just deleted.
     */
    MaterialAsset.prototype.onTextureDeleted = function (textureId) {
        var _this = this;
        var properties = this.getOwnProperties();
        var assignedProps = Object.keys(properties).filter(function (propName) {
            return (properties[propName] === textureId);
        });
        assignedProps.forEach(function (propName) {
            _this.setProperty(propName, null);
        });
    };
    return MaterialAsset;
}(BaseAsset_1.default));
/** A mapping of string ids to MaterialAssetDef for built in materials. */
MaterialAsset.builtInAssetDescriptors = {
    missingMaterial: {
        id: 'missingMaterial',
        type: 'material',
        properties: {
            name: 'Missing Material',
            albedoColor: { r: 0.8275, g: 0.8275, b: 0.8275 }
        }
    }
};
/**
 * Definitions for each different three.js material that will be created for
 * each MaterialAsset. This includes things like materials with and without
 * skinning support to support being applied to different types of objects.
 */
MaterialAsset.materialObjectTypes = {
    static: {
        lights: true,
        fog: true,
        skinning: false
    },
    skinned: {
        lights: true,
        fog: true,
        skinning: true
    },
    staticTangents: {
        lights: true,
        fog: true,
        skinning: false,
        defines: {
            USE_TANGENTS: true
        }
    },
    skinnedTangents: {
        lights: true,
        fog: true,
        skinning: true,
        defines: {
            USE_TANGENTS: true
        }
    },
    depthStatic: {
        lights: false,
        fog: false,
        vertexColors: THREE.NoColors,
        skinning: false,
        defines: {
            DEPTH_PASS: true
        }
    },
    depthSkinned: {
        lights: false,
        fog: false,
        vertexColors: THREE.NoColors,
        skinning: true,
        defines: {
            DEPTH_PASS: true
        }
    }
};
/**
 * Definitions for uniforms that are used in all (or some) materials. Rather
 * that update the values of each copy of the uniform separately, these are
 * just shared between materials.
 */
MaterialAsset.sharedUniforms = {
    time: {
        type: 'f',
        value: 0.0
    },
    screenDimensions: {
        type: 'v4',
        value: new THREE.Vector4()
    }
};
/**
 * Boolean to track whether materials are animating (and thus need the time
 * uniform to be updated). If true, the engine is set to update the render
 * every frame.
 */
MaterialAsset.timeValueInUse = false;
Schemas_1.addSchemas('MaterialAsset', MaterialAsset);
exports.default = MaterialAsset;


/***/ }),
/* 15 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseEntity_1 = __webpack_require__(40);
var baseObject = tslib_1.__assign({}, baseEntity_1.default, { id: 'baseObject', title: 'BaseObjectDef', properties: tslib_1.__assign({}, baseEntity_1.default.properties, { parentId: {
            type: 'string',
            description: 'The ID of the entity\'s parent.'
        }, prefabAssetId: {
            type: 'string'
        }, prefabObjectId: {
            type: 'string'
        }, prefabInstanceId: {
            type: 'string'
        }, children: {
            type: 'array',
            items: {
                type: 'string'
            },
            default: [],
            description: 'The IDs of this entity\'s children.'
        }, properties: {
            $ref: 'baseObjectProperties.json'
        } }) });
exports.default = baseObject;


/***/ }),
/* 16 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LoadingType;
(function (LoadingType) {
    LoadingType[LoadingType["BUFFER"] = 1] = "BUFFER";
    LoadingType[LoadingType["IMAGE"] = 2] = "IMAGE";
    LoadingType[LoadingType["VIDEO"] = 3] = "VIDEO";
    LoadingType[LoadingType["ENTITIES"] = 4] = "ENTITIES";
})(LoadingType || (LoadingType = {}));
exports.default = LoadingType;


/***/ }),
/* 17 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseObjectProperties_1 = __webpack_require__(71);
var nodeObjectProperties = tslib_1.__assign({}, baseObjectProperties_1.default, { id: 'nodeObjectProperties', title: 'NodeObjectPropertiesDef', properties: tslib_1.__assign({}, baseObjectProperties_1.default.properties), required: ['position', 'scale', 'quaternion'] });
exports.default = nodeObjectProperties;


/***/ }),
/* 18 */
/***/ (function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(260);
var v4 = __webpack_require__(261);

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ }),
/* 19 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-bitwise */
/* tslint:disable max-file-line-count */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseEntity_1 = __webpack_require__(9);
var BaseAsset_1 = __webpack_require__(6);
var BaseImageAsset_1 = __webpack_require__(11);
var BaseImageAsset_2 = __webpack_require__(11);
var BaseTextureAsset = (function (_super) {
    tslib_1.__extends(BaseTextureAsset, _super);
    function BaseTextureAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Create a 2D Three.js texture with the specified colour.
     * @param r   Red value (0-255)
     * @param g   Green value (0-255)
     * @param b   Blue value (0-255)
     * @param [a] Alpha value (0-255). If undefined, an RGB texture will be created.
     * @returns   A THREE.DataTexture
     */
    BaseTextureAsset.createColorTexture = function (r, g, b, a) {
        if (r === void 0) { r = 255; }
        if (g === void 0) { g = 255; }
        if (b === void 0) { b = 255; }
        var format = THREE.RGBFormat;
        var byteSize = a !== undefined ? 4 : 3;
        var data = new Uint8Array(byteSize);
        data[0] = r;
        data[1] = g;
        data[2] = b;
        if (byteSize === 4) {
            data[3] = a;
            format = THREE.RGBAFormat;
        }
        var texture = new THREE.DataTexture(data, 1, 1, format, undefined, undefined, undefined, undefined, undefined, undefined);
        texture.needsUpdate = true;
        return texture;
    };
    /**
     * Create a cubemap Three.js texture with the specified colour.
     * @param r   Red value (0-255)
     * @param g   Green value (0-255)
     * @param b   Blue value (0-255)
     * @param [a] Alpha value (0-255). If undefined, an RGB texture will be created.
     * @returns   A THREE.CubeTexture
     */
    BaseTextureAsset.createColorTextureCube = function (r, g, b, a) {
        if (r === void 0) { r = 255; }
        if (g === void 0) { g = 255; }
        if (b === void 0) { b = 255; }
        var sides = [0, 1, 2, 3, 4, 5].map(function (_s) {
            return BaseTextureAsset.createColorTexture(r, g, b, a);
        });
        var texture = new THREE.CubeTexture(sides);
        texture.generateMipmaps = false;
        texture.format = sides[0].format;
        texture.minFilter = THREE.NearestFilter;
        texture.magFilter = THREE.NearestFilter;
        texture.needsUpdate = true;
        return texture;
    };
    /**
     * Returns a 2D texture to be used in place of missing assets.
     * @returns The missing texture.
     */
    BaseTextureAsset.getMissingTexture = function () {
        if (!BaseTextureAsset.missingTexture2d) {
            BaseTextureAsset.missingTexture2d = BaseTextureAsset.createColorTexture();
        }
        return BaseTextureAsset.missingTexture2d;
    };
    /**
     * Returns a cube texture to be used in place of missing assets.
     * @returns THREE.CubeTexture
     */
    BaseTextureAsset.getMissingTextureCube = function () {
        if (!BaseTextureAsset.missingTextureCube) {
            BaseTextureAsset.missingTextureCube = BaseTextureAsset.createColorTextureCube();
        }
        return BaseTextureAsset.missingTextureCube;
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.initialize = function () {
        var _this = this;
        _super.prototype.initialize.call(this);
        this.listenTo(this.engine, 'imageUnloaded', function (imageId) {
            // If this texture is using the image, unload the texture so that entities
            // listening for texture unload can take action.
            if (_this.getProperty('imageId') === imageId) {
                _this.unload();
            }
        });
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        var handleImageFailure = function () {
            _this.runtimeData = BaseTextureAsset.getMissingTexture();
            _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
            _this.trigger('loadProgress', _this);
            if (typeof callback === 'function') {
                callback.call(_this);
            }
        };
        var imageAsset = this.getImage();
        if (imageAsset) {
            // Listen to 'load' event on the image. This can happen multiple times if
            // the image is streaming or a properties change force a new version
            // to be downloaded.
            var onImageLoad = function (image) {
                if (!image.runtimeData) {
                    handleImageFailure();
                    return;
                }
                _this.createTextureData(image.runtimeData);
                if (typeof callback === 'function') {
                    callback.call(_this);
                }
            };
            this.listenTo(imageAsset, 'load', onImageLoad);
            if (imageAsset.isLoaded()) {
                onImageLoad.call(this, imageAsset);
            }
            if (imageAsset.isUnloaded()) {
                imageAsset.load();
            }
        }
        else {
            handleImageFailure();
        }
    };
    /**
     * Create the three.js texture object using the loaded image
     * @param image The runtime data from the image asset
     */
    BaseTextureAsset.prototype.createTextureData = function (_image) {
        Logger_1.default.warn('Need to implement createTextureData in derrived class.');
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.unload = function () {
        // Stop listening to image load events when this texture is unloaded.
        var imageAsset = this.getImage();
        if (imageAsset) {
            this.stopListening(imageAsset, 'load');
        }
        if (this.runtimeData) {
            this.engine.trigger('textureUnloaded', this.id);
            Logger_1.default.info(this.engine.getName() + ' - Unloading texture, ' +
                this.getName());
            this.runtimeData.dispose();
        }
        _super.prototype.unload.call(this);
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        var texture = this.runtimeData instanceof THREE.WebGLRenderTarget ?
            this.runtimeData.texture : this.runtimeData;
        // Textures should always have flipY turned off because it can't be applied to all
        // texture types (e.g. hardware compressed textures). Our shaders will always do
        // the y-flip for us.
        texture.flipY = false;
        if (changes.hasOwnProperty('uMapping')) {
            texture.wrapS = this.getThreeAddressMode(this.getAddressModeU());
        }
        if (changes.hasOwnProperty('vMapping')) {
            texture.wrapT = this.getThreeAddressMode(this.getAddressModeV());
        }
        if (changes.hasOwnProperty('anisotropy')) {
            texture.anisotropy = this.getProperty('anisotropy');
        }
        if (changes.hasOwnProperty('minFilter')) {
            texture.minFilter = this.getThreeFilter(this.getMinFilter());
        }
        if (changes.hasOwnProperty('magFilter')) {
            texture.magFilter = this.getThreeFilter(this.getMagFilter());
        }
        if (changes.hasOwnProperty('generateMipmaps')) {
            texture.generateMipmaps = this.isMipmapsEnabled();
        }
        this.engine.needsRender = true;
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.hasOwnProperty('imageId')) {
            var prevImg = this.getPreviousProperty('imageId');
            if (prevImg) {
                this.unregisterDependencyById(prevImg);
            }
            if (changes.imageId) {
                this.registerDependencyById(this.getProperty('imageId'));
            }
        }
        this.engine.trigger('textureChanged', this.id, changes);
    };
    /**
     * Return the address mode (mapping) for the U axis, taking into account which modes are supported
     * for the image. For example, non power-of-two images must use the "clamp" mode.
     * @returns The best supported address mode.
     */
    BaseTextureAsset.prototype.getAddressModeU = function () {
        return this.getSupportedAddressMode(this.getProperty('uMapping'));
    };
    /**
     * Return the address mode (mapping) for the V axis, taking into account which modes are supported
     * for the image. For example, non power-of-two images must use the "clamp" mode.
     * @returns The best supported address mode.
     */
    BaseTextureAsset.prototype.getAddressModeV = function () {
        return this.getSupportedAddressMode(this.getProperty('vMapping'));
    };
    /**
     * Return the address mode (mapping), taking into account which modes are supported for the image.
     * For example, non power-of-two images must use the "clamp" mode.
     * @param mode  The desired address mode.
     * @returns     The closest supported address mode.
     */
    BaseTextureAsset.prototype.getSupportedAddressMode = function (mode) {
        var image = this.getImage();
        if (image && !image.isPowerOfTwo()) {
            return 'clamp';
        }
        return mode;
    };
    /**
     * Return the layout type of the texture. The different possibilities
     * are defined in BaseImageAsset.LAYOUT. This value comes from the image
     * asset used by this texture or, in the case of renderTextures, is a
     * property of the texture.
     * @returns The layout enum.
     */
    BaseTextureAsset.prototype.getLayout = function () {
        var myLayout = this.getProperty('layout');
        if (myLayout) {
            return myLayout;
        }
        var imageAsset = this.getImage();
        return imageAsset ? imageAsset.getProperty('layout') : BaseImageAsset_2.ImageLayout.Normal;
    };
    /**
     * Returns the width of the texture.
     * @returns The texture width.
     */
    BaseTextureAsset.prototype.getWidth = function () {
        var imageAsset = this.getImage();
        return imageAsset ? imageAsset.getWidth() : 1;
    };
    /**
     * Returns the height of the texture.
     * @returns The texture height.
     */
    BaseTextureAsset.prototype.getHeight = function () {
        var imageAsset = this.getImage();
        return imageAsset ? imageAsset.getHeight() : 1;
    };
    /**
     * Return the minification filter based on the texture's 'minFilter' property, taking into
     * account the capabilities of the current hardware and the texture's data type. e.g. if linear
     * filtering isn't supported for the current data type, this will return the 'nearest' filter.
     * @returns The best supported filter.
     */
    BaseTextureAsset.prototype.getMinFilter = function () {
        return this.getSupportedFilter(this.getProperty('minFilter'));
    };
    /**
     * Return the magnification filter based on the texture's 'magFilter' property, taking into
     * account the capabilities of the current hardware and the texture's data type. e.g. if linear
     * filtering isn't supported for the current data type, this will return the 'nearest' filter.
     * @returns The best supported filter.
     */
    BaseTextureAsset.prototype.getMagFilter = function () {
        return this.getSupportedFilter(this.getProperty('magFilter'));
    };
    /**
     * Given a texture filter, check if it's supported by the current hardware for the current
     * data type and modify and return the filter as necessary. If the filter is supported, the
     * returned value is the same as the filter passed in.
     * @param filter  The filter that we want to check for support
     * @returns       The filter closest to the one passed in that is supported
     * by the current hardware in combination with the current data type.
     */
    BaseTextureAsset.prototype.getSupportedFilter = function (filter) {
        // If we have a float type, check for a compatible filtering extension.
        var type = this.getDataType();
        if (!this.isLinearFilterAvailableForType(type)) {
            return 'nearest';
        }
        // Don't use mipmap filters when mipmapping is disabled.
        if (!this.isMipmapsEnabled()) {
            switch (filter) {
                default:
                case 'nearest':
                case 'nearestWithNearestMipmap':
                case 'nearestWithLinearMipmap':
                    return 'nearest';
                case 'linear':
                case 'linearWithNearestMipmap':
                case 'linearWithLinearMipmap':
                    return 'linear';
            }
        }
        return filter;
    };
    /**
     * Return the texture type of this asset (e.g. 'float', 'uByte', etc.). If the texture type is
     * not compatible with the current hardware, the closest type will be returned instead.
     * @returns The data type of the texture.
     */
    BaseTextureAsset.prototype.getDataType = function () {
        var type = this.getProperty('type');
        if (!type) {
            var image = this.getImage();
            if (image) {
                return image.getDataType();
            }
            return 'uByte';
        }
        var returnType = type;
        var renderer = this.engine.getThreeRenderer();
        var extensions = renderer.extensions;
        switch (type) {
            case 'float':
                if (extensions.get('OES_texture_float')) {
                    returnType = 'float';
                    break;
                }
            /* falls through */
            // (for fallback compatibility)
            case 'halfFloat':
                if (extensions.get('OES_texture_half_float')) {
                    returnType = 'halfFloat';
                }
                else {
                    returnType = 'uByte';
                }
                break;
            default:
                returnType = type;
        }
        return returnType;
    };
    /**
     * Get the format for this texture. 'rgb', 'rgba', etc.
     * @returns The image format as a string.
     */
    BaseTextureAsset.prototype.getFormat = function () {
        var format = this.getProperty('format');
        if (!format) {
            var image = this.getImage();
            if (image) {
                return image.getFormat();
            }
            return 'rgb';
        }
        return format;
    };
    /**
     * Returns the number of mip levels that this texture has, including the full-resolution version.
     * @returns The total number of mip levels used by this texture.
     */
    BaseTextureAsset.prototype.getMipCount = function () {
        if (!this.getProperty('generateMipmaps')) {
            return 1;
        }
        var imageAsset = this.getImage();
        return imageAsset ? imageAsset.getMipCount() : 1;
    };
    /**
     * Return the image asset that is used by this texture, if any.
     * @returns The image asset that is used by this texture, if any.
     */
    BaseTextureAsset.prototype.getImage = function () {
        return this.engine.getAssetById(this.getProperty('imageId'));
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.getDataSizeInMemorySelf = function () {
        var image = this.getImage();
        if (image instanceof BaseImageAsset_1.default) {
            var rep = image.getChosenRepresentation();
            if (!rep) {
                // TODO - video assets that use video tags dont' have representations. So, what should we do here?
                return image.getDataSizeInMemory();
            }
            if (rep.compression && rep.compression !== 'zip' && rep.compression !== 'jpeg') {
                return this.getDataSizeDownloadSelf();
            }
            if (this.getHdrPackingType(rep.channels)) {
                return this.getWidth() * this.getHeight() * BaseImageAsset_1.default.getBytesPerPixel('rgb', this.getDataType());
            }
        }
        return this.getWidth() * this.getHeight() * BaseImageAsset_1.default.getBytesPerPixel(this.getFormat(), this.getDataType());
    };
    /**
     * Returns true iff the texture is a cube texture.
     * @returns Returns true iff the texture is a cube texture.
     */
    BaseTextureAsset.prototype.isCubeMap = function () {
        return this.type === 'textureCube' || this.type === 'renderTextureCube';
    };
    /**
     * Returns true iff linear texture filtering is supported for the provided type
     * on the current hardware.
     * @param dataType  The dataType of the texture (e.g. 'float', 'halfFloat', 'uByte', etc.)
     * @returns         Returns the three.js type (e.g. THREE.FloatType)
     */
    BaseTextureAsset.prototype.isLinearFilterAvailableForType = function (dataType) {
        var renderer = this.engine.getThreeRenderer();
        var extensions = renderer.extensions;
        switch (dataType) {
            case 'halfFloat':
                return !!extensions.get('OES_texture_half_float_linear');
            case 'float':
                return !!extensions.get('OES_texture_float_linear');
            default:
                return true;
        }
    };
    /**
     * Return true if mipmaps are enabled and supported for the data type and image size; otherwise,
     * returns false. For example, non power-of-two images cannot have mipmaps.
     * @returns True if mipmaps are enabled; otherwise, false.
     */
    BaseTextureAsset.prototype.isMipmapsEnabled = function () {
        if (!this.isLinearFilterAvailableForType(this.getDataType())) {
            return false;
        }
        // TODO: isPowerOfTwo() is currently based on the dimensions of the *original* image, not the
        // *loaded* image, so this isn't quite correct. We need to re-evaluate the behaviour of
        // getWidth(), getHeight(), isPowerOfTwo(), etc..
        var image = this.getImage();
        if (image && !image.isPowerOfTwo()) {
            return false;
        }
        return this.getProperty('generateMipmaps');
    };
    /**
     * Return the packing format of the HDR texture. Returns null if either not HDR or
     * not a recognized packing type.
     * @param channels  The channels array for the image. e.g. ['red', 'green', 'blue']
     * @returns         The packing format of the HDR texture (e.g. 'rgbe')
     */
    BaseTextureAsset.prototype.getHdrPackingType = function (channels) {
        if (channels && channels.length === 4 && channels[3] === 'exponent') {
            return 'rgbe';
        }
        return null;
    };
    /**
     * Create DXT compressed texture from an array buffer containing the data.
     * @param buffer  The binary data representing the DXT image file.
     * @returns       The three.js compressed texture
     */
    BaseTextureAsset.prototype.createDxtTextureData = function (buffer) {
        var texture = new THREE.CompressedTexture(null, 0, 0);
        var dds = this.parseDDS(buffer, true);
        var iFace;
        var iMip;
        var nFaces;
        texture.format = dds.format;
        texture.generateMipmaps = false;
        if (dds.isCubemap) {
            texture.flipY = false;
            // FIXME: THREE.CompressedTexture doesn't seem to like this attribute
            // bypassing via cast as `any`. Is this a bug?
            var image = texture.image = [];
            nFaces = dds.mipmaps.length / dds.mipmapCount;
            for (iFace = 0; iFace < nFaces; iFace += 1) {
                image[iFace] = {
                    mipmaps: []
                };
                for (iMip = 0; iMip < dds.mipmapCount; iMip += 1) {
                    image[iFace].mipmaps.push(dds.mipmaps[iFace * dds.mipmapCount + iMip]);
                    image[iFace].format = dds.format;
                    image[iFace].width = dds.width;
                    image[iFace].height = dds.height;
                }
            }
        }
        else {
            texture.mipmaps = dds.mipmaps;
            texture.image.width = dds.width;
            texture.image.height = dds.height;
        }
        return texture;
    };
    /**
     * Get the three.js texture object for this texture. Note that if this is a render texture, this
     * function returns the texture object inside the render target object.
     * @returns The three.js texture object for this texture.
     */
    BaseTextureAsset.prototype.getThreeTexture = function () {
        if (this.runtimeData) {
            return this.runtimeData.texture ? this.runtimeData.texture : this.runtimeData;
        }
        return null;
    };
    /**
     * Converts a Box3D address mode string into a THREE.js Wrapping constant.
     * @param addressMode A string representing the wrapping mode.
     * @returns           The THREE.js wrapping constant.
     */
    BaseTextureAsset.prototype.getThreeAddressMode = function (addressMode) {
        switch (addressMode) {
            case 'wrap':
                return THREE.RepeatWrapping;
            case 'clamp':
                return THREE.ClampToEdgeWrapping;
            case 'mirror':
                return THREE.MirroredRepeatWrapping;
            default:
                Logger_1.default.warn("Unexpected address mode setting: " + addressMode + " defaulting to THREE.ClampToEdgeWrapping");
                return THREE.ClampToEdgeWrapping;
        }
    };
    /**
     * Converts a Box3D filter string into a THREE.js Texture Filter constant.
     * @param filter  A string representing the texture filter setting.
     * @returns       The THREE.js texture filter constant.
     */
    BaseTextureAsset.prototype.getThreeFilter = function (filter) {
        switch (filter) {
            case 'nearest':
                return THREE.NearestFilter;
            case 'nearestWithNearestMipmap':
                return THREE.NearestMipMapNearestFilter;
            case 'nearestWithLinearMipmap':
                return THREE.NearestMipMapLinearFilter;
            case 'linear':
                return THREE.LinearFilter;
            case 'linearWithNearestMipmap':
                return THREE.LinearMipMapNearestFilter;
            case 'linearWithLinearMipmap':
                return THREE.LinearMipMapLinearFilter;
            default:
                Logger_1.default.warn("Unexpected filter setting: " + filter + " defaulting to THREE.LinearFilter");
                return THREE.LinearFilter;
        }
    };
    /**
     * Parse the downloaded DDS file
     * @param buffer      The array buffer containing the downloaded DXT-compressed image
     * @param loadMipmaps True if we want to load mipmaps (if they exist in the data)
     * @returns           An object containing information about the DDS
     */
    BaseTextureAsset.prototype.parseDDS = function (buffer, loadMipmaps) {
        // Disabled  ext-variable-name due to adaptation from external code.
        /* tslint:disable ext-variable-name */
        // Adapted from @toji's DDS utils
        //  https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js
        // All values and structures referenced from:
        // http://msdn.microsoft.com/en-us/library/bb943991.aspx/
        /**
         * Converts a four character code into an 32 bit integer.
         * @param value The four character code.
         * @returns     The converted 32 bit integer.
         */
        function fourCCToInt32(value) {
            return value.charCodeAt(0) +
                (value.charCodeAt(1) << 8) +
                (value.charCodeAt(2) << 16) +
                (value.charCodeAt(3) << 24);
        }
        /**
         * Converts a 32 bit integer into a four character code.
         * @param value The 32 bit integer.
         * @returns     The four character code.
         */
        function int32ToFourCC(value) {
            return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);
        }
        /**
         * Extracts a mip from the input buffer.
         * @param buf         The array buffer to load from.
         * @param dataOffset  The offset into the buffer for this mip.
         * @param width       The width of the mip.
         * @param height      The height of the mip.
         * @returns           An extracted unsigned 8 bit array.
         */
        function loadARGBMip(buf, dataOffset, width, height) {
            var dataLength = width * height * 4;
            var srcBuffer = new Uint8Array(buf, dataOffset, dataLength);
            var byteArray = new Uint8Array(dataLength);
            var dst = 0;
            var src = 0;
            var x;
            var y;
            var r;
            var g;
            var b;
            var a;
            for (y = 0; y < height; y += 1) {
                for (x = 0; x < width; x += 1) {
                    b = srcBuffer[src];
                    g = srcBuffer[src + 1];
                    r = srcBuffer[src + 2];
                    a = srcBuffer[src + 3];
                    byteArray[dst] = r; // r
                    byteArray[dst + 1] = g; // g
                    byteArray[dst + 2] = b; // b
                    byteArray[dst + 3] = a; // a
                    src += 4;
                    dst += 4;
                }
            }
            return byteArray;
        }
        var DDS_MAGIC = 0x20534444;
        // DDSD_CAPS = 0x1,
        // DDSD_HEIGHT = 0x2,
        // DDSD_WIDTH = 0x4,
        // DDSD_PITCH = 0x8,
        // DDSD_PIXELFORMAT = 0x1000,
        var DDSD_MIPMAPCOUNT = 0x20000;
        // DDSD_LINEARSIZE = 0x80000,
        // DDSD_DEPTH = 0x800000,
        // DDSCAPS_COMPLEX = 0x8,
        // DDSCAPS_MIPMAP = 0x400000,
        // DDSCAPS_TEXTURE = 0x1000,
        var DDSCAPS2_CUBEMAP = 0x200;
        // DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
        // DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
        // DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
        // DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
        // DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
        // DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
        // DDSCAPS2_VOLUME = 0x200000,
        // DDPF_ALPHAPIXELS = 0x1,
        // DDPF_ALPHA = 0x2,
        var DDPF_FOURCC = 0x4;
        // DDPF_RGB = 0x40,
        // DDPF_YUV = 0x200,
        // DDPF_LUMINANCE = 0x20000,
        var FOURCC_DXT1 = fourCCToInt32('DXT1');
        var FOURCC_DXT3 = fourCCToInt32('DXT3');
        var FOURCC_DXT5 = fourCCToInt32('DXT5');
        var headerLengthInt = 31; // The header length in 32 bit ints
        // Offsets into the header array
        var off_magic = 0;
        var off_size = 1;
        var off_flags = 2;
        var off_height = 3;
        var off_width = 4;
        var off_mipmapCount = 7;
        var off_pfFlags = 20;
        var off_pfFourCC = 21;
        var off_RGBBitCount = 22;
        var off_RBitMask = 23;
        var off_GBitMask = 24;
        var off_BBitMask = 25;
        var off_ABitMask = 26;
        // off_caps = 27,
        var off_caps2 = 28;
        // off_caps3 = 29,
        // off_caps4 = 30,
        var header;
        var blockBytes;
        var fourCC;
        var isRGBAUncompressed;
        var dataOffset;
        var width;
        var height;
        var iFace;
        var nFaces;
        var iMip;
        var byteArray;
        var dataLength;
        var dds = {
            mipmaps: [],
            width: 0,
            height: 0,
            format: null,
            mipmapCount: 1
        };
        header = new Int32Array(buffer, 0, headerLengthInt);
        // Parse header
        if (header[off_magic] !== DDS_MAGIC) {
            Logger_1.default.error('THREE.DDSLoader.parse: Invalid magic number in DDS ' +
                'header.');
            return dds;
        }
        if (!(header[off_pfFlags] & DDPF_FOURCC)) {
            Logger_1.default.error('THREE.DDSLoader.parse: Unsupported format, must ' +
                'contain a FourCC code.');
            return dds;
        }
        fourCC = header[off_pfFourCC];
        isRGBAUncompressed = false;
        switch (fourCC) {
            case FOURCC_DXT1:
                blockBytes = 8;
                dds.format = THREE.RGB_S3TC_DXT1_Format;
                break;
            case FOURCC_DXT3:
                blockBytes = 16;
                dds.format = THREE.RGBA_S3TC_DXT3_Format;
                break;
            case FOURCC_DXT5:
                blockBytes = 16;
                dds.format = THREE.RGBA_S3TC_DXT5_Format;
                break;
            default:
                if (header[off_RGBBitCount] === 32 &&
                    header[off_RBitMask] & 0xff0000 &&
                    header[off_GBitMask] & 0xff00 &&
                    header[off_BBitMask] & 0xff &&
                    header[off_ABitMask] & 0xff000000) {
                    isRGBAUncompressed = true;
                    blockBytes = 64;
                    dds.format = THREE.RGBAFormat;
                }
                else {
                    Logger_1.default.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));
                    return dds;
                }
        }
        dds.mipmapCount = 1;
        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
            dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
        }
        // TODO: Verify that all faces of the cubemap are present with
        // DDSCAPS2_CUBEMAP_POSITIVEX, etc.
        dds.isCubemap = header[off_caps2] & DDSCAPS2_CUBEMAP ? true : false;
        dds.width = header[off_width];
        dds.height = header[off_height];
        dataOffset = header[off_size] + 4;
        // Extract mipmaps buffers
        width = dds.width;
        height = dds.height;
        nFaces = dds.isCubemap ? 6 : 1;
        for (iFace = 0; iFace < nFaces; iFace += 1) {
            for (iMip = 0; iMip < dds.mipmapCount; iMip += 1) {
                if (isRGBAUncompressed) {
                    byteArray = loadARGBMip(buffer, dataOffset, width, height);
                    dataLength = byteArray.length;
                }
                else {
                    dataLength = Math.max(4, width) / 4 * Math.max(4, height) /
                        4 * blockBytes;
                    byteArray = new Uint8Array(buffer, dataOffset, dataLength);
                }
                dds.mipmaps.push({
                    data: byteArray,
                    width: width,
                    height: height
                });
                dataOffset += dataLength;
                width = Math.max(width * 0.5, 1);
                height = Math.max(height * 0.5, 1);
            }
            width = dds.width;
            height = dds.height;
        }
        return dds;
        /* tslint:enable ext-variable-name */
    };
    return BaseTextureAsset;
}(BaseAsset_1.default));
/** The texture to be used in place of a missing texture2d. */
BaseTextureAsset.missingTexture2d = null;
/** The texture to be used in place of a missing textureCube. */
BaseTextureAsset.missingTextureCube = null;
exports.default = BaseTextureAsset;


/***/ }),
/* 20 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseAsset_1 = __webpack_require__(6);
var functions_1 = __webpack_require__(5);
var LoadingEvent_1 = __webpack_require__(12);
var LoadingType_1 = __webpack_require__(16);
var Schemas_1 = __webpack_require__(4);
/**
 * An asset that holds binary data.
 * @class BufferAsset
 */
var BufferAsset = (function (_super) {
    tslib_1.__extends(BufferAsset, _super);
    function BufferAsset() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * The number of loaded bytes.
         * @protected
         * @type {number}
         */
        _this.loadedBytes = 0;
        /**
         * The associated array buffer.
         * @private
         * @type {ArrayBuffer}
         */
        _this.buffer = null;
        /**
         * A mapping of accessor keys to extracted typed arrays.
         * @private
         * @type {ObjectMap<TypedArray>}
         */
        _this.arrays = {};
        return _this;
    }
    /**
     * Given an accessor ID (i.e., <buffer-id>#<accessor-name>), locate the BufferAsset and return the
     * accessor with the specified name.
     * @param engine      The engine containing the BufferAsset
     * @param accessorId  The accessor ID with the form: <buffer-id>#<accessor-name>
     * @returns           The accessor, or null if the BufferAsset or accessor is not found
     * @throws Error
     */
    BufferAsset.getBufferAccessor = function (engine, accessorId) {
        var tokens = accessorId.split('#');
        if (tokens.length !== 2) {
            throw new Error(engine.getName() + ' - BufferAsset: Invalid accessorId, ' + accessorId);
        }
        var bufferId = tokens[0];
        var accessorName = tokens[1];
        var bufferAsset = engine.getEntityById(bufferId);
        if (!bufferAsset) {
            throw new Error(engine.getName() + ' - BufferAsset: BufferAsset not found, ' + bufferId);
        }
        var accessor = bufferAsset.getAccessor(accessorName);
        if (!accessor) {
            throw new Error(engine.getName() + ' - BufferAsset: Accessor not found, ' + accessorName);
        }
        return accessor;
    };
    /**
     * Given an accessor ID (i.e., <buffer-id>#<accessor-name>), locate the BufferAsset and return the
     * array of the accessor with the specified name.
     * @param engine      The engine containing the BufferAsset
     * @param accessorId  The accessor ID with the form: <buffer-id>#<accessor-name>
     * @returns           The typed array, or null if the BufferAsset or accessor is not found
     * @throws Error
     */
    BufferAsset.getBufferArray = function (engine, accessorId) {
        var tokens = accessorId.split('#');
        if (tokens.length !== 2) {
            throw new Error(engine.getName() + ' - BufferAsset: Invalid accessorId, ' + accessorId);
        }
        var bufferId = tokens[0];
        var accessorName = tokens[1];
        var bufferAsset = engine.getEntityById(bufferId);
        if (!bufferAsset) {
            throw new Error(engine.getName() + ' - BufferAsset: BufferAsset not found, ' + bufferId);
        }
        var array = bufferAsset.getArray(accessorName);
        if (!array) {
            throw new Error(engine.getName() + ' - BufferAsset: Accessor not found, ' + accessorName);
        }
        return array;
    };
    /**
     * Returns the size (in bytes) of the specified component type.
     * @method getComponentTypeSize
     * @public
     * @param {String} componentType One of: 'int8', 'int16', 'int32', 'float16',
     * 'float32', 'float64'.
     * @returns {number} The byte size of the specified component type.
     */
    BufferAsset.getComponentTypeSize = function (componentType) {
        if (!BufferAsset.componentTypeSizes.hasOwnProperty(componentType)) {
            throw new Error('Unknown component type, ' + componentType);
        }
        return BufferAsset.componentTypeSizes[componentType];
    };
    /**
     * Returns the size (in components) of the specified type.
     * @method getTypeSize
     * @public
     * @param {String} type One of: 'scalar', 'vec2', 'vec3', 'vec4', 'mat2',
     * 'mat3', 'mat4'.
     * @returns {number} The size of the specified type.
     */
    BufferAsset.getTypeSize = function (type) {
        if (!BufferAsset.typeSizes.hasOwnProperty(type)) {
            throw new Error('Unknown attribute value type, ' + type);
        }
        return BufferAsset.typeSizes[type];
    };
    /** @inheritdoc */
    BufferAsset.prototype.unload = function () {
        this.buffer = null;
        this.arrays = {};
        _super.prototype.unload.call(this);
    };
    /**
     * Returns the accessor with the specified name.
     * @method getAccessor
     * @public
     * @param {String} The name of the accessor.
     * @returns {Object|undefined} The accessor with the specified name, if it
     * exists; otherwise, undefined.
     */
    BufferAsset.prototype.getAccessor = function (name) {
        var accessors = this.getProperty('accessors');
        return accessors[name];
    };
    /**
     * Returns the typed-array for the accessor with the specified name.
     * @method getArray
     * @public
     * @param {String} name The name of the accessor.
     * @returns {TypedArray|undefined} The typed-array with the specified name, if
     * it exists; otherwise, undefined.
     */
    BufferAsset.prototype.getArray = function (name) {
        return this.arrays[name];
    };
    /** @inheritdoc */
    BufferAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        var resource = this.loadResource(this.getProperty('src'), LoadingType_1.default.BUFFER, callback, { size: 1, priority: 1, isExternal: this.getProperty('isExternal') });
        resource.on(LoadingEvent_1.default.PROGRESS, function (progressObj) {
            _this.loadedBytes = _this.getDataSizeDownload() * progressObj.loaded / progressObj.total;
            _this.trigger('loadProgress', _this);
        });
        resource.on(LoadingEvent_1.default.LOAD, function (data) {
            _this.buffer = data;
            _this.createArrays();
            _this.loadedBytes = _this.getDataSizeDownload();
        });
    };
    /** @inheritdoc */
    BufferAsset.prototype.getDataSizeDownloadSelf = function () {
        // Loop through each accessor and total up the size of the data.
        var accessors = this.getProperty('accessors');
        return Object.keys(accessors).map(function (name) {
            var acc = accessors[name];
            return BufferAsset.getComponentTypeSize(acc.componentType) *
                BufferAsset.getTypeSize(acc.type) * acc.count;
        }).reduce(function (total, size) {
            return size + total;
        }, 0);
    };
    /** @inheritdoc */
    BufferAsset.prototype.getDataSizeLoadedSelf = function () {
        return this.loadedBytes;
    };
    /**
     * Returns the typed-array constructor for the specified component type.
     * @method getArrayType
     * @private
     * @param {String} componentType One of: 'int8', 'uint8', 'int16', 'uint16',
     * 'int32', 'uint32', 'float32', 'float64'.
     * @returns {Function} The typed-array constructor.
     */
    BufferAsset.prototype.getArrayType = function (componentType) {
        if (!BufferAsset.arrayTypes.hasOwnProperty(componentType)) {
            throw new Error('Unknown component type, ' + componentType);
        }
        return BufferAsset.arrayTypes[componentType];
    };
    /**
     * Create a typed-array for the specified accessor.
     * @method createArray
     * @private
     * @param {Object} accessor The accessor to create a typed-array for.
     * @returns {TypedArray} The typed-array for the accessor.
     */
    BufferAsset.prototype.createArray = function (accessor) {
        var type = this.getArrayType(accessor.componentType);
        var typeSize = BufferAsset.getTypeSize(accessor.type);
        return new type(this.buffer, accessor.byteOffset, accessor.count * typeSize);
    };
    /**
     * Create a typed-array for each accessor.
     * @method createArrays
     * @private
     * @returns {void}
     */
    BufferAsset.prototype.createArrays = function () {
        var _this = this;
        var accessors = this.getProperty('accessors');
        this.arrays = functions_1.map(accessors, function (accessor) {
            return _this.createArray(accessor);
        });
    };
    return BufferAsset;
}(BaseAsset_1.default));
/**
 * Maps array types to typed-array constructors.
 */
BufferAsset.arrayTypes = {
    int8: Int8Array,
    uint8: Uint8Array,
    int16: Int16Array,
    uint16: Uint16Array,
    int32: Int32Array,
    uint32: Uint32Array,
    float32: Float32Array,
    float64: Float64Array
};
/**
 * Maps accessor types to sizes (number of components per value).
 */
BufferAsset.typeSizes = {
    scalar: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16
};
/**
 * Maps component types to sizes (number of bytes per component).
 */
BufferAsset.componentTypeSizes = {
    int8: 1,
    uint8: 1,
    int16: 2,
    uint16: 2,
    int32: 4,
    uint32: 4,
    float16: 2,
    float32: 4,
    float64: 8
};
Schemas_1.addSchemas('BufferAsset', BufferAsset);
exports.default = BufferAsset;


/***/ }),
/* 21 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var baseTextureAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'baseTextureAssetProperties', title: 'BaseTextureAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { uMapping: {
            type: 'string',
            description: '',
            default: 'wrap'
        }, vMapping: {
            type: 'string',
            description: '',
            default: 'wrap'
        }, 
        // This value is temporarily here for compatibility with three.js
        // Remove it when adding a separate transform object to textures.
        mappingType: {
            type: 'string',
            default: 'equirec'
        }, 
        // This value is temporarily here for compatibility with three.js
        // It really doesn't belong anywhere near the texture...
        projectionMode: {
            type: 'string',
            default: 'reflection'
        }, minFilter: {
            type: 'string',
            description: '',
            default: 'linearWithLinearMipmap'
        }, magFilter: {
            type: 'string',
            description: '',
            default: 'linear'
        }, anisotropy: {
            type: 'number',
            description: '',
            default: 8.0
        }, generateMipmaps: {
            type: 'boolean',
            description: '',
            default: true
        }, imageId: {
            type: ['string', 'null'],
            default: null
        } }) });
exports.default = baseTextureAssetProperties;


/***/ }),
/* 22 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Gets a simplified representation of the UserAgent eg: "Chrome 52".
 * @method
 * @return {String} The name of the browser and the version
 */
var getBrowser = function (ua) {
    if (ua === 'node') {
        return ua;
    }
    var edgeM = ua.match(/(edge(?=\/))\/?\s*(\d+)/i) || [];
    var tem;
    var m = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (edgeM.length) {
        m = edgeM;
    }
    if (/trident/i.test(m[1])) {
        tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE ' + (tem[1] || '');
    }
    if (m[1] === 'Chrome') {
        tem = ua.match(/\bOPR\/(\d+)/);
        if (tem != null) {
            return 'Opera ' + tem[1];
        }
    }
    m = m[2] ? [m[1], m[2]] : [navigator.appName, navigator.appVersion, '-?'];
    tem = ua.match(/version\/(\d+)/i);
    if (tem != null) {
        m.splice(1, 1, tem[1]);
    }
    return m.join(' ');
};
// Browser user agent cache
var browser = {
    isMobile: undefined,
    isIOS: undefined,
    isAndroid: undefined,
    isMac: undefined,
    isLinux: undefined,
    isUnix: undefined,
    isWindows: undefined,
    isChrome: undefined,
    isFirefox: undefined,
    isSafari: undefined,
    isOpera: undefined,
    isEdge: undefined,
    isIpad: undefined,
    isNode: undefined,
    isIE: undefined,
    isIE11: undefined,
    isAndroidTablet: undefined,
    isTablet: undefined
};
var userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : 'node';
/**
 * Updates the user agent cache.
 */
var updateAgentCache = function () {
    var browserName = getBrowser(userAgent);
    var agentTests = {
        isMobile: /iphone|ipad|ipod|android|blackberry|bb10|mini|windows\sce|palm/i.test(userAgent),
        isIOS: /iphone|ipad|ipod/i.test(userAgent),
        isAndroid: /android/i.test(userAgent),
        isMac: /mac/i.test(userAgent),
        isLinux: /linux/i.test(userAgent),
        isUnix: /x11/i.test(userAgent),
        isWindows: /windows/i.test(userAgent),
        isChrome: /chrome/i.test(userAgent),
        isFirefox: /firefox/i.test(userAgent),
        isSafari: /safari/i.test(userAgent),
        isOpera: /opera/i.test(userAgent),
        isEdge: /edge/i.test(userAgent),
        isIpad: /ipad/i.test(userAgent),
        isNode: userAgent === 'node',
        isIE: /ie/i.test(browserName),
        isIE11: /ie 11/i.test(browserName)
    };
    agentTests.isAndroidTablet = agentTests.isAndroid && !/mobile/i.test(userAgent);
    agentTests.isTablet = agentTests.isIpad || agentTests.isAndroidTablet;
    // Copy over new agent tests
    Object.keys(agentTests).forEach(function (test) {
        browser[test] = agentTests[test];
    });
};
// Pre-test all of the conditions and cache the results.
updateAgentCache();
/**
 * Overrides user agent.
 * @param newUserAgent Override the current user agent with this.
 */
exports.setUserAgent = function (newUserAgent) {
    userAgent = newUserAgent;
    updateAgentCache();
};
/**
 * Determines if the browser is mobile.
 * @method
 * @return {Boolean}
 */
exports.isMobile = function () { return browser.isMobile; };
/**
 * Determines if the browser is iOS.
 * @method
 * @return {Boolean}
 */
exports.isIOS = function () { return browser.isIOS; };
/**
 * Determines if the browser is Android.
 * @method
 * @return {Boolean}
 */
exports.isAndroid = function () { return browser.isAndroid; };
/**
 * Determines if the browser is Mac.
 * @method
 * @return {Boolean}
 */
exports.isMac = function () { return browser.isMac; };
/**
 * Determines if the browser is Linux.
 * @method
 * @return {Boolean}
 */
exports.isLinux = function () { return browser.isLinux; };
/**
 * Determines if the browser is Unix.
 * @method
 * @return {Boolean}
 */
exports.isUnix = function () { return browser.isUnix; };
/**
 * Determines if the browser is Windows.
 * @method
 * @return {Boolean}
 */
exports.isWindows = function () { return browser.isWindows; };
/**
 * Determines if the browser is Chrome.
 * @method
 * @return {Boolean}
 */
exports.isChrome = function () { return browser.isChrome; };
/**
 * Determines if the browser is Firefox.
 * @method
 * @return {Boolean}
 */
exports.isFirefox = function () { return browser.isFirefox; };
/**
 * Determines if the browser is Safari.
 * @method
 * @return {Boolean}
 */
exports.isSafari = function () { return browser.isSafari; };
/**
 * Determines if the browser is Opera.
 * @method
 * @return {Boolean}
 */
exports.isOpera = function () { return browser.isOpera; };
/**
 * Determines if the browser is Microsoft Edge.
 * @method
 * @return {Boolean}
 */
exports.isEdge = function () { return browser.isEdge; };
/**
 * Determines if the browser is an Android tablet.
 * @method
 * @return {Boolean}
 */
exports.isAndroidTablet = function () { return browser.isAndroidTablet; };
/**
 * Determines if the browser is an iPad.
 * @method
 * @return {Boolean}
 */
exports.isIpad = function () { return browser.isIpad; };
/**
 * Determines if the browser is a tablet.
 * @method
 * @return {Boolean}
 */
exports.isTablet = function () { return browser.isTablet; };
/**
 * Determines if the browser is Internet Explorer.
 * @method
 * @return {Boolean}
 */
exports.isIE = function () { return browser.isIE; };
/**
 * Determines if the browser is Internet Explorer 11.
 * @method
 * @return {Boolean}
 */
exports.isIE11 = function () { return browser.isIE11; };
/**
 * Determines if the environment is Node.js.
 * @method
 * @return {Boolean}
 */
exports.isNode = function () { return browser.isNode; };


/***/ }),
/* 23 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(6);
var functions_1 = __webpack_require__(5);
/**
 * An abstract base class that holds geometry.
 * @class BaseGeometryAsset
 */
var BaseGeometryAsset = (function (_super) {
    tslib_1.__extends(BaseGeometryAsset, _super);
    /**
     * Create a BaseGeometryAsset.
     * @constructor
     * @protected
     */
    function BaseGeometryAsset(jsonDesc, runtime) {
        var _this = _super.call(this, jsonDesc, runtime) || this;
        /**
         * The loaded Three.js geometries for this asset.
         */
        _this.geometries = {};
        /**
         * The maximum index in the material array referenced by the geometry.
         */
        _this.maxMaterialIndices = {};
        functions_1.forEach(BaseGeometryAsset.primitiveType, function (type) {
            _this.maxMaterialIndices[type] = -1;
        });
        return _this;
    }
    /**
     * Calculates the highest material index referenced by a Three.js geometry object.
     * @method computeMaxMaterialIndex
     * @private
     * @param {THREE.Geometry|THREE.BufferGeometry} geometry The Three.js geometry.
     * @returns {number} The maximum material index.
     */
    BaseGeometryAsset.computeMaxMaterialIndex = function (geometry) {
        var groups = BaseGeometryAsset.getMaterialGroups(geometry);
        return groups.reduce(function (maxIndex, group) { return Math.max(maxIndex, group.materialIndex); }, -1);
    };
    /**
     * Map negative material indices, which indicate no material assignment, to positive ones. All
     * negative material indices are mapped to maxMaterialIndex + 1, where maxMaterialIndex is the
     * maximum material index as calculated by computeMaxMaterialIndex().
     * @method fixNegativeMaterialIndices
     * @private
     * @param {THREE.Geometry|THREE.BufferGeometry} geometry The Three.js geometry.
     * @returns {void}
     */
    BaseGeometryAsset.fixNegativeMaterialIndices = function (geometry) {
        var groups = this.getMaterialGroups(geometry);
        var negativeGroups = groups.filter(function (group) { return group.materialIndex < 0; });
        var maxMaterialIndex = BaseGeometryAsset.computeMaxMaterialIndex(geometry);
        negativeGroups.forEach(function (group) {
            group.materialIndex = maxMaterialIndex + 1;
        });
    };
    /**
     * Get an array of "groups", where each group has a material assignment (materialIndex). For a
     * THREE.BufferGeometry, this method returns the "groups" property. For a THREE.Geometry, this
     * method returns the "faces" property. If neither of these properties exist, this method returns
     * an empty array.
     * @method getMaterialGroups
     * @private
     * @param {THREE.Geometry|THREE.BufferGeometry} geometry The Three.js geometry.
     * @returns {Array} The array of material groups.
     */
    BaseGeometryAsset.getMaterialGroups = function (geometry) {
        if (geometry instanceof THREE.BufferGeometry && geometry.groups) {
            return geometry.groups;
        }
        if (geometry instanceof THREE.Geometry && geometry.faces) {
            return geometry.faces;
        }
        return [];
    };
    /** @inheritdoc */
    BaseGeometryAsset.prototype.unload = function () {
        Logger_1.default.info(this.engine.getName() +
            ' - BaseGeometryAsset: Unloading geometry, ' + this.getName() + ' - "' + this.id + '"');
        functions_1.forEach(this.geometries, function (geometry) {
            if (geometry) {
                geometry.dispose();
            }
        });
        this.geometries = {};
        _super.prototype.unload.call(this);
    };
    /**
     * Get the bounds of this geometry.
     * @param [outBounds] Optional Box3 to write the result to. Passing this in will
     * avoid another THREE.Box3 from being created.
     * @returns The bounds of this geometry.
     */
    BaseGeometryAsset.prototype.getBounds = function (outBounds) {
        var geometries = functions_1.values(this.geometries).filter(function (geometry) { return geometry; });
        return geometries.reduce(function (bounds, geometry) {
            return bounds.union(geometry.boundingBox);
        }, outBounds || new THREE.Box3());
    };
    /**
     * Returns an array of this asset's geometries (all PrimitiveTypes).
     * @method getGeometries
     * @public
     * @returns {Array} An array of THREE.Geometry and THREE.BufferGeometry objects.
     */
    BaseGeometryAsset.prototype.getGeometries = function () {
        return functions_1.values(this.geometries);
    };
    /**
     * Returns this asset's geometry of the specified type.
     * @method getGeometry
     * @public
     * @param {String} [type] One of BaseGeometryAsset.primitiveType (default is TRIANGLES).
     * @returns {THREE.Geometry|THREE.BufferGeometry} A Three.js geometry.
     */
    BaseGeometryAsset.prototype.getGeometry = function (type) {
        if (type === void 0) { type = BaseGeometryAsset.primitiveType.TRIANGLES; }
        return this.geometries[type];
    };
    /**
     * Returns this asset's maximum material index for the specified type.
     * @method getMaxMaterialIndex
     * @public
     * @param {String} [type] One of BaseGeometryAsset.primitiveType (default is TRIANGLES).
     * @returns {number} The maximum material index.
     */
    BaseGeometryAsset.prototype.getMaxMaterialIndex = function (type) {
        if (type === void 0) { type = BaseGeometryAsset.primitiveType.TRIANGLES; }
        return this.maxMaterialIndices[type];
    };
    /**
     * Adds required attributes to the specified geometry.
     * @param geometry The Three.js geometry.
     */
    BaseGeometryAsset.prototype.addMissingAttributes = function (geometry) {
        // Create an empty position array if it doesn't exist.
        if (geometry.attributes.position === undefined) {
            Logger_1.default.warn(this.engine.getName() +
                ' - BaseGeometryAsset: Mesh is missing "position" attribute.');
            geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
        }
        // Compute vertex normals if they don't exist.
        if (geometry.attributes.normal === undefined) {
            Logger_1.default.warn(this.engine.getName() + ' - BaseGeometryAsset: Mesh is missing "normal" attribute.');
            geometry.computeVertexNormals();
        }
    };
    /**
     * Called by subclasses to register a THREE.Geometry or THREE.BufferGeometry with this asset. The
     * geometry can then be fetched with getGeometry().
     * @protected
     * @param {String} type One of the BaseGeometryAsset.primitiveType.
     * @param {THREE.Geometry|THREE.BufferGeometry} geometry The Three.js geometry.
     * @returns {void}
     */
    BaseGeometryAsset.prototype.setGeometry = function (type, geometry) {
        if (geometry) {
            BaseGeometryAsset.fixNegativeMaterialIndices(geometry);
            // FIXME: does dynamic exist as a property anymore? casting as any to allow
            geometry.dynamic = this.getProperty('dynamic') || false;
        }
        this.geometries[type] = geometry;
        this.maxMaterialIndices[type] = geometry ?
            BaseGeometryAsset.computeMaxMaterialIndex(geometry) : -1;
    };
    return BaseGeometryAsset;
}(BaseAsset_1.default));
/**
 * The available types of primitives to render.
 */
BaseGeometryAsset.primitiveType = {
    POINTS: 'points',
    LINES: 'lines',
    TRIANGLES: 'triangles'
};
exports.default = BaseGeometryAsset;


/***/ }),
/* 24 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseImageAsset_1 = __webpack_require__(11);
var LoadingType_1 = __webpack_require__(16);
var LoadingEvent_1 = __webpack_require__(12);
var Schemas_1 = __webpack_require__(4);
var maxVideoHeight = 1080;
/**
 * @class VideoAsset
 * @constructor
 */
var VideoAsset = (function (_super) {
    tslib_1.__extends(VideoAsset, _super);
    function VideoAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    VideoAsset.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.engine.on('update', this.onUpdate, this);
        this.on('pause', this.pause, this);
        this.on('play', this.play, this);
        this.on('stop', this.stop, this);
        this.on('toggle', this.toggle, this);
    };
    /** @inheritdoc */
    VideoAsset.prototype.uninitialize = function () {
        this.engine.off('update', this.onUpdate, this);
        this.off('pause', this.pause, this);
        this.off('play', this.play, this);
        this.off('stop', this.stop, this);
        this.off('toggle', this.toggle, this);
        if (this.runtimeData && this.runtimeData.image) {
            // TODO: should we be doing more here?
            this.runtimeData.image.pause();
        }
        _super.prototype.uninitialize.call(this);
    };
    /** @inheritdoc */
    VideoAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        var onVideoReady = function (videoEl) {
            if (videoEl) {
                videoEl.style.display = 'none';
                videoEl.loop = _this.getProperty('loop');
                videoEl.autoplay = _this.getProperty('autoPlay');
                videoEl.muted = _this.getProperty('muted');
                if (!_this.runtimeData) {
                    _this.runtimeData = {};
                }
                _this.runtimeData.imageData = videoEl;
                _this.runtimeData.width = videoEl.width;
                _this.runtimeData.height = videoEl.height;
                _this.loadedBytes = _this.getDataSizeDownload();
                _this.trigger('loadProgress', _this);
            }
        };
        var parentEl = this.engine.getRenderer().getCanvas().parentElement;
        var cssSelector = this.getProperty('querySelector');
        if (cssSelector) {
            var videoEl = parentEl.querySelector(cssSelector);
            onVideoReady(videoEl);
            callback();
        }
        else {
            var rep = this.findRepresentation();
            if (rep) {
                var resource = this.loadResource(rep.src, LoadingType_1.default.VIDEO, callback);
                resource.on(LoadingEvent_1.default.PROGRESS, function (progressObj) {
                    _this.loadedBytes = _this.getDataSizeDownload() * progressObj.loaded / progressObj.total;
                    _this.trigger('loadProgress', _this);
                });
                resource.once(LoadingEvent_1.default.LOAD, function (data) {
                    parentEl.appendChild(data);
                    onVideoReady(data);
                });
            }
        }
    };
    /** @inheritdoc */
    VideoAsset.prototype.applyPropertiesUnloaded = function (_changes) {
        var rep = this.findRepresentation();
        // Don't need to check for existing representation here because it's okay to not have any.
        // The video might be coming from a video tag.
        this.chosenRepresentation = rep;
    };
    /** @inheritdoc */
    VideoAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (!this.runtimeData || !this.runtimeData.imageData) {
            return;
        }
        var videoEl = this.runtimeData.imageData;
        if (changes.hasOwnProperty('loop')) {
            videoEl.loop = this.getProperty('loop');
        }
        if (changes.hasOwnProperty('muted')) {
            videoEl.muted = this.getProperty('muted');
        }
        if (changes.hasOwnProperty('autoPlay')) {
            videoEl.autoplay = this.getProperty('autoPlay');
        }
    };
    /** @inheritdoc */
    VideoAsset.prototype.getMaxRepresentationWidth = function () {
        var representations = this.get('representations');
        if (!representations) {
            return 0;
        }
        return representations.reduce(function (maxWidth, rep) {
            return rep.video && rep.video.width > maxWidth ? rep.video.width : maxWidth;
        }, 0);
    };
    /** @inheritdoc */
    VideoAsset.prototype.getMaxRepresentationHeight = function () {
        var representations = this.get('representations');
        if (!representations) {
            return 0;
        }
        return representations.reduce(function (maxHeight, rep) {
            return rep.video && rep.video.height > maxHeight ? rep.video.height : maxHeight;
        }, 0);
    };
    /** @inheritdoc */
    VideoAsset.prototype.onUpdate = function () {
        if (this.runtimeData) {
            var videoEl = this.runtimeData.imageData;
            if (videoEl && !videoEl.paused && !videoEl.error &&
                videoEl.readyState >= videoEl.HAVE_CURRENT_DATA) {
                this.engine.needsRender = true;
            }
        }
    };
    /** Pauses the video. */
    VideoAsset.prototype.pause = function () {
        if (this.runtimeData) {
            this.runtimeData.image.pause();
        }
    };
    /**
     * Starts playing the video.
     * @param [seek]      If true the video will start playing at the specified seekTime.
     * @param [seekTime]  The time position to seek to. Only used if seek is true.
     */
    VideoAsset.prototype.play = function (seek, seekTime) {
        if (this.runtimeData) {
            if (seek) {
                this.runtimeData.imageData.currentTime = seekTime;
            }
            this.runtimeData.imageData.play();
        }
    };
    /** Stops playing the video. */
    VideoAsset.prototype.stop = function () {
        if (this.runtimeData) {
            this.runtimeData.imageData.pause();
            this.runtimeData.imageData.currentTime = 0;
        }
    };
    /** Toggles the state between paused/playing. */
    VideoAsset.prototype.toggle = function () {
        if (this.runtimeData) {
            if (this.runtimeData.imageData.paused) {
                this.play();
            }
            else {
                this.pause();
            }
        }
    };
    /** @inheritdoc */
    VideoAsset.prototype.getOriginalWidth = function () {
        var streams = this.getProperty('streams') || [];
        return streams.reduce(function (max, stream) {
            return Math.max(stream.width || 0, max);
        }, 0);
    };
    /** @inheritdoc */
    VideoAsset.prototype.getOriginalHeight = function () {
        var streams = this.getProperty('streams') || [];
        return streams.reduce(function (max, stream) {
            return Math.max(stream.height || 0, max);
        }, 0);
    };
    /** @inheritdoc */
    VideoAsset.prototype.getMaxTextureSize = function () {
        var renderer = this.engine.getRenderer();
        return renderer ? renderer.getMaxTextureSize2d() : _super.prototype.getMaxTextureSize.call(this);
    };
    /**
     * Find the video representation that best matches the specified criteria.
     * @method findRepresentation
     * @private
     * @param {BaseAsset} asset The video asset.
     * @param {Object} options Loading options (@see XhrResourceLoader.prototype.load()).
     * @returns {Object} the representation that best matches the search criteria or null if none were
     * found.
     */
    VideoAsset.prototype.findRepresentation = function (options) {
        if (options === void 0) { options = {}; }
        var representations = this.get('representations');
        if (!representations || representations.length === 0) {
            return null;
        }
        var optionsEx = Object.assign({ maxHeight: maxVideoHeight }, options);
        // For each representation, compute the difference between its height and the max height.
        var sizeDiffs = representations.map(function (representation) {
            return optionsEx.maxHeight - (representation.video || {}).height || 0;
        });
        // Find the index of the minimum, *positive* diff. This is equivalent to the largest video
        // that is less than or equal to the max specified.
        var foundIdx = sizeDiffs.reduce(function (bestIdx, currentDiff, currentIdx) {
            var bestDiff = bestIdx >= 0 ? sizeDiffs[bestIdx] : Number.MAX_VALUE;
            return currentDiff >= 0 && currentDiff < bestDiff ? currentIdx : bestIdx;
        }, -1);
        // Locate the match.
        return foundIdx >= 0 ? representations[foundIdx] : null;
    };
    return VideoAsset;
}(BaseImageAsset_1.default));
/** @inheritdoc */
VideoAsset.events = {
    pause: {
        params: [],
        action: true,
        category: ''
    },
    play: {
        params: [{
                name: 'seek',
                type: 'b',
                description: '',
                default: false
            }, {
                name: 'seekTime',
                type: 'f',
                description: '',
                default: 0
            }],
        action: true,
        category: ''
    },
    stop: {
        params: [],
        action: true,
        category: ''
    },
    toggle: {
        params: [],
        action: true,
        category: ''
    }
};
Schemas_1.addSchemas('VideoAsset', VideoAsset);
exports.default = VideoAsset;


/***/ }),
/* 25 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var UserAgent_1 = __webpack_require__(22);
/** Very tiny number. */
var epsilon = 0.001;
// @todo @jholdstock: Remove this after we normalize scroll amounts.
/** Scales input amounts down to usable values. */
var zoomFactor = 0.1;
/** Events that can be triggered on this component. */
exports.orbitEvents = {
    startOrbit: 'startOrbit',
    orbit: 'orbit',
    pan: 'pan',
    zoom: 'zoom'
};
/** Events that can be triggered on the entity, to trigger orbit actions. */
exports.entityOrbitEvents = {
    enable: 'enableOrbitCamera',
    disable: 'disableOrbitCamera',
    toggle: 'toggleOrbitCamera',
    reset: 'resetOrbitCamera'
};
/**
 * Do a fuzzy equal check on two quaternions.
 * @param qa The first quaternion to check.
 * @param qb The second quaternion to check.
 * @returns  True if the quaternions are roughly equal.
 */
function fuzzyEquals(qa, qb) {
    return Math.abs(qa.x - qb.x) < epsilon &&
        Math.abs(qa.y - qb.y) < epsilon &&
        Math.abs(qa.z - qb.z) < epsilon &&
        Math.abs(qa.w - qb.w) < epsilon;
}
;
/**
 * A Component that moves a camera around a point in space.
 * @vid orbit_camera
 * @vname Orbit Camera
 * @vdescription Allows a camera to easily orbit a point in space.
 * @vfilter camera
 * @vcategory Camera Controllers
 */
var OrbitCamera = (function (_super) {
    tslib_1.__extends(OrbitCamera, _super);
    function OrbitCamera() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * How far the camera is positioned from the pivot point.
         * @vattr float orbitDistance {
         *   description : 'How far the camera is positioned from the pivot point.',
         *   default : 2.5,
         *   max : 100000,
         *   min : 0.001
         * }
         */
        _this.orbitDistance = 2.5;
        /**
         * Allows you to set how far the camera can zoom, for perspective cameras. X = min, Y = max
         * @vattr Vector2 zoomPerspectiveBounds {
         *   description: 'Allows you to set how far the camera can zoom, for perspective cameras. X = min, Y = max',
         *   default: {x: 5.0, y: 90.0 },
         *   max: { x: 180.0, y: 180.0 },
         *   min: { x: 1, y: 1 }
         * }
         */
        _this.zoomPerspectiveBounds = new THREE.Vector2(5, 90);
        /**
         * Allows you to set how far the camera can zoom, for ortho cameras. X = min, Y = max
         * @vattr Vector2 zoomOrthographicBounds {
         *   description: 'Allows you to set how far the camera can zoom, for ortho cameras. X = min, Y = max',
         *   default: {x: 0.125, y: 2.5 },
         *   max: { x: 5.0, y: 5.0 },
         *   min: { x: 0.01, y: 0.01 }
         * }
         */
        _this.zoomOrthographicBounds = new THREE.Vector2(0.125, 2.5);
        /**
         * Allow the user to pan side-to-side and up and down with the camera.
         * @vattr bool panEnabled {
         *   default: true,
         *   description: 'Allow the user to pan side-to-side and up and down with the camera.'
         * }
         */
        _this.panEnabled = true;
        /**
         * Allow the user to zoom in and out with the camera.
         * @vattr bool zoomEnabled {
         *   default: true,
         *   description: 'Allow the user to zoom in and out with the camera.'
         * }
         */
        _this.zoomEnabled = true;
        /**
         * How quickly the camera stops moving when input stops.
         * @vattr float inertialDamping {
         *   default: 0.20,
         *   description: 'How quickly the camera stops moving when input stops.',
         *   min: 0.0,
         *   max: 1.0
         * }
         */
        _this.inertialDamping = 0.20;
        /**
         * The speed that the camera moves when panning.
         * @vattr float panSpeed {
         *   description: 'The speed that the camera moves when panning.',
         *   default: 2.0,
         *   max: 2000,
         *   min: 0.1
         * }
         */
        _this.panSpeed = 2.0;
        /**
         * The speed that the camera orbits the target.
         * @vattr float orbitSpeed {
         *   description: 'The speed that the camera orbits the target.',
         *   default: 2.0,
         *   max: 1000,
         *   min: 0.0001
         * }
         */
        _this.orbitSpeed = 2.0;
        /**
         * The speed that the camera moves while zooming in and out.
         * @vattr float zoomSpeed {
         *   description: 'The speed that the camera moves while zooming in and out.',
         *   default: 8.0,
         *   max: 2000,
         *   min: 0.1
         * }
         */
        _this.zoomSpeed = 8.0;
        /**
         * Allows you to set how far the camera can pitch (tilt) from horizontal.
         * @vattr Vector2 pitchAngleBounds {
         *   description: 'Allows you to set how far the camera can pitch (tilt) from horizontal.',
         *   default: {x: 75.0, y: -75.0 },
         *   max: { x: 90.0, y: 90.0 },
         *   min: { x: -90.0, y: -90.001 }
         * }
         */
        _this.pitchAngleBounds = new THREE.Vector2();
        /** The point the camera is orbiting, in 3D space. */
        _this.pivotPoint = new THREE.Object3D();
        /** Temporary container for Vector3 operations. */
        _this.tempVector = new THREE.Vector3();
        /** Temporary container for Vector4 operations. */
        _this.tempVector4 = new THREE.Vector4();
        /** Temporary container for Quaternion operations. */
        _this.tempQuaternion = new THREE.Quaternion();
        /** Temporary container for Matrix4 operations. */
        _this.tempMatrix4 = new THREE.Matrix4();
        /** Delta to increment/decrement zoom level by. Resets to zero after frame end. */
        _this.zoomDelta = 0;
        /** Used to track initial input position for orbit action. */
        _this.inputDragOrbitStart = new THREE.Vector2();
        /** For finding the position diff from initial mouse down and input movements, for orbit action. */
        _this.inputDragOrbitPosition = new THREE.Vector2();
        /** Delta x & y to change orbit position, based off of input delta. Is zeroed out at frame end. */
        _this.inputDragOrbitDelta = new THREE.Vector2();
        /** Delta x & y to change pan position, based off of input delta. Is zeroed out at frame end. */
        _this.inputDragPanDelta = new THREE.Vector2();
        /** The current speed at which zoom is being applied. */
        _this.currentZoomSpeed = 0;
        /** The current speed at which the camera is panning. */
        _this.currentPanSpeed = new THREE.Vector2();
        /** Signals the entity to apply changes to runtime data and trigger a render of the scene. */
        _this.hasChanged = false;
        /** The target rotation the camera should be rotated to. */
        _this.targetEuler = new THREE.Euler(0, 0, 0, 'YXZ');
        /** The source rotation to rotate the camera from */
        _this.eulerStart = new THREE.Euler(0, 0, 0, 'YXZ');
        /** The max at which the camera can be orbitted "above" and "below" the orbit pivot point. */
        _this.pitchAngleBoundsMax = 0.0;
        /** The min at which the camera can be orbitted "above" and "below" the orbit pivot point. */
        _this.pitchAngleBoundsMin = 0.0;
        /** Used for storing reference to origin of camera pivot point, and for resetting. */
        _this.originPoint = new THREE.Vector3();
        /** Pivot position to orbit around, in world space. */
        _this.pivotWorldPos = new THREE.Vector3();
        /** Used to throttle panning updates of the camera. */
        _this.isPanning = false;
        /** Used to throttle orbiting updates of the camera. */
        _this.isOrbiting = false;
        /** Used to throttle panning updates of the camera. */
        _this.isZooming = false;
        return _this;
    }
    /**
     * Set the initial position of the camera orientation once the entity is ready.
     */
    OrbitCamera.prototype.onEntityReady = function () {
        this.updatePan();
        this.updateZoom();
        this.updateOrbit();
        this.reset();
    };
    /**
     * Run orbit action.
     * @param inputPosScenePercent Mouse position, onscreen, of the input.
     */
    OrbitCamera.prototype.orbitStart = function (inputPosScenePercent) {
        if (!this.isEnabled()) {
            return;
        }
        this.updateTargetRotation();
        this.inputDragOrbitStart.copy(inputPosScenePercent);
        this.inputDragOrbitPosition.copy(inputPosScenePercent);
    };
    /**
     * Orbit the camera around the focal point.
     * @param inputPosScenePercent Mouse position, onscreen, of the input.
     */
    OrbitCamera.prototype.orbit = function (inputPosScenePercent) {
        if (!this.isEnabled()) {
            return;
        }
        this.inputDragOrbitPosition.copy(inputPosScenePercent);
        this.isOrbiting = true;
    };
    /**
     * Trigger zoom on the camera.
     * @param scrollDelta Amount to zoom.
     */
    OrbitCamera.prototype.zoom = function (scrollDelta) {
        if (scrollDelta === void 0) { scrollDelta = 0; }
        if (!this.isEnabled()) {
            return;
        }
        this.zoomDelta = -scrollDelta * zoomFactor;
        this.isZooming = true;
    };
    /**
     * Move the camera based on the input position delta.
     * @param inputPositionDelta The amount the input has moved since the last input event.
     */
    OrbitCamera.prototype.pan = function (inputPositionDelta) {
        if (!this.isEnabled()) {
            return;
        }
        this.inputDragPanDelta.copy(inputPositionDelta);
        this.isPanning = true;
    };
    /**
     * Reset the rotation of orbit to the current orientation it is at. Also stops
     * interpolation from continuing.
     */
    OrbitCamera.prototype.resetOrbitRotation = function () {
        this.updateTargetRotation();
        this.inputDragOrbitPosition.set(0, 0);
        this.inputDragOrbitStart.set(0, 0);
    };
    /**
     * Reset camera position and orientation as well as stop camera orbit movement.
     */
    OrbitCamera.prototype.reset = function () {
        // Reset the transform of the camera to what it is in the entity data.
        this.getEntity().reset();
        // Reset pan position
        if (this.panEnabled) {
            this.setPivotPosition(this.originPoint);
        }
        this.inputDragPanDelta.set(0, 0);
        this.currentPanSpeed.set(0, 0);
        // Reset zoom speed and distance
        if (this.zoomEnabled) {
            // Reset camera to half way between min and max zoom levels
            this.zoomComponent.lerpZoom(0.5);
        }
        this.currentZoomSpeed = 0;
        this.resetOrbitRotation();
        this.hasChanged = true;
    };
    /**
     * Set position of the pivot point.
     * @param position The new position to set the pivot point to.
     */
    OrbitCamera.prototype.setPivotPosition = function (position) {
        this.pivotPoint.position.copy(position);
        this.hasChanged = true;
    };
    /**
     * Set the distance the camera sits, from the pivot point.
     * @param distance The new distance to set the camera away from the pivot point
     */
    OrbitCamera.prototype.setOrbitDistance = function (distance) {
        this.orbitDistance = distance;
        this.hasChanged = true;
    };
    /**
     * Get the current distance from pivot point.
     * @returns The distance to the pivot point.
     */
    OrbitCamera.prototype.getOrbitDistance = function () {
        return this.orbitDistance;
    };
    /**
     * Toggle on and off the component.
     */
    OrbitCamera.prototype.toggle = function () {
        if (this.isEnabled()) {
            this.disable();
        }
        else {
            this.enable();
        }
    };
    /**
     * Update camera position based off of input deltas.
     *
     * @inheritdoc
     */
    OrbitCamera.prototype.onPreUpdate = function (delta) {
        if (!this.hasRuntimeData() || !this.isEnabled()) {
            return;
        }
        if (this.isOrbiting) {
            this.updateOrbit();
            this.hasChanged = true;
        }
        if (this.isPanning && this.panEnabled) {
            this.updatePan(delta);
            this.hasChanged = true;
        }
        if (this.isZooming) {
            this.updateZoom(delta);
            this.hasChanged = true;
        }
        if (this.hasChanged) {
            // Apply new orientation to this entity
            var runtimeData = this.getRuntimeData();
            runtimeData.position.set(0, 0, this.orbitDistance);
            runtimeData.position.applyQuaternion(runtimeData.quaternion);
            // Get the world-space position of the pivot point.
            this.pivotPoint.getWorldPosition(this.pivotWorldPos);
            if (runtimeData.parent) {
                this.tempMatrix4.getInverse(runtimeData.parent.matrixWorld);
                this.pivotWorldPos.applyMatrix4(this.tempMatrix4);
            }
            runtimeData.position.add(this.pivotWorldPos);
            runtimeData.lookAt(this.pivotWorldPos);
            this.getEngine().needsRender = true;
            this.hasChanged = false;
        }
    };
    /** @inheritdoc */
    OrbitCamera.prototype.onStartup = function () {
        var entity = this.getEntity();
        var inputComponent;
        // @todo @JHoldstock: Pull this out into a config (Scene entities?)
        if (UserAgent_1.isMobile()) {
            inputComponent = entity.getComponentByScriptId('orbit_touch_input');
            if (!inputComponent) {
                inputComponent = entity.addComponent('orbit_touch_input');
            }
        }
        else {
            inputComponent = entity.getComponentByScriptId('orbit_desktop_input');
            if (!inputComponent) {
                inputComponent = entity.addComponent('orbit_desktop_input');
            }
        }
        if (this.zoomEnabled) {
            // Attach zoom component if it hasn't been done yet
            this.zoomComponent = entity.getComponentByScriptId('camera_zoom');
            if (!this.zoomComponent) {
                this.zoomComponent = entity.addComponent('camera_zoom');
            }
            // Transfer bounds to the component.
            this.zoomComponent.setAttribute('perspectiveZoomMin', this.zoomPerspectiveBounds.x);
            this.zoomComponent.setAttribute('perspectiveZoomMax', this.zoomPerspectiveBounds.y);
            this.zoomComponent.setAttribute('orthoZoomMin', this.zoomOrthographicBounds.x);
            this.zoomComponent.setAttribute('orthoZoomMax', this.zoomOrthographicBounds.y);
            this.listenTo(inputComponent, exports.orbitEvents.zoom, this.zoom);
            this.on(exports.orbitEvents.zoom, this.zoom);
        }
        if (this.panEnabled) {
            this.listenTo(inputComponent, exports.orbitEvents.pan, this.pan);
            this.on(exports.orbitEvents.pan, this.pan);
        }
        this.listenTo(inputComponent, exports.orbitEvents.startOrbit, this.orbitStart);
        this.on(exports.orbitEvents.startOrbit, this.orbitStart);
        this.listenTo(inputComponent, exports.orbitEvents.orbit, this.orbit);
        this.on(exports.orbitEvents.orbit, this.orbit);
        this.listenTo(entity, 'enableOrbitCamera', this.enable);
        this.listenTo(entity, 'disableOrbitCamera', this.disable);
        this.listenTo(entity, 'toggleOrbitCamera', this.toggle);
        this.listenTo(entity, 'resetOrbitCamera', this.reset);
    };
    /**
     * Update camera orbit position.
     * @param delta Time elapsed since last update.
     */
    // @todo @JHoldstock: Incorporate delta for smoother orbit.
    OrbitCamera.prototype.updateOrbit = function () {
        // Guard to prevent orbit locking from mouse down events not being registered because of
        // Double click event.
        // @todo @jholdstock: Remove input drag amounts from this function!
        if (!this.inputDragOrbitStart.x && !this.inputDragOrbitStart.y) {
            this.inputDragOrbitStart.copy(this.inputDragOrbitPosition);
        }
        this.inputDragOrbitDelta.copy(this.inputDragOrbitPosition);
        this.inputDragOrbitDelta.sub(this.inputDragOrbitStart);
        this.inputDragOrbitDelta.multiplyScalar(6.0 * this.orbitSpeed);
        this.targetEuler.copy(this.eulerStart);
        // Look at current angular movement since the start of control and clamp the min/max pitch.
        this.targetEuler.x -= this.inputDragOrbitDelta.y;
        this.targetEuler.y -= this.inputDragOrbitDelta.x;
        // Keeps in sync if pitch angle bounds changes
        this.pitchAngleBoundsMax = Math.PI * this.pitchAngleBounds.x / 180.0;
        this.pitchAngleBoundsMin = Math.PI * this.pitchAngleBounds.y / 180.0;
        if (this.targetEuler.x > this.pitchAngleBoundsMax) {
            this.targetEuler.x = this.pitchAngleBoundsMax;
        }
        else if (this.targetEuler.x < this.pitchAngleBoundsMin) {
            this.targetEuler.x = this.pitchAngleBoundsMin;
        }
        var runtimeData = this.getRuntimeData();
        this.tempQuaternion.setFromEuler(this.targetEuler);
        if (fuzzyEquals(runtimeData.quaternion, this.tempQuaternion)) {
            this.isOrbiting = false;
        }
        runtimeData.quaternion.slerp(this.tempQuaternion, this.inertialDamping);
        this.inputDragOrbitDelta.set(0.0, 0.0);
    };
    /**
     * Move the camera via a pan action around the scene.
     * @param delta Time elapsed since last update.
     */
    OrbitCamera.prototype.updatePan = function (delta) {
        if (delta === void 0) { delta = 0; }
        var damping = Math.max(0.0, Math.min(delta * 33.3 * this.inertialDamping, 1.0));
        var oneMinusDamping = 1.0 - damping;
        // Handle panning of the camera
        this.inputDragPanDelta.multiplyScalar(this.panSpeed);
        this.currentPanSpeed.x = oneMinusDamping * this.currentPanSpeed.x +
            damping * this.inputDragPanDelta.x;
        this.currentPanSpeed.y = oneMinusDamping * this.currentPanSpeed.y +
            damping * this.inputDragPanDelta.y;
        var runtimeData = this.getRuntimeData();
        // If there is panning movement, shift the location of the pivot point.
        this.tempVector.set(-this.currentPanSpeed.x, this.currentPanSpeed.y, 0.0);
        this.tempVector.applyQuaternion(runtimeData.quaternion);
        this.tempMatrix4.getInverse(this.pivotPoint.matrixWorld);
        this.tempVector4.set(this.tempVector.x, this.tempVector.y, this.tempVector.z, 0.0);
        this.tempVector4.applyMatrix4(this.tempMatrix4);
        this.tempVector.set(this.tempVector4.x, this.tempVector4.y, this.tempVector4.z);
        this.pivotPoint.position.add(this.tempVector);
        // Stop panning the camera
        if (Math.abs(this.currentPanSpeed.y) < epsilon && Math.abs(this.currentPanSpeed.x) < epsilon) {
            this.currentPanSpeed.set(0, 0);
            this.isPanning = false;
        }
        this.inputDragPanDelta.set(0, 0);
    };
    /**
     * Update and dampen zoom speed.
     * @param delta Time elapsed since last update.
     */
    OrbitCamera.prototype.updateZoom = function (delta) {
        if (delta === void 0) { delta = 0; }
        if (!this.zoomEnabled) {
            this.isZooming = false;
            return;
        }
        var damping = Math.max(0.0, Math.min(delta * 33.3 * this.inertialDamping, 1.0));
        var oneMinusDamping = 1.0 - damping;
        this.currentZoomSpeed = oneMinusDamping * this.currentZoomSpeed + damping * this.zoomSpeed * this.zoomDelta;
        // Stop zooming the camera
        if (Math.abs(this.currentZoomSpeed) < epsilon) {
            this.currentZoomSpeed = 0.0;
            this.isZooming = false;
        }
        this.zoomComponent.zoom(this.currentZoomSpeed);
        this.zoomDelta = 0.0;
    };
    /**
     * Updates the orbit target rotation to that of the current camera orientation.
     */
    OrbitCamera.prototype.updateTargetRotation = function () {
        this.tempQuaternion.copy(this.getRuntimeData().quaternion);
        this.eulerStart.setFromQuaternion(this.tempQuaternion, 'YXZ');
        this.targetEuler.copy(this.eulerStart);
    };
    return OrbitCamera;
}(BaseComponent_1.default));
exports.default = OrbitCamera;


/***/ }),
/* 26 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-file-line-count */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseObject_1 = __webpack_require__(10);
var MaterialAsset_1 = __webpack_require__(14);
var BaseGeometryAsset_1 = __webpack_require__(23);
var Schemas_1 = __webpack_require__(4);
/**
 * @class MeshObject
 * @constructor
 */
var MeshObject = (function (_super) {
    tslib_1.__extends(MeshObject, _super);
    function MeshObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    MeshObject.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.engine.on('materialDeleted', this.onMaterialDeleted, this);
        this.on('setMaterial', this.setMaterial, this);
        this.on('castShadowsEnable', this.castShadowsEnable, this);
        this.on('castShadowsDisable', this.castShadowsDisable, this);
        this.on('castShadowsToggle', this.castShadowsToggle, this);
    };
    /** @inheritdoc */
    MeshObject.prototype.uninitialize = function () {
        this.off('setMaterial', this.setMaterial, this);
        this.off('castShadowsEnable', this.castShadowsEnable, this);
        this.off('castShadowsDisable', this.castShadowsDisable, this);
        this.off('castShadowsToggle', this.castShadowsToggle, this);
        this.engine.off('materialDeleted', this.onMaterialDeleted, this);
        _super.prototype.uninitialize.call(this);
    };
    /** @inheritdoc */
    MeshObject.prototype.unload = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        if (this.runtimeData) {
            // TODO: is this line needed?
            this.runtimeData.material = null;
            // TODO: is this line needed?
            this.runtimeData.geometry = null;
        }
        _super.prototype.unload.call(this, recursive);
    };
    /**
     * Disable shadow casting.
     * @method castShadowsDisable
     * @public
     * @returns {void}
     */
    MeshObject.prototype.castShadowsDisable = function () {
        this.setProperty('castShadow', false);
        this.engine.needsRender = true;
    };
    /**
     * Enable shadow casting.
     * @method castShadowsEnable
     * @public
     * @returns {void}
     */
    MeshObject.prototype.castShadowsEnable = function () {
        this.setProperty('castShadow', true);
        this.engine.needsRender = true;
    };
    /**
     * Toggle shadow casting.
     * @method castShadowsToggle
     * @public
     * @returns {void}
     */
    MeshObject.prototype.castShadowsToggle = function () {
        var castShadow = this.getProperty('castShadow') ? false : true;
        this.setProperty('castShadow', castShadow);
        this.engine.needsRender = true;
    };
    /** @inheritdoc */
    MeshObject.prototype.createRuntimeData = function (callback) {
        var _this = this;
        var geometryId = this.getProperty('geometryId');
        var skinId = this.getProperty('skinId');
        var missingMaterial = this.engine.materialUtilities.getMissingMaterial();
        var missingMaterialId = missingMaterial ? missingMaterial.id : null;
        Promise.all([
            this.loadAsset(missingMaterialId),
            this.loadAsset(geometryId),
            this.loadAsset(skinId)
        ])
            .then(function () {
            _this.createMeshLoaded();
            callback();
        })
            .catch(function (err) {
            if (_this.isDestroyed()) {
                return;
            }
            Logger_1.default.error(_this.engine.getName() + ' - MeshObject: ' + err.toString());
            _this.createDefaultMesh();
            if (typeof callback === 'function') {
                callback();
            }
        });
    };
    /**
     * Return the Three.js geometry object.
     * @method getGeometry
     * @public
     * @returns {THREE.BufferGeometry|THREE.Geometry|null} The Three.js geometry object if it exists;
     * otherwise, null.
     */
    MeshObject.prototype.getGeometry = function () {
        var geometryAsset = this.getGeometryAsset();
        if (geometryAsset) {
            return geometryAsset.getGeometry(BaseGeometryAsset_1.default.primitiveType.TRIANGLES);
        }
        return null;
    };
    /**
     * Get the geometry asset assigned to this mesh.
     * @method getGeometryAsset
     * @public
     * @returns {BaseGeometryAsset|null} The geometry asset if it exists; otherwise, null.
     */
    MeshObject.prototype.getGeometryAsset = function () {
        var geometryId = this.getProperty('geometryId');
        return geometryId ? this.engine.getAssetById(geometryId) : null;
    };
    /** @inheritDoc */
    MeshObject.prototype.getLocalBounds = function (outBounds) {
        var geometryAsset = this.getGeometryAsset();
        if (geometryAsset) {
            return geometryAsset.getBounds(outBounds);
        }
        if (outBounds) {
            return outBounds.set(MeshObject.defaultLocalBounds.min, MeshObject.defaultLocalBounds.max);
        }
        return MeshObject.defaultLocalBounds;
    };
    /**
     * Get the material asset assigned to this mesh at the specified index.
     * @method getMaterial
     * @public
     * @param {number} [index] The material index (default is 0).
     * @param {Boolean} [placeholder] Return a placeholder material if the material is missing
     * (default is true).
     * @returns {MaterialAsset|null} The material if it exists; otherwise, null.
     */
    MeshObject.prototype.getMaterial = function (index, placeholder) {
        if (index === void 0) { index = 0; }
        if (placeholder === void 0) { placeholder = true; }
        // Validate the index parameter.
        if (index < 0 || index >= this.getMaterialCount()) {
            throw new Error('Invalid index parameter');
        }
        var materialId = this.getMaterialIds()[index];
        if (materialId) {
            var asset = this.engine.getAssetById(materialId);
            if (asset) {
                return asset;
            }
        }
        if (placeholder) {
            return this.engine.materialUtilities.getMissingMaterial();
        }
        return null;
    };
    /**
     * Get the material asset previously assigned to this mesh at the specified index.
     * @method getPreviousMaterial
     * @public
     * @param {number} [index] The material index (default is 0).
     * @param {Boolean} [placeholder] Return a placeholder material if the material is missing
     * (default is true).
     * @returns {MaterialAsset|null} The material if it exists; otherwise, null.
     */
    MeshObject.prototype.getPreviousMaterial = function (index, placeholder) {
        if (index === void 0) { index = 0; }
        if (placeholder === void 0) { placeholder = true; }
        // Validate the index parameter.
        if (index < 0 || index >= this.getMaterialCount()) {
            throw new Error('Invalid index parameter');
        }
        var materialId = this.getPreviousMaterialIds()[index];
        if (materialId) {
            var asset = this.engine.getAssetById(materialId);
            if (asset) {
                return asset;
            }
        }
        if (placeholder) {
            return this.engine.materialUtilities.getMissingMaterial();
        }
        return null;
    };
    /**
     * Get the number of material slots that this mesh has.
     * @method getMaterialCount
     * @public
     * @returns {number} The number of material slots that this mesh has.
     */
    MeshObject.prototype.getMaterialCount = function () {
        return this.getMaterialIds().length;
    };
    /**
     * Get an array of material assets that are assigned to this mesh.
     * @method getMaterials
     * @public
     * @param {Boolean} [placeholder] Substitute a placeholder for missing materials (default is
     * true).
     * @returns {MaterialAsset[]} An array of assets.
     */
    MeshObject.prototype.getMaterials = function (placeholder) {
        if (placeholder === void 0) { placeholder = true; }
        var materials = [];
        var nMaterials = this.getMaterialCount();
        for (var i = 0; i < nMaterials; ++i) {
            materials.push(this.getMaterial(i, placeholder));
        }
        return materials;
    };
    /**
     * Get the skin asset assigned to this mesh.
     * @method getSkinAsset
     * @public
     * @returns {SkinAsset|null} The skin asset if it exists; otherwise, null.
     */
    MeshObject.prototype.getSkinAsset = function () {
        var skinId = this.getProperty('skinId');
        return skinId ? this.engine.getAssetById(skinId) : null;
    };
    /**
     * Indicates whether or not this mesh is skinned.
     * @method isSkinned
     * @public
     * @returns {Boolean} true if this mesh is skinned; otherwise, false.
     */
    MeshObject.prototype.isSkinned = function () {
        return this.getSkinAsset() !== null;
    };
    /** @inheritdoc */
    MeshObject.prototype.applyPropertiesLoaded = function (changes, reason) {
        var _this = this;
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (changes.hasOwnProperty('geometryId')) {
            var prevGeometryId = this.getPreviousProperty('geometryId');
            var newGeometryId = this.getProperty('geometryId');
            // Stop listening to the old geometry, start listening to the new one.
            this.registerChangeListener(prevGeometryId, this.onGeometryChanged, false);
            this.registerChangeListener(newGeometryId, this.onGeometryChanged, true);
            // Reload the runtime data.
            if (reason !== 'init') {
                this.reloadBase();
                return;
            }
        }
        if (changes.hasOwnProperty('materials')) {
            // Stop listening for changes to the previous materials.
            var prevMaterialIds = this.getPreviousMaterialIds();
            prevMaterialIds.forEach(function (materialId) {
                _this.registerChangeListener(materialId, _this.onMaterialChanged, false);
            });
            // Allocate the MultiMaterial (container for other materials).
            if (!(this.runtimeData.material instanceof THREE.MultiMaterial)) {
                this.runtimeData.material = new THREE.MultiMaterial();
            }
            // Reset the MultiMaterial's material list.
            this.runtimeData.material.materials = [];
            // Assign the new materials and listen for changes.
            var materialType_1 = this.getMaterialType();
            var newMaterialIds = this.getMaterialIds();
            // Extend newMaterialIds to cover all of the material slots that the geometry references.
            var geometryAsset = this.getGeometryAsset();
            var maxMaterialIndex = geometryAsset ? geometryAsset.getMaxMaterialIndex('triangles') : 0;
            while (newMaterialIds.length <= maxMaterialIndex) {
                newMaterialIds.push(null);
            }
            newMaterialIds.forEach(function (materialId, index) {
                _this.registerChangeListener(materialId, _this.onMaterialChanged, true);
                _this.loadAndAssignMaterial(_this.runtimeData.material.materials, index, materialId, materialType_1);
            });
        }
        if (changes.hasOwnProperty('customDepthMaterial')) {
            var prevDepthMaterialId = this.getPreviousProperty('customDepthMaterial');
            var newDepthMaterialId = this.getProperty('customDepthMaterial');
            // Stop listening to the old material, start listening to the new one.
            this.registerChangeListener(prevDepthMaterialId, this.onMaterialChanged, false);
            this.registerChangeListener(newDepthMaterialId, this.onMaterialChanged, true);
            // Assign the new depth material.
            this.loadAndAssignMaterial(this.runtimeData, 'customDepthMaterial', newDepthMaterialId, this.getDepthMaterialType());
        }
    };
    /**
     * Load the asset with the specified ID.
     * @method loadAsset
     * @private
     * @param {String} assetId The ID of the asset to load.
     * @returns {Promise} A promise that resolves with the loaded asset or an error, if one occurs.
     * If assetId is null, the promise resolves with null.
     */
    MeshObject.prototype.loadAsset = function (assetId) {
        if (!assetId) {
            return Promise.resolve(null);
        }
        var asset = this.engine.getAssetById(assetId);
        if (!asset) {
            return Promise.reject(new Error("Asset \"" + assetId + "\" not found"));
        }
        return new Promise(function (resolve, reject) {
            asset.when('load', function () {
                if (asset.isLoadFailed()) {
                    reject(new Error("Asset \"" + assetId + "\" failed to load"));
                    return;
                }
                resolve(asset);
            });
            if (!asset.isLoaded()) {
                asset.load();
            }
        });
    };
    /**
     * Called in response to GeometryAsset property changes.
     * @method onGeometryChanged
     * @public
     * @returns {void}
     */
    MeshObject.prototype.onGeometryChanged = function () {
        this.createRuntimeData();
    };
    /**
     * Called in response to MaterialAsset property changes.
     * @method onMaterialChanged
     * @public
     * @returns {void}
     */
    MeshObject.prototype.onMaterialChanged = function () {
        // TODO: Update runtimeData.customDepthMaterial.
        return;
    };
    /**
     * Called when a MaterialAsset is deleted.
     * @method onMaterialDeleted
     * @public
     * @param {String} unloadedMaterialId The ID of the material being unloaded.
     * @returns {void}
     */
    MeshObject.prototype.onMaterialDeleted = function (unloadedMaterialId) {
        var materialIds = this.getMaterialIds();
        var removed = false;
        // Remove the unloaded material from the list of materials.
        materialIds.forEach(function (materialId, index) {
            if (materialId === unloadedMaterialId) {
                // Note: we assign null (no material) rather than undefined (use prefab material).
                materialIds[index] = null;
                removed = true;
            }
        });
        // If the material was in-use, remove it from the material list.
        if (removed) {
            this.setProperty('materials', materialIds);
        }
    };
    /**
     * Revert the material assignment at the specified index. This will cause the material at that
     * index to be inherited from the prefab object, if one is set.
     * @method revertMaterial
     * @public
     * @param {number} [index] The material index (default is 0).
     * @returns {void}
     */
    MeshObject.prototype.revertMaterial = function (index) {
        if (index === void 0) { index = 0; }
        // Note: we pass undefined, which unassigns the material and causes the prefab material at the
        // same index to be used. Passing null would override the prefab's material with an empty
        // material slot.
        this.setMaterial(undefined, index);
    };
    /**
     * Assign the specified material to the mesh at the specified index.
     * @method setMaterial
     * @public
     * @param {String|MaterialAsset} material The MaterialAsset, its ID or null/undefined.
     * @param {number} [index] The material index (default is 0).
     * @returns {void}
     */
    MeshObject.prototype.setMaterial = function (material, index) {
        if (index === void 0) { index = 0; }
        // Validate the index parameter.
        if (index < 0 || index >= this.getMaterialCount()) {
            throw new Error('Invalid index parameter');
        }
        // If material is a MaterialAsset, get the ID.
        var materialId = material instanceof MaterialAsset_1.default ? material.id : material;
        // Assign the material to the index.
        var materialIds = (this.getOwnProperty('materials') || []).slice();
        if (materialIds[index] !== materialId) {
            materialIds[index] = materialId;
            this.setProperty('materials', materialIds);
        }
    };
    /**
     * Get an array of material asset IDs that are assigned to this mesh.
     * @method getMaterialIds
     * @public
     * @returns {Array} An array of BaseAsset IDs.
     */
    MeshObject.prototype.getMaterialIds = function () {
        var materialIds = this.getProperty('materials');
        var prefab = this.getPrefabObject();
        var prefabMaterialIds = prefab ? prefab.getProperty('materials') : [];
        var merged = [];
        var length = Math.max(materialIds.length, prefabMaterialIds.length);
        for (var i = 0; i < length; ++i) {
            // Note: if the material ID is null, we interpret that as "no material" rather than falling
            // back to the prefab's material ID, which we do when material ID is undefined.
            merged.push(materialIds[i] !== undefined ? materialIds[i] : prefabMaterialIds[i]);
        }
        return merged;
    };
    /** @inheritdoc */
    MeshObject.prototype.applyPropertiesUnloaded = function (changes) {
        var _this = this;
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.hasOwnProperty('materials')) {
            // Unregister previous materials.
            this.getPreviousMaterials().forEach(function (material) { return _this.unregisterDependency(material); });
            // Register new materials.
            this.getMaterials().forEach(function (material) { return _this.registerDependency(material); });
        }
        if (changes.hasOwnProperty('customDepthMaterial')) {
            // Unregister previous material.
            var prevDepthMaterialId = this.getPreviousProperty('customDepthMaterial');
            if (prevDepthMaterialId) {
                this.unregisterDependencyById(prevDepthMaterialId);
            }
            // Register new material.
            var newDepthMaterialId = this.getProperty('customDepthMaterial');
            if (newDepthMaterialId) {
                this.registerDependencyById(newDepthMaterialId);
            }
        }
        if (changes.hasOwnProperty('geometryId')) {
            // Unregister previous geometry.
            var prevGeometryId = this.getPreviousProperty('geometryId');
            if (prevGeometryId) {
                this.unregisterDependencyById(prevGeometryId);
            }
            // Register new geometry.
            var newGeometryId = this.getProperty('geometryId');
            if (newGeometryId) {
                this.registerDependencyById(newGeometryId);
            }
        }
    };
    /**
     * Bind this mesh to a skeleton using the assigned skin. An error will be thrown if:
     *   * This mesh is not part of a prefab instance
     *   * No skin asset is assigned
     *   * The skin asset is not loaded
     *   * The mesh's runtime data is not loaded
     * @method bindToHierarchy
     * @private
     * @returns {void}
     * @throws Error
     */
    MeshObject.prototype.bindToHierarchy = function () {
        var _this = this;
        var root = this.getInstanceTop();
        if (!root) {
            throw new Error('Cannot bind mesh to hierarchy because it is not part of a prefab instance');
        }
        var skinAsset = this.getSkinAsset();
        if (!skinAsset) {
            throw new Error('Cannot bind mesh to hierarchy because it does not have a skin asset');
        }
        if (!skinAsset.isLoaded()) {
            throw new Error('Cannot bind mesh to hierarchy because the skin asset is not loaded');
        }
        var mesh = this.runtimeData;
        if (!mesh) {
            throw new Error('Cannot bind mesh to hierarchy because the mesh is not loaded');
        }
        root.when('loadDependencies', function () {
            var entities = root ? root.getDescendants() : [];
            var objects = entities.map(function (entity) { return entity.getRuntimeData(); });
            var objectsByName = objects.reduce(function (curr, obj) {
                curr[obj.name] = obj;
                return curr;
            }, {});
            var joints = skinAsset.getJointNames().map(function (jointName) {
                var runtimeName = _this.engine.getRuntimeName(jointName);
                return objectsByName[runtimeName];
            });
            var skeleton = new THREE.Skeleton(joints, skinAsset.getInverseBindMatrices());
            mesh.bind(skeleton, skinAsset.getBindShapeMatrix());
        });
        if (!root.isUnloaded()) {
            root.load();
        }
    };
    /**
     * Create a default three.js mesh using default geometry. Used when problems
     * loading this meshes assigned geometry occur.
     */
    MeshObject.prototype.createDefaultMesh = function () {
        var defaultGeometry = this.engine.geometryUtilities.getDefaultGeometry();
        this.createMesh(defaultGeometry);
    };
    /**
     * Create three.js mesh using the given geometry.
     * @param geometry The Three.js geometry to create the mesh from.
     */
    MeshObject.prototype.createMesh = function (geometry) {
        if (!this.runtimeData) {
            var meshType = this.isSkinned() ? THREE.SkinnedMesh : THREE.Mesh;
            var mesh = new meshType(geometry);
            mesh.name = this.getRuntimeName();
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.material = null;
            this.runtimeData = mesh;
        }
        else {
            this.runtimeData.geometry = geometry;
        }
    };
    /**
     * Create the runtime mesh (i.e., a THREE.Mesh or THREEE.SkinnedMesh).
     * @method createMesh
     * @private
     * @returns {void}
     * @throws Error
     */
    MeshObject.prototype.createMeshLoaded = function () {
        var geometryAsset = this.getGeometryAsset();
        if (!geometryAsset.isLoaded()) {
            throw new Error('Cannot create mesh because geometry asset is not loaded');
        }
        var skinAsset = this.getSkinAsset();
        if (skinAsset && !skinAsset.isLoaded()) {
            throw new Error('Cannot create mesh because skin asset is not loaded');
        }
        var primitiveType = BaseGeometryAsset_1.default.primitiveType.TRIANGLES;
        var geometry = geometryAsset ? geometryAsset.getGeometry(primitiveType) : undefined;
        this.createMesh(geometry);
        if (skinAsset) {
            this.bindToHierarchy();
        }
    };
    /**
     * Get the depth material type.
     * @method getDepthMaterialType
     * @private
     * @returns {String} Either 'depthSkinned' or 'depthStatic'.
     */
    MeshObject.prototype.getDepthMaterialType = function () {
        var materialType = this.getMaterialType();
        if (MaterialAsset_1.default.materialObjectTypes[materialType].skinning) {
            return 'depthSkinned';
        }
        return 'depthStatic';
    };
    /**
     * Get an array of material assets that were previously assigned to this mesh.
     * @method getPreviousMaterials
     * @public
     * @param {Boolean} [placeholder] Substitute a placeholder for missing materials (default is
     * true).
     * @returns {MaterialAsset[]} An array of assets.
     */
    MeshObject.prototype.getPreviousMaterials = function (placeholder) {
        if (placeholder === void 0) { placeholder = true; }
        var materials = [];
        var nMaterials = this.getMaterialCount();
        for (var i = 0; i < nMaterials; ++i) {
            materials.push(this.getPreviousMaterial(i, placeholder));
        }
        return materials;
    };
    /**
     * Get the material type.
     * @method getMaterialType
     * @private
     * @returns {String} One of 'static', 'staticTangents', 'skinned', or 'skinnedTangents'.
     */
    MeshObject.prototype.getMaterialType = function () {
        var geometry = this.getGeometry();
        // FIXME does hasTangents exist anymore? I can't find it with a grep in three.js
        var hasTangents = geometry && geometry.hasTangents;
        if (this.isSkinned()) {
            return hasTangents ? 'skinnedTangents' : 'skinned';
        }
        return hasTangents ? 'staticTangents' : 'static';
    };
    /**
     * Get an array of material asset IDs that were previously assigned to this mesh.
     * @method getPreviousMaterialIds
     * @private
     * @returns {Array} an array of BaseAsset IDs.
     */
    MeshObject.prototype.getPreviousMaterialIds = function () {
        var materialIds = this.getPreviousProperty('materials');
        var prefab = this.getPrefabObject();
        var prefabMaterialIds = prefab ? prefab.getPreviousProperty('materials') : [];
        var merged = [];
        var length = Math.max(materialIds.length, prefabMaterialIds.length);
        for (var i = 0; i < length; ++i) {
            // Note: if the material ID is null, we interpret that as "no material" rather than falling
            // back to the prefab's material ID, which we do when material ID is undefined.
            merged.push(materialIds[i] !== undefined ? materialIds[i] : prefabMaterialIds[i]);
        }
        return merged;
    };
    /**
     * Load a material asset and assign its runtime data to the specified property.
     * @method loadAndAssignMaterial
     * @private
     * @param {Object} obj The object that receives the material assignment.
     * @param {String} property The property that receives the material assignment.
     * @param {String} materialId The ID of the material asset.
     * @param {String} materialType The type of material to use.
     * @returns {void}
     */
    MeshObject.prototype.loadAndAssignMaterial = function (obj, property, materialId, materialType) {
        // Assign the missing material while the real material loads.
        var missingMaterial = this.engine.materialUtilities.getMissingMaterial();
        if (missingMaterial && missingMaterial.getRuntimeData()) {
            obj[property] = missingMaterial.getRuntimeData()[materialType];
        }
        else {
            Logger_1.default.error(this.engine.getName() +
                ' - MeshObject: "Missing" material needed, but can\'t be found or isn\'t loaded.');
        }
        // Load and assign the real material.
        if (materialId) {
            var materialAsset_1 = this.engine.getAssetById(materialId);
            if (materialAsset_1) {
                materialAsset_1.when('loadBase', function () {
                    obj[property] = materialAsset_1.getRuntimeData()[materialType];
                });
                if (!materialAsset_1.isLoaded()) {
                    materialAsset_1.load();
                }
            }
        }
    };
    /**
     * Start or stop listening for changes to a BaseAsset.
     * @method registerChangeListener
     * @private
     * @param {String} assetId The ID of the BaseAsset to listen to.
     * @param {Function} callback The function to be called when properties change.
     * @param {Boolean} enabled Indicates whether to start or stop listening.
     * @returns {void}
     */
    MeshObject.prototype.registerChangeListener = function (assetId, callback, enabled) {
        // TODO: move this functionality into BaseEntity.
        if (!assetId) {
            return;
        }
        var asset = this.engine.getAssetById(assetId);
        if (!asset) {
            return;
        }
        if (enabled) {
            asset.on('propertyChanges', callback, this);
        }
        else {
            asset.off('propertyChanges', callback, this);
        }
    };
    return MeshObject;
}(BaseObject_1.default));
/** @inheritdoc */
MeshObject.events = {
    setMaterial: {
        scope: 'local',
        action: true,
        category: 'Materials',
        params: [
            {
                name: 'material',
                type: 'asset',
                filter: {
                    material: true
                }
            },
            {
                name: 'index',
                type: 'i',
                description: 'Optional - the index of the material (default is 0).',
                default: 0
            }
        ]
    },
    castShadowsEnable: {
        params: [],
        action: true,
        category: 'Rendering'
    },
    castShadowsDisable: {
        params: [],
        action: true,
        category: 'Rendering'
    },
    castShadowsToggle: {
        params: [],
        action: true,
        category: 'Rendering'
    }
};
/**
 * Default value for mesh bounds.
 */
MeshObject.defaultLocalBounds = new THREE.Box3();
Schemas_1.addSchemas('MeshObject', MeshObject);
exports.default = MeshObject;


/***/ }),
/* 27 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* tslint:disable no-invalid-this */
// RuntimeEvents based on code adapted from Backbone.Events.
//
// Backbone.js:
//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org
//

Object.defineProperty(exports, "__esModule", { value: true });
var uuid_1 = __webpack_require__(18);
;
var triggerEvents = function (events, args) {
    var ev;
    var i = -1;
    var l = events.length;
    var a1 = args[0];
    var a2 = args[1];
    var a3 = args[2];
    switch (args.length) {
        case 0:
            while (++i < l) {
                (ev = events[i]).callback.call(ev.ctx);
            }
            break;
        case 1:
            while (++i < l) {
                (ev = events[i]).callback.call(ev.ctx, a1);
            }
            break;
        case 2:
            while (++i < l) {
                (ev = events[i]).callback.call(ev.ctx, a1, a2);
            }
            break;
        case 3:
            while (++i < l) {
                (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
            }
            break;
        default:
            while (++i < l) {
                (ev = events[i]).callback.apply(ev.ctx, args);
            }
            break;
    }
};
// Inversion-of-control versions of `on` and `once`. Tell *this* object to
// listen to an event in another object ... keeping track of what it's
// listening to.
var invertedListen = function (method) {
    return function (obj, name, callback) {
        var id = obj._listenId || (obj._listenId = uuid_1.v4());
        this._listeningTo[id] = obj;
        if (!callback && typeof name === 'object') {
            callback = this;
        }
        obj[method](name, callback, this);
        return this;
    };
};
var once = function (fn) {
    var _this = this;
    var called = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!called) {
            called = true;
            fn.apply(_this, args);
        }
    };
};
var listenTo = invertedListen('on');
var listenToOnce = invertedListen('once');
var RuntimeEvents = (function () {
    function RuntimeEvents() {
        this._events = { all: [] };
        this._listeningTo = {};
        this._listenId = uuid_1.v4();
    }
    /**
     * Bind an event to a `callback` function.
     * @method on
     * @public
     * @param  {String}   name     The name of the event
     * @param  {Function} callback The function to call when the event occurs.
     * @param  {Object}   [context]  The context in which the callback will be called.
     */
    RuntimeEvents.prototype.on = function (name, callback, context) {
        var events = this._events[name] || (this._events[name] = []);
        events.push({ callback: callback, context: context, ctx: context || this });
        return this;
    };
    /**
     * Bind an event to only be triggered a single time. After the first time the callback
     * is invoked, it will be removed.
     * @method once
     * @public
     * @param  {String}   name      The name of the event
     * @param  {Function} callback  The function to call when the event occurs.
     * @param  {Object}   [context] The context in which the callback will be called.
     */
    RuntimeEvents.prototype.once = function (name, callback, context) {
        var _this = this;
        if (typeof callback !== 'function') {
            return;
        }
        var fn = once(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            _this.off(name, once);
            callback.apply(context || _this, args);
        });
        return this.on(name, fn, context);
    };
    /**
     * Remove one or many callbacks. If `context` is null, removes all
     * callbacks with that function. If `callback` is null, removes all
     * callbacks for the event. If `name` is null, removes all bound
     * callbacks for all events.
     * @method off
     * @public
     * @param  {String}   [name]     The name of the event
     * @param  {Function} [callback] The function to call when the event occurs.
     * @param  {Object}   [context]  The context in which the callback will be called.
     */
    RuntimeEvents.prototype.off = function (name, callback, context) {
        var retain;
        var ev;
        var events;
        var names;
        if (!name && !callback && !context) {
            return this;
        }
        names = name ? [name] : Object.keys(this._events);
        /* tslint:disable one-variable-per-declaration */
        for (var i = 0, l = names.length; i < l; i++) {
            name = names[i];
            events = this._events[name];
            if (events) {
                this._events[name] = retain = [];
                if (callback || context) {
                    for (var j = 0, k = events.length; j < k; j++) {
                        ev = events[j];
                        if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                            (context && context !== ev.context)) {
                            retain.push(ev);
                        }
                    }
                }
                if (!retain.length) {
                    delete this._events[name];
                }
            }
        }
        /* tslint:enable one-variable-per-declaration */
        return this;
    };
    /**
     * Trigger one or many events, firing all bound callbacks. Callbacks are
     * passed the same arguments as `trigger` is, apart from the event name
     * (unless you're listening on `"all"`, which will cause your callback to
     * receive the true name of the event as the first argument).
     * @method trigger
     * @public
     * @param {String} name The name of the event
     */
    RuntimeEvents.prototype.trigger = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!this._events) {
            return this;
        }
        var events = this._events[name];
        var allEvents = this._events.all;
        if (events) {
            triggerEvents(events, args);
        }
        args.unshift(name);
        if (allEvents) {
            triggerEvents(allEvents, args);
        }
        return this;
    };
    /**
     * Tell this object to stop listening to either specific events ... or
     * to every object it's currently listening to.
     * @method stopListening
     * @public
     * @param  {[type]}   [obj]      The object that the event is bound to
     * @param  {String}   [name]     The name of the event
     * @param  {Function} [callback] The function to call when the event occurs.
     */
    RuntimeEvents.prototype.stopListening = function (obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) {
            return this;
        }
        var remove = !name && !callback;
        if (!callback && typeof name === 'object') {
            callback = this;
        }
        if (obj) {
            (listeningTo = {})[obj._listenId] = obj;
        }
        for (var id in listeningTo) {
            if (listeningTo.hasOwnProperty(id)) {
                obj = listeningTo[id];
                obj.off(name, callback, this);
                if (remove || !obj._events) {
                    delete this._listeningTo[id];
                }
            }
        }
    };
    /**
     * Returns true if someone is listening to the specified event on this object.
     * @method isEventBound
     * @public
     * @param  {String}  name The name of the event.
     * @return {Boolean}      True if the event has a listener already. False otherwise.
     */
    RuntimeEvents.prototype.isEventBound = function (name) {
        return this._events[name] ? true : false;
    };
    /**
     * Inversion-of-control version of `on`.
     * @method listenTo
     * @public
     * @param  {Object}   obj      The object which emits the event.
     * @param  {String}   name     The name of the event
     * @param  {Function} [callback] The function to call when the event occurs.
     */
    RuntimeEvents.prototype.listenTo = function (obj, name, callback) {
        return listenTo.call(this, obj, name, callback);
    };
    /**
     * Inversion-of-control version of `once`.
     * @method listenTo
     * @public
     * @param  {Object}   obj      The object which emits the event.
     * @param  {String}   name     The name of the event
     * @param  {Function} [callback] The function to call when the event occurs.
     */
    RuntimeEvents.prototype.listenToOnce = function (obj, name, callback) {
        return listenToOnce.call(this, obj, name, callback);
    };
    return RuntimeEvents;
}());
;
exports.default = RuntimeEvents;


/***/ }),
/* 28 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var baseGeometryAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'baseGeometryAsset', title: 'BaseGeometryAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { properties: {
            $ref: 'baseGeometryAssetProperties.json'
        } }) });
exports.default = baseGeometryAsset;


/***/ }),
/* 29 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var baseGeometryAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'baseGeometryAssetProperties', title: 'BaseGeometryAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { bounds: {
            description: 'The bounds of the geometry.',
            $ref: 'box3.json'
        } }) });
exports.default = baseGeometryAssetProperties;


/***/ }),
/* 30 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var baseTextureAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'baseTextureAsset', title: 'BaseTextureAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { properties: {
            $ref: 'baseTextureAssetProperties.json'
        } }) });
exports.default = baseTextureAsset;


/***/ }),
/* 31 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var representation = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'representation',
    title: 'RepresentationDef',
    type: 'object',
    properties: {
        src: {
            type: 'string'
        },
        contentType: {
            type: 'string'
        },
        contentLength: {
            type: 'number'
        },
        colorspace: {
            type: 'string',
            enum: ['srgb', 'rgb', 'gray']
        }
    },
    additionalProperties: false
};
exports.default = representation;


/***/ }),
/* 32 */
/***/ (function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ }),
/* 33 */
/***/ (function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ }),
/* 34 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseAsset_1 = __webpack_require__(6);
var Schemas_1 = __webpack_require__(4);
var ApplicationAsset = (function (_super) {
    tslib_1.__extends(ApplicationAsset, _super);
    function ApplicationAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    ApplicationAsset.prototype.createRuntimeData = function (callback) {
        this.engine.setCurrentApp(this.id);
        var scene = this.engine.getEntityById(this.getProperty('startupSceneId'));
        if (scene) {
            scene.load();
        }
        callback();
    };
    return ApplicationAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('ApplicationAsset', ApplicationAsset);
exports.default = ApplicationAsset;


/***/ }),
/* 35 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var BaseEntity_1 = __webpack_require__(9);
var BaseImageAsset_1 = __webpack_require__(11);
var LoadingEvent_1 = __webpack_require__(12);
var LoadingType_1 = __webpack_require__(16);
var Schemas_1 = __webpack_require__(4);
var defaultChannels = ['red', 'green', 'blue'];
var maxImageSize = 16384;
/**
 * Class that represents all static image data to be loaded by the engine.
 */
var ImageAsset = (function (_super) {
    tslib_1.__extends(ImageAsset, _super);
    function ImageAsset() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * The current loading priority of this asset. Changes based on
         * streaming state and settings.
         */
        _this.loadPriority = 2;
        return _this;
    }
    /** @inheritdoc */
    ImageAsset.prototype.unload = function () {
        if (this.runtimeData) {
            this.engine.trigger('imageUnloaded', this.id);
            Logger_1.default.info(this.engine.getName() + ' - Unloading image, ' +
                this.getName());
            _super.prototype.unload.call(this);
        }
    };
    /**
     * Get the chosen image representation definition.
     * @returns {ImageRepresentationDef}
     */
    ImageAsset.prototype.getChosenRepresentation = function () {
        return this.chosenRepresentation;
    };
    /**
     * Returns true iff the loaded image is using hardware compression. If not loaded, returns true
     * iff the image as flagged to load a hardware compressed version.
     * @method isCompressed
     * @public
     * @return {Boolean} True iff the texture is using a hardware compression format.
     */
    ImageAsset.prototype.isCompressed = function () {
        if (this.runtimeData) {
            return this.runtimeData.compression !== 'jpeg' &&
                this.runtimeData.compression !== 'zip';
        }
        return this.getProperty('useCompression');
    };
    /**
     * Returns the preferred texture compression format for the device.
     * @returns The compression format.
     */
    ImageAsset.prototype.getCompressionFormat = function () {
        var format = this.getFormat();
        var compression = format === 'rgb' ? 'jpeg' : 'zip';
        // If a compressed format is preferred, get one based on the device caps.
        if (this.getProperty('useCompression')) {
            var renderer = this.engine.getThreeRenderer();
            var extensions = renderer.extensions;
            if (extensions.get('WEBGL_compressed_texture_s3tc')) {
                compression = 'dxt';
            }
            else if (extensions.get('WEBGL_compressed_texture_pvrtc')) {
                compression = 'pvrtc';
            }
        }
        return compression;
    };
    /** @inheritdoc */
    ImageAsset.prototype.getOriginalWidth = function () {
        return this.getProperty('width') || 0;
    };
    /** @inheritdoc */
    ImageAsset.prototype.getOriginalHeight = function () {
        return this.getProperty('height') || 0;
    };
    /** @inheritdoc */
    ImageAsset.prototype.getMaxRepresentationWidth = function () {
        var representations = this.get('representations');
        if (!representations) {
            return 0;
        }
        return representations.reduce(function (maxWidth, rep) {
            return rep.width > maxWidth ? rep.width : maxWidth;
        }, 0);
    };
    /** @inheritdoc */
    ImageAsset.prototype.getMaxRepresentationHeight = function () {
        var representations = this.get('representations');
        if (!representations) {
            return 0;
        }
        return representations.reduce(function (maxHeight, rep) {
            return rep.height > maxHeight ? rep.height : maxHeight;
        }, 0);
    };
    /** @inheritdoc */
    ImageAsset.prototype.getMaxTextureSize = function () {
        var renderer = this.engine.getRenderer();
        return renderer ? renderer.getMaxTextureSize2d() : _super.prototype.getMaxTextureSize.call(this);
    };
    /**
     * Given a compression type for a representation (e.g. 'jpeg', 'dxt', etc.),
     * return the response type that is expected (e.g. 'blob' or 'arraybuffer').
     * @param compression The compression format for the representation.
     * @returns           Either 'blob' or 'arraybuffer'.
     */
    ImageAsset.prototype.getImageResponseType = function (compression) {
        switch (compression) {
            case 'dxt':
            case 'dxt1':
            case 'dxt5':
                return 'arraybuffer';
            default:
                return 'blob';
        }
    };
    /** @inheritdoc */
    ImageAsset.prototype.applyPropertiesUnloaded = function (_changes) {
        // Find an appropriate representation.
        var imageParams = {
            maxSize: Math.max(this.getWidth(), this.getHeight()),
            compression: this.getCompressionFormat()
        };
        this.chosenRepresentation = this.findRepresentation(imageParams);
    };
    /** @inheritdoc */
    ImageAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        // Throw an error if no representations were found.
        if (!this.chosenRepresentation) {
            throw new Error('No suitable representation found to load');
        }
        this.loadLowResImage(callback)
            .then(function () { return _this.loadHighResImage(callback); })
            .catch(this.onImageLoadError.bind(this));
    };
    /**
     * Loads the low resolution version of the image.
     * @method loadLowResImage
     * @private
     * @param {Function} callback A function which will be called on completion
     *                            regardless of success/failure.
     * @return {Promise} A promise which will resolve when the image finishes loading.
     */
    ImageAsset.prototype.loadLowResImage = function (callback) {
        var _this = this;
        this.loadPriority = 2;
        // This image is not to be streamed, so this promise is a NOOP.
        if (!this.getProperty('stream')) {
            return Promise.resolve();
        }
        // FIXME - The hardcoded maxSize should probably be replaced by a global (or per-image) value
        var textureParams = {
            maxSize: 64,
            compression: this.getCompressionFormat()
        };
        var rep = this.findRepresentation(textureParams);
        if (!rep) {
            // We don't have an acceptable low-res image for streaming so just return
            // and let the high res image load.
            return Promise.resolve();
        }
        // If this image is set to be streamed, load the low-res image first
        return new Promise(function (resolve, reject) {
            var resource = _this.loadResource(rep.src, LoadingType_1.default.IMAGE, callback, {
                priority: _this.loadPriority,
                responseType: _this.getImageResponseType(rep.compression),
                isExternal: rep.isExternal
            });
            resource.once(LoadingEvent_1.default.LOAD, function (data) {
                _this.onImageLoad(data, rep);
                _this.loadPriority = 8;
                resolve();
            });
            resource.once(LoadingEvent_1.default.CANCEL, function () {
                reject(new Error('Failed to load low res texture'));
            });
            resource.once(LoadingEvent_1.default.ERROR, reject);
        });
    };
    /**
     * Loads the high resolution version of the image. Typically called after the
     * low resolution version has already been loaded.
     * @method loadHighResImage
     * @private
     * @param {Function} callback A function which will be called on completion
     *                            regardless of success/failure.
     * @return {Promise} A promise which will resolve when the image finishes loading.
     */
    ImageAsset.prototype.loadHighResImage = function (callback) {
        var _this = this;
        if (this.isDestroyed()) {
            return;
        }
        // Now load the high-res version of the image.
        return new Promise(function (_resolve, reject) {
            var onImageLoadProgress = function (progressObj) {
                if (_this.isDestroyed()) {
                    return;
                }
                _this.loadedBytes = _this.getDataSizeDownload() * progressObj.loaded / progressObj.total;
                _this.trigger('loadProgress', _this);
            };
            _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.InProgress);
            var rep = _this.chosenRepresentation;
            var resource = _this.loadResource(rep.src, LoadingType_1.default.IMAGE, callback, {
                responseType: _this.getImageResponseType(rep.compression),
                isExternal: rep.isExternal,
                priority: _this.loadPriority
            });
            resource.once(LoadingEvent_1.default.PROGRESS, onImageLoadProgress);
            resource.once(LoadingEvent_1.default.LOAD, function (data) {
                _this.onImageLoad(data, rep);
            });
            resource.once(LoadingEvent_1.default.ERROR, reject);
        });
    };
    /**
     * Called when image is finished loading
     * @method onImageLoad
     * @private
     * @param  {Object} data Loaded data
     * @returns {void}
     */
    ImageAsset.prototype.onImageLoad = function (data, representation) {
        if (!this.runtimeData) {
            this.runtimeData = {};
        }
        this.runtimeData.compression = representation.compression;
        this.runtimeData.colorspace = representation.colorspace;
        this.runtimeData.channels = representation.channels || defaultChannels;
        this.runtimeData.width = representation.width;
        this.runtimeData.height = representation.height;
        if (data instanceof ArrayBuffer || data instanceof Image) {
            this.runtimeData.imageData = data;
            this.loadedBytes = this.getDataSizeDownload();
            this.trigger('loadProgress', this);
        }
        else {
            throw new Error('Uknown container type for image data!');
        }
    };
    /**
     * Called when something unexpected happened during image load.
     * @method onImageLoadError
     * @private
     * @param  {Error} err Error object
     * @returns {void}
     */
    ImageAsset.prototype.onImageLoadError = function (err) {
        if (this.isDestroyed()) {
            return;
        }
        Logger_1.default.error('There was an error loading the image, ' + this.getName(), err);
        this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
        this.loadedBytes = this.getDataSizeDownload();
        this.trigger('loadProgress', this);
    };
    /**
     * Find the image representation that best matches the specified criteria.
     * @method findRepresentation
     * @private
     * @param {Object} options Loading options (@see XhrResourceLoader.prototype.load()).
     * @returns {Object} the representation that best matches the search criteria or null if none were
     * found.
     */
    ImageAsset.prototype.findRepresentation = function (options) {
        if (options === void 0) { options = {}; }
        var representations = this.get('representations');
        if (!representations || representations.length === 0) {
            return null;
        }
        var optionsEx = Object.assign({ maxSize: maxImageSize }, options);
        // Get closest match for compression param. Compression will either match exactly or fall back
        // to 'none'.
        var compressionMatches = representations.filter(function (image) {
            if (image.compression === optionsEx.compression) {
                return true;
            }
            switch (image.compression) {
                case 'zip':
                case 'jpeg':
                    return !optionsEx.compression;
                case 'dxt':
                case 'dxt1':
                case 'dxt5':
                    return optionsEx.compression === 'dxt';
                default:
            }
            return false;
        });
        // If no matches for the supplied compression exist, try to find the regular images (png or
        // jpg).
        if (compressionMatches.length === 0) {
            compressionMatches = representations.filter(function (image) {
                return image.compression === 'zip' || image.compression === 'jpeg';
            });
        }
        var formatMatches = compressionMatches.filter(function (image) {
            var channels = image.channels || defaultChannels;
            return !optionsEx.channels || channels.toString() === optionsEx.channels.toString();
        });
        if (formatMatches.length === 0) {
            formatMatches = compressionMatches;
        }
        // For each match, compute the difference between its size and the max size.
        var sizeDiffs = formatMatches.map(function (image) {
            return optionsEx.maxSize - Math.max(image.width || 1, image.height || 1);
        });
        // Find the index of the minimum, *positive* diff. This is equivalent to the largest image
        // that is less than or equal to the max specified.
        var bestIdx = sizeDiffs.reduce(function (currentBestIdx, currentDiff, currentIdx) {
            var bestDiff = currentBestIdx >= 0 ? sizeDiffs[currentBestIdx] : Number.MAX_VALUE;
            return currentDiff >= 0 && currentDiff < bestDiff ? currentIdx : currentBestIdx;
        }, -1);
        // Locate the match.
        return bestIdx >= 0 ? formatMatches[bestIdx] : null;
    };
    return ImageAsset;
}(BaseImageAsset_1.default));
Schemas_1.addSchemas('ImageAsset', ImageAsset);
exports.default = ImageAsset;


/***/ }),
/* 36 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(6);
var Box3DShaderPBR_1 = __webpack_require__(205);
var functions_1 = __webpack_require__(5);
var Schemas_1 = __webpack_require__(4);
var ShaderAsset = (function (_super) {
    tslib_1.__extends(ShaderAsset, _super);
    function ShaderAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Return a list of all parameters that are dependent on the specified one.
     * @param paramName The name of the dependency to check for.
     * @returns         An array of parameters that are dependent on the
     *                  given one.
     */
    ShaderAsset.prototype.getDependentParameters = function (paramName) {
        if (this.paramDependencyMap[paramName]) {
            return this.paramDependencyMap[paramName];
        }
    };
    /**
     * Get a list of all parameters that the given parameter is dependent on.
     * @param paramName The name of the parameter to get dependencies for.
     * @returns         An array of parameter names.
     */
    ShaderAsset.prototype.getParameterDependencies = function (paramName) {
        /**
         * Gets a list of dependency names for a logical and condition.
         * @param conditions  The shader conditions object.
         * @param deps        A reference to the current array of dependencies.
         * @returns           An array of dependent parameter names.
         */
        function getLogicalAndDependencies(conditions, deps) {
            if (deps === void 0) { deps = []; }
            var dependencies = deps;
            functions_1.forEach(conditions, function (cond, key) {
                if (key === 'or') {
                    dependencies = getLogicalOrDependencies(cond, dependencies);
                }
                else if (dependencies.indexOf(key) === -1) {
                    dependencies = dependencies.concat([key]);
                }
            });
            return dependencies;
        }
        /**
         * Gets a list of dependency names for a logical or condition.
         * @param conditions  An array of shader conditions objects.
         * @param deps        A reference to the current array of dependencies.
         * @returns           An array of dependent parameter names.
         */
        function getLogicalOrDependencies(conditions, deps) {
            if (deps === void 0) { deps = []; }
            var dependencies = deps;
            functions_1.forEach(conditions, function (cond) {
                dependencies = getLogicalAndDependencies(cond, dependencies);
            });
            return dependencies;
        }
        var parameters = this.getProperty('parameters');
        if (parameters[paramName] && parameters[paramName].enabledWhen) {
            return getLogicalAndDependencies(parameters[paramName].enabledWhen, []);
        }
        else {
            return [];
        }
    };
    /** @inheritdoc */
    ShaderAsset.prototype.createRuntimeData = function (callback) {
        this.runtimeData = {};
        this.runtimeData.vertexShader = this.getProperty('vertexShader');
        this.runtimeData.fragmentShader = this.getProperty('fragmentShader');
        this.buildUniformList();
        this.buildRenderParamList();
        callback();
    };
    /** @inheritdoc */
    ShaderAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        this.buildParamDependencies();
    };
    /**
     * Builds the uniform list runtime data.
     */
    ShaderAsset.prototype.buildUniformList = function () {
        var _this = this;
        var parameters = this.getProperty('parameters');
        var uniforms = this.getProperty('uniforms');
        var uniform;
        this.runtimeData.uniforms = THREE.UniformsUtils.clone(uniforms);
        functions_1.forEach(parameters, function (param, paramName) {
            uniform = {};
            if (!param || param.isRenderParam || !param.isUniform) {
                return;
            }
            switch (param.type) {
                case 'opt':
                    uniform.type = 'i';
                    uniform.value = param.default;
                    break;
                case 'b':
                    uniform.type = 'i';
                    uniform.value = param.default ? 1 : 0;
                    break;
                case 't':
                    uniform.type = 't';
                    uniform.value = param.default;
                    break;
                case 'c':
                    uniform.type = param.type;
                    uniform.value = new THREE.Color(param.default);
                    uniform.value.copyGammaToLinear(uniform.value);
                    break;
                case 'v2':
                    uniform.type = param.type;
                    uniform.value = new THREE.Vector2();
                    uniform.value.set(param.default.x, param.default.y);
                    break;
                case 'v3':
                    uniform.type = param.type;
                    uniform.value = new THREE.Vector3();
                    uniform.value.set(param.default.x, param.default.y, param.default.z);
                    break;
                case 'v4':
                    uniform.type = param.type;
                    uniform.value = new THREE.Vector4();
                    uniform.value.set(param.default.x, param.default.y, param.default.z, param.default.w);
                    break;
                default:
                    uniform.type = param.type;
                    uniform.value = param.default;
            }
            var uniformName = param.uniformName || paramName;
            _this.runtimeData.uniforms[uniformName] = uniform;
        });
    };
    /**
     * Builds the render parameter list runtime data.
     */
    ShaderAsset.prototype.buildRenderParamList = function () {
        var _this = this;
        var parameters = this.getProperty('parameters');
        var renderParams = this.getProperty('renderParams');
        this.runtimeData.renderParams = renderParams || {};
        functions_1.forEach(parameters, function (param, paramName) {
            if (!param || param.isUniform || !param.isRenderParam) {
                return;
            }
            switch (param.type) {
                case 'b':
                    _this.runtimeData.renderParams[paramName] = !!param.default;
                    break;
                default:
                    _this.runtimeData.renderParams[paramName] = param.default;
            }
        });
    };
    /**
     * Build a mapping from a parameter name to a list of all parameters
     * that are dependent on it.
     */
    ShaderAsset.prototype.buildParamDependencies = function () {
        var _this = this;
        var parameters = this.getProperty('parameters');
        this.paramDependencyMap = {};
        functions_1.forEach(parameters, function (_param, name) {
            // Add this param to the list for each dependency that it has.
            var deps = _this.getParameterDependencies(name);
            functions_1.forEach(deps, function (paramName) {
                if (!_this.paramDependencyMap[paramName]) {
                    _this.paramDependencyMap[paramName] = [];
                }
                if (_this.paramDependencyMap[paramName].indexOf(name) === -1) {
                    _this.paramDependencyMap[paramName].push(name);
                }
            });
            // Make sure that there is at least an empty array for each param.
            if (!_this.paramDependencyMap[name]) {
                _this.paramDependencyMap[name] = [];
            }
        });
    };
    return ShaderAsset;
}(BaseAsset_1.default));
/**
 * A mapping of string to entity descriptors for built in shaders.
 */
ShaderAsset.builtInAssetDescriptors = {
    PBR: Box3DShaderPBR_1.default
};
Schemas_1.addSchemas('ShaderAsset', ShaderAsset);
exports.default = ShaderAsset;


/***/ }),
/* 37 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* tslint:disable no-bitwise */

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseObject_1 = __webpack_require__(10);
var Schemas_1 = __webpack_require__(4);
/**
 * @class LightObject
 * @constructor
 */
var LightObject = (function (_super) {
    tslib_1.__extends(LightObject, _super);
    function LightObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    LightObject.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.on('setColor', this.setColor, this);
        this.on('setIntensity', this.setIntensity, this);
    };
    /** @inheritdoc */
    LightObject.prototype.uninitialize = function () {
        this.off('setColor', this.setColor, this);
        this.off('setIntensity', this.setIntensity, this);
        _super.prototype.uninitialize.call(this);
    };
    /** @inheritdoc */
    LightObject.prototype.createRuntimeData = function (callback) {
        var type = this.getProperty('lightType');
        if (type === 'directional') {
            this.runtimeData = new THREE.DirectionalLight();
        }
        else if (type === 'ambient') {
            this.runtimeData = new THREE.AmbientLight();
        }
        else if (type === 'spot') {
            this.runtimeData = new THREE.SpotLight();
        }
        else if (type === 'hemisphere') {
            this.runtimeData = new THREE.HemisphereLight();
        }
        else {
            this.runtimeData = new THREE.PointLight();
        }
        this.runtimeData.name = this.getRuntimeName();
        callback(this);
    };
    /** @inheritdoc */
    LightObject.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        // If the light type changed, we need to re-create the runtimeData.
        if (changes.hasOwnProperty('lightType') && reason !== 'init') {
            this.reloadBase();
            return;
        }
        if (changes.hasOwnProperty('intensity')) {
            this.runtimeData.intensity = this.getProperty('intensity');
        }
        if (changes.hasOwnProperty('color')) {
            this.runtimeData.color.copy(this.getProperty('color'));
        }
        var type = this.getProperty('lightType');
        if (type === 'directional') {
            // If any of the shadow camera properties have changed, we'll need to update the
            // projection matrix for the camera.
            if (changes.hasOwnProperty('shadowCameraNear') ||
                changes.hasOwnProperty('shadowCameraFar') ||
                changes.hasOwnProperty('shadowCameraLeft') ||
                changes.hasOwnProperty('shadowCameraRight') ||
                changes.hasOwnProperty('shadowCameraTop') ||
                changes.hasOwnProperty('shadowCameraBottom')) {
                if (this.runtimeData.shadowCamera) {
                    this.runtimeData.shadow.camera.near = this.getProperty('shadowCameraNear');
                    this.runtimeData.shadow.camera.far = this.getProperty('shadowCameraFar');
                    this.runtimeData.shadow.camera.left = this.getProperty('shadowCameraLeft');
                    this.runtimeData.shadow.camera.right = this.getProperty('shadowCameraRight');
                    this.runtimeData.shadow.camera.top = this.getProperty('shadowCameraTop');
                    this.runtimeData.shadow.camera.bottom = this.getProperty('shadowCameraBottom');
                    this.runtimeData.shadow.camera.updateProjectionMatrix();
                }
            }
            if (changes.hasOwnProperty('shadowBias')) {
                this.runtimeData.shadow.bias = this.getProperty('shadowBias');
            }
            if (changes.hasOwnProperty('shadowMapWidth') ||
                changes.hasOwnProperty('shadowMapHeight')) {
                var maxSize = this.engine.getGPUCapability('MAX_TEXTURE_SIZE');
                this.runtimeData.shadow.width = Math.min(maxSize, this.getProperty('shadowMapWidth'));
                this.runtimeData.shadow.height = Math.min(maxSize, this.getProperty('shadowMapHeight'));
                this.disposeShadowMap();
            }
            if (changes.hasOwnProperty('castShadow')) {
                this.runtimeData.castShadow = this.getProperty('castShadow');
                if (!this.runtimeData.castShadow) {
                    this.disposeShadowMap();
                }
            }
        }
        else if (type === 'point') {
            if (changes.hasOwnProperty('scale')) {
                this.runtimeData.distance = 100 * this.getProperty('scale').x;
            }
        }
    };
    /**
     * Cleanup the shadowmap data for the light, if any.
     * @method disposeShadowMap
     * @private
     * @return {void}
     */
    LightObject.prototype.disposeShadowMap = function () {
        if (this.runtimeData.shadowMap) {
            this.runtimeData.shadowMap.dispose();
            this.runtimeData.shadowMap = undefined;
            if (this.runtimeData.cameraHelper && this.runtimeData.cameraHelper.parent) {
                this.runtimeData.cameraHelper.parent.remove(this.runtimeData.cameraHelper);
            }
            if (this.runtimeData.shadowCamera && this.runtimeData.shadowCamera.parent) {
                this.runtimeData.shadowCamera.parent.remove(this.runtimeData.shadowCamera);
            }
            this.runtimeData.shadowCamera = undefined;
            this.runtimeData.cameraHelper = undefined;
        }
    };
    /** @inheritdoc */
    LightObject.prototype.unload = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        if (this.runtimeData) {
            if (this.runtimeData.shadowMap) {
                Logger_1.default.info(this.engine.getName() + ' - Deallocating shadow map texture for light ' +
                    this.getName());
                this.disposeShadowMap();
            }
        }
        _super.prototype.unload.call(this, recursive);
    };
    /**
     * Set the color of the light.
     * @method setColor
     * @public
     * @param {number} newValue        New color in numeric form (rgb)
     * @param {number} [animationTime] Optional time to animate the color change over.
     */
    LightObject.prototype.setColor = function (newValue, animationTime) {
        var _this = this;
        var ellapsedTime = 0.0;
        var newR;
        var newG;
        var newB;
        var oldR;
        var oldG;
        var oldB;
        var oldValue;
        var animateValue = function (delta) {
            ellapsedTime += delta;
            if (ellapsedTime > animationTime) {
                _this.engine.off('update', animateValue, _this);
                _this.setProperty('color', newValue);
            }
            else {
                // Interpolate
                var interp = Math.min(ellapsedTime / animationTime, 1.0);
                var interpR = (1.0 - interp) * oldR + interp * newR;
                var interpG = (1.0 - interp) * oldG + interp * newG;
                var interpB = (1.0 - interp) * oldB + interp * newB;
                _this.runtimeData.color.setRGB(interpR, interpG, interpB);
            }
        };
        if (animationTime) {
            oldValue = this.getProperty('color');
            oldR = (oldValue >> 16 & 255) / 255;
            oldG = (oldValue >> 8 & 255) / 255;
            oldB = (oldValue & 255) / 255;
            newR = (newValue >> 16 & 255) / 255;
            newG = (newValue >> 8 & 255) / 255;
            newB = (newValue & 255) / 255;
            this.engine.on('update', animateValue, this);
        }
        else {
            this.setProperty('color', newValue);
        }
    };
    /**
     * Set the brightness of the light.
     * @method setIntensity
     * @public
     * @param {number} newValue      The intensity of the light.
     * @param {number} [animationTime] Optional time to animate the brightness change over.
     */
    LightObject.prototype.setIntensity = function (newValue, animationTime) {
        var _this = this;
        var ellapsedTime = 0.0;
        var oldValue;
        var animateValue = function (delta) {
            ellapsedTime += delta;
            if (ellapsedTime > animationTime) {
                _this.engine.off('update', animateValue, _this);
                _this.setProperty('intensity', newValue);
            }
            else {
                // Interpolate
                var interp = Math.min(ellapsedTime / animationTime, 1.0);
                var interpValue = (1.0 - interp) * oldValue + interp * newValue;
                _this.runtimeData.intensity = interpValue;
            }
        };
        if (animationTime) {
            oldValue = this.getProperty('intensity');
            this.engine.on('update', animateValue, this);
        }
        else {
            this.setProperty('intensity', newValue);
        }
    };
    return LightObject;
}(BaseObject_1.default));
/** @inheritdoc */
LightObject.events = {
    setColor: {
        scope: 'local',
        action: true,
        category: 'Materials',
        params: [
            {
                name: 'value',
                type: 'c',
                description: 'The colour to set.',
                default: 0xff0000
            },
            {
                name: 'animationTime',
                type: 'f',
                description: 'The length of time that the change will take. ' +
                    'i.e. this lets you animate the change.',
                default: 0.0,
                min: 0.0
            }
        ]
    },
    setIntensity: {
        scope: 'local',
        action: true,
        category: 'Materials',
        params: [
            {
                name: 'value',
                type: 'f',
                description: 'The intensity to set.',
                default: 1.0
            },
            {
                name: 'animationTime',
                type: 'f',
                description: 'The length of time that the change will take. ' +
                    'i.e. this lets you animate the change.',
                default: 0.0,
                min: 0.0
            }
        ]
    }
};
Schemas_1.addSchemas('LightObject', LightObject);
exports.default = LightObject;


/***/ }),
/* 38 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseObject_1 = __webpack_require__(10);
var Schemas_1 = __webpack_require__(4);
/**
 * @class SceneObject
 * @constructor
 */
var SceneObject = (function (_super) {
    tslib_1.__extends(SceneObject, _super);
    function SceneObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    SceneObject.prototype.createRuntimeData = function (callback) {
        this.runtimeData = new THREE.Scene();
        this.runtimeData.matrixAutoUpdate = false;
        this.runtimeData.name = this.getName();
        callback();
    };
    /** @inheritdoc */
    SceneObject.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (!this.getProperty('fogEnabled')) {
            this.runtimeData.fog = null;
        }
        else {
            if (!this.runtimeData.fog) {
                this.runtimeData.fog = new THREE.FogExp2(this.getProperty('fogColor'));
            }
            if (changes.hasOwnProperty('fogColor')) {
                this.runtimeData.fog.color.setHex(this.getProperty('fogColor'));
            }
            if (changes.hasOwnProperty('fogDensity')) {
                this.runtimeData.fog.density = this.getProperty('fogDensity');
            }
        }
        if (changes.hasOwnProperty('fogEnabled')) {
            this.engine.trigger('rebuildMaterials');
            this.engine.needsRender = true;
        }
    };
    /** @inheritdoc */
    SceneObject.prototype.unload = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        if (this.runtimeData) {
            Logger_1.default.info('Unloading scene, ' + this.getName());
            _super.prototype.unload.call(this, recursive);
        }
    };
    return SceneObject;
}(BaseObject_1.default));
Schemas_1.addSchemas('SceneObject', SceneObject);
exports.default = SceneObject;


/***/ }),
/* 39 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LoadingEvent_1 = __webpack_require__(12);
/**
 * Configures an XMLHttpRequest object and adds it to a LoadableResource.
 * @function makeXhr
 * @param {Function} configureXhr     The function used to generate / configureXhr
 *                                    the XMLHttpRequest object, should return a
 *                                    promise to resolve with an XHR.
 * @param {LoadableResource} resource The loadable resource which contains the
 *                                    XMLHttpRequest object.
 * @return {Promise}                  Promise that will resolve with the same
 *                                    LoadableResource for purposes of continuation.
 */
exports.makeXhr = function (configureXhr) {
    return function (resource) {
        return configureXhr(resource.path, resource.params)
            .then(function (xhr) {
            resource.loaderData.xhr = xhr;
            return Promise.resolve(resource);
        });
    };
};
/**
 * Loads an XMLHttpRequest object.
 * @function loadXhr
 * @param {LoadableResource} resource The loadable resource which contains the
 *                                    XMLHttpRequest object.
 * @return {Promise}                  Promise that will resolve with the
 *                                    same LoadableResource for purposes of
 *                                    continuation.
 */
exports.loadXhr = function (resource) {
    return new Promise(function (resolve, reject) {
        resource.setLoading();
        var getContentLength = function (xhr) {
            return parseInt(xhr.getResponseHeader('Content-Length'), 10);
        };
        var getLoadStatus = function (ev) {
            return {
                total: (ev.lengthComputable && ev.target) ? getContentLength(ev.target) : 0,
                loaded: ev.loaded
            };
        };
        var cancel = function () {
            resource.loaderData.xhr.abort();
            resolve(resource);
            resource.off(LoadingEvent_1.default.CANCEL, cancel);
        };
        var complete = function () {
            resource.off(LoadingEvent_1.default.CANCEL, cancel);
            resolve(resource);
        };
        var error = function (err) {
            resource.off(LoadingEvent_1.default.CANCEL, cancel);
            reject(err);
        };
        resource.on(LoadingEvent_1.default.CANCEL, cancel);
        resource.loaderData.xhr.send();
        resource.loaderData.xhr.addEventListener('load', complete);
        resource.loaderData.xhr.addEventListener('error', error);
        resource.loaderData.xhr.addEventListener('progress', function (ev) {
            return resource.trigger(LoadingEvent_1.default.PROGRESS, getLoadStatus(ev));
        });
    });
};
/**
 * Uses predicate function to determine whether the status code constitutes
 * success or failure.
 * @function requireStatus
 * @param {Function} predicate A function which takes a status code and
 *                             returns a Boolean.
 * @param {Resource} resource  A LoadableResource instance.
 * @return {Promise}           Promise that will resolve with the same
 *                             LoadableResource for purposes of continuation.
 */
exports.requireStatus = function (predicate) {
    return function (resource) {
        return predicate(resource.loaderData.xhr.status) ?
            Promise.resolve(resource) :
            Promise.reject(new Error("Failed to load: " + resource.path + " status: " + resource.loaderData.xhr.status));
    };
};
/**
 * Sets the repsonseType on the XMLHttpRequest object.
 * @function setResponseType
 * @param {String}           defaultType A default type to use in the situation which one
 * @param {LoadableResource} resource A LoadableResource instance.
 * @return {Function}        Promise that will resolve with the same
 *                           LoadableResource for purposes of continuation.
 */
exports.setResponseType = function (defaultType) { return function (resource) {
    resource.loaderData.xhr.responseType = resource.params.responseType || defaultType;
    return Promise.resolve(resource);
}; };
/**
 * Handles an error condition by setting the LoadableResource error and then
 * returning the error down the promise chain.
 * @function handleError
 * @param {LoadableResource} resource A LoadableResource instance.
 * @param {Error} err                 An Error object.
 * @return {Promise}                  Promise that will resolve with the same
 *                                    LoadableResource for purposes of continuation.
 */
exports.handleError = function (resource) { return function (err) {
    resource.setError(err);
    return Promise.reject(err);
}; };
/**
 * A wrapper for a promise which first checks if the LoadableResource was
 * cancelled before executing the wrapped promise. In the case where the
 * LoadableResource was cancelled, the continuation will continue with the next
 * Promise in the chain.
 * @function unlessCancelled
 * @param {Promise} promise            The Promise to wrap.
 * @param {LoadableResource} resource  A LoadableResource object.
 * @return {Promise}                   Promise that will resolve with the same
 *                                     LoadableResource for purposes of
 *                                     continuation.
 */
exports.unlessCancelled = function (promise) { return function (resource) {
    return resource.isCancelled() ? Promise.resolve(resource) : promise(resource);
}; };


/***/ }),
/* 40 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var baseEntity = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'baseEntity',
    title: 'BaseEntityDef',
    type: 'object',
    description: 'Base hierarchical type for assets and objects.',
    properties: {
        type: {
            type: 'string',
            description: 'The entity\'s type.'
        },
        sid: {
            type: 'string',
            description: 'The entity\'s scoped ID.'
        },
        id: {
            type: 'string',
            description: 'The entity\'s unique ID.'
        },
        properties: {
            $ref: 'baseEntityProperties.json'
        },
        previousProperties: {
            $ref: 'baseEntityProperties.json'
        },
        components: {
            type: 'array',
            items: {
                $ref: 'component.json'
            },
            default: []
        },
        previousComponents: {
            type: 'array',
            items: {
                $ref: 'component.json'
            },
            default: []
        }
    },
    additionalProperties: false,
    required: ['id']
};
exports.default = baseEntity;


/***/ }),
/* 41 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var baseEntityProperties = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'baseEntityProperties',
    title: 'BaseEntityPropertiesDef',
    type: 'object',
    description: 'Holds type-specific properties.',
    properties: {
        name: {
            type: 'string',
            description: 'The entity\'s name.',
            default: 'unnamed'
        }
    },
    additionalProperties: false
};
exports.default = baseEntityProperties;


/***/ }),
/* 42 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var commonImageProperties_1 = __webpack_require__(45);
var baseImageAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, commonImageProperties_1.default, { id: 'baseImageAssetProperties', title: 'BaseImageAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, commonImageProperties_1.default.properties, { premultiplyAlpha: {
            type: 'boolean',
            default: false
        }, stream: {
            type: 'boolean',
            description: 'True if a low-resolution image should be loaded before the full-size image.',
            default: true
        }, filename: {
            type: 'string',
            description: 'The filename of the original image.',
            default: ''
        }, compression: {
            type: 'string',
            description: 'The type of compression used for the original image file.',
            default: 'zip'
        }, depth: {
            type: 'integer',
            description: 'The bit-depth of each channel in the original image file.',
            default: 8
        }, sequenceLength: {
            type: 'integer',
            description: 'The number of images contained in the original image file.',
            default: 1
        }, channels: {
            type: 'array',
            item: {
                type: 'string'
            },
            description: 'The distinct channels found in the original image file.',
            default: ['red', 'green', 'blue']
        } }) });
exports.default = baseImageAssetProperties;


/***/ }),
/* 43 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseTextureAsset_1 = __webpack_require__(30);
var baseRenderTextureAsset = tslib_1.__assign({}, baseTextureAsset_1.default, { id: 'baseRenderTextureAsset', title: 'BaseRenderTextureAssetDef', properties: tslib_1.__assign({}, baseTextureAsset_1.default.properties, { properties: {
            $ref: 'baseRenderTextureAssetProperties.json'
        } }) });
exports.default = baseRenderTextureAsset;


/***/ }),
/* 44 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseTextureAssetProperties_1 = __webpack_require__(21);
var commonImageProperties_1 = __webpack_require__(45);
var baseRenderTextureAssetProperties = tslib_1.__assign({}, baseTextureAssetProperties_1.default, commonImageProperties_1.default, { id: 'baseRenderTextureAssetProperties', title: 'BaseRenderTextureAssetPropertiesDef', properties: tslib_1.__assign({}, baseTextureAssetProperties_1.default.properties, commonImageProperties_1.default.properties, { stencilBuffer: {
            type: 'boolean',
            default: false
        }, depthBuffer: {
            type: 'boolean',
            default: false
        }, encoding: {
            type: 'string',
            description: 'The encoding of the image (e.g. \'srgb\', \'linear\', etc.).',
            default: 'srgb'
        }, width: {
            type: 'integer',
            description: 'The width, in pixels, of the texture.',
            default: 256
        }, height: {
            type: 'integer',
            description: 'The height, in pixels, of the texture.',
            default: 256
        } }) });
exports.default = baseRenderTextureAssetProperties;


/***/ }),
/* 45 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var commonImageProperties = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'commonImageProperties',
    title: 'CommonImagePropertiesDef',
    type: 'object',
    properties: {
        width: {
            type: 'integer',
            description: 'The width, in pixels, of the original image file.'
        },
        height: {
            type: 'integer',
            description: 'The height, in pixels, of the original image file.'
        },
        format: {
            type: 'string',
            default: 'rgb'
        },
        type: {
            type: 'string',
            default: 'uByte'
        },
        encoding: {
            type: 'string',
            description: 'The encoding of the image (e.g. \'srgb\', \'linear\', etc.). ' +
                'If undefined, the encoding will be inferred.',
            default: undefined
        },
        layout: {
            type: 'string',
            default: 'normal'
        }
    },
    additionalProperties: false
};
exports.default = commonImageProperties;


/***/ }),
/* 46 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable no-invalid-this */
/**
 * Copy properties of source object to target object excluding constructor.
 * If a property with the same exists on the target it is NOT overwritten.
 *
 * @param target
 * @param source
 */
function extend(target, source) {
    Object.getOwnPropertyNames(source).forEach(function (name) {
        if (name !== 'constructor' && !target.hasOwnProperty(name)) {
            Object.defineProperty(target, name, Object.getOwnPropertyDescriptor(source, name));
        }
    });
}
/**
 * Create a constructor function for a class implementing the given mixins.
 *
 * @param defaultOptions options that will be used if some options are missing at construction time
 * @param mixins array of classes to be mixed together. The constructor of those classes will receive the options given
 *               to the constructor of the composed object
 * @returns {{new(any): {}}} a constructor function
 */
function classComposer(defaultOptions, mixins) {
    // our constructor function that will be called every time a new composed object is created
    var ctor = function (options) {
        var _this = this;
        var o = {};
        // clone options given to the constructor
        if (options) {
            extend(o, options);
        }
        // complete with the defaultOptions
        if (defaultOptions) {
            extend(o, defaultOptions);
        }
        // call the constructor function of all the mixins
        mixins.forEach(function (mixin) {
            mixin.call(_this, o);
        });
    };
    // add all mixins properties and methods to the constructor prototype for all
    // created objects to have them
    mixins.forEach(function (mixin) {
        extend(ctor.prototype, mixin.prototype);
    });
    return ctor;
}
exports.default = classComposer;


/***/ }),
/* 47 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var RuntimeEvents_1 = __webpack_require__(27);
exports.default = new RuntimeEvents_1.default();


/***/ }),
/* 48 */
/***/ (function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ }),
/* 49 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(6);
var BufferAsset_1 = __webpack_require__(20);
var functions_1 = __webpack_require__(5);
var Schemas_1 = __webpack_require__(4);
/**
 * An asset that holds animation data: clips, layers and channels.
 * @class AnimationAsset
 * @constructor
 */
var AnimationAsset = (function (_super) {
    tslib_1.__extends(AnimationAsset, _super);
    function AnimationAsset() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * A mapping of ids to THREE.AnimationClips
         * @private
         * @type {ObjectMap<THREE.AnimationClip>}
         */
        _this.clips = {};
        return _this;
    }
    /**
     * Get the THREE.AnimationClip for the clip with the specified ID.
     * @method getAnimationClip
     * @param {String} id The clip ID.
     * @returns {THREE.AnimationClip} A THREE.AnimationClip.
     */
    AnimationAsset.prototype.getAnimationClip = function (id) {
        return this.clips[id];
    };
    /**
     * Get the channel with the specified ID.
     * @method getChannel
     * @public
     * @param {String} id The channel ID.
     * @returns {Object|undefined} The channel or undefined if the channel does not exist.
     */
    AnimationAsset.prototype.getChannel = function (id) {
        return this.getProperty('channels')[id];
    };
    /**
     * Get the IDs of all the channels.
     * @method getChannelIds
     * @public
     * @returns {Array} An array of channel IDs.
     */
    AnimationAsset.prototype.getChannelIds = function () {
        return Object.keys(this.getProperty('channels'));
    };
    /**
     * Get all channels.
     * @method getChannels
     * @public
     * @returns {Array} An array of channels.
     */
    AnimationAsset.prototype.getChannels = function () {
        return functions_1.values(this.getProperty('channels'));
    };
    /**
     * Get the clip with the specified ID.
     * @method getClip
     * @public
     * @param {String} id The clip ID.
     * @returns {Object} The clip or undefined if the clip does not exist.
     */
    AnimationAsset.prototype.getClip = function (id) {
        return this.getProperty('clips')[id];
    };
    /**
     * Get IDs of all the clips.
     * @method getClipIds
     * @public
     * @returns {Array} An array of clip IDs.
     */
    AnimationAsset.prototype.getClipIds = function () {
        return Object.keys(this.getProperty('clips'));
    };
    /**
     * Get all clips.
     * @method getClips
     * @public
     * @returns {Array} An array of clips.
     */
    AnimationAsset.prototype.getClips = function () {
        return functions_1.values(this.getProperty('clips'));
    };
    /**
     * Get the layer with the specified ID.
     * @method getLayer
     * @public
     * @param {String} id The layer ID.
     * @returns {Object|undefined} The layer or undefined if the layer does not exist.
     */
    AnimationAsset.prototype.getLayer = function (id) {
        return this.getProperty('layers')[id];
    };
    /**
     * Get IDs of all the layers.
     * @method getLayerIds
     * @public
     * @returns {Array} An array of layer IDs.
     */
    AnimationAsset.prototype.getLayerIds = function () {
        return Object.keys(this.getProperty('layers'));
    };
    /**
     * Get all layers.
     * @method getLayers
     * @public
     * @returns {Array} An array of layers.
     */
    AnimationAsset.prototype.getLayers = function () {
        return functions_1.values(this.getProperty('layers'));
    };
    /** @inheritdoc */
    AnimationAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        this.when('loadDependencies', function () {
            if (_this.isDestroyed()) {
                return;
            }
            var dependencies = _this.getDependencies();
            var loadFailed = dependencies.some(function (asset) { return asset.isLoadFailed(); });
            if (!loadFailed) {
                _this.createClips();
            }
            callback();
        }, this);
    };
    /** @inheritdoc */
    AnimationAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.hasOwnProperty('channels')) {
            this.registerBufferDependency();
        }
    };
    /**
     * Register the buffer asset as a dependency.
     * @method registerBufferDependency
     * @private
     * @return {void}
     */
    AnimationAsset.prototype.registerBufferDependency = function () {
        var _this = this;
        var channels = this.getChannels();
        var accessorIds = [];
        channels.forEach(function (channel) {
            accessorIds.push(channel.times);
            accessorIds.push(channel.values);
        });
        accessorIds.forEach(function (accessorId) {
            var tokens = accessorId.split('#');
            if (tokens.length !== 2) {
                throw new Error(_this.engine.getName() +
                    ' - AnimationAsset: Invalid accessorId, ' + accessorId);
            }
            _this.registerDependencyById(tokens[0]);
        });
    };
    /**
     * Create a THREE.AnimationClip for each clip.
     * @method createClips
     * @private
     * @returns {void}
     */
    AnimationAsset.prototype.createClips = function () {
        var _this = this;
        var clipIds = this.getClipIds();
        clipIds.forEach(function (clipId) {
            _this.clips[clipId] = _this.createClip(clipId);
        });
    };
    /**
     * Create a THREE.AnimationClip for a clip.
     * @method createClip
     * @private
     * @param {String} clipId The clip ID.
     * @returns {THREE.AnimationClip} A THREE.AnimationClip.
     */
    AnimationAsset.prototype.createClip = function (clipId) {
        var _this = this;
        var clip = this.getClip(clipId);
        if (!clip) {
            throw new Error("Invalid argument: clip \"" + clipId + "\" not found");
        }
        if (clip.layers.length > 1) {
            Logger_1.default.warn("Clip \"" + clipId + "\" contains multiple layers, but " +
                'AnimationAsset.prototype.createAnimation() only supports a single layer.');
        }
        // Get channels that belong to the first layer.
        var layer = this.getLayer(clip.layers[0]);
        var channels = layer ?
            layer.channels.map(function (channelId) { return _this.getChannel(channelId); }) : [];
        // Create a keyframe track for each channel.
        var tracks = channels.map(function (channel) {
            return _this.createKeyframeTrack(channel, clip.start, clip.stop);
        });
        return new THREE.AnimationClip(clip.name, clip.stop - clip.start, tracks);
    };
    /**
     * Create a THREE.KeyframeTrack for the specified channel.
     * @method createKeyframeTrack
     * @private
     * @param {Object} channel The channel object (@see getChannel()).
     * @param {number} startTime The track's start time (in seconds).
     * @param {number} stopTime The track's stop time (in seconds).
     * @returns {THREE.KeyframeTrack} A THREE.KeyframeTrack.
     */
    AnimationAsset.prototype.createKeyframeTrack = function (channel, startTime, stopTime) {
        var _this = this;
        var timeTokens = channel.times.split('#');
        var timeBufferId = timeTokens[0];
        var timeAccessorName = timeTokens[1];
        var timeBuffer = this.engine.getEntityById(timeBufferId);
        if (!timeBuffer) {
            throw new Error(this.engine.getName() +
                ' - AnimationAsset: BufferAsset not found, ' + timeBufferId);
        }
        var timeAccessor = timeBuffer.getAccessor(timeAccessorName);
        var times = timeBuffer.getArray(timeAccessorName);
        if (!timeAccessor || !times) {
            throw new Error(this.engine.getName() +
                ' - AnimationAsset: Accessor not found, ' + timeAccessorName);
        }
        var valueTokens = channel.values.split('#');
        var valueBufferId = valueTokens[0];
        var valueAccessorName = valueTokens[1];
        var valueBuffer = this.engine.getEntityById(valueBufferId);
        if (!valueBuffer) {
            throw new Error(this.engine.getName() +
                ' - AnimationAsset: BufferAsset not found, ' + valueBufferId);
        }
        var valueAccessor = valueBuffer.getAccessor(valueAccessorName);
        var values = valueBuffer.getArray(valueAccessorName);
        if (!valueAccessor || !values) {
            throw new Error(this.engine.getName() +
                ' - AnimationAsset: Accessor not found, ' + valueAccessorName);
        }
        var runtimeNames = channel.targetObject.map(function (sid) { return _this.engine.getRuntimeName(sid); });
        var target = runtimeNames.join('/') + '.' + channel.targetProperty;
        var trackType = channel.targetProperty === 'quaternion' ?
            THREE.QuaternionKeyframeTrack : THREE.VectorKeyframeTrack;
        // Crop the time and value arrays by [startTime, stopTime] so that only the keyframes in that
        // time range are included in the track.
        var firstTimeNo = -1;
        var index;
        for (index = 0; index < times.length; ++index) {
            if (times[index] >= startTime) {
                firstTimeNo = index;
                break;
            }
        }
        var lastTimeNo = -1;
        for (index = times.length; index-- > 0;) {
            if (times[index] <= stopTime) {
                lastTimeNo = index;
                break;
            }
        }
        var begin = firstTimeNo >= 0 ? firstTimeNo : 0;
        var end = lastTimeNo >= 0 ? lastTimeNo + 1 : times.length;
        var valueSize = BufferAsset_1.default.getTypeSize(valueAccessor.type);
        var croppedTimes = times.subarray(begin, end);
        var croppedValues = values.subarray(begin * valueSize, end * valueSize);
        var shiftedTimes = (startTime === 0)
            ? croppedTimes
            : croppedTimes.slice().map(function (n) { return n - startTime; });
        return new trackType(target, shiftedTimes, croppedValues, null);
    };
    return AnimationAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('AnimationAsset', AnimationAsset);
exports.default = AnimationAsset;


/***/ }),
/* 50 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseAsset_1 = __webpack_require__(6);
var Schemas_1 = __webpack_require__(4);
/**
 * @class AudioAsset
 * @constructor
 */
var AudioAsset = (function (_super) {
    tslib_1.__extends(AudioAsset, _super);
    function AudioAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    AudioAsset.prototype.uninitialize = function () {
        if (this.runtimeData) {
            // TODO: should we be doing more here?
            this.runtimeData.pause();
        }
        _super.prototype.uninitialize.call(this);
    };
    /** @inheritdoc */
    AudioAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (this.runtimeData) {
            if (changes.hasOwnProperty('loop')) {
                this.runtimeData.loop = this.getProperty('loop');
            }
            if (changes.hasOwnProperty('state')) {
                switch (this.getProperty('state')) {
                    case 'pause':
                        this.runtimeData.pause();
                        break;
                    case 'play':
                        this.runtimeData.play();
                        break;
                    default:
                        break;
                }
            }
        }
    };
    return AudioAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('AudioAsset', AudioAsset);
exports.default = AudioAsset;


/***/ }),
/* 51 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseTextureAsset_1 = __webpack_require__(19);
var ImageAsset_1 = __webpack_require__(35);
var BaseImageAsset_1 = __webpack_require__(11);
/**
 * An asset that holds geometry.
 * @class BaseRenderTextureAsset
 * @constructor
 */
var BaseRenderTextureAsset = (function (_super) {
    tslib_1.__extends(BaseRenderTextureAsset, _super);
    function BaseRenderTextureAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.createRuntimeData = function (callback) {
        this.createRTImageData();
        this.trigger('loadProgress', this); // TODO: do we need this?
        callback();
    };
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.getLayout = function () {
        return this.getProperty('layout');
    };
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.getWidth = function () {
        return this.getProperty('width');
    };
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.getHeight = function () {
        return this.getProperty('height');
    };
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.getMipCount = function () {
        return ImageAsset_1.default.prototype.getMipCount.call(this);
    };
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        // If something changed that necessitates the texture being recreated, do so.
        if (changes.hasOwnProperty('format') ||
            changes.hasOwnProperty('type') ||
            changes.hasOwnProperty('width') ||
            changes.hasOwnProperty('height')) {
            if (this.runtimeData.__webglFramebuffer) {
                this.runtimeData.dispose();
                delete this.runtimeData.__webglFramebuffer;
            }
            this.runtimeData.texture.format = BaseImageAsset_1.default.getThreeImageFormat(this.getProperty('format'));
            this.runtimeData.texture.type = BaseImageAsset_1.default.getThreeImageType(this.getDataType());
            this.runtimeData.texture.height = this.getHeight();
            this.runtimeData.texture.width = this.getWidth();
        }
        this.runtimeData.texture.encoding = BaseImageAsset_1.default.getThreeImageEncoding(this.getProperty('encoding'));
    };
    return BaseRenderTextureAsset;
}(BaseTextureAsset_1.default));
exports.default = BaseRenderTextureAsset;


/***/ }),
/* 52 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {
Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseGeometryAsset_1 = __webpack_require__(23);
var BaseEntity_1 = __webpack_require__(9);
var BufferAsset_1 = __webpack_require__(20);
var functions_1 = __webpack_require__(5);
var Schemas_1 = __webpack_require__(4);
/**
 * A concrete subclass of BaseGeometryAsset that holds Draco-compressed geometry.
 */
var DracoGeometryAsset = (function (_super) {
    tslib_1.__extends(DracoGeometryAsset, _super);
    function DracoGeometryAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    DracoGeometryAsset.prototype.getBounds = function (outBounds) {
        var bounds = this.getProperty('bounds');
        var returnBounds = outBounds || new THREE.Box3();
        return returnBounds.set(bounds.min, bounds.max);
    };
    /** @inheritdoc */
    DracoGeometryAsset.prototype.getDataSizeInMemorySelf = function () {
        // TODO: estimate this, if possible
        return 0;
    };
    /** @inheritdoc */
    DracoGeometryAsset.prototype.applyPropertiesUnloaded = function (changes) {
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.accessorId) {
            this.registerBufferDependency();
        }
    };
    /** @inheritdoc */
    DracoGeometryAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        this.when('loadDependencies', function () {
            if (_this.isDestroyed()) {
                return;
            }
            var dependencies = _this.getDependencies();
            var loadFailed = dependencies.some(function (asset) { return asset.isLoadFailed(); });
            if (!loadFailed) {
                try {
                    _this.decode();
                }
                catch (err) {
                    Logger_1.default.error(err.toString());
                    _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
                }
            }
            else {
                _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
            }
            callback();
        });
    };
    /**
     * Create a THREE.BufferAttribute for the specified Draco attribute.
     * @param draco               The Draco module.
     * @param wrapper             The Draco Web IDL wrapper.
     * @param dracoGeometry       The Draco geometry containing the attribute.
     * @param dracoAttribute      The Draco attribute to create a THREE.BufferAttribute for.
     * @returns                   The THREE.BufferAttribute.
     */
    DracoGeometryAsset.prototype.createBufferAttribute = function (draco, wrapper, dracoGeometry, dracoAttribute) {
        var nPoints = dracoGeometry.num_points();
        var nComponents = dracoAttribute.components_count();
        var nValues = nPoints * nComponents;
        var dracoData = new draco.DracoFloat32Array();
        wrapper.GetAttributeFloatForAllPoints(dracoGeometry, dracoAttribute, dracoData);
        var values = new Float32Array(nValues);
        for (var i = 0; i < nValues; ++i) {
            values[i] = dracoData.GetValue(i);
        }
        draco.destroy(dracoData);
        return new THREE.BufferAttribute(values, nComponents);
    };
    /**
     * Create geometries for this asset and register them with BaseGeometryAsset.
     * @param draco       The Draco module.
     * @param wrapper     The Draco Web IDL wrapper.
     * @param dracoMesh   The Draco mesh to create the geometry for.
     */
    DracoGeometryAsset.prototype.createBufferGeometry = function (draco, wrapper, dracoMesh) {
        var _this = this;
        // A map of our attribute names to Three.js attribute names.
        var nameMap = {
            indices: 'index',
            positions: 'position',
            normals: 'normal',
            tangents: 'tangent',
            colors: 'color',
            uvs1: 'uv',
            uvs2: 'uv2',
            skinIndices: 'skinIndex',
            skinWeights: 'skinWeight'
        };
        // Convert Draco attributes to THREE.BufferAttributes.
        var attributes = this.getProperty('attributes');
        var bufferAttributes = {};
        functions_1.forEach(nameMap, function (newName, oldName) {
            if (attributes.hasOwnProperty(oldName)) {
                var dracoAttribute = wrapper.GetAttribute(dracoMesh, attributes[oldName].id);
                bufferAttributes[newName] = _this.createBufferAttribute(draco, wrapper, dracoMesh, dracoAttribute);
            }
        });
        // Extract faces (vertex indices) from the Draco mesh.
        var nFaces = dracoMesh.num_faces();
        var indices = new Uint32Array(nFaces * 3);
        var face = new draco.DracoInt32Array();
        for (var i = 0; i < nFaces; ++i) {
            wrapper.GetFaceFromMesh(dracoMesh, i, face);
            indices[i * 3] = face.GetValue(0);
            indices[i * 3 + 1] = face.GetValue(1);
            indices[i * 3 + 2] = face.GetValue(2);
        }
        draco.destroy(face);
        // Create a THREE.BufferGeometry and assign the indices and attributes.
        var geometry = new THREE.BufferGeometry();
        geometry.setIndex(new THREE.BufferAttribute(indices, 1));
        functions_1.forEach(bufferAttributes, function (attribute, name) {
            if (attribute) {
                geometry.addAttribute(name, attribute);
            }
        });
        // Add groups to the BufferGeometry based on material indices.
        if (attributes.hasOwnProperty('materialIndices')) {
            // Extract material indices from the Draco material attribute.
            var materialAttribute = wrapper.GetAttribute(dracoMesh, attributes.materialIndices.id);
            var dracoData = new draco.DracoFloat32Array();
            wrapper.GetAttributeFloatForAllPoints(dracoMesh, materialAttribute, dracoData);
            // Loop through the mesh faces and create a new group every time we encounter a new material
            // index. This naive approach could result in an excessive number of groups if the vertices
            // are not ordered well by the converter (e.g., if the vertices are not ordered by material
            // assignment).
            var lastMaterialIndex = -1;
            var groupStart = 0;
            for (var iFace = 0; iFace < nFaces; ++iFace) {
                // Get the material index for the face's first vertex. We assume that the material index is
                // the same for each vertex (i.e., materials are assigned per-face, not per-vertex).
                var materialIndex = Math.round(dracoData.GetValue(indices[iFace * 3]));
                if (materialIndex !== lastMaterialIndex) {
                    // Only create a new group when groupCount > 0.
                    var groupCount_1 = iFace * 3 - groupStart;
                    if (groupCount_1 > 0) {
                        geometry.addGroup(groupStart, groupCount_1, lastMaterialIndex);
                        groupStart += groupCount_1;
                    }
                    lastMaterialIndex = materialIndex;
                }
            }
            // Create one final group for any remaining faces.
            var groupCount = nFaces * 3 - groupStart;
            if (groupCount > 0) {
                geometry.addGroup(groupStart, groupCount, lastMaterialIndex);
            }
            draco.destroy(dracoData);
        }
        else {
            // There are no material assignments so create a single group for the entire mesh.
            geometry.addGroup(0, nFaces * 3, -1);
        }
        // Create bounding primitives.
        var bounds = this.getProperty('bounds');
        var boundsMin = new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z);
        var boundsMax = new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z);
        geometry.boundingBox = new THREE.Box3(boundsMin, boundsMax);
        geometry.computeBoundingSphere();
        this.addMissingAttributes(geometry);
        // Register the geometry.
        this.setGeometry(BaseGeometryAsset_1.default.primitiveType.TRIANGLES, geometry);
    };
    /**
     * Decode the Draco byte sequence and initialize geometries.
     */
    DracoGeometryAsset.prototype.decode = function () {
        // Get the global draco module.
        var draco = global.Module;
        if (!draco) {
            throw new Error('Draco module not found');
        }
        // Get the encoded byte array.
        var array = BufferAsset_1.default.getBufferArray(this.engine, this.getProperty('accessorId'));
        // For some reason the first Init() call does not seem to initialize the Draco buffer when the
        // raw buffer is large. Instead, the first call zero-fills the Draco buffer. This seems like an
        // Emscripten bug, but I have not fully investigated. In the meantime, calling Init() a second
        // time seems to fix the problem.
        var dracoBuffer = new draco.DecoderBuffer();
        dracoBuffer.Init(array, array.byteLength);
        dracoBuffer.Init(array, array.byteLength);
        // Determine the encoded geometry type. For now, we only support TRIANGULAR_MESH.
        var wrapper = new draco.WebIDLWrapper();
        var geometryType = wrapper.GetEncodedGeometryType(dracoBuffer);
        if (geometryType === draco.TRIANGULAR_MESH) {
            var mesh = wrapper.DecodeMeshFromBuffer(dracoBuffer);
            this.createBufferGeometry(draco, wrapper, mesh);
            draco.destroy(mesh);
        }
        else {
            Logger_1.default.warn(this.engine.getName() +
                (" - DracoGeometryAsset: Unrecognized geometry type '" + geometryType + "'"));
        }
        // Free Draco resources.
        draco.destroy(wrapper);
        draco.destroy(dracoBuffer);
    };
    /**
     * Register the buffer asset as a dependency.
     */
    DracoGeometryAsset.prototype.registerBufferDependency = function () {
        var accessorId = this.getProperty('accessorId');
        var tokens = accessorId.split('#');
        if (tokens.length !== 2) {
            throw new Error(this.engine.getName() +
                ' - DracoGeometryAsset: Invalid accessorId, ' + accessorId);
        }
        this.registerDependencyById(tokens[0]);
    };
    return DracoGeometryAsset;
}(BaseGeometryAsset_1.default));
Schemas_1.addSchemas('DracoGeometryAsset', DracoGeometryAsset);
exports.default = DracoGeometryAsset;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(75)))

/***/ }),
/* 53 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseGeometryAsset_1 = __webpack_require__(23);
var BaseEntity_1 = __webpack_require__(9);
var BufferAsset_1 = __webpack_require__(20);
var functions_1 = __webpack_require__(5);
var Schemas_1 = __webpack_require__(4);
/**
 * A concrete subclass of BaseGeometryAsset that holds mesh geometry.
 */
var MeshGeometryAsset = (function (_super) {
    tslib_1.__extends(MeshGeometryAsset, _super);
    function MeshGeometryAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    MeshGeometryAsset.prototype.getBounds = function (outBounds) {
        var bounds = this.getProperty('bounds');
        var returnBounds = outBounds || new THREE.Box3();
        return returnBounds.set(bounds.min, bounds.max);
    };
    /** @inheritdoc */
    MeshGeometryAsset.prototype.getDataSizeInMemorySelf = function () {
        var _this = this;
        // Loop through each attribute and total up the size of the data.
        var attributes = this.getProperty('attributes');
        return Object.keys(attributes).map(function (name) {
            var attribute = attributes[name];
            var accessor = BufferAsset_1.default.getBufferAccessor(_this.engine, attribute.accessorId);
            return BufferAsset_1.default.getComponentTypeSize(accessor.componentType) *
                BufferAsset_1.default.getTypeSize(accessor.type) * accessor.count;
        }).reduce(function (total, size) { return size + total; }, 0);
    };
    /** @inheritdoc */
    MeshGeometryAsset.prototype.applyPropertiesUnloaded = function (changes) {
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.attributes || changes.indices) {
            this.registerBufferDependency();
        }
    };
    /** @inheritdoc */
    MeshGeometryAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        this.when('loadDependencies', function () {
            if (_this.isDestroyed()) {
                return;
            }
            var dependencies = _this.getDependencies();
            var loadFailed = dependencies.some(function (asset) { return asset.isLoadFailed(); });
            if (!loadFailed) {
                try {
                    _this.createBufferGeometry();
                }
                catch (err) {
                    Logger_1.default.error(err.toString());
                    _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
                }
            }
            else {
                _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
            }
            callback();
        });
    };
    /**
     * Create a collection of THREE.BufferAttributes for this mesh.
     * @param typeSizes The desired value-size of each attribute.
     * @returns         A collection of THREE.BufferAttributes.
     * @throws Error    (@see createBufferAttribute)
     */
    MeshGeometryAsset.prototype.createAttributes = function (typeSizes) {
        var _this = this;
        var nameMap = {
            indices: 'index',
            positions: 'position',
            normals: 'normal',
            tangents: 'tangent',
            colors: 'color',
            uvs1: 'uv',
            uvs2: 'uv2',
            skinIndices: 'skinIndex',
            skinWeights: 'skinWeight'
        };
        // Add indices to the list of attributes.
        var attributes = Object.assign({
            indices: {
                accessorId: this.getProperty('indices')
            }
        }, this.getProperty('attributes'));
        var bufferAttributes = {};
        functions_1.forEach(nameMap, function (newName, oldName) {
            if (attributes.hasOwnProperty(oldName)) {
                var accessorId = attributes[oldName].accessorId;
                bufferAttributes[newName] = _this.createBufferAttribute(accessorId, typeSizes[newName]);
            }
        });
        return bufferAttributes;
    };
    /**
     * Create a THREE.BufferAttribute for the specified attribute. The underlying typed-array will be
     * resized if necessary. This method will throw an error if the accessorId is invalid because:
     *   * it is not of the form <buffer-id>#<accessor-name>
     *   * the referenced buffer asset does not exist
     *   * the buffer failed to load
     *   * the buffer does not contain the referenced accessor
     * @param accessorId  The ID of the accessor.
     * @param newTypeSize The desired number of components in each value.
     * @returns           A THREE.BufferAttribute.
     * @throws Error
     */
    MeshGeometryAsset.prototype.createBufferAttribute = function (accessorId, newTypeSize) {
        var accessor = BufferAsset_1.default.getBufferAccessor(this.engine, accessorId);
        var array = BufferAsset_1.default.getBufferArray(this.engine, accessorId);
        var oldTypeSize = BufferAsset_1.default.getTypeSize(accessor.type);
        if (newTypeSize === undefined || oldTypeSize === newTypeSize) {
            return new THREE.BufferAttribute(array, oldTypeSize);
        }
        // The attribute size needs to be adjusted.
        var dstArray = new array.constructor(accessor.count * newTypeSize);
        var minSize = Math.min(oldTypeSize, newTypeSize);
        for (var iValue = 0; iValue < accessor.count; iValue += 1) {
            var iComponent = 0;
            for (; iComponent < minSize; iComponent += 1) {
                dstArray[iValue * newTypeSize + iComponent] = array[iValue * oldTypeSize + iComponent];
            }
            while (iComponent < newTypeSize) {
                dstArray[iValue * newTypeSize + iComponent] = 0;
                iComponent += 1;
            }
        }
        return new THREE.BufferAttribute(dstArray, newTypeSize);
    };
    /**
     * Create THREE.BufferGeometry objects for this mesh.
     * @throws Error (@see createAttributes)
     */
    MeshGeometryAsset.prototype.createBufferGeometry = function () {
        var _this = this;
        // Create vertex attributes.
        var attributes = this.createAttributes({
            index: 1,
            position: 3,
            normal: 3,
            tangent: 4,
            color: 4,
            uv: 2,
            uv2: 2,
            skinIndex: 4,
            skinWeight: 4
        });
        var bounds = this.getProperty('bounds');
        var boundsMin = new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z);
        var boundsMax = new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z);
        var primitivesByType = this.getProperty('primitives')
            .reduce(function (grouped, primitive) {
            grouped[primitive.primitive] = grouped[primitive.primitive] || [];
            grouped[primitive.primitive].push(primitive);
            return grouped;
        }, {});
        functions_1.forEach(primitivesByType, function (primitives, type) {
            var geometry = new THREE.BufferGeometry();
            // Add groups to the BufferGeometry.
            primitives.forEach(function (primitive) {
                geometry.addGroup(primitive.start, primitive.count, primitive.materialIndex);
            });
            // Add attributes to the BufferGeometry.
            functions_1.forEach(attributes, function (attribute, name) {
                if (name === 'index') {
                    geometry.setIndex(attribute);
                }
                else {
                    geometry.addAttribute(name, attribute);
                }
            });
            // Add missing attributes.
            _this.addMissingAttributes(geometry);
            // Calculate the geometry bounds.
            geometry.boundingBox = new THREE.Box3(boundsMin, boundsMax);
            geometry.computeBoundingSphere();
            // Register the geometry.
            _this.setGeometry(type, geometry);
        });
    };
    /**
     * Register the buffer asset as a dependency.
     */
    MeshGeometryAsset.prototype.registerBufferDependency = function () {
        var _this = this;
        var attributes = this.getProperty('attributes');
        var indices = this.getProperty('indices');
        var accessorIds = [indices];
        Object.keys(attributes).forEach(function (name) {
            accessorIds.push(attributes[name].accessorId);
        });
        var bufferIds = {};
        accessorIds.forEach(function (accessorId) {
            var tokens = accessorId.split('#');
            if (tokens.length !== 2) {
                throw new Error(_this.engine.getName() +
                    ' - MeshGeometryAsset: Invalid accessorId, ' + accessorId);
            }
            bufferIds[tokens[0]] = true;
        });
        Object.keys(bufferIds).forEach(function (bufferId) {
            _this.registerDependencyById(bufferId);
        });
    };
    return MeshGeometryAsset;
}(BaseGeometryAsset_1.default));
Schemas_1.addSchemas('MeshGeometryAsset', MeshGeometryAsset);
exports.default = MeshGeometryAsset;


/***/ }),
/* 54 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseAsset_1 = __webpack_require__(6);
var uuid_1 = __webpack_require__(18);
var functions_1 = __webpack_require__(5);
var Schemas_1 = __webpack_require__(4);
/**
 * @class PrefabAsset
 * @constructor
 */
var PrefabAsset = (function (_super) {
    tslib_1.__extends(PrefabAsset, _super);
    function PrefabAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    PrefabAsset.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.engine.on('prefabDeleted', this.onPrefabDeleted, this);
        this.on('load', this.onPrefabLoaded, this);
    };
    /** @inheritdoc */
    PrefabAsset.prototype.uninitialize = function () {
        var _this = this;
        this.engine.off('prefabDeleted', this.onPrefabDeleted, this);
        this.off('load', this.onPrefabLoaded, this);
        var root = this.getRootObject();
        if (root) {
            // We call unregister here because we don't know the context of why uninitialize
            // is being called. It could be that the prefab is being destroyed or it could be
            // that the engine is shutting down. Either way, we want to remove the child objects from
            // this runtime only.
            root.getDescendants().forEach(function (obj) { return _this.engine.unregisterEntity(obj); });
        }
        _super.prototype.uninitialize.call(this);
    };
    /**
     * Returns the BaseObject that is the root of this asset's object hierarchy, if any.
     * @returns The BaseObject root, if it exists, or null otherwise
     */
    PrefabAsset.prototype.getRootObject = function () {
        return this.engine.getObjectById(this.getProperty('rootObjectId'));
    };
    /**
     * Set the BaseObject that will be the root of this asset's object hierarchy.
     * @param rootObjectId The ID of the BaseObject to set as the root.
     */
    PrefabAsset.prototype.setRootObjectById = function (rootObjectId) {
        return this.setProperty('rootObjectId', rootObjectId);
    };
    /**
     * Set the BaseObject that will be the root of this asset's object hierarchy.
     * @param rootObject The BaseObject to set as the root.
     */
    PrefabAsset.prototype.setRootObject = function (rootObject) {
        return this.setProperty('rootObjectId', rootObject.id);
    };
    /** @inheritdoc */
    PrefabAsset.prototype.unload = function () {
        var root = this.getRootObject();
        if (root) {
            root.unload(true);
        }
        _super.prototype.unload.call(this);
    };
    /**
     * Create and return an instance of this prefab's object hierarchy.
     * @param [id]  An ID for the new instance. If the one specified is not unique or
     *              not given, a new one will be generated.
     * @returns     The new instance object
     */
    PrefabAsset.prototype.createInstance = function (id) {
        var _this = this;
        var rootObject = this.getRootObject();
        if (!rootObject) {
            throw new Error('No object hierarchy inside of this prefab so can\'t create an instance');
        }
        var newTopObjectId = id || uuid_1.v4();
        var topInstanceDesc = {
            id: newTopObjectId,
            sid: rootObject.get('sid'),
            prefabObjectId: rootObject.id,
            prefabAssetId: this.id,
            prefabInstanceId: newTopObjectId,
            type: rootObject.type,
            components: rootObject.getComponentDescriptors()
        };
        // Create the top-level instance object
        var topInst = this.engine.createEntity(topInstanceDesc);
        var instanceMap = {};
        instanceMap[rootObject.id] = topInst;
        // Create child instance objects
        var prefabObjects = rootObject.getDescendants();
        prefabObjects.forEach(function (prefabObject) {
            var instanceDesc = {
                sid: prefabObject.get('sid'),
                prefabObjectId: prefabObject.id,
                prefabAssetId: _this.id,
                prefabInstanceId: newTopObjectId,
                type: prefabObject.type,
                properties: {},
                components: prefabObject.getComponentDescriptors()
            };
            var inst = _this.engine.createEntity(instanceDesc);
            instanceMap[prefabObject.id] = inst;
        });
        // For each object, set 'parentId' and 'children' on the instance using
        // the mapping created above.
        prefabObjects.forEach(function (prefabObject) {
            var instChildren = [];
            var childIds = prefabObject.getChildIds();
            var instance = instanceMap[prefabObject.id];
            functions_1.forEach(childIds, function (childId) {
                if (instanceMap[childId]) {
                    instChildren.push(instanceMap[childId].id);
                    instanceMap[childId].set('parentId', instance.id);
                }
            });
            instance.setChildIds(instChildren);
            // Re-link component entity refs.
            _this.relinkComponentRefs(instance, instanceMap);
        });
        this.relinkComponentRefs(topInst, instanceMap);
        // Add top-level instance children
        var instChildren = [];
        var childIds = rootObject.getChildIds();
        functions_1.forEach(childIds, function (childId) {
            if (instanceMap[childId]) {
                instChildren.push(instanceMap[childId].id);
                instanceMap[childId].set('parentId', topInst.id);
            }
        });
        topInst.setChildIds(instChildren);
        return topInst;
    };
    /** @inheritdoc */
    PrefabAsset.prototype.clone = function (id) {
        var clonedAsset = _super.prototype.clone.call(this, id);
        var rootObject = this.getRootObject();
        if (rootObject) {
            clonedAsset.setRootObject(rootObject.clone());
        }
        return clonedAsset;
    };
    /** @inheritdoc */
    PrefabAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.hasOwnProperty('rootObjectId')) {
            var prevRoot = this.getPreviousProperty('rootObjectId');
            if (prevRoot) {
                this.unregisterDependencyById(prevRoot);
            }
            var rootObj = this.getProperty('rootObjectId');
            if (rootObj) {
                this.registerDependencyById(rootObj);
            }
        }
    };
    /**
     * Look at the given instance object and check to see if its components contain any
     * references to objects within the prefab's hierarchy. If so, remap these references
     * to the appropriate object in its own hierarchy.
     * @param instance    The object to modify.
     * @param instanceMap A map from prefab object ID's to instance objects.
     */
    PrefabAsset.prototype.relinkComponentRefs = function (instance, instanceMap) {
        var _this = this;
        instance.getComponents().forEach(function (comp) {
            var attrDefs = comp.getScriptAsset().getAttributes();
            functions_1.forEach(comp.getAttributes(), function (attr, name) {
                comp.setAttribute(name, _this.relinkAttributeRefs(attrDefs[name], attr, instanceMap));
            });
        });
    };
    /**
     * Look at a particular component attribute and, if it contains references to an object within
     * a prefab's hierarchy, remap it so that it references the appropriate object in its own hierarchy.
     * @param
     * @param instanceMap A map from prefab object ID's to instance objects.
     */
    PrefabAsset.prototype.relinkAttributeRefs = function (attrDef, attributeValue, instanceMap) {
        var _this = this;
        var newAttributeValue;
        // Relink if the attribute is either an array of objects...
        if (attrDef.type === 'a') {
            newAttributeValue = [];
            attributeValue.forEach(function (value) {
                newAttributeValue.push(_this.relinkAttributeRefs(attrDef.subType, value, instanceMap));
            });
            // ...or just a simple object reference.
        }
        else if (attrDef.type === 'object') {
            var objId = attributeValue;
            if (objId && instanceMap[objId]) {
                newAttributeValue = instanceMap[objId].id;
            }
            else {
                newAttributeValue = objId;
            }
        }
        else if (attrDef.type === 'custom') {
            newAttributeValue = {};
            functions_1.forEach(attrDef.attributes, function (customAttr, attrName) {
                newAttributeValue[attrName] = _this.relinkAttributeRefs(customAttr, attributeValue[attrName], instanceMap);
            });
        }
        else {
            newAttributeValue = attributeValue;
        }
        return newAttributeValue;
    };
    /**
     * Called when a PrefabAsset has been deleted. This goes through this asset and deletes any
     * instances of that prefab within this asset.
     * @param prefabId The ID of the prefab asset that was deleted
     */
    PrefabAsset.prototype.onPrefabDeleted = function (prefabId) {
        if (!this.runtimeData) {
            return;
        }
        var rootObj = this.getRootObject();
        if (!rootObj) {
            return;
        }
        rootObj.traverse(function (obj) {
            if (obj.get('prefabObjectId') === prefabId) {
                obj.breakPrefabLink();
            }
        });
    };
    /**
     * When this prefab loads, this function handles ensuring that the renderer re-renders
     * the final scene.
     */
    PrefabAsset.prototype.onPrefabLoaded = function () {
        this.engine.needsRender = true;
    };
    return PrefabAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('PrefabAsset', PrefabAsset);
exports.default = PrefabAsset;


/***/ }),
/* 55 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseGeometryAsset_1 = __webpack_require__(23);
var Schemas_1 = __webpack_require__(4);
/**
 * A concreate subclass of BaseGeometryAsset that holds primitive geometry.
 * @class PrimitiveGeometryAsset
 */
var PrimitiveGeometryAsset = (function (_super) {
    tslib_1.__extends(PrimitiveGeometryAsset, _super);
    function PrimitiveGeometryAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    PrimitiveGeometryAsset.prototype.getDataSizeInMemorySelf = function () {
        // TODO: Primitive geometry should report in-memory size even before data is loaded.
        return 0;
    };
    /** @inheritdoc */
    PrimitiveGeometryAsset.prototype.createRuntimeData = function (callback) {
        this.createPrimitiveGeometry();
        this.trigger('geometryChanged', this); // TODO: do we need this?
        callback();
    };
    /** @inheritdoc */
    PrimitiveGeometryAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (reason !== 'init') {
            // Currently, any property changes cause the runtimeData to be re-created.
            this.reloadBase();
            // Keeping the return here in case we add additional property handling below.
            return;
        }
    };
    /**
     * Create and register a THREE.Geometry with the base class.
     * @method createPrimitiveGeometry
     * @private
     * @returns {void}
     */
    PrimitiveGeometryAsset.prototype.createPrimitiveGeometry = function () {
        var type = this.getProperty('type');
        var geometry;
        switch (type) {
            case 'box':
                geometry = new THREE.BoxGeometry(this.getProperty('sizeX'), this.getProperty('sizeY'), this.getProperty('sizeZ'), this.getProperty('segmentsX'), this.getProperty('segmentsY'), this.getProperty('segmentsZ'));
                break;
            case 'cylinder':
                geometry = new THREE.CylinderGeometry(this.getProperty('radiusTop'), this.getProperty('radiusBottom'), this.getProperty('height'), this.getProperty('segmentsV'), this.getProperty('segmentsU'), this.getProperty('open'));
                break;
            case 'plane':
                geometry = new THREE.PlaneGeometry(this.getProperty('sizeX'), this.getProperty('sizeY'), this.getProperty('segmentsX'), this.getProperty('segmentsY'));
                geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
                break;
            case 'sphere':
                geometry = new THREE.SphereGeometry(this.getProperty('radius'), this.getProperty('segmentsU'), this.getProperty('segmentsV'));
                break;
            case 'torus':
                geometry = new THREE.TorusGeometry(this.getProperty('radius'), 2 * this.getProperty('tubeRadius'), this.getProperty('segmentsV'), this.getProperty('segmentsU'), this.getProperty('arcAngle'));
                break;
            default:
                Logger_1.default.error(this.engine.getName() +
                    ' - PrimitiveGeometryAsset: Unrecognized geometry type, "' +
                    type + '"');
                break;
        }
        if (geometry) {
            geometry.groupsNeedUpdate = true;
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            this.setGeometry(BaseGeometryAsset_1.default.primitiveType.TRIANGLES, geometry);
        }
    };
    return PrimitiveGeometryAsset;
}(BaseGeometryAsset_1.default));
Schemas_1.addSchemas('PrimitiveGeometryAsset', PrimitiveGeometryAsset);
exports.default = PrimitiveGeometryAsset;


/***/ }),
/* 56 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseImageAsset_1 = __webpack_require__(11);
var BaseRenderTextureAsset_1 = __webpack_require__(51);
var Schemas_1 = __webpack_require__(4);
/**
 * An asset that holds geometry.
 * @class RenderTexture2DAsset
 * @constructor
 */
var RenderTexture2DAsset = (function (_super) {
    tslib_1.__extends(RenderTexture2DAsset, _super);
    function RenderTexture2DAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    RenderTexture2DAsset.prototype.createRTImageData = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        this.runtimeData = new THREE.WebGLRenderTarget(width, height, {
            wrapS: this.getThreeAddressMode(this.getProperty('uMapping')),
            wrapT: this.getThreeAddressMode(this.getProperty('vMapping')),
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: BaseImageAsset_1.default.getThreeImageFormat(this.getProperty('format')),
            type: BaseImageAsset_1.default.getThreeImageType(this.getDataType()),
            stencilBuffer: this.getProperty('stencilBuffer')
        });
    };
    return RenderTexture2DAsset;
}(BaseRenderTextureAsset_1.default));
Schemas_1.addSchemas('RenderTexture2DAsset', RenderTexture2DAsset);
exports.default = RenderTexture2DAsset;


/***/ }),
/* 57 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseImageAsset_1 = __webpack_require__(11);
var BaseRenderTextureAsset_1 = __webpack_require__(51);
var Schemas_1 = __webpack_require__(4);
/**
 * @class RenderTextureCubeAsset
 * @constructor
 */
var RenderTextureCubeAsset = (function (_super) {
    tslib_1.__extends(RenderTextureCubeAsset, _super);
    function RenderTextureCubeAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    RenderTextureCubeAsset.prototype.createRTImageData = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        this.runtimeData = new THREE.WebGLRenderTargetCube(width, height, {
            wrapS: this.getThreeAddressMode(this.getProperty('uMapping')),
            wrapT: this.getThreeAddressMode(this.getProperty('vMapping')),
            minFilter: this.getThreeFilter(this.getMinFilter()),
            magFilter: this.getThreeFilter(this.getMagFilter()),
            format: BaseImageAsset_1.default.getThreeImageFormat(this.getProperty('format')),
            type: BaseImageAsset_1.default.getThreeImageType(this.getDataType()),
            stencilBuffer: this.getProperty('stencilBuffer')
        });
    };
    /** @inheritdoc */
    RenderTextureCubeAsset.prototype.getDataSizeInMemorySelf = function () {
        var oneFaceSize = _super.prototype.getDataSizeInMemorySelf.call(this);
        return oneFaceSize * 6;
    };
    return RenderTextureCubeAsset;
}(BaseRenderTextureAsset_1.default));
Schemas_1.addSchemas('RenderTextureCubeAsset', RenderTextureCubeAsset);
exports.default = RenderTextureCubeAsset;


/***/ }),
/* 58 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseEntity_1 = __webpack_require__(9);
var BaseAsset_1 = __webpack_require__(6);
var functions_1 = __webpack_require__(5);
var Schemas_1 = __webpack_require__(4);
var ScriptAsset = (function (_super) {
    tslib_1.__extends(ScriptAsset, _super);
    function ScriptAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    ScriptAsset.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        var category = this.getProperty('category');
        if (!category) {
            this.setProperty('category', 'User Defined');
        }
        this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Succeeded);
    };
    /**
     * Return the attribute descriptions for this script.
     * @method getAttributes
     * @public
     * @return {Object} Object containing attribute descriptions, keyed by attribute name.
     */
    ScriptAsset.prototype.getAttributes = function () {
        return this.getProperty('attributes');
    };
    /**
     * Return the default values of all attributes.
     * @method getAttributeDefaults
     * @public
     * @return {Object} Object containing default attribute values, keyed by attribute name.
     */
    ScriptAsset.prototype.getAttributeDefaults = function () {
        var _this = this;
        var scriptAttributes = this.getProperty('attributes');
        return functions_1.map(scriptAttributes, function (_attr, attrName) {
            return _this.getAttributeDefault(attrName);
        });
    };
    /**
     * Return the default value of the specified attribute.
     * @method getAttributeDefault
     * @public
     * @param {string} attribName The name of the attribute.
     * @return {mixed} The default attribute value.
     */
    ScriptAsset.prototype.getAttributeDefault = function (attribName) {
        var scriptAttributes = this.getProperty('attributes');
        if (!scriptAttributes[attribName]) {
            return;
        }
        var attribute = scriptAttributes[attribName];
        if (attribute.hasOwnProperty('default')) {
            return (attribute.default);
        }
        else if (attribute.type === 'custom') {
            return functions_1.map(attribute.attributes, function (attr) { return attr.default; });
        }
        else if (attribute.type === 'a') {
            return attribute.subType.default !== undefined ? [attribute.subType.default] : [];
        }
    };
    return ScriptAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('ScriptAsset', ScriptAsset);
exports.default = ScriptAsset;


/***/ }),
/* 59 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(6);
var Schemas_1 = __webpack_require__(4);
/**
 * An asset that holds skinning data.
 */
var SkinAsset = (function (_super) {
    tslib_1.__extends(SkinAsset, _super);
    function SkinAsset() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The bind-shape matrix, which is the world-space transform of the mesh. */
        _this.bindShapeMatrix = new THREE.Matrix4();
        /** The inverse bind matrices for all joints. */
        _this.inverseBindMatrices = [];
        return _this;
    }
    /** @inheritdoc */
    SkinAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        this.when('loadDependencies', function () {
            if (_this.isDestroyed()) {
                return;
            }
            var dependencies = _this.getDependencies();
            var loadFailed = dependencies.some(function (asset) { return asset.isLoadFailed(); });
            if (!loadFailed) {
                _this.createMatrices();
            }
            callback();
        }, this);
    };
    /**
     * Get the bind-shape matrix, which is the world-space transform of the mesh.
     * @returns The bind-shape matrix.
     */
    SkinAsset.prototype.getBindShapeMatrix = function () {
        return this.bindShapeMatrix;
    };
    /**
     * Get the inverse bind matrices for all joints (@see getInverseBindMatrix).
     * @returns An array of THREE.Matrix4 instances.
     */
    SkinAsset.prototype.getInverseBindMatrices = function () {
        return this.inverseBindMatrices;
    };
    /**
     * Get the inverse bind matrix for the joint with the specified index. The
     * inverse bind matrix is the inverse, world-space transform of the joint at
     * bind-time.
     * @param index The joint index.
     * @returns     The inverse bind matrix.
     */
    SkinAsset.prototype.getInverseBindMatrix = function (index) {
        return this.inverseBindMatrices[index];
    };
    /**
     * Get the number of joints.
     * @returns The number of joints.
     */
    SkinAsset.prototype.getJointCount = function () {
        return this.getJointNames().length;
    };
    /**
     * Get the name of the joint with the specified index.
     * @param index The joint index.
     * @returns     The name of the joint.
     */
    SkinAsset.prototype.getJointName = function (index) {
        return this.getJointNames()[index];
    };
    /**
     * Get all of the joint names.
     * @returns An array of joint names.
     */
    SkinAsset.prototype.getJointNames = function () {
        return this.getProperty('jointNames');
    };
    /** @inheritdoc */
    SkinAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.inverseBindMatrices) {
            var previousAccessorId = this.getPreviousProperty('inverseBindMatrices');
            var accessorId = this.getProperty('inverseBindMatrices');
            if (previousAccessorId && previousAccessorId !== accessorId) {
                var prevTokens = accessorId.split('#');
                if (prevTokens.length === 2) {
                    this.unregisterDependencyById(prevTokens[0]);
                }
            }
            var tokens = accessorId.split('#');
            if (tokens.length !== 2) {
                throw new Error(this.engine.getName() +
                    ' - SkinAsset: Invalid accessorId, ' + accessorId);
            }
            this.registerDependencyById(tokens[0]);
        }
    };
    /**
     * Create a THREE.Matrix4 instance for the bind-shape matrix and each inverse bind matrix.
     */
    SkinAsset.prototype.createMatrices = function () {
        // Initialize the bind-shape matrix.
        this.bindShapeMatrix.fromArray(this.getProperty('bindShapeMatrix'));
        // Get the inverse bind matrix array.
        var accessorId = this.getProperty('inverseBindMatrices');
        var tokens = accessorId.split('#');
        if (tokens.length !== 2) {
            throw new Error(this.engine.getName() +
                ' - SkinAsset: Invalid accessorId, ' + accessorId);
        }
        var bufferId = tokens[0];
        var buffer = this.engine.getAssetById(bufferId);
        if (!buffer) {
            throw new Error(this.engine.getName() +
                ' - SkinAsset: Invalid accessorId, ' + accessorId);
        }
        var accessorName = tokens[1];
        var accessor = buffer.getAccessor(accessorName);
        var array = buffer.getArray(accessorName);
        if (!accessor || !array) {
            throw new Error(this.engine.getName() +
                ' - SkinAsset: Invalid accessorId, ' + accessorId);
        }
        // Create THREE.Matrix4 instances for each inverse bind matrix.
        var nJoints = this.getJointCount();
        this.inverseBindMatrices = [];
        for (var i = 0; i < nJoints; ++i) {
            var subArray = array.subarray(i * 16, (i + 1) * 16);
            var transform = new THREE.Matrix4().fromArray(subArray);
            this.inverseBindMatrices.push(transform);
        }
    };
    return SkinAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('SkinAsset', SkinAsset);
exports.default = SkinAsset;


/***/ }),
/* 60 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var UnpackHDRShader_1 = __webpack_require__(210);
var ShaderPass_1 = __webpack_require__(209);
var BaseTextureAsset_1 = __webpack_require__(19);
var BaseImageAsset_1 = __webpack_require__(11);
var VideoAsset_1 = __webpack_require__(24);
var Schemas_1 = __webpack_require__(4);
/**
 * @class Texture2DAsset
 * @constructor
 */
var Texture2DAsset = (function (_super) {
    tslib_1.__extends(Texture2DAsset, _super);
    function Texture2DAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Unpack this texture into a 16-bit floating point colour texture.
     * @method unpackHdrTextureData
     * @public
     * @param {Object} imageData Descriptor object for the raw image data.
     * @return {void}
     */
    Texture2DAsset.prototype.unpackHdrTextureData = function (imageData) {
        if (this.hdrSource) {
            this.hdrSource.dispose();
        }
        this.hdrSource = this.runtimeData;
        this.runtimeData = new THREE.WebGLRenderTarget(imageData.width, imageData.height, {
            // The filter settings will be overridden later by the usual method
            minFilter: this.getThreeFilter(this.getMinFilter()),
            magFilter: this.getThreeFilter(this.getMagFilter()),
            format: THREE.RGBAFormat,
            type: BaseImageAsset_1.default.getThreeImageType(this.getDataType()),
            depthBuffer: false,
            stencilBuffer: false
        });
        var packingDefines = {};
        switch (this.getHdrPackingType(imageData.channels)) {
            case 'rgbe':
                packingDefines.HDR_RGBE = 0;
                packingDefines.FLIP_Y = 0;
                break;
            default:
                packingDefines.HDR_RGBE = 0;
                packingDefines.FLIP_Y = 0;
                break;
        }
        var renderer = this.engine.getThreeRenderer();
        if (!this.hdrSource) {
            Logger_1.default.warn('Unable to unpack HDR texture because the source data is missing.');
            return;
        }
        this.hdrSource.minFilter = THREE.NearestFilter;
        this.hdrSource.magFilter = THREE.NearestFilter;
        this.hdrSource.generateMipmaps = false;
        var texture = this.getThreeTexture();
        if (!this.isLinearFilterAvailableForType(this.getDataType())) {
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            texture.generateMipmaps = false;
        }
        if (!this.unpackHdrPass) {
            this.unpackHdrPass = new ShaderPass_1.default(UnpackHDRShader_1.default);
        }
        this.unpackHdrPass.material.defines = packingDefines;
        this.unpackHdrPass.render(renderer, this.runtimeData, this.hdrSource);
    };
    /** @inheritdoc */
    Texture2DAsset.prototype.unload = function () {
        if (this.hdrSource) {
            this.hdrSource.dispose();
            this.hdrSource = undefined;
        }
        _super.prototype.unload.call(this);
    };
    /** @inheritdoc */
    Texture2DAsset.prototype.createTextureData = function (image) {
        // If there was a previous texture loaded, dispose of it.
        if (this.runtimeData) {
            this.runtimeData.dispose();
        }
        // TODO - what about animated GIFs? Can they share logic with videos?
        if (this.getImage() instanceof VideoAsset_1.default) {
            this.runtimeData = new THREE.VideoTexture(image.imageData);
        }
        else {
            // Depending on the data returned, handle as an image tag or a compressed texture
            switch (image.compression) {
                case 'dxt':
                case 'dxt1':
                case 'dxt5':
                    this.runtimeData = this.createDxtTextureData(image.imageData);
                    break;
                default:
                    this.runtimeData = new THREE.Texture(image.imageData);
                    break;
            }
            this.runtimeData.needsUpdate = true;
            // If the image is HDR, unpack it.
            if (this.getHdrPackingType(image.channels)) {
                this.unpackHdrTextureData(image);
            }
        }
        this.runtimeData.encoding = BaseImageAsset_1.default.getThreeImageEncoding(this.getImage().getEncoding());
        this.runtimeData.name = this.getName();
    };
    return Texture2DAsset;
}(BaseTextureAsset_1.default));
Schemas_1.addSchemas('Texture2DAsset', Texture2DAsset);
exports.default = Texture2DAsset;


/***/ }),
/* 61 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseTextureAsset_1 = __webpack_require__(19);
var Schemas_1 = __webpack_require__(4);
/**
 * @class TextureCubeAsset
 * @constructor
 */
var TextureCubeAsset = (function (_super) {
    tslib_1.__extends(TextureCubeAsset, _super);
    function TextureCubeAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    TextureCubeAsset.prototype.createTextureData = function (image) {
        // If there was a previous texture loaded, dispose of it.
        if (this.runtimeData) {
            this.runtimeData.dispose();
        }
        // Depending on the data returned, handle as an image tag or a compressed texture
        switch (image.compression) {
            case 'dxt':
                this.runtimeData = this.createDxtTextureData(image.imageData);
                break;
            default:
                this.runtimeData = new THREE.CubeTexture(image.imageData, THREE.CubeReflectionMapping);
                break;
        }
        if (this.getHdrPackingType(image.channels)) {
            this.createHdrTextureData(image);
        }
        this.runtimeData.name = this.getName();
    };
    /**
     * Unpack this texture into a 16-bit floating point colour texture.
     * @return {[type]} [description]
     */
    TextureCubeAsset.prototype.createHdrTextureData = function (_image) {
        throw new Error('createHdrTextureData isn\'t implemented yet.');
    };
    /** @inheritdoc */
    TextureCubeAsset.prototype.getDataSizeInMemorySelf = function () {
        var oneFaceSize = _super.prototype.getDataSizeInMemorySelf.call(this);
        return oneFaceSize * 6;
    };
    return TextureCubeAsset;
}(BaseTextureAsset_1.default));
Schemas_1.addSchemas('TextureCubeAsset', TextureCubeAsset);
exports.default = TextureCubeAsset;


/***/ }),
/* 62 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseComponent_1 = __webpack_require__(2);
/**
 * Represents a single gamepad connected to the system. Component attributes can be used to
 * configure which gamepad gets assigned.
 * @vid gamepad_device
 * @vname Gamepad Device
 * @vfilter object
 * @vcategory Input
 */
var GamepadDevice = (function (_super) {
    tslib_1.__extends(GamepadDevice, _super);
    function GamepadDevice() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The index of the selected gamepad device in the array provided by navigator.getGamepads(). */
        _this.gamepadIndex = -1;
        return _this;
    }
    /**
     * Return the gamepad that matches the settings on this component.
     * @returns The found gamepad, if any.
     */
    GamepadDevice.prototype.getGamepad = function () {
        if (this.gamepadIndex !== -1 && navigator.getGamepads) {
            return navigator.getGamepads()[this.gamepadIndex];
        }
        return null;
    };
    /**
     * Call the provided callback
     * @param callback Function to call when the first controller is found that
     * can be used by this component.
     */
    GamepadDevice.prototype.whenGamepadFound = function (callback) {
        var gamepad = this.getGamepad();
        if (gamepad) {
            callback(gamepad);
            return;
        }
        this.listenToOnce(this, 'foundGamepad', callback);
    };
    /**
     * Detach this component from the assigned gamepad device. This frees up the
     * device to be used by other components.
     */
    GamepadDevice.prototype.releaseGamepad = function () {
        if (this.gamepadIndex === -1) {
            return;
        }
        GamepadDevice.assignedGamepads[this.gamepadIndex] = null;
        this.gamepadIndex = -1;
    };
    /** @inheritDoc */
    GamepadDevice.prototype.onAwake = function () {
        this.listenTo(this.getEngine(), 'onGamepadConnected', this.findGamepad);
        this.listenTo(this.getEngine(), 'onGamepadDisconnected', this.findGamepad);
        this.findGamepad();
    };
    /** @inheritDoc */
    GamepadDevice.prototype.onShutdown = function () {
        this.releaseGamepad();
    };
    /** @inheritDoc */
    GamepadDevice.prototype.onPreUpdate = function (_delta) {
        if (!this.isEnabled()) {
            return;
        }
        if (this.gamepadIndex === -1) {
            var gamepad = this.findGamepad();
            if (gamepad) {
                GamepadDevice.assignedGamepads[gamepad.id] = this;
                this.trigger('foundGamepad', gamepad);
            }
        }
        if (this.gamepadIndex !== -1) {
            this.updateState(this.getGamepad());
        }
    };
    /**
     * Find an appropriate gamepad in the list of the ones available.
     * @param [predicateFn] If provided, only match gamepads that satisfy this function.
     * @returns             The found gamepad, if any.
     */
    GamepadDevice.prototype.findGamepad = function (predicateFn) {
        if (!navigator.getGamepads) {
            return;
        }
        var gamepads = navigator.getGamepads();
        // navigator.getGamepads() doesn't return an array in Chrome so we need to iterate
        // with a regular for loop. Firefox does.
        /* tslint:disable prefer-for-of */
        for (var i = 0; i < gamepads.length; i++) {
            if (!gamepads[i]) {
                GamepadDevice.assignedGamepads[i] = null;
                continue;
            }
            // If the controller is in use by another component, skip it.
            if (GamepadDevice.assignedGamepads[i] &&
                GamepadDevice.assignedGamepads[i] !== this) {
                continue;
            }
            if (!predicateFn || predicateFn(gamepads[i])) {
                GamepadDevice.assignedGamepads[gamepads[i].index] = this;
                this.gamepadIndex = gamepads[i].index;
                this.trigger('foundGamepad', gamepads[i]);
                // Initialize state tracking for this gamepad.
                this.buttonState = gamepads[i].buttons.map(function () {
                    return {
                        pressed: false,
                        touched: false,
                        value: 0
                    };
                });
                this.axesState = gamepads[i].axes.map(function () { return 0; });
                return gamepads[i];
            }
        }
        /* tslint:enable prefer-for-of */
        // If we made it here, we didn't find a gamepad so we'll wipeout what we currently had.
        this.releaseGamepad();
    };
    /**
     * Update the state of all buttons and axes and fire appropriate events.
     * @param gamepad The native Gamepad object to read state from.
     */
    GamepadDevice.prototype.updateState = function (gamepad) {
        var _this = this;
        if (!gamepad) {
            return;
        }
        // For each axis, check if the value has changed and then fire an event if it has.
        gamepad.axes.forEach(function (axis, idx) {
            if (axis === _this.axesState[idx]) {
                return;
            }
            _this.axesState[idx] = axis;
            _this.trigger('gamepadAxisChanged', gamepad, idx);
            _this.getEntity().trigger('gamepadAxisChanged', gamepad, idx);
        });
        // For each button, check if its value has changed and fire an event if it has.
        gamepad.buttons.forEach(function (but, idx) {
            var button = but; // FIXME: When type defs for Gamepad extensions are released
            if (button.pressed !== _this.buttonState[idx].pressed) {
                _this.buttonState[idx].pressed = button.pressed;
                var eventName = _this.buttonState[idx].pressed ?
                    'gamepadButtonDown' : 'gamepadButtonUp';
                _this.trigger(eventName, gamepad, idx);
                _this.getEntity().trigger(eventName, gamepad, idx);
            }
            if (button.value !== _this.buttonState[idx].value) {
                _this.buttonState[idx].value = button.value;
                _this.trigger('gamepadButtonChanged', gamepad, idx);
                _this.getEntity().trigger('gamepadButtonChanged', gamepad, idx);
            }
            if (button.touched !== _this.buttonState[idx].touched) {
                _this.buttonState[idx].touched = button.touched;
                var eventName = _this.buttonState[idx].touched ? 'gamepadButtonTouched' : 'gamepadButtonReleased';
                _this.trigger(eventName, gamepad, idx);
                _this.getEntity().trigger(eventName, gamepad, idx);
            }
        });
    };
    return GamepadDevice;
}(BaseComponent_1.default));
/** Structure to track which gamepads are already in use by other instances of GamepadDevice */
GamepadDevice.assignedGamepads = [];
exports.default = GamepadDevice;


/***/ }),
/* 63 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var GamepadDevice_1 = __webpack_require__(62);
/** The preferred handedness. i.e. Left, Right, Any, etc. */
var Handedness;
(function (Handedness) {
    Handedness[Handedness["LeftOrRight"] = 0] = "LeftOrRight";
    Handedness[Handedness["Left"] = 1] = "Left";
    Handedness[Handedness["Right"] = 2] = "Right";
    Handedness[Handedness["Any"] = 3] = "Any";
    Handedness[Handedness["None"] = 4] = "None";
})(Handedness = exports.Handedness || (exports.Handedness = {}));
/**
 * Represents a gamepad device with either 3DOF or 6DOF motion.
 * @vid motion_gamepad_device
 * @vname Motion Gamepad Device
 * @vfilter object
 * @vcategory Input
 */
var MotionGamepadDevice = (function (_super) {
    tslib_1.__extends(MotionGamepadDevice, _super);
    function MotionGamepadDevice() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * The preference for the handedness of this controller.
         * @vattr integer handPreference { 'default': 0 }
         */
        _this.handPreference = Handedness.LeftOrRight;
        /** Internal value for to store standing matrix from device */
        _this.standingMatrix = new THREE.Matrix4();
        /**
         * The scale of the scene FIXME: this should be set via some global scale value so that all
         * VR can abide by it.
         */
        _this.scale = 1.0;
        return _this;
    }
    /** @inheritDoc */
    MotionGamepadDevice.prototype.updateState = function (gamepad) {
        if (!this.isEnabled()) {
            return;
        }
        _super.prototype.updateState.call(this, gamepad);
        var engine = this.getEngine();
        var vrDisplay = engine.getVrDisplay();
        if (!vrDisplay) {
            return;
        }
        if (gamepad && gamepad.pose) {
            var pose = gamepad.pose;
            var object = this.getRuntimeData();
            var entity = this.getEntity();
            if (pose.position) {
                entity.setPosition(pose.position[0], pose.position[1], pose.position[2]);
            }
            if (pose.orientation) {
                entity.setQuaternion(pose.orientation[0], pose.orientation[1], pose.orientation[2], pose.orientation[3]);
            }
            object.updateMatrix();
            if (vrDisplay.stageParameters) {
                this.standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
                object.applyMatrix(this.standingMatrix);
            }
            entity.setQuaternion(object.quaternion.x, object.quaternion.y, object.quaternion.z, object.quaternion.w);
            object.position.multiplyScalar(this.scale);
            entity.setPosition(object.position.x, object.position.y, object.position.z);
            engine.needsRender = true;
        }
    };
    /** @inheritdoc */
    MotionGamepadDevice.prototype.findGamepad = function () {
        var _this = this;
        return _super.prototype.findGamepad.call(this, function (gamepad) {
            // FIXME - Currently, Chromium doesn't report matching displayId's for headsets and
            // controllers so we can't actually do this test yet.
            // if (gamepad.displayId !== displayId) {
            //   continue;
            // }
            var motionGamepad = gamepad;
            switch (_this.handPreference) {
                case Handedness.Left:
                    if (motionGamepad.hand === 'left') {
                        return gamepad;
                    }
                    break;
                case Handedness.Right:
                    if (motionGamepad.hand === 'right') {
                        return gamepad;
                    }
                    break;
                case Handedness.LeftOrRight:
                    if (motionGamepad.hand === 'left' || motionGamepad.hand === 'right') {
                        return gamepad;
                    }
                    break;
                case Handedness.None:
                    if (motionGamepad.hand === '') {
                        return gamepad;
                    }
                    break;
                default:
                    return gamepad;
            }
        });
    };
    return MotionGamepadDevice;
}(GamepadDevice_1.default));
exports.default = MotionGamepadDevice;


/***/ }),
/* 64 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-string-literal */
/* tslint:disable max-file-line-count */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var functions_1 = __webpack_require__(5);
var globalEvents_1 = __webpack_require__(47);
var Logger_1 = __webpack_require__(3);
var MeshObject_1 = __webpack_require__(26);
var SceneObject_1 = __webpack_require__(38);
/** The render modes supported by the RenderModes component */
var RenderMode;
(function (RenderMode) {
    RenderMode[RenderMode["Lit"] = 0] = "Lit";
    RenderMode[RenderMode["Unlit"] = 1] = "Unlit";
    RenderMode[RenderMode["Shape"] = 2] = "Shape";
    RenderMode[RenderMode["Normals"] = 3] = "Normals";
    RenderMode[RenderMode["Untextured"] = 4] = "Untextured";
    RenderMode[RenderMode["UVOverlay"] = 5] = "UVOverlay";
    RenderMode[RenderMode["SkinWeights"] = 6] = "SkinWeights";
})(RenderMode = exports.RenderMode || (exports.RenderMode = {}));
/**
 * A component for controlling the rendering style, allowing you to switch between "lit", "unlit",
 * "untextured", etc., and enable/disable skeleton and wireframe visualization.
 * @vid render_modes
 * @vname Render Modes
 * @vfilter Application
 * @vcategory Rendering
 * @vreserved
 */
var RenderModes = (function (_super) {
    tslib_1.__extends(RenderModes, _super);
    function RenderModes() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** Materials that have been replaced by the material override during rendering */
        _this.prevMaterials = {};
        /** The cache for material overrides */
        _this.materialOverrides = {};
        /** The material to use for wireframe rendering */
        _this.wireframeMaterial = null;
        /** The cache for THREE.SkeletonHelper instances */
        _this.skeletonHelpers = {};
        /** The render mode "definitions" */
        _this.renderModes = {};
        return _this;
    }
    /**
     * Calculates the color value for the specified UV grid cell.
     * @param x    The grid cell x position.
     * @param y    The grid cell y position.
     * @param grid The grid description.
     * @returns The color in the format of rgb(x,x,x).
     */
    RenderModes.calculateUVGridCellColor = function (x, y, grid) {
        var quadrants = [
            { r: 200, g: 200, b: 0 },
            { r: 0, g: 200, b: 200 },
            { r: 0, g: 200, b: 0 },
            { r: 200, g: 0, b: 200 }
        ];
        var center = Math.floor(grid.divisions / 2);
        var quadrant = (Math.floor(x / Math.floor((grid.divisions / 2))) % 2) +
            ((Math.floor(y / Math.floor((grid.divisions / 2))) % 2) * 2);
        var distancePct = 1.0 - Math.sqrt((Math.pow(x - center, 2)) +
            (Math.pow(y - center, 2))) / Math.sqrt(Math.pow(center + center, 2));
        var color = {
            r: Math.floor(quadrants[quadrant].r * distancePct),
            g: Math.floor(quadrants[quadrant].g * distancePct),
            b: Math.floor(quadrants[quadrant].b * distancePct)
        };
        return "rgb(" + color.r + "," + color.g + "," + color.b + ")";
    };
    /**
     * Clone the specified Three.js material.
     * @param material The material to clone.
     * @returns The new material.
     */
    RenderModes.cloneMaterial = function (material) {
        var newMaterial = material.clone();
        // When cloning a material in three.js, it clones the uniforms which clones any uniform values
        // assigned. This includes textures. For some reason, when a texture is cloned, it doesn't get
        // re-uploaded to the GPU and so doesn't work. We should probably look into fixing this in
        // three.js at some point. In this case, we don't want a cloned texture anyway.
        if (material instanceof THREE.ShaderMaterial) {
            var oldShaderMaterial_1 = material;
            var newShaderMaterial = newMaterial;
            functions_1.forEach(newShaderMaterial.uniforms, function (uniform, name) {
                if (uniform.value instanceof THREE.Texture || uniform.value instanceof THREE.WebGLRenderTarget) {
                    // Re-use the existing texture in the new material.
                    uniform.value = oldShaderMaterial_1.uniforms[name].value;
                }
            });
        }
        newMaterial.needsUpdate = true;
        return newMaterial;
    };
    /**
     * Generate a UV grid texture programatically.
     * @param grid The grid description.
     * @returns Returns a canvas containing the UV grid.
     */
    RenderModes.createUVGrid = function (grid) {
        var canvas = document.createElement('canvas');
        canvas.width = grid.size;
        canvas.height = grid.size;
        var context = canvas.getContext('2d');
        context.fillStyle = 'rgb(255,255,255)';
        context.fillRect(0, 0, canvas.width, canvas.height);
        for (var y = 0; y < grid.divisions; y++) {
            for (var x = 0; x < grid.divisions; x++) {
                RenderModes.renderUVGridCell(context, x, y, grid);
            }
        }
        return canvas;
    };
    /**
     * Renders a single UV grid cell to the canvas.
     * @param context The canvas's context.
     * @param x       The grid cell x position.
     * @param y       The grid cell y position.
     * @param grid    The grid description.
     */
    RenderModes.renderUVGridCell = function (context, x, y, grid) {
        var xPos = (grid.size / grid.divisions) * x;
        var yPos = (grid.size / grid.divisions) * y;
        var width = (grid.size / grid.divisions);
        var height = (grid.size / grid.divisions);
        // Draw the background for this grid cell.
        context.fillStyle = RenderModes.calculateUVGridCellColor(x, y, grid);
        context.fillRect(xPos + grid.padding, yPos + grid.padding, width - (grid.padding * 2), height - (grid.padding * 2));
        // Render the sub grid on the grid cell.
        context.strokeStyle = 'rgba(0,0,0,0.2)';
        context.beginPath();
        context.moveTo(xPos + grid.padding, yPos + height / 2);
        context.lineTo(xPos + width - grid.padding, yPos + height / 2);
        context.moveTo(xPos + width / 2, yPos + grid.padding);
        context.lineTo(xPos + width / 2, yPos + height - grid.padding);
        context.stroke();
        // Draw the grid position on alternating grid cells.
        if ((x + y) % 2 === 0) {
            var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
            context.fillStyle = 'white';
            context.strokeStyle = 'white';
            context.font = Math.floor(grid.size / (5 * grid.divisions)) + 'px sans-serif';
            context.fillText(characters[y] + x, xPos + (height / 10), yPos + height - (height / 10));
        }
    };
    /**
     * Reset the skeleton visualization, for example, if the scene changes.
     */
    RenderModes.prototype.resetSkeletons = function () {
        var _this = this;
        // Clear the cache.
        this.skeletonHelpers = {};
        if (this.skeletonsVisible) {
            // Create a THREE.SkeletonHelper for each scene.
            var scenes = this.getEngine().getObjectsByClass(SceneObject_1.default);
            scenes.forEach(function (scene) {
                var runtimeData = scene.getRuntimeData();
                _this.skeletonHelpers[runtimeData.uuid] = runtimeData ?
                    new THREE.SkeletonHelper(runtimeData) : undefined;
            });
        }
        this.getEngine().needsRender = true;
    };
    /**
     * Set the render mode.
     * @param renderMode One of RenderMode.Lit, RenderMode.Unlit, etc.
     */
    RenderModes.prototype.setRenderMode = function (renderMode) {
        this.setAttribute('renderMode', renderMode);
    };
    /**
     * Set the visibility of skeletons.
     * @param visible Indicates whether or not skeletons are visible.
     */
    RenderModes.prototype.setSkeletonsVisible = function (visible) {
        this.setAttribute('skeletonsVisible', visible);
    };
    /**
     * Set the visibility of wireframes.
     * @param visible Indicates whether or not wireframes are visible.
     */
    RenderModes.prototype.setWireframesVisible = function (visible) {
        this.setAttribute('wireframesVisible', visible);
    };
    /** @inheritdoc */
    RenderModes.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('shapeTexture') !== -1) {
            this.onShapeTextureChanged();
        }
        if (changes.indexOf('renderMode') !== -1) {
            this.onRenderModeChanged();
        }
        if (changes.indexOf('skeletonsVisible') !== -1) {
            this.resetSkeletons();
        }
        if (changes.indexOf('wireframesVisible') !== -1) {
            this.getEngine().needsRender = true;
        }
    };
    /** @inheritdoc */
    RenderModes.prototype.onPostRender = function () {
        this.unapplyRenderMode();
    };
    /** @inheritdoc */
    RenderModes.prototype.onPostRenderView = function (scene, camera) {
        if (this.wireframesVisible) {
            this.renderWireframes(scene, camera);
        }
        if (this.skeletonsVisible) {
            this.renderSkeletons(scene, camera);
        }
    };
    /** @inheritdoc */
    RenderModes.prototype.onPreRender = function (_delta) {
        this.applyRenderMode();
    };
    /** @inheritdoc */
    RenderModes.prototype.onShutdown = function () {
        globalEvents_1.default.off('resetSkeletons', this.resetSkeletons, this);
        globalEvents_1.default.off('setRenderMode', this.setRenderMode, this);
        globalEvents_1.default.off('setSkeletonsVisible', this.setSkeletonsVisible, this);
        globalEvents_1.default.off('setWireframesVisible', this.setWireframesVisible, this);
        this.clearMaterialCache();
        functions_1.forEach(this.renderModes, function (mode) {
            if (mode.materialOverrides) {
                functions_1.forEach(mode.materialOverrides, function (material) {
                    material.dispose();
                });
            }
        });
        this.wireframeMaterial.dispose();
    };
    /** @inheritdoc */
    RenderModes.prototype.onStartup = function () {
        this.renderModes[RenderMode.Lit] = { materialOverrides: null };
        this.renderModes[RenderMode.Unlit] = {
            materialOverrides: {
                static: new THREE.ShaderMaterial(RenderModes.unlitMaterial)
            },
            copyUniforms: ['diffuse', 'opacity', 'map', 'alphaMap', 'emissive', 'emissiveMap']
        };
        this.renderModes[RenderMode.Shape] = {
            materialOverrides: {
                static: new THREE.ShaderMaterial(RenderModes.shapeMaterial)
            },
            copyUniforms: ['bumpMap', 'normalMap']
        };
        this.renderModes[RenderMode.Normals] = {
            materialOverrides: {
                static: new THREE.ShaderMaterial(RenderModes.normalsMaterial)
            },
            copyUniforms: ['bumpMap', 'normalMap']
        };
        this.renderModes[RenderMode.Untextured] = {
            materialOverrides: {
                static: new THREE.MeshLambertMaterial({
                    emissive: '#e6d9cc',
                    side: THREE.DoubleSide
                })
            }
        };
        // Create a UV grid texture.
        var uvTexture = new THREE.Texture(RenderModes.createUVGrid({
            size: 1024,
            divisions: 10,
            padding: 2
        }));
        uvTexture.anisotropy = 8;
        uvTexture.needsUpdate = true;
        this.renderModes[RenderMode.UVOverlay] = {
            materialOverrides: {
                static: new THREE.MeshBasicMaterial({
                    map: uvTexture,
                    side: THREE.DoubleSide
                })
            }
        };
        this.renderModes[RenderMode.SkinWeights] = {
            materialOverrides: {
                static: new THREE.ShaderMaterial(RenderModes.skinWeightsMaterial)
            }
        };
        // Create "skinned" versions of each material override.
        functions_1.forEach(this.renderModes, function (mode) {
            if (mode.materialOverrides) {
                var staticMaterial = mode.materialOverrides.static;
                mode.materialOverrides.skinned = staticMaterial.clone();
                mode.materialOverrides.skinned.skinning = true;
            }
        });
        // Create a wireframe material.
        this.wireframeMaterial = new THREE.MeshBasicMaterial({
            color: '#050505',
            wireframe: true
        });
        this.getGlobalEvents().on('resetSkeletons', this.resetSkeletons, this);
        this.getGlobalEvents().on('setRenderMode', this.setRenderMode, this);
        this.getGlobalEvents().on('setSkeletonsVisible', this.setSkeletonsVisible, this);
        this.getGlobalEvents().on('setWireframesVisible', this.setWireframesVisible, this);
    };
    /**
     * Apply the current render mode.
     */
    RenderModes.prototype.applyRenderMode = function () {
        var _this = this;
        var renderMode = this.renderModes[this.renderMode];
        if (renderMode.materialOverrides) {
            var meshes = this.getEngine().getObjectsByClass(MeshObject_1.default);
            meshes.forEach(function (mesh) {
                _this.applyRenderModeToMesh(mesh, renderMode);
            });
        }
    };
    /**
     * Apply the specified RenderMode to the mesh.
     * @param mesh       The mesh to apply the material override to.
     * @param renderMode The render mode to apply to the mesh.
     */
    RenderModes.prototype.applyRenderModeToMesh = function (mesh, renderMode) {
        var _this = this;
        if (!mesh.isBaseLoaded() || !renderMode.materialOverrides) {
            return;
        }
        var matType = mesh.isSkinned() ? 'skinned' : 'static';
        var materials = mesh.runtimeData.material.materials;
        // By default, reference the material override in each material "slot."
        var newMaterials = materials.map(function () { return renderMode.materialOverrides[matType]; });
        // Copy the specified uniforms from the original material to the override.
        if (renderMode.copyUniforms) {
            var materialAssets = mesh.getMaterials();
            materialAssets.forEach(function (materialAsset, idx) {
                if (materialAsset.isLoaded()) {
                    // Get the cached material override (or create a new one and cache it).
                    newMaterials[idx] = _this.getMaterialOverride(materialAsset, renderMode, matType);
                }
            });
        }
        this.prevMaterials[mesh.id] = materials;
        mesh.runtimeData.material.materials = newMaterials;
    };
    /**
     * Dispose of all materials in the material cache.
     */
    RenderModes.prototype.clearMaterialCache = function () {
        functions_1.forEach(this.materialOverrides, function (materials) {
            functions_1.forEach(materials, function (material) {
                material.dispose();
            });
        });
        this.materialOverrides = {};
    };
    /**
     * Returns the material override for the specified material asset, creating a new override when
     * one does not already exist.
     * @param materialAsset The material asset to get an override for.
     * @param renderMode    The render mode to get the material override from.
     * @param matType       The material type (e.g., "skinned", "static", etc.).
     */
    RenderModes.prototype.getMaterialOverride = function (materialAsset, renderMode, matType) {
        var _this = this;
        // Check to see if the material override is cached.
        if (!this.materialOverrides.hasOwnProperty(materialAsset.id)) {
            this.materialOverrides[materialAsset.id] = {};
        }
        if (!this.materialOverrides[materialAsset.id].hasOwnProperty(matType)) {
            // Create a copy of the override material.
            var materialOverride = renderMode.materialOverrides[matType];
            var newMaterial = RenderModes.cloneMaterial(materialOverride);
            // Copy certain uniforms from the original material to the override.
            if (renderMode.copyUniforms) {
                var oldShaderMaterial_2 = materialAsset.runtimeData[matType];
                var newShaderMaterial_1 = newMaterial;
                renderMode.copyUniforms.forEach(function (uniformName) {
                    if (newShaderMaterial_1.uniforms[uniformName]) {
                        newShaderMaterial_1[uniformName] = oldShaderMaterial_2.uniforms[uniformName].value;
                        newShaderMaterial_1.uniforms[uniformName].value = oldShaderMaterial_2.uniforms[uniformName].value;
                    }
                });
            }
            // Cache the material override.
            this.materialOverrides[materialAsset.id][matType] = newMaterial;
            // Clear the material override when the underlying material asset changes.
            materialAsset.once('change:properties', function () {
                _this.invalidateMaterialOverride(materialAsset.id);
            });
        }
        return this.materialOverrides[materialAsset.id][matType];
    };
    /**
     * Dispose of and clear the material override for the specified material ID. Call this method when
     * the material override needs to be re-built.
     * @param materialId The ID of the material whose override is to be invalidated.
     */
    RenderModes.prototype.invalidateMaterialOverride = function (materialId) {
        if (!this.materialOverrides.hasOwnProperty(materialId)) {
            return;
        }
        functions_1.forEach(this.materialOverrides[materialId], function (material) {
            material.dispose();
        });
        delete this.materialOverrides[materialId];
    };
    /**
     * Called when the render mode changes.
     */
    RenderModes.prototype.onRenderModeChanged = function () {
        if (!this.renderModes[this.renderMode]) {
            this.renderMode = RenderMode.Lit;
        }
        // Clear the material overrides so that they get re-built.
        this.clearMaterialCache();
        this.getEngine().needsRender = true;
    };
    /**
     * Called when the shape texture changes.
     */
    RenderModes.prototype.onShapeTextureChanged = function () {
        var _this = this;
        if (!this.shapeTexture) {
            return;
        }
        this.shapeTexture.when('load', function (texture) {
            functions_1.forEach(_this.renderModes[RenderMode.Shape].materialOverrides, function (material) {
                if (material instanceof THREE.ShaderMaterial) {
                    material.uniforms['matCapTexture'].value = texture.runtimeData;
                }
            });
        });
        if (this.shapeTexture.isBaseUnloaded()) {
            this.shapeTexture.load();
        }
    };
    /**
     * Render skeletons in the scene.
     * @param scene  The Three.js scene.
     * @param camera The Three.js camera.
     */
    RenderModes.prototype.renderSkeletons = function (scene, camera) {
        if (!this.skeletonHelpers.hasOwnProperty(scene.uuid)) {
            Logger_1.default.warn('Skeleton cache out of date');
            return;
        }
        var skeletonScene = new THREE.Scene();
        this.skeletonHelpers[scene.uuid].update();
        skeletonScene.add(this.skeletonHelpers[scene.uuid]);
        this.getThreeRenderer().render(skeletonScene, camera);
    };
    /**
     * Render wireframes for meshes in the scene.
     * @param scene  The Three.js scene.
     * @param camera The Three.js camera.
     */
    RenderModes.prototype.renderWireframes = function (scene, camera) {
        // First pass: render wireframes of THREE.Mesh instances.
        var oldVisible = {};
        scene.traverse(function (obj) {
            oldVisible[obj.id] = obj.visible;
            if (obj instanceof THREE.SkinnedMesh ||
                obj instanceof THREE.Line ||
                obj instanceof THREE.Points) {
                obj.visible = false;
            }
        });
        var oldOverrideMaterial = scene.overrideMaterial;
        scene.overrideMaterial = this.wireframeMaterial;
        this.wireframeMaterial.skinning = false;
        this.getThreeRenderer().render(scene, camera);
        // Second pass: render wireframes of THREE.SkinnedMesh instances.
        scene.traverse(function (obj) {
            if (obj instanceof THREE.SkinnedMesh) {
                obj.visible = oldVisible[obj.id];
            }
            else if (obj instanceof THREE.Mesh) {
                obj.visible = false;
            }
        });
        this.wireframeMaterial.skinning = true;
        this.getThreeRenderer().render(scene, camera);
        // Restore the visibility of all objects in the scene.
        scene.traverse(function (obj) {
            obj.visible = oldVisible[obj.id];
        });
        scene.overrideMaterial = oldOverrideMaterial;
    };
    /**
     * Restore the mesh's original material assignments that were overriden for rendering.
     * @param mesh The mesh whose material assignments are to be restored.
     */
    RenderModes.prototype.unapplyMaterialOverride = function (mesh) {
        if (this.prevMaterials.hasOwnProperty(mesh.id)) {
            mesh.runtimeData.material.materials = this.prevMaterials[mesh.id];
            delete this.prevMaterials[mesh.id];
        }
    };
    /**
     * Restore runtime data to its original state, reversing the effects of applyRenderMode.
     */
    RenderModes.prototype.unapplyRenderMode = function () {
        var _this = this;
        // Restore the original materials of each mesh.
        var meshes = this.getEngine().getObjectsByClass(MeshObject_1.default);
        meshes.forEach(function (mesh) {
            _this.unapplyMaterialOverride(mesh);
        });
    };
    return RenderModes;
}(BaseComponent_1.default));
/** Material parameters for the "Unlit" render mode */
RenderModes.unlitMaterial = {
    side: THREE.DoubleSide,
    uniforms: THREE.UniformsUtils.merge([
        THREE.UniformsLib.common,
        THREE.UniformsLib.emissivemap,
        { emissive: { value: new THREE.Color(0) } }
    ]),
    vertexShader: [
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.color_pars_vertex,
        THREE.ShaderChunk.uv_pars_vertex,
        THREE.ShaderChunk.skinning_pars_vertex,
        'void main() {',
        THREE.ShaderChunk.uv_vertex,
        '#if defined(USE_MAP) || defined(USE_ALPHAMAP) || defined(USE_EMISSIVEMAP)',
        'vUv.y = 1.0 - vUv.y;',
        '#endif',
        THREE.ShaderChunk.beginnormal_vertex,
        THREE.ShaderChunk.morphnormal_vertex,
        THREE.ShaderChunk.skinbase_vertex,
        THREE.ShaderChunk.skinnormal_vertex,
        THREE.ShaderChunk.defaultnormal_vertex,
        THREE.ShaderChunk.begin_vertex,
        THREE.ShaderChunk.displacementmap_vertex,
        THREE.ShaderChunk.morphtarget_vertex,
        THREE.ShaderChunk.skinning_vertex,
        THREE.ShaderChunk.project_vertex,
        THREE.ShaderChunk.logdepthbuf_vertex,
        THREE.ShaderChunk.clipping_planes_vertex,
        THREE.ShaderChunk.worldpos_vertex,
        '}'
    ].join('\n'),
    fragmentShader: [
        'uniform vec3 diffuse;',
        'uniform vec3 emissive;',
        'uniform float opacity;',
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.color_pars_fragment,
        THREE.ShaderChunk.map_pars_fragment,
        THREE.ShaderChunk.alphamap_pars_fragment,
        THREE.ShaderChunk.emissivemap_pars_fragment,
        THREE.ShaderChunk.uv_pars_fragment,
        'void main() {',
        'vec4 diffuseColor = vec4(diffuse, opacity);',
        'vec3 totalEmissiveRadiance = emissive;',
        THREE.ShaderChunk.map_fragment,
        THREE.ShaderChunk.color_fragment,
        THREE.ShaderChunk.alphamap_fragment,
        THREE.ShaderChunk.alphatest_fragment,
        THREE.ShaderChunk.emissivemap_fragment,
        'gl_FragColor = vec4(diffuseColor.rgb + totalEmissiveRadiance, diffuseColor.a);',
        THREE.ShaderChunk.premultiplied_alpha_fragment,
        THREE.ShaderChunk.tonemapping_fragment,
        THREE.ShaderChunk.encodings_fragment,
        '}'
    ].join('\n')
};
/** Material parameters for the "Normals" render mode */
RenderModes.normalsMaterial = {
    side: THREE.DoubleSide,
    uniforms: THREE.UniformsUtils.merge([
        THREE.UniformsLib.common,
        THREE.UniformsLib.bumpmap,
        THREE.UniformsLib.normalmap
    ]),
    vertexShader: [
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.uv_pars_vertex,
        THREE.ShaderChunk.bsdfs,
        THREE.ShaderChunk.skinning_pars_vertex,
        '#ifndef FLAT_SHADED',
        'varying vec3 vNormal;',
        '#endif',
        'varying vec3 vViewPosition;',
        'void main() {',
        THREE.ShaderChunk.uv_vertex,
        '#if defined(USE_NORMALMAP) || defined(USE_BUMPMAP)',
        'vUv.y = 1.0 - vUv.y;',
        '#endif',
        THREE.ShaderChunk.beginnormal_vertex,
        THREE.ShaderChunk.morphnormal_vertex,
        THREE.ShaderChunk.skinbase_vertex,
        THREE.ShaderChunk.skinnormal_vertex,
        THREE.ShaderChunk.defaultnormal_vertex,
        '#ifndef FLAT_SHADED',
        'vNormal = normalize( transformedNormal );',
        '#endif',
        THREE.ShaderChunk.begin_vertex,
        THREE.ShaderChunk.displacementmap_vertex,
        THREE.ShaderChunk.morphtarget_vertex,
        THREE.ShaderChunk.skinning_vertex,
        THREE.ShaderChunk.project_vertex,
        THREE.ShaderChunk.logdepthbuf_vertex,
        THREE.ShaderChunk.clipping_planes_vertex,
        'vViewPosition = - mvPosition.xyz;',
        THREE.ShaderChunk.worldpos_vertex,
        '}'
    ].join('\n'),
    fragmentShader: [
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.uv_pars_fragment,
        THREE.ShaderChunk.bsdfs,
        THREE.ShaderChunk.lights_phong_pars_fragment,
        THREE.ShaderChunk.normalmap_pars_fragment,
        THREE.ShaderChunk.bumpmap_pars_fragment,
        'void main() {',
        THREE.ShaderChunk.normal_flip,
        THREE.ShaderChunk.normal_fragment,
        'normal = 0.5 * normal + 0.5;',
        'gl_FragColor = vec4(normal, 1.0);',
        '}'
    ].join('\n')
};
/** Material parameters for the "Shape" render mode */
RenderModes.shapeMaterial = {
    side: THREE.DoubleSide,
    uniforms: THREE.UniformsUtils.merge([
        THREE.UniformsLib.common,
        THREE.UniformsLib.bumpmap,
        THREE.UniformsLib.normalmap,
        { matCapTexture: { value: null } }
    ]),
    vertexShader: [
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.uv_pars_vertex,
        THREE.ShaderChunk.bsdfs,
        THREE.ShaderChunk.skinning_pars_vertex,
        '#ifndef FLAT_SHADED',
        'varying vec3 vNormal;',
        '#endif',
        'varying vec3 vViewPosition;',
        'void main() {',
        THREE.ShaderChunk.uv_vertex,
        '#if defined(USE_NORMALMAP) || defined(USE_BUMPMAP)',
        'vUv.y = 1.0 - vUv.y;',
        '#endif',
        THREE.ShaderChunk.beginnormal_vertex,
        THREE.ShaderChunk.morphnormal_vertex,
        THREE.ShaderChunk.skinbase_vertex,
        THREE.ShaderChunk.skinnormal_vertex,
        THREE.ShaderChunk.defaultnormal_vertex,
        '#ifndef FLAT_SHADED',
        'vNormal = normalize(transformedNormal);',
        '#endif',
        THREE.ShaderChunk.begin_vertex,
        THREE.ShaderChunk.displacementmap_vertex,
        THREE.ShaderChunk.morphtarget_vertex,
        THREE.ShaderChunk.skinning_vertex,
        THREE.ShaderChunk.project_vertex,
        THREE.ShaderChunk.logdepthbuf_vertex,
        THREE.ShaderChunk.clipping_planes_vertex,
        'vViewPosition = - mvPosition.xyz;',
        THREE.ShaderChunk.worldpos_vertex,
        '}'
    ].join('\n'),
    fragmentShader: [
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.uv_pars_fragment,
        THREE.ShaderChunk.bsdfs,
        THREE.ShaderChunk.lights_phong_pars_fragment,
        THREE.ShaderChunk.normalmap_pars_fragment,
        THREE.ShaderChunk.bumpmap_pars_fragment,
        'uniform sampler2D matCapTexture;',
        'void main() {',
        'vec3 eyeVector_VS = normalize(vViewPosition);',
        THREE.ShaderChunk.normal_flip,
        THREE.ShaderChunk.normal_fragment,
        'vec3 reflect_SS = reflect(-eyeVector_VS, normal);',
        'reflect_SS.z += 1.0;',
        'float temp = 2.0 * sqrt(dot(reflect_SS, reflect_SS));',
        'reflect_SS.xy = reflect_SS.xy / vec2(temp) + vec2(0.5);',
        'reflect_SS.y = 1.0 - reflect_SS.y;',
        // Sample matCap
        'vec3 colour = texture2D(matCapTexture, reflect_SS.xy).rgb;',
        'gl_FragColor = vec4(colour, 1.0);',
        '}'
    ].join('\n')
};
/** Material parameters for the "SkinWeights" render mode */
RenderModes.skinWeightsMaterial = {
    side: THREE.DoubleSide,
    vertexShader: [
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.skinning_pars_vertex,
        'varying vec3 vColor;',
        'void main() {',
        THREE.ShaderChunk.beginnormal_vertex,
        THREE.ShaderChunk.morphnormal_vertex,
        THREE.ShaderChunk.skinbase_vertex,
        THREE.ShaderChunk.skinnormal_vertex,
        THREE.ShaderChunk.defaultnormal_vertex,
        THREE.ShaderChunk.begin_vertex,
        THREE.ShaderChunk.displacementmap_vertex,
        THREE.ShaderChunk.morphtarget_vertex,
        THREE.ShaderChunk.skinning_vertex,
        THREE.ShaderChunk.project_vertex,
        THREE.ShaderChunk.logdepthbuf_vertex,
        THREE.ShaderChunk.clipping_planes_vertex,
        THREE.ShaderChunk.worldpos_vertex,
        '#ifdef USE_SKINNING',
        'vColor = vec3(skinWeight.x, skinWeight.y, skinWeight.z);',
        '#else',
        'vColor = vec3(0.0, 0.0, 0);',
        '#endif',
        '}'
    ].join('\n'),
    fragmentShader: [
        'varying vec3 vColor;',
        'void main() {',
        'gl_FragColor = vec4(vColor, 1.0);',
        '}'
    ].join('\n')
};
/**
 * @vevent local resetSkeletons {
 *   scope: 'local',
 *   action: true,
 *   category: 'Rendering',
 *   parameters: []
 * }
 * @vevent local setRenderMode {
 *   scope: 'local',
 *   action: true,
 *   category: 'Rendering',
 *   parameters: [{
 *     name: 'renderMode',
 *     type: 'n',
 *     description: 'RenderMode.Lit, RenderMode.Unlit, etc.',
 *     default: 'Lit'
 *   }]
 * }
 * @vevent local setSkeletonsVisible {
 *   scope: 'local',
 *   action: true,
 *   category: 'Rendering',
 *   parameters: [{
 *     name: 'visible',
 *     type: 'b',
 *     description: 'Whether or not skeletons are visible.',
 *     default: false
 *   }]
 * }
 * @vevent local setWireframesVisible {
 *   scope: 'local',
 *   action: true,
 *   category: 'Rendering',
 *   parameters: [{
 *     name: 'visible',
 *     type: 'b',
 *     description: 'Whether or not wireframes are visible.',
 *     default: false
 *   }]
 * }
 */
exports.default = RenderModes;


/***/ }),
/* 65 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid render_view
 * @vname Render View
 * @vfilter camera
 * @vcategory Rendering
 */
var RenderView = (function (_super) {
    tslib_1.__extends(RenderView, _super);
    function RenderView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // tslint:disable max-line-length */
        /**
         * Run pre-render functions with this view. These include things like real-time reflections,
         * which need to be rendered for each view separately.
         * @vattr Boolean enablePreRenderFunctions {
         *   description: 'Run pre-render functions with this view. These include things like real-time reflections, which need to be rendered for each view separately.',
         *   default : true
         * }
         */
        // tslint:enable max-line-length */
        _this.enablePreRenderFunctions = true;
        /**
         * Render shadows for this view.
         * @vattr Boolean enableShadows {
         *   description: 'Render shadows for this view.',
         *   default : true
         * }
         */
        _this.enableShadows = true;
        /**
         * The opacity value to use while rendering.
         * @vattr Boolean opacity {
         *   description: 'The opacity value to use while rendering.',
         *   default : 1.0
         * }
         */
        _this.opacity = 1.0;
        /**
         * The camera's aspect ratio will be controlled by this component's viewport
         * settings only if this is enabled (the default).
         * @vattr Boolean overrideCameraAspect {
         *   description: 'Override the aspect ratio of the camera using viewport settings.',
         *   default : true
         * }
         */
        _this.overrideCameraAspect = true;
        /**
         * The render event name to listen to.
         */
        _this.renderEventName = 'render';
        /** The current, internal structure for the render options */
        _this.currentOptions = {
            viewPort: {
                x: 0,
                y: 0,
                width: 100,
                height: 200
            }
        };
        return _this;
    }
    /** @inheritdoc */
    RenderView.prototype.onStartup = function () {
        this.listenTo(this.getEntity(), 'setViewport', this.setViewport);
        this.listenTo(this.getEntity(), 'enableRenderView', this.enable);
        this.listenTo(this.getEntity(), 'disableRenderView', this.disable);
        this.listenTo(this.getEntity(), 'toggleRenderView', this.toggle);
        this.listenTo(this.getEngine(), 'rendererResize', this.onRendererResize);
    };
    /**
     * Sets the render effect.
     * @param effect The three.js effect to apply
     */
    RenderView.prototype.setEffect = function (effect) {
        this.effect = effect;
    };
    /** @inheritDoc */
    RenderView.prototype.onEnable = function () {
        if (this.renderTarget && this.renderTarget.isUnloaded()) {
            this.renderTarget.load();
        }
    };
    /** @inheritDoc */
    RenderView.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('renderGroup') !== -1) {
            this.stopListening(this.getEngine(), this.renderEventName);
            this.renderEventName = 'render';
            if (this.renderGroup) {
                this.renderEventName += 'Group' + this.renderGroup;
            }
            this.listenTo(this.getEngine(), this.renderEventName, this.renderView);
        }
        if (changes.indexOf('viewportWidth') !== -1 ||
            changes.indexOf('viewportHeight') !== -1 ||
            changes.indexOf('viewportBottom') !== -1 ||
            changes.indexOf('viewportLeft') !== -1) {
            this.updateViewport();
            this.updateCameraAspect();
        }
    };
    /**
     * The default renderView implementation. Can be overridden via setRenderOverride().
     * @param delta The current frame delta.
     */
    RenderView.prototype.renderView = function (delta) {
        if (!this.isEnabled() || !this.hasRuntimeData()) {
            return;
        }
        var scene = this.getRootObject();
        if (!scene.runtimeData) {
            return;
        }
        this.currentOptions.viewPort.x = this.x;
        this.currentOptions.viewPort.y = this.y;
        this.currentOptions.viewPort.width = this.width;
        this.currentOptions.viewPort.height = this.height;
        this.currentOptions.enablePreRenderFunctions = this.enablePreRenderFunctions;
        this.currentOptions.enableShadows = this.enableShadows;
        this.currentOptions.clearColor = this.clearColor;
        this.currentOptions.clearDepth = this.clearDepth;
        this.currentOptions.opacity = this.opacity;
        this.currentOptions.renderTarget = this.renderTarget;
        this.currentOptions.effect = this.effect;
        this.currentOptions.delta = delta;
        // Render the view
        this.getRuntimeData().layers.set(this.renderLayer);
        this.getRenderer().renderView(scene.runtimeData, this.getRuntimeData(), this.currentOptions);
    };
    /**
     * Sets the viewport, handled on event trigger. See @vevent descriptor below.
     * @param x             The x position.
     * @param y             The y position.
     * @param width         The width.
     * @param height        The height.
     */
    RenderView.prototype.setViewport = function (x, y, width, height) {
        this.setAttributes({
            viewportLeft: x,
            viewportBottom: y,
            viewportWidth: width,
            viewportHeight: height
        });
    };
    /** Updates the viewport */
    RenderView.prototype.updateViewport = function () {
        var renderer = this.getEngine().getRenderer();
        if (!renderer) {
            return;
        }
        var cWidth = renderer.getWidth();
        var cHeight = renderer.getHeight();
        var percent;
        if (this.viewportBottom.slice(-1) === '%') {
            percent = parseFloat(this.viewportBottom.slice(0, -1)) * 0.01;
            this.y = percent * cHeight;
        }
        else {
            this.y = parseInt(this.viewportBottom, 10);
        }
        this.y = Math.min(this.y, cHeight);
        if (this.viewportLeft.slice(-1) === '%') {
            percent = parseFloat(this.viewportLeft.slice(0, -1)) * 0.01;
            this.x = percent * cWidth;
        }
        else {
            this.x = parseInt(this.viewportLeft, 10);
        }
        this.x = Math.min(this.x, cWidth);
        if (this.viewportWidth.slice(-1) === '%') {
            percent = parseFloat(this.viewportWidth.slice(0, -1)) * 0.01;
            this.width = percent * cWidth;
        }
        else {
            this.width = parseInt(this.viewportWidth, 10);
        }
        this.width = Math.min(this.width, cWidth - this.x);
        if (this.viewportHeight.slice(-1) === '%') {
            percent = parseFloat(this.viewportHeight.slice(0, -1)) * 0.01;
            this.height = percent * cHeight;
        }
        else {
            this.height = parseInt(this.viewportHeight, 10);
        }
        this.height = Math.min(this.height, cHeight - this.y);
        // Handle negative positioning of viewport (clamping to bottom left).
        if (this.x < 0) {
            this.x = Math.max(this.x + cWidth, 0);
        }
        if (this.y < 0) {
            this.y = Math.max(this.y + cHeight, 0);
        }
    };
    /** Updates the camera projection properties. */
    RenderView.prototype.updateCameraAspect = function () {
        if (!this.overrideCameraAspect || !this.isEnabled()) {
            return;
        }
        var camera = this.getEntity();
        var aspect = this.width / this.height;
        camera.setProperties({
            aspect: aspect,
            left: camera.getProperty('bottom') * aspect,
            right: camera.getProperty('top') * aspect
        });
    };
    /** Handles the resize event. */
    RenderView.prototype.onRendererResize = function () {
        this.updateViewport();
        this.updateCameraAspect();
    };
    return RenderView;
}(BaseComponent_1.default));
/**
 * Event definitions:
 *
 * @vevent local enableRenderView {
 *   'category': 'Rendering'
 * }
 *
 * @vevent local setViewport {
 *   'category': 'Rendering',
 *   'parameters': [
 *     {'name': 'viewportLeft', 'description': 'Left position of the viewport to be rendered by this camera.',
 *        'type': 's', 'default' : '0px' },
 *     {'name': 'viewportBottom', 'description': 'Bottom position of the viewport to be rendered by this camera.',
 *        'type': 's', 'default' : '0px' },
 *     {'name': 'viewportWidth', 'description': 'Width of the viewport to be rendered by this camera.',
 *        'type': 's', 'default' : '100%' },
 *     {'name': 'viewportHeight', 'description': 'Height of the viewport to be rendered by this camera.',
 *        'type': 's', 'default' : '100%' }
 *   ]
 * }
 *
 * @vevent local disableRenderView {
 *   'category': 'Rendering'
 * }
 *
 * @vevent local toggleRenderView {
 *   'category': 'Rendering'
 * }
 */
exports.default = RenderView;


/***/ }),
/* 66 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseObject_1 = __webpack_require__(10);
var Schemas_1 = __webpack_require__(4);
/**
 * @class BoneObject
 * @constructor
 */
var BoneObject = (function (_super) {
    tslib_1.__extends(BoneObject, _super);
    function BoneObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    BoneObject.prototype.createRuntimeData = function (callback) {
        this.runtimeData = new THREE.Bone(null);
        this.runtimeData.name = this.getRuntimeName();
        callback(this);
    };
    return BoneObject;
}(BaseObject_1.default));
Schemas_1.addSchemas('BoneObject', BoneObject);
exports.default = BoneObject;


/***/ }),
/* 67 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseObject_1 = __webpack_require__(10);
var Schemas_1 = __webpack_require__(4);
/**
 * @class CameraObject
 * @constructor
 */
var CameraObject = (function (_super) {
    tslib_1.__extends(CameraObject, _super);
    function CameraObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /**
     * Returns the current aspect ratio used by the camera.
     */
    CameraObject.prototype.getAspectRatio = function () {
        var type = this.getProperty('cameraType');
        if (type === 'perspective') {
            return this.getProperty('aspect');
        }
        var width = this.getProperty('right') - this.getProperty('left');
        var height = this.getProperty('top') - this.getProperty('bottom');
        return width / height;
    };
    /** @inheritdoc */
    CameraObject.prototype.createRuntimeData = function (callback) {
        var type = this.getProperty('cameraType');
        if (type === 'orthographic') {
            this.runtimeData = new THREE.OrthographicCamera(this.getProperty('left') || 0, this.getProperty('right') || 0, this.getProperty('top') || 0, this.getProperty('bottom') || 0);
        }
        else {
            this.runtimeData = new THREE.PerspectiveCamera();
        }
        this.runtimeData.name = this.getRuntimeName();
        callback(this);
    };
    /** @inheritdoc */
    CameraObject.prototype.reset = function () {
        _super.prototype.reset.call(this);
        if (!this.runtimeData) {
            return;
        }
        var type = this.getProperty('cameraType');
        if (type === 'orthographic') {
            this.resetOrthographicRTData();
        }
        else {
            this.resetPerspectiveRTData();
        }
    };
    /** @inheritdoc */
    CameraObject.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        // If the camera type changed, we need to re-create runtimeData.
        if (changes.hasOwnProperty('cameraType') &&
            this.getProperty('cameraType') !== this.getPreviousProperty('cameraType') &&
            reason !== 'init') {
            this.reloadBase();
            return;
        }
        var type = this.getProperty('cameraType');
        if (type === 'perspective') {
            // If any of the camera properties have changed, we'll need to update the
            // projection matrix for the camera.
            if (changes.hasOwnProperty('fov') ||
                changes.hasOwnProperty('aspect') ||
                changes.hasOwnProperty('near') ||
                changes.hasOwnProperty('far')) {
                this.resetPerspectiveRTData();
            }
        }
        else if (type === 'orthographic') {
            // If any of the shadow camera properties have changed, we'll need to update the
            // projection matrix for the camera.
            if (changes.hasOwnProperty('left') ||
                changes.hasOwnProperty('right') ||
                changes.hasOwnProperty('top') ||
                changes.hasOwnProperty('bottom') ||
                changes.hasOwnProperty('near') ||
                changes.hasOwnProperty('far')) {
                this.resetOrthographicRTData();
            }
        }
    };
    /**
     * Resets runtimeData properties for perspective cameras.
     */
    CameraObject.prototype.resetOrthographicRTData = function () {
        this.runtimeData.left = this.getProperty('left');
        this.runtimeData.right = this.getProperty('right');
        this.runtimeData.top = this.getProperty('top');
        this.runtimeData.bottom = this.getProperty('bottom');
        this.runtimeData.near = this.getProperty('near');
        this.runtimeData.far = this.getProperty('far');
        this.runtimeData.updateProjectionMatrix();
    };
    /**
     * Resets runtimeData properties for orthographic cameras.
     */
    CameraObject.prototype.resetPerspectiveRTData = function () {
        this.runtimeData.fov = this.getProperty('fov');
        this.runtimeData.aspect = this.getProperty('aspect');
        this.runtimeData.near = this.getProperty('near');
        this.runtimeData.far = this.getProperty('far');
        this.runtimeData.updateProjectionMatrix();
    };
    return CameraObject;
}(BaseObject_1.default));
Schemas_1.addSchemas('CameraObject', CameraObject);
exports.default = CameraObject;


/***/ }),
/* 68 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseObject_1 = __webpack_require__(10);
var Schemas_1 = __webpack_require__(4);
/**
 * @class NodeObject
 * @constructor
 */
var NodeObject = (function (_super) {
    tslib_1.__extends(NodeObject, _super);
    function NodeObject() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    return NodeObject;
}(BaseObject_1.default));
Schemas_1.addSchemas('NodeObject', NodeObject);
exports.default = NodeObject;


/***/ }),
/* 69 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LoadingState;
(function (LoadingState) {
    LoadingState[LoadingState["STARTING"] = 0] = "STARTING";
    LoadingState[LoadingState["LOADING"] = 1] = "LOADING";
    LoadingState[LoadingState["PROCESSING"] = 2] = "PROCESSING";
    LoadingState[LoadingState["COMPLETE"] = 3] = "COMPLETE";
    LoadingState[LoadingState["CANCELLED"] = 4] = "CANCELLED";
    LoadingState[LoadingState["ERROR"] = 5] = "ERROR";
})(LoadingState || (LoadingState = {}));
;
exports.default = LoadingState;


/***/ }),
/* 70 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var baseImageAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'baseImageAsset', title: 'BaseImageAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { properties: {
            $ref: 'baseImageAssetProperties.json'
        } }) });
exports.default = baseImageAsset;


/***/ }),
/* 71 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseEntityProperties_1 = __webpack_require__(41);
var baseObjectProperties = tslib_1.__assign({}, baseEntityProperties_1.default, { id: 'baseObjectProperties', title: 'BaseObjectPropertiesDef', properties: tslib_1.__assign({}, baseEntityProperties_1.default.properties, { position: {
            $ref: 'vector3.json',
            default: { x: 0, y: 0, z: 0 }
        }, quaternion: {
            $ref: 'vector4.json',
            default: { x: 0, y: 0, z: 0, w: 1 }
        }, scale: {
            $ref: 'vector3.json',
            default: { x: 1, y: 1, z: 1 }
        }, castShadow: {
            type: 'boolean',
            default: true
        }, receiveShadow: {
            type: 'boolean',
            default: true
        }, visible: {
            type: 'boolean',
            default: true
        }, bounds: {
            $ref: 'box3.json'
        } }), required: ['position', 'scale', 'quaternion'] });
exports.default = baseObjectProperties;


/***/ }),
/* 72 */
/***/ (function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(187)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 73 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(33)
  , core      = __webpack_require__(32)
  , hide      = __webpack_require__(74)
  , redefine  = __webpack_require__(249)
  , ctx       = __webpack_require__(186)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ }),
/* 74 */
/***/ (function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(247)
  , createDesc = __webpack_require__(248);
module.exports = __webpack_require__(72) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ }),
/* 75 */
/***/ (function(module, exports) {

var g;

// This works in non-strict mode
g = (function() {
	return this;
})();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ }),
/* 76 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseAsset_1 = __webpack_require__(6);
var Schemas_1 = __webpack_require__(4);
// import JSONLoader from '../Util/JSONLoader';
/**
 * An asset that loads entities from an external document and adds them to the
 * runtime.
 * @class DocumentAsset
 * @constructor
 */
var DocumentAsset = (function (_super) {
    tslib_1.__extends(DocumentAsset, _super);
    function DocumentAsset() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    // public loadedBytes: number = 0;
    /** @inheritdoc */
    DocumentAsset.prototype.createRuntimeData = function (callback) {
        return callback();
        // FIXME: Outdated!
        // const loadFromJson = (response) => {
        //   const loader = new JSONLoader(this.engine);
        //   return loader.loadFromJson(response.data);
        // };
        // const onDocumentLoadError = (err) => {
        //   log.error(this.engine.engineName +
        //     ' - DocumentAsset: Error loading document, ' +
        //     this.getName(), err);
        //   callback();
        // };
        // const onDocumentProgress = (progressObj) => {
        //   this.loadedBytes = progressObj.loaded / progressObj.total;
        //   this.trigger('loadProgress', this);
        // };
        // const onDocumentLoaded = (entities) => {
        //   // Reference entities by SID.
        //   this.runtimeData = {
        //     entityIds: {}
        //   };
        //   entities.forEach(function(entity) {
        //     this.runtimeData.entityIds[entity.sid] = entity.id;
        //   }, this);
        //   callback();
        // };
        // this.engine.resourceLoader
        //   .load(this, { xhrKey: this.id }, onDocumentProgress)
        //   .then(loadFromJson)
        //   .then(onDocumentLoaded)
        //   .catch(onDocumentLoadError);
    };
    /**
     * Return the ID of the entity with the specified SID.
     * @method getEntityId
     * @public
     * @param {String} sid - the SID of the entity
     * @returns {String|undefined} the ID of the entity or undefined
     */
    DocumentAsset.prototype.getEntityId = function (sid) {
        return this.runtimeData ? this.runtimeData.entityIds[sid] : undefined;
    };
    return DocumentAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('DocumentAsset', DocumentAsset);
exports.default = DocumentAsset;


/***/ }),
/* 77 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/*
* NAMING CONVENTION FOR EVENTS
* play  <-- to start an event, is an action
* pause <-- to pause an event, is an action
* stop  <-- to stop an event, is an action
*
* enable  <-- , is an action
* disable <-- , is an action
* toggle  <-- , is an action
*
* begin  <-- triggered when event started, not an action
* end    <-- triggered when event complete, not an action
*
* Naming convention goes as follows
* <one of the above or one of your own><describing the event>
*
* Examples:
* playAnimateAlongCurve <-- start the curve animation
* stopKeyframeAnimation <-- stop a keyframe animation from playing
* pauseAudio            <-- pause a sound
* enableFreeCameraController   <-- turn on the free camera controller
* disableOrbitCameraController <-- turn off the orbit camera controller
* toggleVisibility             <-- toggle the visibility of an object
* beginShot                    <-- a shot has begun
* endExplode                   <-- the exploder has finished animating
*
* hideAnnotationPin    <-- hides just the pin for the annotation
* setViewport
*/

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var components_builtin_1 = __webpack_require__(222);
var scriptsInitialized = false;
var scripts = {};
/**
 * All ScriptAssets are manged by this registry.
 */
var ScriptRegistry = (function () {
    /**
     * Creates an instance of ScriptRegistry.
     */
    function ScriptRegistry(engine) {
        this.engine = engine;
        if (!scriptsInitialized) {
            scriptsInitialized = true;
            ScriptRegistry.registerScripts(components_builtin_1.default);
        }
        this.initBuiltInScripts();
    }
    /**
     * Registers a script globally for use by all engines which initialize after
     * this call.
     * @param scriptAssetDef  The script asset definition
     * @param constructor     The constructor function
     */
    ScriptRegistry.registerScript = function (scriptAssetDef, constructor) {
        if (!scriptAssetDef.id) {
            throw new Error('Component definition is lacking an id attribute!');
        }
        if (!constructor) {
            throw new Error('A constructor must be provided!');
        }
        scripts[scriptAssetDef.id] = {
            def: scriptAssetDef,
            constructor: constructor
        };
    };
    /**
     * @param scripts
     */
    ScriptRegistry.registerScripts = function (scriptPairs) {
        scriptPairs.forEach(function (_a) {
            var scriptAssetDef = _a[0], constructor = _a[1];
            return ScriptRegistry.registerScript(scriptAssetDef, constructor);
        });
    };
    /**
     * Initializes all ot the built in scripts, making them available for use in the engine.
     */
    ScriptRegistry.prototype.initBuiltInScripts = function () {
        var _this = this;
        Object.keys(scripts).forEach(function (scriptId) {
            var script = scripts[scriptId];
            var scriptAsset = _this.engine.createEntity(tslib_1.__assign({}, script.def, { type: 'script' }));
            var constructor = script.constructor;
            scriptAsset.sharedData.classConstructor = constructor;
        });
    };
    return ScriptRegistry;
}());
exports.default = ScriptRegistry;


/***/ }),
/* 78 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid animation
 * @vname Animation
 * @vfilter object
 * @vcategory Animation
 */
var Animation = (function (_super) {
    tslib_1.__extends(Animation, _super);
    function Animation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Whether or not this needs to update.
         * @private
         * @type {boolean}
         */
        _this.dirty = true;
        /**
         * Whether or not the animation is currently paused.
         * @private
         * @type {boolean}
         */
        _this.paused = false;
        /**
         * Whether the animation needs to be reset or not.
         * @private
         * @type {boolean}
         */
        _this.needsReset = false;
        /**
         * Whether or not the animation is ended.
         * @private
         * @type {boolean}
         */
        _this.ended = false;
        return _this;
    }
    /** @inheritdoc */
    Animation.prototype.onEntityLoaded = function () {
        var _this = this;
        // Don't recreate the mixer if it already exists unless the runtime data is different.
        if (!this.mixer || this.mixer._root !== this.getRuntimeData()) {
            this.mixer = new THREE.AnimationMixer(this.getRuntimeData());
            this.mixer.addEventListener('finished', function (event) { return _this.onMixerEvent(event); });
        }
    };
    /**
     * Returns the animation time.
     * @method getTime
     * @returns {number} The animation time.
     */
    Animation.prototype.getTime = function () {
        if (this.action) {
            return this.action.time;
        }
        return 0.0;
    };
    /**
     * Called when the BaseEntity begins to load.
     * @method start
     * @public
     * @returns {void}
     */
    /** @inheritdoc */
    Animation.prototype.onStartup = function () {
        // Listen to changes on the animation asset.
        if (this.asset) {
            this.listenTo(this.asset, 'propertyChanges', this.onAssetChanged);
        }
        // this.entity is available here but the Three.JS data isn't loaded yet.
        this.getEntity().on('playAnimation', this.playAnimation, this);
        this.getEntity().on('pauseAnimation', this.pause, this);
        this.getEntity().on('stopAnimation', this.stop, this);
        this.getEntity().on('toggleAnimation', this.toggle, this);
    };
    /**
     * Returns true if the animation is playing; otherwise, returns false.
     * @method isPlaying
     * @public
     * @returns {Boolean} true if the animation is playing; otherwise, false.
     */
    Animation.prototype.isPlaying = function () {
        // FIXME isScheduled not defined on typings
        return this.action && this.action.isScheduled() && !this.paused;
    };
    /**
     * Load the currently assigned animation asset and clip and reset playback. Use this method to
     * preload the animation asset prior to calling play(); otherwise, playback might be delayed.
     * @method load
     * @public
     * @param {Function} [callback] Called when the animation is loaded or an error occurs.
     * @returns {void}
     */
    Animation.prototype.load = function (callback) {
        var _this = this;
        if (!this.mixer) {
            if (callback) {
                callback(new Error('Mixer is not initialized'));
            }
            return;
        }
        // Release the current animation (if there is one).
        this.release();
        // Make sure an animation asset is set.
        if (!this.asset) {
            if (callback) {
                callback(new Error('No asset assigned'));
            }
            return;
        }
        this.asset.when('load', function () {
            // Get the THREE.AnimationClip from the asset.
            var clip = _this.asset.getAnimationClip(_this.clipId);
            if (!clip) {
                if (callback) {
                    callback(new Error("Failed to get animation clip \"" + _this.clipId + "\""));
                }
                return;
            }
            // Create a THREE.AnimationAction.
            _this.action = _this.mixer.clipAction(clip);
            if (!_this.action) {
                if (callback) {
                    callback(new Error('Failed to create THREE.AnimationAction'));
                }
                return;
            }
            // FIXME typings workaround
            _this.action.setLoop(_this.loop ? THREE.LoopRepeat : THREE.LoopOnce, Infinity);
            _this.action.timeScale = _this.speed;
            _this.action.time = _this.startTime;
            _this.action.weight = _this.weight;
            _this.action.clampWhenFinished = true;
            _this.action.paused = _this.paused;
            _this.dirty = false;
            _this.getEntity().trigger('animationLoaded');
            if (callback) {
                callback(null, _this);
            }
        });
        if (this.asset.isUnloaded()) {
            this.asset.load();
        }
    };
    /**
     * Pause the animation, without resetting the playhead.
     * @method pause
     * @public
     * @returns {void}
     */
    Animation.prototype.pause = function () {
        this.paused = true;
        if (this.action) {
            this.action.paused = this.paused;
        }
    };
    /**
     * Play the currently assigned animation asset and clip.
     * @method play
     * @public
     * @returns {void}
     */
    Animation.prototype.play = function () {
        var _this = this;
        this.paused = false;
        if (this.dirty) {
            this.load(function (err) {
                if (err) {
                    Logger_1.default.error('Error playing animation: ', err.toString());
                    return;
                }
                _this.play();
            });
            return;
        }
        if (this.action) {
            if (this.needsReset) {
                this.action.reset();
                this.action.time = this.startTime;
                this.needsReset = false;
            }
            this.action.play();
            this.action.paused = this.paused;
        }
    };
    /**
     * Play the specified animation, with the given playback settings.
     * @method playAnimation
     * @public
     * @param {String} assetId The ID of the animation asset.
     * @param {String} clipId The ID of the clip to play.
     * @param {Boolean} loop Whether or not to loop the animation.
     * @param {number} speed The playback speed.
     * @param {number} startTime The time offset to start the animation at.
     * @returns {void}
     */
    Animation.prototype.playAnimation = function (assetId, clipId, loop, speed, startTime) {
        if (assetId !== undefined) {
            this.setAsset(this.getEngine().getEntityById(assetId));
        }
        if (clipId !== undefined) {
            this.setClipId(clipId);
        }
        this.loop = loop !== undefined ? loop : this.loop;
        this.speed = speed !== undefined ? speed : this.speed;
        this.startTime = startTime !== undefined ? startTime : this.startTime;
        this.play();
    };
    /**
     * Stop and release the current animation.
     * @method release
     * @public
     * @returns {void}
     */
    Animation.prototype.release = function () {
        this.stop();
        if (this.action) {
            this.action.stop();
            this.action = undefined;
        }
    };
    /**
     * Set the current animation asset.
     * @method setAsset
     * @public
     * @param {AnimationAsset|null} asset The animation asset or null to unset the asset.
     * @returns {void}
     */
    Animation.prototype.setAsset = function (asset) {
        if (this.asset === asset) {
            return;
        }
        // Remove old change listener from the animation asset.
        if (this.asset) {
            this.stopListening(this.asset, 'propertyChanges', this.onAssetChanged);
            this.unregisterDependency(this.asset);
        }
        this.asset = asset;
        this.dirty = true;
        // Add new change listener to the animation asset.
        if (this.asset) {
            this.listenTo(this.asset, 'propertyChanges', this.onAssetChanged);
            this.registerDependency(this.asset);
        }
    };
    /**
     * Set the current animation clip.
     * @method setClipId
     * @public
     * @param {String} clipId The ID of the clip.
     * @returns {void}
     */
    Animation.prototype.setClipId = function (clipId) {
        if (this.clipId === clipId) {
            return;
        }
        this.clipId = clipId;
        this.dirty = true;
    };
    /**
     * Enable or disable looping.
     * @method setLoop
     * @public
     * @param {Boolean} loop Whether or not looping is enabled.
     * @returns {void}
     */
    Animation.prototype.setLoop = function (loop) {
        this.loop = loop;
        if (this.action) {
            // FIXME, workaround for typings
            this.action.setLoop.apply(this.action, [this.loop ? THREE.LoopRepeat : THREE.LoopOnce, Infinity]);
        }
    };
    /**
     * Set the animation speed.
     * @method setSpeed
     * @public
     * @param {number} speed The animation speed.
     * @returns {void}
     */
    Animation.prototype.setSpeed = function (speed) {
        this.speed = speed;
        if (this.action) {
            this.action.timeScale = speed;
        }
    };
    /**
     * Set the animation time.
     * @method setTime
     * @param {number} time The animation time.
     * @returns {void}
     */
    Animation.prototype.setTime = function (time) {
        if (this.action) {
            this.action.time = time;
        }
    };
    /**
     * Set the animation weight.
     * @method setWeight
     * @param {number} weight The animation weight.
     * @returns {void}
     */
    Animation.prototype.setWeight = function (weight) {
        this.weight = weight;
        if (this.action) {
            this.action.weight = this.weight;
        }
    };
    /** @inheritdoc */
    Animation.prototype.onShutdown = function () {
        // Remove the change listener from the animation asset.
        if (this.asset) {
            this.stopListening(this.asset, 'stopListening', this.onAssetChanged);
        }
        // Release the animation.
        this.release();
        this.getEntity().off('playAnimation', this.playAnimation, this);
        this.getEntity().off('pauseAnimation', this.pause, this);
        this.getEntity().off('stopAnimation', this.stop, this);
        this.getEntity().off('toggleAnimation', this.toggle, this);
    };
    /**
     * Stop the animation and reset the playhead to 0.
     * @method stop
     * @returns {void}
     */
    Animation.prototype.stop = function () {
        if (this.action) {
            this.action.stop();
        }
    };
    /**
     * Toggle between the play and paused state.
     * @method toggle
     * @public
     * @returns {void}
     */
    Animation.prototype.toggle = function () {
        if (this.isPlaying()) {
            this.pause();
        }
        else {
            this.play();
        }
    };
    /** @inheritdoc */
    Animation.prototype.onUpdate = function (deltaTime) {
        if (this.mixer) {
            this.mixer.update(deltaTime);
            this.getEngine().needsRender = true;
            if (this.ended) {
                this.getEntity().trigger('endAnimation');
                this.ended = false;
            }
        }
    };
    /**
     * Called when the animation asset's properties change.
     * @method onAssetChanged
     * @private
     * @returns {void}
     */
    Animation.prototype.onAssetChanged = function () {
        this.dirty = true;
    };
    /**
     * Called when mixer events occur.
     * @method onMixerEvent
     * @private
     * @param {Object} event The mixer event.
     * @returns {void}
     */
    Animation.prototype.onMixerEvent = function (event) {
        // These events are fired in the mixer update loop. Rather than firing an event immediately,
        // set the "ended" flag to true, and fire the event after the mixer update loop completes. This
        // prevents callbacks from modifying animation state during the update loop, which can cause
        // unexpected problems.
        // TODO: Fix THREE.js typings? action is missing on the event.
        if (event.action === this.action && event.type === 'finished') {
            this.needsReset = true;
            this.ended = true;
        }
    };
    return Animation;
}(BaseComponent_1.default));
/**
 * Event definitions:
 *
 * @vevent local playAnimation {
 *  scope: 'local',
 *  action: true,
 *  category: 'Animation',
 *  parameters: [{
 *    name: 'asset',
 *    type: 'asset',
 *    description: 'The animation asset to play.',
 *    default: null,
 *    filter: { 'animation': true }
 *  }, {
 *    name: 'clipId',
 *    type: 's',
 *    description: 'The ID of the clip to play.',
 *    default: null
 *  }, {
 *    name: 'loop',
 *    type: 'b',
 *    description: 'Continuously replay the animation.',
 *    default: true
 *  }, {
 *    name: 'speed',
 *    type: 'f',
 *    description: 'Playback speed.',
 *    default: 1.0,
 *    min: 0.0,
 *    max: 100.0
 *  }, {
 *    name: 'startTime',
 *    type: 'f',
 *    description: 'Begin playback at this time offset.',
 *    default: 0.0,
 *    min: 0.0
 *  }]
 * }
 *
 * @vevent local pauseAnimation {
 *   scope: 'local',
 *   action: true,
 *   category: 'Animation',
 *   parameters: []
 * }
 *
 * @vevent local stopAnimation {
 *   scope: 'local',
 *   action: true,
 *   category: 'Animation',
 *   parameters: []
 * }
 *
 * @vevent local toggleAnimation {
 *   scope: 'local',
 *   action: true,
 *   category: 'Animation',
 *   parameters: []
 * }
 *
 * @vevent local animationLoaded {
 *   scope: 'local',
 *   action: false,
 *   category: 'Animation',
 *   parameters: []
 * }
 *
 * @vevent local endAnimation {
 *   scope: 'local',
 *   action: false,
 *   category: 'Animation',
 *   parameters: []
 * }
 */
exports.default = Animation;


/***/ }),
/* 79 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid audio_listener
 * @vname Audio Listener
 * @vcategory Audio
 * @vdescription Audio listener for 3D, positional sound effects
 */
var AudioListener = (function (_super) {
    tslib_1.__extends(AudioListener, _super);
    /** Creates an instance of AudioListener. */
    function AudioListener() {
        var _this = _super.call(this) || this;
        _this.context = null;
        return _this;
    }
    /** @inheritdoc */
    AudioListener.prototype.onStartup = function () {
        this.context = this.getEntity().engine.getAudioContext();
        if (!this.context) {
            Logger_1.default.warn('Failed to create Web Audio context.');
            return;
        }
    };
    /** @inheritdoc */
    AudioListener.prototype.onUpdate = function () {
        if (this.hasRuntimeData() && this.context) {
            var transform = this.getRuntimeData().matrixWorld;
            var objPos = new THREE.Vector3(0, 0, 0).applyMatrix4(transform);
            var objDir = new THREE.Vector3(0, 0, -1).applyMatrix4(transform).sub(objPos).normalize();
            var objUp = new THREE.Vector3(0, 1, 0).applyMatrix4(transform).sub(objPos).normalize();
            this.context.listener.setPosition(objPos.x, objPos.y, objPos.z);
            this.context.listener.setOrientation(objDir.x, objDir.y, objDir.z, objUp.x, objUp.y, objUp.z);
        }
    };
    return AudioListener;
}(BaseComponent_1.default));
exports.default = AudioListener;


/***/ }),
/* 80 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var VideoAsset_1 = __webpack_require__(24);
var BaseComponent_1 = __webpack_require__(2);
var LoadingType_1 = __webpack_require__(16);
var LoadingEvent_1 = __webpack_require__(12);
/**
 * A component which is used for playback of audio assets.
 * @vid audio_source
 * @vname Audio Source
 * @vcategory Audio
 * @vdescription Controls playback of audio assets
 */
var AudioSource = (function (_super) {
    tslib_1.__extends(AudioSource, _super);
    /** Creates an instance of AudioSource. */
    function AudioSource() {
        var _this = _super.call(this) || this;
        _this.gainNode = null;
        _this.sourceNode = null;
        _this.pannerNode = null;
        _this.context = null;
        _this.buffer = null;
        _this.startTime = 0;
        _this.playOffset = 0;
        _this.state = 'stopped';
        _this.element = null;
        _this.isVideo = false;
        return _this;
    }
    /**
     * Getter for the current gain value.
     * @returns The current gain value
     */
    AudioSource.prototype.getGain = function () {
        return this.gain;
    };
    /**
     * Getter for the current audio state.
     * @returns The current audio state
     */
    AudioSource.prototype.getState = function () {
        return this.state;
    };
    /**
     * Checks whether the source is configured to loop.
     * @returns True if the source is set to loop.
     */
    AudioSource.prototype.isLoop = function () {
        return this.loop;
    };
    /**
     * Checks whether the source is paused.
     * @returns True if the source is paused.
     */
    AudioSource.prototype.isPaused = function () {
        return this.state === 'paused';
    };
    /**
     * Checks whether the source is playing.
     * @returns True if the source is playing.
     */
    AudioSource.prototype.isPlaying = function () {
        return this.state === 'playing';
    };
    /**
     * Checks whether the source is stopped.
     * @returns True if the source is stopped.
     */
    AudioSource.prototype.isStopped = function () {
        return this.state === 'stopped';
    };
    /** Pauses the audio source */
    AudioSource.prototype.pause = function () {
        if (this.state === 'playing') {
            // The order of these function calls is important: getCurrentTime() must be
            // called while state is 'playing' and before freeAudioGraph().
            this.playOffset = this.getCurrentTime();
            this.state = 'paused';
            this.freeAudioGraph();
        }
    };
    /**
     * Plays the audio source.
     * @param [offset] The position to start playing from
     */
    AudioSource.prototype.play = function (offset) {
        var _this = this;
        if (offset === void 0) { offset = 0; }
        if (this.state === 'paused' || this.state === 'stopped') {
            // Add the specified offset to the current play offset.
            this.playOffset += offset;
            this.initAudioGraph(function (err) {
                if (err) {
                    Logger_1.default.warn('Error playing audio: ' + err);
                    return;
                }
                // Update the gain and loop settings.
                _this.setGain(_this.gain);
                _this.setLoop(_this.loop);
                // If we are streaming, play the audio/video element; otherwise, play the
                // buffer source node.
                if (_this.stream) {
                    _this.element.currentTime = _this.playOffset;
                    _this.element.play();
                }
                else if (_this.context) {
                    _this.startTime = _this.context.currentTime;
                    _this.sourceNode.start(0, _this.playOffset);
                }
                else {
                    Logger_1.default.warn('No Web Audio context.');
                }
                _this.state = 'playing';
            });
        }
    };
    /**
     * Sets the gain on the audio source.
     * @param gain The amount of gain to apply
     */
    AudioSource.prototype.setGain = function (gain) {
        this.gain = gain;
        // If we have a gain node, set the gain on it; otherwise, set the gain on the
        // audio/video element.
        if (this.gainNode) {
            this.gainNode.gain.value = this.gain;
        }
        else if (this.element) {
            this.element.volume = this.gain;
        }
    };
    /**
     * Sets whether or not the source should loop.
     * @param loop True if the audio should loop.
     */
    AudioSource.prototype.setLoop = function (loop) {
        this.loop = loop;
        if (this.element) {
            this.element.loop = this.loop;
        }
        else if (this.sourceNode) {
            this.sourceNode.loop = this.loop;
        }
    };
    /** Stops the audio source from playing. */
    AudioSource.prototype.stop = function () {
        if (this.state === 'playing' || this.state === 'paused') {
            this.playOffset = 0;
            this.state = 'stopped';
            this.freeAudioGraph();
        }
    };
    /** Toggles the audio between playing and paused state. */
    AudioSource.prototype.toggle = function () {
        if (this.state === 'playing') {
            this.pause();
        }
        else {
            this.play();
        }
    };
    /** @inheritdoc */
    AudioSource.prototype.onStartup = function () {
        this.context = this.getEntity().engine.getAudioContext();
        if (this.context) {
            this.gainNode = this.context.createGain();
            this.pannerNode = this.context.createPanner();
        }
        else {
            Logger_1.default.warn('No audio context, using fallback.');
            this.stream = true; // Must stream via an audio element.
            this.positional = false; // Positional audio not supported.
        }
        // Always stream video assets.
        this.isVideo = this.asset instanceof VideoAsset_1.default;
        if (this.isVideo) {
            this.stream = true;
        }
        if (this.autoPlay) {
            this.play();
        }
        else if (this.preload) {
            this.load(function (err, _source) {
                if (err) {
                    Logger_1.default.warn(err);
                }
            });
        }
        this.listenTo(this.getEntity(), 'playAudio', this.play);
        this.listenTo(this.getEntity(), 'pauseAudio', this.pause);
        this.listenTo(this.getEntity(), 'stopAudio', this.stop);
        this.listenTo(this.getEntity(), 'toggleAudio', this.toggle);
    };
    /** @inheritdoc */
    AudioSource.prototype.onUpdate = function () {
        if (this.hasRuntimeData() && this.positional) {
            var transform = this.getRuntimeData().matrixWorld;
            var objPos = new THREE.Vector3(0, 0, 0).applyMatrix4(transform);
            var objDir = new THREE.Vector3(0, 0, 1).applyMatrix4(transform).sub(objPos).normalize();
            this.pannerNode.setPosition(objPos.x, objPos.y, objPos.z);
            this.pannerNode.setOrientation(objDir.x, objDir.y, objDir.z);
        }
    };
    /**
     * Initializes the audio graph.
     * @param fn A function which will be called on completion.
     */
    AudioSource.prototype.initAudioGraph = function (fn) {
        var _this = this;
        this.load(function (err, source) {
            if (err) {
                return fn(err);
            }
            else if (!_this.context) {
                return fn(null, null);
            }
            var nodes = [];
            if (_this.stream) {
                _this.sourceNode = _this.context.createMediaElementSource(source);
            }
            else {
                _this.sourceNode = _this.context.createBufferSource();
                _this.sourceNode.buffer = source;
            }
            nodes.push(_this.sourceNode);
            nodes.push(_this.gainNode);
            if (_this.positional) {
                nodes.push(_this.pannerNode);
            }
            nodes.push(_this.context.destination);
            for (var iNode = 1; iNode < nodes.length; ++iNode) {
                nodes[iNode - 1].connect(nodes[iNode]);
            }
            fn(null, _this.sourceNode);
        });
    };
    /**
     * Loads the attached asset.
     * @param fn A function which will be called on completion.
     */
    AudioSource.prototype.load = function (fn) {
        var _this = this;
        // Return the element or buffer, if they have already been created.
        if (this.stream && this.element) {
            return fn(null, this.element);
        }
        else if (!this.stream && this.buffer) {
            return fn(null, this.buffer);
        }
        if (!this.asset) {
            return fn(new Error('No audio asset'));
        }
        // If we are streaming, load the audio asset and reference the audio or video
        // element. If we aren't streaming, load the entire file into an audio buffer.
        if (this.stream) {
            this.asset.load(function (asset) {
                if (!asset) {
                    return fn(new Error('Error loading audio/video file'));
                }
                if (_this.isVideo) {
                    _this.element = asset.runtimeData.image;
                }
                else {
                    _this.element = asset.runtimeData;
                }
                fn(null, _this.element);
            });
        }
        else {
            if (!this.context) {
                return fn(new Error('No Web Audio context'));
            }
            var representations = this.asset.get('representations');
            var resource = this.getEngine()
                .resourceLoader
                .load(representations[0].src, LoadingType_1.default.BUFFER, {});
            resource.once(LoadingEvent_1.default.ERROR, function (err) { return fn(err); });
            resource.once(LoadingEvent_1.default.LOAD, function (response) {
                _this.context.decodeAudioData(response, function (buffer) {
                    _this.buffer = buffer;
                    fn(null, _this.buffer);
                }, function (err) { return fn(err); });
            });
        }
    };
    /** Frees the audio graph */
    AudioSource.prototype.freeAudioGraph = function () {
        if (this.element) {
            this.element.pause();
            this.element.currentTime = 0;
        }
        if (this.sourceNode) {
            // If sourceNode is an AudioBufferSourceNode, stop it first.
            if (!this.stream) {
                this.sourceNode.stop(0);
            }
            this.sourceNode.disconnect();
            this.sourceNode = null;
        }
        if (this.gainNode) {
            this.gainNode.disconnect();
        }
        if (this.pannerNode) {
            this.pannerNode.disconnect();
        }
    };
    /**
     * The current play time.
     * @returns The current play time
     */
    AudioSource.prototype.getCurrentTime = function () {
        if (this.state === 'playing') {
            if (this.element) {
                return this.element.currentTime;
            }
            else if (this.context) {
                return this.context.currentTime - this.startTime;
            }
        }
        return this.playOffset;
    };
    return AudioSource;
}(BaseComponent_1.default));
/**
 * Event definitions:
 *
 * @vevent local playAudio {
 *   scope: 'local',
 *   action: true,
 *   category: 'Audio',
 *   parameters: [
 *     {
 *       name: 'offset',
 *       type: 'f',
 *       description: 'Defined in seconds',
 *       default: 0
 *      }
 *   ]
 * }
 *
 * @vevent local pauseAudio {
 *   scope: 'local',
 *   action: true,
 *   category: 'Audio',
 *   parameters: []
 * }
 *
 * @vevent local stopAudio {
 *   scope: 'local',
 *   action: true,
 *   category: 'Audio',
 *   parameters: []
 * }
 *
 * @vevent local toggleAudio {
 *   scope: 'local',
 *   action: true,
 *   category: 'Audio',
 *   parameters: []
 * }
 */
exports.default = AudioSource;


/***/ }),
/* 81 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/**
 * @vid bounding_box_renderer
 * @vname BoundingBox Renderer
 * @vcategory Rendering
 * @vfilter object
 */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var MeshObject_1 = __webpack_require__(26);
var BoundingBoxRenderer = (function (_super) {
    tslib_1.__extends(BoundingBoxRenderer, _super);
    function BoundingBoxRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Automatically render bounding boxes for all meshes in the hierarchy.
         * @vattr bool recursive {
         *   default: true,
         *   description: 'Automatically render bounding boxes for all meshes in the hierarchy'
         * }
         */
        _this.recursive = true;
        /**
         * The geometry used to render the bounding boxes.
         */
        _this.boxGeometry = new THREE.BoxGeometry(1, 1, 1);
        /** The material to render the top bounding box with. */
        _this.topBoxMaterial = new THREE.MeshBasicMaterial({ color: 0x0011ff, wireframe: true });
        /** The material to render all sub-meshes with. */
        _this.subBoxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0800, wireframe: true });
        /** Internal Box3 for doing calculations. To avoid repeated allocation of Box3's. */
        _this.workBounds = new THREE.Box3();
        /**
         * An internal array of all the created BB helpers. Used to enable and disable the
         * BB's at anytime.
         */
        _this.helpers = [];
        return _this;
    }
    /** @inheritdoc */
    BoundingBoxRenderer.prototype.onStartup = function () {
        var _this = this;
        var object = this.getEntity();
        if (this.recursive) {
            object.getDescendantsByType('mesh').forEach(function (mesh) {
                _this.createBoundingBox(mesh, _this.subBoxMaterial);
            });
        }
        this.createBoundingBox(object, this.topBoxMaterial, false);
    };
    /** @inheritdoc */
    BoundingBoxRenderer.prototype.onShutdown = function () {
        this.helpers.forEach(function (helper) {
            if (helper.boxMesh.parent) {
                helper.boxMesh.parent.remove(helper.boxMesh);
            }
        });
    };
    /** @inheritdoc */
    BoundingBoxRenderer.prototype.onEnable = function () {
        this.helpers.forEach(function (helper) { return helper.boxMesh.visible = true; });
    };
    /** @inheritdoc */
    BoundingBoxRenderer.prototype.onDisable = function () {
        this.helpers.forEach(function (helper) { return helper.boxMesh.visible = false; });
    };
    /**
     * Setup bounding box rendering for the given object.
     * @param object The mesh to setup the BB render for.
     * @param hexColor The hexidecimal color used to render the bounding box.
     */
    BoundingBoxRenderer.prototype.createBoundingBox = function (object, material, localBounds) {
        var _this = this;
        if (localBounds === void 0) { localBounds = true; }
        if (!object) {
            return;
        }
        object.when('loadBase', function () {
            var bounds = object instanceof MeshObject_1.default && localBounds ?
                object.getLocalBounds(_this.workBounds) : object.getBounds(_this.workBounds);
            var boxHelper = {
                boxMesh: new THREE.Mesh(_this.boxGeometry, material),
                object: object,
                bounds: bounds
            };
            if (!_this.isEnabled()) {
                boxHelper.boxMesh.visible = false;
            }
            _this.helpers.push(boxHelper);
            boxHelper.bounds.getSize(boxHelper.boxMesh.scale);
            boxHelper.bounds.getCenter(boxHelper.boxMesh.position);
            object.runtimeData.add(boxHelper.boxMesh);
        });
    };
    return BoundingBoxRenderer;
}(BaseComponent_1.default));
exports.default = BoundingBoxRenderer;


/***/ }),
/* 82 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseComponent_1 = __webpack_require__(2);
/**
 * Lerp between two values.
 * @param min     The minimum bounds of the range.
 * @param max     The maximum bounds of the range.
 * @param percent Position to lerp to. 0 = min, 1 = max.
 * @returns       The lerped value.
 */
function lerp(min, max, percent) {
    var range = max - min;
    return Math.min(max, Math.max(min, min + range * percent));
}
/**
 * A Component that handles zooming with orthographic and perspective cameras.
 * @vid camera_zoom
 * @vname Camera Zoom
 * @vdescription Handles zooming with orthographic and perspective cameras.
 * @vfilter camera
 * @vcategory Camera Controllers
 */
var CameraZoom = (function (_super) {
    tslib_1.__extends(CameraZoom, _super);
    function CameraZoom() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * The maximum amount a perspective camera can be zoomed (out).
         * @vattr float perspectiveZoomMax {
         *   description : 'The maximum amount a perspective camera can be zoomed (out)',
         *   default : 180,
         *   max : 100000,
         *   min : 0
         * }
         */
        _this.perspectiveZoomMax = 180;
        /**
         * The minimum amount a perspective camera can be zoomed (in).
         * @vattr float perspectiveZoomMin {
         *   description : 'The minimum amount a perspective camera can be zoomed (in)',
         *   default : 0,
         *   max : 100000,
         *   min : 0
         * }
         */
        _this.perspectiveZoomMin = 0;
        /**
         * The maximum amount an orthographic camera can be zoomed (out).
         * @vattr float orthoZoomMax {
         *   description : 'The maximum amount an orthographic camera can be zoomed (out)',
         *   default : 5,
         *   max : 100000,
         *   min : 0
         * }
         */
        _this.orthoZoomMax = 5;
        /**
         * The minimum amount an orthographic camera can be zoomed (in).
         * @vattr float orthoZoomMin {
         *   description : 'The minimum amount an orthographic camera can be zoomed (in)',
         *   default : 0,
         *   max : 100000,
         *   min : 0
         * }
         */
        _this.orthoZoomMin = 0;
        /**
         * Used to unify zoom between ortho and perspective zoom (this.zoom(+-1)).
         * @vattr float perspectiveStep {
         *   description : 'Used to unify zoom between ortho and perspective zoom (this.zoom(+-1))',
         *   default : 4,
         *   max : 100000,
         *   min : 0
         * }
         */
        _this.perspectiveStep = 4;
        /**
         * Used to unify zoom between ortho and perspective zoom (this.zoom(+-1)).
         * @vattr float orthographicStep {
         *   description : 'Used to unify zoom between ortho and perspective zoom (this.zoom(+-1))',
         *   default : 0.2,
         *   max : 100000,
         *   min : 0
         * }
         */
        _this.orthographicStep = 0.2;
        return _this;
    }
    /**
     * Zoom the camera.
     * @param amount The amount to zoom by.
     */
    CameraZoom.prototype.zoom = function (amount) {
        if (amount === void 0) { amount = 0; }
        if (!this.hasRuntimeData() || !this.isEnabled()) {
            return;
        }
        var entity = this.getEntity();
        switch (entity.getProperty('cameraType')) {
            case ('perspective'):
                this.zoomPerspective(amount);
                break;
            case ('orthographic'):
                this.zoomOrthographic(amount);
                break;
            default:
                // Do nothing, for now
                break;
        }
        this.updateRenderer();
    };
    /**
     * Zoom to a position inside of the min and max zoom bounds.
     * @param percent The position to zoom to. 0 is full zoom in, 1 is full zoom out.
     */
    CameraZoom.prototype.lerpZoom = function (percent) {
        if (!this.hasRuntimeData() || !this.isEnabled()) {
            return;
        }
        var entity = this.getEntity();
        var clampedPercent = Math.max(0, Math.min(1, percent));
        switch (entity.getProperty('cameraType')) {
            case ('perspective'):
                this.lerpZoomPerspective(clampedPercent);
                break;
            case ('orthographic'):
                this.lerpZoomOrtho(clampedPercent);
                break;
            default:
                // Do nothing, for now
                break;
        }
        this.updateRenderer();
    };
    /**
     * Get the current level of zoom.
     * @returns 0 if fully zoomed in, 1 if fully zoomed out.
     */
    CameraZoom.prototype.getZoomLevel = function () {
        var type = this.getEntity().getProperty('cameraType');
        var camera = this.getRuntimeData();
        var diff;
        var current;
        if (type === 'perspective') {
            diff = this.perspectiveZoomMax - this.perspectiveZoomMin;
            current = camera.fov - this.perspectiveZoomMin;
        }
        else {
            diff = this.orthoZoomMax - this.orthoZoomMin;
            current = (camera.top + Math.abs(camera.bottom)) - this.orthoZoomMin;
        }
        return current / diff;
    };
    /**
     * Set the min and max Field of View, in degrees, that the perspective camera can be zoomed to.
     * @param min The minimum a perspective camera can be zoomed.
     * @param max The maximum a perspective camera can be zoomed.
     */
    CameraZoom.prototype.setPerspectiveBounds = function (min, max) {
        this.perspectiveZoomMin = min;
        this.perspectiveZoomMax = max;
        // Force update
        this.zoom();
    };
    /**
     * Set the min and max size bounds that the orthographic camera can be zoomed to.
     * @param min The minimum an orthographic camera can be zoomed.
     * @param max The maximum an orthographic camera can be zoomed.
     */
    CameraZoom.prototype.setOrthographicBounds = function (min, max) {
        this.orthoZoomMin = min;
        this.orthoZoomMax = max;
        // Force update
        this.zoom();
    };
    /** @inheritdoc */
    CameraZoom.prototype.onStartup = function () {
        // this.listenTo(this.getEntity(), 'change:properties', this.onPropertyChanges);
        this.listenTo(this.getEntity(), 'lerpZoom', this.lerpZoom);
        this.listenTo(this.getEntity(), 'zoom', this.zoom);
    };
    /**
     * Zoom a perspective camera.
     * @param amount The amount to zoom the camera.
     */
    CameraZoom.prototype.zoomPerspective = function (amount) {
        var camera = this.getRuntimeData();
        var fov = camera.fov;
        var newFOV = fov + amount * this.perspectiveStep;
        var clampedFOV = Math.min(this.perspectiveZoomMax, Math.max(this.perspectiveZoomMin, newFOV));
        this.setFOV(clampedFOV);
    };
    /**
     * Set the current zoom level of the perspective camera to a value between min and max.
     * @param percent The percent to zoom to. 0 is full zoom in, 1 is full zoom out.
     */
    CameraZoom.prototype.lerpZoomPerspective = function (percent) {
        var newFOV = lerp(this.perspectiveZoomMin, this.perspectiveZoomMax, percent);
        this.setFOV(newFOV);
    };
    /**
     * Zoom an orthographic camera.
     * @param amount The amount to zoom the camera.
     */
    CameraZoom.prototype.zoomOrthographic = function (amount) {
        var camera = this.getRuntimeData();
        var topBound = (camera.top * 2) + amount * this.orthographicStep;
        var clampedBound = Math.min(this.orthoZoomMax, Math.max(this.orthoZoomMin, topBound));
        this.setOrthoBounds(clampedBound);
    };
    /**
     * Set the current zoom level of the ortho camera to a value between min and max.
     * @param percent The percent to zoom to. 0 is full zoom in, 1 is full zoom out.
     */
    CameraZoom.prototype.lerpZoomOrtho = function (percent) {
        var bounds = lerp(this.orthoZoomMin, this.orthoZoomMax, percent);
        this.setOrthoBounds(bounds);
    };
    /**
     * Listen to property change events.
     * @param changes Any property changes that occur when setProperty() is called.
     */
    CameraZoom.prototype.onPropertyChanges = function (changes) {
        var cameraType = changes.cameraType;
        if (cameraType) {
            this.zoom();
        }
    };
    /**
     * Set the field of view for the camera.
     * @param fov The fov to set the camera to use.
     */
    CameraZoom.prototype.setFOV = function (fov) {
        this.getEntity().setProperty('fov', fov);
    };
    /**
     * Set the bounds of the orthographic camera.
     * @param bounds The bound for top and bottom of the camera. Left and right are determined
     *               by the existing aspect ratio.
     */
    CameraZoom.prototype.setOrthoBounds = function (bounds) {
        var aspect = this.getEntity().getAspectRatio();
        this.getEntity().setProperties({
            top: bounds * 0.5,
            bottom: -bounds * 0.5,
            right: aspect * bounds * 0.5,
            left: aspect * -bounds * 0.5
        });
    };
    /**
     * Trigger the correct updates to re-render with new viewport properties.
     */
    CameraZoom.prototype.updateRenderer = function () {
        this.getEngine().needsRender = true;
    };
    return CameraZoom;
}(BaseComponent_1.default));
;
exports.default = CameraZoom;


/***/ }),
/* 83 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * A component to make rendering to a cube map easier.
 *
 * @class CubeMapCapture
 * @vid cube_map_capture
 * @vname Cube-Map Capture
 * @vcategory Rendering
 * @vreserved
 * @vfilter Object
 */
var CubeMapCapture = (function (_super) {
    tslib_1.__extends(CubeMapCapture, _super);
    /**
     * Creates an instance of CubeMapCapture.
     */
    function CubeMapCapture() {
        var _this = _super.call(this) || this;
        _this.framesElapsed = 0;
        _this.near = 1.0;
        _this.far = 12000.0;
        _this.updateFrameInterval = 0.0;
        _this.cubeMaterial = undefined;
        _this.tempRenderTexture = undefined;
        return _this;
    }
    /** @inheritdoc */
    CubeMapCapture.prototype.onStartup = function () {
        this.initCameras();
    };
    /** @inheritdoc */
    CubeMapCapture.prototype.onShutdown = function () {
        if (this.hasRuntimeData()) {
            this.getRuntimeData().remove(this.cubeCamera);
        }
    };
    /** @inheritdoc */
    CubeMapCapture.prototype.onEntityLoaded = function () {
        var threeData = this.getRuntimeData();
        threeData.add(this.cubeCamera);
    };
    /** @inheritdoc */
    CubeMapCapture.prototype.onAttributesChanged = function (changes) {
        var _this = this;
        if (changes.indexOf('captureTexture') !== -1) {
            if (this.captureTexture) {
                this.captureTexture.when('load', function () {
                    if (_this.tempRenderTexture) {
                        _this.tempRenderTexture.unload();
                    }
                });
                if (this.captureTexture.isBaseUnloaded()) {
                    this.captureTexture.load();
                }
            }
            else if (!this.tempRenderTexture) {
                this.createTempRenderTexture();
            }
        }
        if (!this.hasRuntimeData()) {
            return;
        }
        if (changes.indexOf('near') !== -1 || changes.indexOf('far') !== -1) {
            this.cameraPX.near = this.near;
            this.cameraPX.far = this.far;
            this.cameraPX.updateProjectionMatrix();
            this.cameraNX.near = this.near;
            this.cameraNX.far = this.far;
            this.cameraNX.updateProjectionMatrix();
            this.cameraPY.near = this.near;
            this.cameraPY.far = this.far;
            this.cameraPY.updateProjectionMatrix();
            this.cameraNY.near = this.near;
            this.cameraNY.far = this.far;
            this.cameraNY.updateProjectionMatrix();
            this.cameraPZ.near = this.near;
            this.cameraPZ.far = this.far;
            this.cameraPZ.updateProjectionMatrix();
            this.cameraNZ.near = this.near;
            this.cameraNZ.far = this.far;
            this.cameraNZ.updateProjectionMatrix();
        }
        if (changes.indexOf('debugView') !== -1) {
            this.cubeCamera.traverse(function (obj) {
                if (obj instanceof THREE.PerspectiveCamera) {
                    // FIXME: Should we be attaching this camera helper like this?
                    if (!obj.cameraHelper) {
                        obj.cameraHelper = new THREE.CameraHelper(obj);
                        _this.getRootThreeObject().add(obj.cameraHelper);
                    }
                    obj.cameraHelper.visible = !!_this.debugView;
                }
            });
        }
    };
    /**
     * Render the scene to the texture.
     * @method captureScene
     * @public
     * @return {void}
     */
    CubeMapCapture.prototype.captureScene = function () {
        var renderer = this.getRenderer();
        var scene = this.getRootThreeObject();
        var renderTarget = this.captureTexture ? this.captureTexture.runtimeData :
            this.tempRenderTexture.runtimeData;
        if (renderTarget) {
            var generateMipmaps_1 = renderTarget.texture.generateMipmaps;
            var cameras_1 = [];
            var faces_1 = [];
            renderTarget.texture.generateMipmaps = false;
            if (this.renderPosX) {
                faces_1.push(0);
                cameras_1.push(this.cameraPX);
            }
            if (this.renderNegX) {
                faces_1.push(1);
                cameras_1.push(this.cameraNX);
            }
            if (this.renderPosY) {
                faces_1.push(2);
                cameras_1.push(this.cameraPY);
            }
            if (this.renderNegY) {
                faces_1.push(3);
                cameras_1.push(this.cameraNY);
            }
            if (this.renderPosZ) {
                faces_1.push(4);
                cameras_1.push(this.cameraPZ);
            }
            if (this.renderNegZ) {
                faces_1.push(5);
                cameras_1.push(this.cameraNZ);
            }
            cameras_1.forEach(function (camera, idx) {
                if (idx === cameras_1.length - 1) {
                    renderTarget.texture.generateMipmaps = generateMipmaps_1;
                }
                renderTarget.activeCubeFace = faces_1[idx];
                renderer.renderView(scene, camera, {
                    renderTarget: renderTarget,
                    clearColor: true
                });
            });
            renderTarget.needsUpdate = true;
        }
    };
    /** @inheritdoc */
    CubeMapCapture.prototype.onPreRender = function () {
        var scene = this.getRootObject();
        if (!scene.isLoaded()) {
            return;
        }
        this.framesElapsed++;
        if (this.framesElapsed >= this.updateFrameInterval && this.isEnabled()) {
            this.framesElapsed = 0.0;
            this.captureScene();
        }
    };
    /**
     * Return the internal cube camera used to render the scene.
     */
    CubeMapCapture.prototype.getCubeCamera = function () {
        return this.cubeCamera;
    };
    /**
     * Creates a temporary render texture.
     * @private
     */
    CubeMapCapture.prototype.createTempRenderTexture = function () {
        this.tempRenderTexture = this.getEngine().createRenderTextureCube({
            width: 512,
            height: 512,
            format: 'rgba',
            type: 'uByte'
        }, 'render_tex_cube');
        this.tempRenderTexture.load();
    };
    /**
     * Called immediately after after component creation
     * @private
     * @returns {void}
     */
    CubeMapCapture.prototype.initCameras = function () {
        this.cubeCamera = new THREE.Object3D();
        var fov = 90;
        var aspect = 1;
        this.cameraPX = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraPX.up.set(0, -1, 0);
        this.cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
        this.cubeCamera.add(this.cameraPX);
        this.cameraNX = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraNX.up.set(0, -1, 0);
        this.cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
        this.cubeCamera.add(this.cameraNX);
        this.cameraPY = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraPY.up.set(0, 0, 1);
        this.cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
        this.cubeCamera.add(this.cameraPY);
        this.cameraNY = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraNY.up.set(0, 0, -1);
        this.cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
        this.cubeCamera.add(this.cameraNY);
        this.cameraPZ = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraPZ.up.set(0, -1, 0);
        this.cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
        this.cubeCamera.add(this.cameraPZ);
        this.cameraNZ = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraNZ.up.set(0, -1, 0);
        this.cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
        this.cubeCamera.add(this.cameraNZ);
    };
    return CubeMapCapture;
}(BaseComponent_1.default));
exports.default = CubeMapCapture;


/***/ }),
/* 84 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var functions_1 = __webpack_require__(5);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * A component to render spline curves.
 * @vid curve
 * @vname Curve
 * @vfilter object
 * @vreserved
 * @vdescription Creates a spline curve that can be used for various things, including making
 *               objects follow it. Add controls points to shape the curve.
 * @vcategory General
 */
var Curve = (function (_super) {
    tslib_1.__extends(Curve, _super);
    /** Creates an instance of Curve. */
    function Curve() {
        var _this = _super.call(this) || this;
        _this.controlPoints = undefined;
        _this.prevControlPointsLength = 0;
        _this.closed = false;
        _this.tempVector = new THREE.Vector3();
        _this.tempVector4 = new THREE.Vector4();
        _this.tempMatrix = new THREE.Matrix4();
        _this.visualizationCurveColor = 0x222222;
        _this.visualizationSelectedCurveColor = 0x0d56a6;
        _this.orientationHelpers = [];
        _this.canTryUpdateAgain = true;
        _this.curveMaterial = undefined;
        _this.curveGeometry = undefined;
        _this.curveMesh = undefined;
        _this.curveTessellation = 200;
        _this.selected = false;
        _this.updateStarted = false;
        return _this;
    }
    /** Enables edit mode on the curve. */
    Curve.prototype.onSelected = function () {
        this.selected = true;
        if (this.curveMaterial) {
            this.curveMaterial.color.setHex(this.visualizationSelectedCurveColor);
        }
        this.orientationHelpers.forEach(function (helper) {
            return helper.traverse(function (obj) {
                obj.visible = true;
            });
        });
    };
    /** Disables edit mode on the curve */
    Curve.prototype.onUnselected = function () {
        this.selected = false;
        if (this.curveMaterial) {
            this.curveMaterial.color.setHex(this.visualizationCurveColor);
        }
        this.orientationHelpers.forEach(function (helper) {
            return helper.traverse(function (obj) {
                obj.visible = false;
            });
        });
    };
    /**
     * Checks whether or not the curve has been initialized.
     * @returns True if the curve has been initialized.
     */
    Curve.prototype.isCurveInit = function () {
        return this.curve.points.length > 0;
    };
    /** @inheritdoc */
    Curve.prototype.onStartup = function () {
        this.initCurve();
    };
    /** @inheritdoc */
    Curve.prototype.onAttributesChanged = function () {
        this.initCurve();
    };
    /** @inheritdoc */
    Curve.prototype.onShutdown = function () {
        this.cleanupCurveMesh();
        this.cleanupOrientationHelpers();
        this.cleanupCurveMaterial();
    };
    /** Initializes the component. */
    Curve.prototype.initCurve = function () {
        if (!this.updateStarted && this.controlPoints && this.controlPoints.length) {
            this.updateStarted = true;
            this.cleanupCurveMesh();
            this.cleanupOrientationHelpers();
            this.prevControlPointsLength = this.controlPoints.length;
            this.createCurve();
            if (this.enableVisualizations) {
                this.cleanupCurveMesh();
                this.createCurveMesh();
                this.updateOrientationHelpers();
            }
        }
    };
    /** Creates the curve. */
    Curve.prototype.createCurve = function () {
        var _this = this;
        this.controlPoints.forEach(function (point) {
            return point.off('change:properties', _this.updateCurve, _this);
        });
        this.curve = new THREE.CatmullRomCurve3();
        if (this.closed) {
            this.curve.closed = true;
        }
        var scene = this.getEntity().getRootObject();
        scene.when('loadDependencies', function (_scene) {
            scene.runtimeData.updateMatrixWorld(true);
            functions_1.forEach(_this.controlPoints, function (point) {
                if (point) {
                    var newPos = point.getPosition().clone();
                    _this.curve.points.push(newPos);
                    _this.tempMatrix.makeRotationFromQuaternion(point.runtimeData.quaternion);
                    var matArray = _this.tempMatrix.toArray();
                    _this.tempVector.set(matArray[0], matArray[1], matArray[2]);
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, newPos, 0.25, 0xff0000));
                    _this.tempVector.set(matArray[4], matArray[5], matArray[6]);
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, newPos, 0.25, 0x00ff00));
                    _this.tempVector.set(matArray[8], matArray[9], matArray[10]);
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, newPos, 0.25, 0x0000ff));
                    point.on('change:properties', _this.updateCurve, _this);
                }
                else {
                    _this.tempVector.set(0, 0, 0);
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, _this.tempVector, 0.25, 0xff0000));
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, _this.tempVector, 0.25, 0xff0000));
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, _this.tempVector, 0.25, 0xff0000));
                }
            });
            _this.updateCurve({});
            _this.updateStarted = false;
            if (!_this.selected) {
                _this.onUnselected();
            }
            _this.trigger('curveInit');
        }, this);
    };
    /**
     * Updates the curve on changes.
     * @param changes The changes object
     */
    Curve.prototype.updateCurve = function (changes) {
        var _this = this;
        var index = 0;
        if (changes.hasOwnProperty('position')) {
            functions_1.forEach(this.controlPoints, function (point) {
                if (point) {
                    if (point.runtimeData.parent) {
                        point.getPosition(_this.tempVector);
                        _this.tempVector4.set(_this.tempVector.x, _this.tempVector.y, _this.tempVector.z, 1.0);
                        _this.tempVector4.applyMatrix4(point.runtimeData.parent.matrixWorld);
                        _this.curve.points[index].set(_this.tempVector4.x, _this.tempVector4.y, _this.tempVector4.z);
                        index++;
                    }
                    else if (_this.canTryUpdateAgain) {
                        _this.canTryUpdateAgain = false;
                        setTimeout(function () {
                            Logger_1.default.info('Trying again');
                            _this.updateCurve({});
                        }, 10);
                    }
                }
            });
            if (this.enableVisualizations) {
                this.cleanupCurveMesh();
                this.createCurveMesh();
            }
            this.canTryUpdateAgain = true;
        }
        if (changes.hasOwnProperty('quaternion')) {
            this.updateOrientationHelpers();
        }
    };
    /** Dispose of the curve material. */
    Curve.prototype.cleanupCurveMaterial = function () {
        if (this.curveMaterial) {
            this.curveMaterial.dispose();
            this.curveMaterial = undefined;
        }
    };
    /** Removes the orientation helpers. */
    Curve.prototype.cleanupOrientationHelpers = function () {
        var _this = this;
        this.orientationHelpers.forEach(function (helper) {
            _this.getRootThreeObject().remove(helper);
        });
        this.orientationHelpers = [];
    };
    /** Dispose of the curve mesh. */
    Curve.prototype.cleanupCurveMesh = function () {
        if (this.enableVisualizations && this.curveMesh) {
            this.getRootThreeObject().remove(this.curveMesh);
            this.curveGeometry.dispose();
            this.curveMesh.material = undefined;
        }
    };
    /** Creates the curve mesh  */
    Curve.prototype.createCurveMesh = function () {
        var _this = this;
        if (!this.curveMaterial) {
            this.curveMaterial = new THREE.MeshPhongMaterial({
                color: this.visualizationCurveColor,
                transparent: false,
                opacity: 0.75,
                blending: THREE.AdditiveBlending
            });
        }
        if (this.curve.points.length) {
            this.curveGeometry = new THREE.TubeGeometry(this.curve, this.curveTessellation, 0.1, 8, this.closed);
            this.curveMesh = new THREE.Mesh(this.curveGeometry, this.curveMaterial);
            this.getRootObject().when('loadBase', function () {
                _this.getRootThreeObject().add(_this.curveMesh);
                functions_1.forEach(_this.orientationHelpers, function (helper) {
                    _this.getRootThreeObject().add(helper);
                });
            }, this);
            this.updateOrientationHelpers();
        }
    };
    /** Update arrow helpers when a control point's quaternion changes */
    Curve.prototype.updateOrientationHelpers = function () {
        var _this = this;
        this.controlPoints.forEach(function (point, i) {
            var obj = point.runtimeData;
            _this.orientationHelpers[i * 3].position.copy(_this.curve.points[i]);
            _this.orientationHelpers[i * 3 + 1].position.copy(_this.curve.points[i]);
            _this.orientationHelpers[i * 3 + 2].position.copy(_this.curve.points[i]);
            _this.tempMatrix.makeRotationFromQuaternion(obj.quaternion);
            var matArray = _this.tempMatrix.toArray();
            _this.tempVector.set(matArray[0], matArray[1], matArray[2]);
            _this.orientationHelpers[i * 3].setDirection(_this.tempVector);
            _this.tempVector.set(matArray[4], matArray[5], matArray[6]);
            _this.orientationHelpers[i * 3 + 1].setDirection(_this.tempVector);
            _this.tempVector.set(matArray[8], matArray[9], matArray[10]);
            _this.orientationHelpers[i * 3 + 2].setDirection(_this.tempVector);
        });
    };
    return Curve;
}(BaseComponent_1.default));
exports.default = Curve;


/***/ }),
/* 85 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid debug_console_display
 * @vname Debug Console Display
 * @vcategory Debug
 * @vfilter Application
 */
var DebugConsoleDisplay = (function (_super) {
    tslib_1.__extends(DebugConsoleDisplay, _super);
    /** Creates an instance of DebugConsoleDisplay. */
    function DebugConsoleDisplay() {
        return _super.call(this) || this;
    }
    /** @inheritdoc */
    DebugConsoleDisplay.prototype.onStartup = function () {
        var logTag = document.createElement('div');
        logTag.id = 'consoleLogger';
        logTag.style.position = 'absolute';
        logTag.style.top = '0';
        logTag.style.left = '0';
        logTag.style.width = '100%';
        logTag.style.height = '100%';
        logTag.style.margin = '0';
        logTag.style.padding = '0';
        logTag.style.color = '#000';
        logTag.style.background = 'rgba(0,0,0,0.5)';
        logTag.style.fontWeight = 'bold';
        logTag.style.textAlign = 'left';
        logTag.style.overflow = 'scroll';
        logTag.style['pointer-events'] = 'none';
        logTag.style['z-index'] = '1';
        window.document.body.appendChild(logTag);
        window.console.log = window.console.error = window.console.warn = function (text) {
            logTag.innerHTML += text + '<br>';
        };
    };
    return DebugConsoleDisplay;
}(BaseComponent_1.default));
exports.default = DebugConsoleDisplay;


/***/ }),
/* 86 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/**
 * @vid debug_performance
 * @vname Debug Performance
 * @vcategory Debug
 * @vfilter Application
 */
var BaseComponent_1 = __webpack_require__(2);
var Stats = __webpack_require__(259);
var DebugPerformance = (function (_super) {
    tslib_1.__extends(DebugPerformance, _super);
    /** Creates an instance of DebugPerformance. */
    function DebugPerformance() {
        var _this = _super.call(this) || this;
        _this.stats = new Stats();
        _this.initialized = false;
        return _this;
    }
    /** @inheritdoc */
    DebugPerformance.prototype.onStartup = function () {
        this.stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
    };
    /** @inheritdoc */
    DebugPerformance.prototype.onPreUpdate = function () {
        if (this.isEnabled()) {
            this.stats.begin();
        }
    };
    /** @inheritdoc */
    DebugPerformance.prototype.onPostRender = function () {
        if (this.isEnabled()) {
            this.stats.end();
        }
    };
    /** @inheritdoc */
    DebugPerformance.prototype.onEnable = function () {
        document.body.appendChild(this.stats.dom);
        this.initialized = true;
    };
    /** @inheritdoc */
    DebugPerformance.prototype.onDisable = function () {
        if (this.initialized) {
            document.body.removeChild(this.stats.dom);
            this.initialized = false;
        }
    };
    return DebugPerformance;
}(BaseComponent_1.default));
exports.default = DebugPerformance;


/***/ }),
/* 87 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var functions_1 = __webpack_require__(5);
var BaseTextureAsset_1 = __webpack_require__(19);
var CopyShader_1 = __webpack_require__(208);
var elementCss = {
    position: 'absolute',
    left: '0',
    top: '0',
    padding: '8px',
    'border-radius': '5px',
    'font-family': 'proxima_nova_regular,Helvetica,Arial,sans-serif',
    'max-width': '25%',
    'min-width': '25px',
    transition: 'opacity 0.1s ease-in-out, background 0.1s ease-in-out',
    cursor: 'pointer'
};
/**
 * Changes the css styles for a given element.
 * @param el The element.
 * @param styles An object of key-value pairs representing the styles.
 */
function css(el, styles) {
    if (!el || !el.style) {
        return;
    }
    for (var i in styles) {
        if (styles.hasOwnProperty(i)) {
            el.style[i] = styles[i];
        }
    }
}
/**
 * Adds a class to the given element.
 * @param el The element.
 * @param className The class name to add.
 */
function addClass(el, className) {
    if (el.classList) {
        el.classList.add(className);
    }
    else {
        el.className += ' ' + className;
    }
}
/**
 * @vid debug_texture_viewer
 * @vname Debug Texture Viewer
 * @vreserved
 * @vcategory Debug
 * @vfilter Application
 */
var DebugTextureViewer = (function (_super) {
    tslib_1.__extends(DebugTextureViewer, _super);
    /**
     * Creates an instance of DebugTextureViewer.
     */
    function DebugTextureViewer() {
        var _this = _super.call(this) || this;
        _this.renderEventName = 'render';
        _this.textureRegistryById = {};
        return _this;
    }
    /** @inheritdoc */
    DebugTextureViewer.prototype.onAwake = function () {
        this.getEngine().on('assetLoaded', this.registerTexture, this);
        this.getEngine().on('assetUnloaded', this.unregisterTexture, this);
    };
    /** @inheritdoc */
    DebugTextureViewer.prototype.onStartup = function () {
        var _this = this;
        this.init2dScene();
        this.initCubeScene();
        this.renderEventName += 'Group' + this.renderGroup;
        this.getEngine().on(this.renderEventName, this.renderView, this);
        this.listenTo(this.getEngine(), 'rendererResize', this.resize);
        this.getEngine().getAssetsByClass(BaseTextureAsset_1.default).forEach(function (tex) { return _this.registerTexture(tex); });
        this.resize();
    };
    /** @inheritdoc */
    DebugTextureViewer.prototype.onShutdown = function () {
        this.getEngine().off('assetLoaded', this.registerTexture, this);
        this.getEngine().off('assetUnloaded', this.unregisterTexture, this);
        this.getEngine().off(this.renderEventName, this.renderView, this);
    };
    /**
     * Initializes the 2D scene.
     */
    DebugTextureViewer.prototype.init2dScene = function () {
        this.camera2D = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.scene2D = new THREE.Scene();
        this.material2D = new THREE.ShaderMaterial(CopyShader_1.default);
        this.mesh2D = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this.material2D);
        this.scene2D.add(this.mesh2D);
    };
    /**
     * Initializes the cube scene.
     */
    DebugTextureViewer.prototype.initCubeScene = function () {
        var fov = 90;
        var aspect = 1;
        var cubeShader = THREE.ShaderLib.cube;
        this.sceneCube = new THREE.Scene();
        this.geoCube = new THREE.BoxGeometry(100, 100, 100);
        this.materialCube = new THREE.ShaderMaterial({
            fragmentShader: cubeShader.fragmentShader,
            vertexShader: cubeShader.vertexShader,
            uniforms: cubeShader.uniforms,
            depthWrite: false,
            depthTest: false,
            side: THREE.BackSide
        });
        this.meshCube = new THREE.Mesh(this.geoCube, this.materialCube);
        this.cameraPX = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraPX.up.set(0, 1, 0);
        this.cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
        this.sceneCube.add(this.cameraPX);
        this.cameraNX = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraNX.up.set(0, 1, 0);
        this.cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
        this.sceneCube.add(this.cameraNX);
        this.cameraPY = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraPY.up.set(0, 0, -1);
        this.cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
        this.sceneCube.add(this.cameraPY);
        this.cameraNY = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraNY.up.set(0, 0, 1);
        this.cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
        this.sceneCube.add(this.cameraNY);
        this.cameraPZ = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraPZ.up.set(0, 1, 0);
        this.cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
        this.sceneCube.add(this.cameraPZ);
        this.cameraNZ = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraNZ.up.set(0, 1, 0);
        this.cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
        this.sceneCube.add(this.cameraNZ);
        this.sceneCube.add(this.meshCube);
    };
    /**
     * Sets the texture to debug.
     * @param textureId The id of the texture
     */
    DebugTextureViewer.prototype.setTexture = function (textureId) {
        var _this = this;
        this.currentTexture = this.textureRegistryById[textureId];
        if (this.currentTexture) {
            this.currentTexture.load(function () {
                /* tslint:disable no-string-literal */
                // Rule disabled as uniforms is used as a mapping of strings to uniforms rather than a strongly typed
                // object.
                switch (_this.currentTexture.type) {
                    case 'renderTextureCube':
                    case 'textureCube':
                        _this.materialCube.uniforms['tCube'].value = _this.currentTexture.getThreeTexture();
                        break;
                    case 'texture2D':
                    case 'renderTexture2D':
                        _this.material2D.uniforms['tDiffuse'].value = _this.currentTexture.getThreeTexture();
                        break;
                    default: // nothing
                }
                /* tslint:enable no-string-literal */
                _this.mesh2D.visible = true;
                _this.meshCube.visible = true;
            });
        }
        else {
            this.mesh2D.visible = false;
            this.meshCube.visible = false;
        }
    };
    /**
     * Updates the viewport, useful after resize, etc.
     */
    DebugTextureViewer.prototype.updateViewport = function () {
        var percent;
        var cWidth = this.getEngine().getRenderer().getWidth();
        var cHeight = this.getEngine().getRenderer().getHeight();
        if (this.viewportBottom.slice(-1) === '%') {
            percent = parseFloat(this.viewportBottom.slice(0, -1)) * 0.01;
            this.y = percent * cHeight;
        }
        else {
            this.y = parseInt(this.viewportBottom, 10);
        }
        if (this.viewportLeft.slice(-1) === '%') {
            percent = parseFloat(this.viewportLeft.slice(0, -1)) * 0.01;
            this.x = percent * cWidth;
        }
        else {
            this.x = parseInt(this.viewportLeft, 10);
        }
        if (this.viewportWidth.slice(-1) === '%') {
            percent = parseFloat(this.viewportWidth.slice(0, -1)) * 0.01;
            this.width = percent * cWidth;
        }
        else {
            this.width = parseInt(this.viewportWidth, 10);
        }
        if (this.viewportHeight.slice(-1) === '%') {
            percent = parseFloat(this.viewportHeight.slice(0, -1)) * 0.01;
            this.height = percent * cHeight;
        }
        else {
            this.height = parseInt(this.viewportHeight, 10);
        }
        if (this.x < 0) {
            this.x += cWidth;
        }
        if (this.y < 0) {
            this.y += cHeight;
        }
    };
    /**
     * Updates the texture dropdown dom element.
     */
    DebugTextureViewer.prototype.updateTextureDropdown = function () {
        var _this = this;
        if (this.isEnabled()) {
            setTimeout(function () {
                var newOption;
                if (!_this.textureDropDown) {
                    _this.textureDropDown = document.createElement('select');
                    _this.textureDropDown.name = 'Textures';
                    _this.textureDropDown.id = 'Textures';
                    addClass(_this.textureDropDown, 'debugger-dropdown');
                    css(_this.textureDropDown, elementCss);
                    if (!_this.getThreeRenderer()) {
                        return;
                    }
                    var canvas = _this.getThreeRenderer().domElement;
                    if (canvas.parentElement) {
                        canvas.parentElement.appendChild(_this.textureDropDown);
                    }
                    else {
                        canvas.appendChild(_this.textureDropDown);
                    }
                    _this.textureDropDown.onchange = function () {
                        _this.setTexture(_this.textureDropDown.value);
                    };
                }
                _this.textureDropDown.options.length = 0;
                newOption = document.createElement('option');
                newOption.value = 0;
                newOption.text = 'None';
                _this.textureDropDown.appendChild(newOption);
                functions_1.forEach(_this.textureRegistryById, function (tex, id) {
                    newOption = document.createElement('option');
                    newOption.value = id;
                    newOption.text = tex.name !== '' ? tex.getName() : id;
                    _this.textureDropDown.appendChild(newOption);
                });
                _this.textureDropDown.style.top = (_this.getEngine().getRenderer().getHeight() -
                    _this.y - _this.height) + 'px';
                _this.textureDropDown.style.left = _this.x + 'px';
                _this.textureDropDown.style.zIndex = '200';
            }, 0);
        }
    };
    /**
     * Handles the engine resize event.
     */
    DebugTextureViewer.prototype.resize = function () {
        if (this.isEnabled()) {
            this.updateTextureDropdown();
            this.updateViewport();
        }
    };
    /**
     * Renders the debug texture viewer.
     */
    DebugTextureViewer.prototype.renderView = function () {
        var renderer = this.getThreeRenderer();
        if (this.isEnabled() && this.currentTexture) {
            renderer.setRenderTarget(null);
            switch (this.currentTexture.type) {
                case 'texture2D':
                case 'renderTexture2D':
                    renderer.setViewport(this.x, this.y, this.width, this.height);
                    renderer.render(this.scene2D, this.camera2D);
                    break;
                case 'textureCube':
                case 'renderTextureCube':
                    {
                        var portWidthInc = 0.25 * this.width;
                        var portHeightInc = 0.3333 * this.height;
                        renderer.setViewport(this.x, this.y + portHeightInc, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraPX, null, false);
                        renderer.setViewport(this.x + 1.999 * portWidthInc, this.y + portHeightInc, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraNX, null, false);
                        renderer.setViewport(this.x + portWidthInc, this.y + 1.99 * portHeightInc, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraPY, null, false);
                        renderer.setViewport(this.x + portWidthInc, this.y, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraNY, null, false);
                        renderer.setViewport(this.x + portWidthInc, this.y + portHeightInc, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraPZ, null, false);
                        renderer.setViewport(this.x + 2.99 * portWidthInc, this.y + portHeightInc, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraNZ, null, false);
                    }
                    break;
                default: // nothing
            }
        }
    };
    /**
     * Registers the texture asset.
     * @param texture The texture asset to register.
     */
    DebugTextureViewer.prototype.registerTexture = function (texture) {
        if (!texture) {
            return;
        }
        switch (texture.type) {
            case 'renderTextureCube':
            case 'textureCube':
            case 'texture2D':
            case 'renderTexture2D':
                this.textureRegistryById[texture.id] = texture;
                break;
            default: // nothing
        }
    };
    /**
     * Unregisters the texture asset.
     * @param texture The texture asset to unregister.
     */
    DebugTextureViewer.prototype.unregisterTexture = function (texture) {
        if (texture) {
            if (this.textureRegistryById[texture.id]) {
                delete this.textureRegistryById[texture.id];
            }
        }
    };
    return DebugTextureViewer;
}(BaseComponent_1.default));
exports.default = DebugTextureViewer;


/***/ }),
/* 88 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-classes-per-file */
var BaseComponent_1 = __webpack_require__(2);
/**
 * A class which represents a change to make to properties on a matching entities.
 * @class QualityChangeLevel
 */
var QualityChangeLevel = (function () {
    /**
     * Creates an instance of QualityChangeLevel.
     * @param targetEntityType    The target entity's type
     * @param targetComponentName The name of the target entity
     * @param propertyName        The property name
     * @param targetValue         The target value
     */
    function QualityChangeLevel(targetEntityType, targetComponentName, propertyName, targetValue) {
        this.targetEntityType = targetEntityType;
        this.targetComponentName = targetComponentName;
        this.propertyName = propertyName;
        this.targetValue = targetValue;
        /** A mapping of component/entity ids to previous values */
        this.previousValues = {};
        /** A number representing the time savings from the last step. */
        this.lastTimeSavings = 0;
        this.targetEntityType = targetEntityType;
        this.targetComponentName = targetComponentName;
        this.propertyName = propertyName;
        this.targetValue = targetValue;
    }
    return QualityChangeLevel;
}());
exports.QualityChangeLevel = QualityChangeLevel;
/**
 * A percentage used to prevent jumping back and forth between performance levels.
 * We must achieve a frame time equal to this constant multiplied by our frameTimeThreshold
 * minus the performance savings from the last quality drop before we step back up a
 * quality level.
 */
var stepUpBufferPercentage = 0.9;
/**
 * DynamicOptimizer
 * This class controls the dynamic down-stepping of rendering features in an
 * attempt to achieve goal performance.
 * @vid dynamic_optimizer
 * @vname Dynamic Performance Optimizer
 * @vreserved
 * @vcategory Rendering
 * @vfilter Application
 */
var DynamicOptimizer = (function (_super) {
    tslib_1.__extends(DynamicOptimizer, _super);
    /**
     * Creates an instance of DynamicOptimizer.
     */
    function DynamicOptimizer() {
        var _this = _super.call(this) || this;
        /** A reference to the constructor of QualityChangeLevel */
        /* tslint:disable ext-variable-name */
        // Disabled rule to preserve backwards compatibility.
        _this.QualityChangeLevel = QualityChangeLevel;
        _this.frameTimeThreshold = 33.333333333; // Attribute defined above
        _this.testInterval = 2000.0; // Attribute defined above
        _this.qualityChangeLevels = [];
        _this.currentLevel = _this.qualityChangeLevels.length;
        _this.elapsedRenderTime = 0.0;
        _this.framesRecorded = 0;
        _this.justStarted = true;
        _this.justAutoSteppedDown = false;
        _this.autoOptimize = true;
        return _this;
    }
    /**
     * Assign the descriptions of the quality levels to be used by the optimizer.
     * @param qualityLevels Array of DynamicOptimizer.QualityChangeLevel objects in order
     *                      from lowest quality level to highest.
     */
    DynamicOptimizer.prototype.setQualityChangeLevels = function (qualityLevels) {
        // First, set the quality back to the top to reset all changed values.
        this.setMaxQuality();
        this.qualityChangeLevels = qualityLevels;
        this.currentLevel = this.qualityChangeLevels.length;
        if (this.isEnabled()) {
            this.autoOptimize = true;
        }
    };
    /**
     * Set the length of frame, above which we will drop a quality level. i.e. if the frame time
     * is above this threshold, the performance is considered poor enough that we will try to
     * disable features to improve it.
     * @param threshold The length of a frame above which we will move down in quality.
     */
    DynamicOptimizer.prototype.setFrameTimeThreshold = function (threshold) {
        this.frameTimeThreshold = threshold;
    };
    /**
     * Set the time interval over which we will average the performance measurement.
     * @param interval The time interval in milliseconds.
     */
    DynamicOptimizer.prototype.setTestInterval = function (interval) {
        this.testInterval = interval;
        this.elapsedRenderTime = 0.0;
        this.framesRecorded = 0;
    };
    /** @inheritdoc */
    DynamicOptimizer.prototype.onPreUpdate = function (delta) {
        if (!this.isEnabled()) {
            return;
        }
        this.elapsedRenderTime += delta * 1000;
        this.framesRecorded++;
        if (this.elapsedRenderTime < this.testInterval) {
            return;
        }
        // When the given amount of rendering time has passed, make a decision
        // about whether to take action based on the current performance
        this.lastAvgFrameTime = this.elapsedRenderTime / this.framesRecorded;
        this.elapsedRenderTime = 0.0;
        this.framesRecorded = 0;
        if (this.justAutoSteppedDown && this.currentLevel < this.qualityChangeLevels.length) {
            var info = this.qualityChangeLevels[this.currentLevel];
            info.lastTimeSavings = info.frameTimeAtDrop - this.lastAvgFrameTime;
            this.justAutoSteppedDown = false;
        }
        // If this is the first recorded interval, don't do anything.
        // This lets the browser settle (after doing its own optimization) and
        // all GPU data to finish uploading to the device.
        if (this.justStarted || !this.autoOptimize || !this.qualityChangeLevels.length) {
            this.justStarted = false;
            return;
        }
        // If the average time it takes to render a frame is larger than our threshold
        // step the rendering quality down.
        if (this.lastAvgFrameTime > this.frameTimeThreshold) {
            // Step down
            this.stepRenderingQualityDown();
            this.justAutoSteppedDown = true;
            // Otherwise, if the average frame time is less than the threshold minus the
            // last frame time savings, bump up the rendering quality. This aims to prevent
            // ping-ponging back and forth between two quality levels.
        }
        else if (this.qualityChangeLevels[this.currentLevel] &&
            this.lastAvgFrameTime < stepUpBufferPercentage * (this.frameTimeThreshold -
                this.qualityChangeLevels[this.currentLevel].lastTimeSavings)) {
            this.stepRenderingQualityUp();
        }
    };
    /**
     * Move to the next lower quality level that actually has an impact. i.e. if the defined
     * quality change isn't applicable to the current scene, we'll skip it and move on.
     */
    DynamicOptimizer.prototype.stepRenderingQualityDown = function () {
        var needsStep = true;
        while (needsStep && this.currentLevel > 0) {
            this.currentLevel = this.currentLevel > 1 ? this.currentLevel - 1 : 0;
            needsStep = !this.stepRenderingQuality(false);
        }
        // Record frame time at time of step down. Only if we actually did a step.
        if (!needsStep) {
            this.qualityChangeLevels[this.currentLevel].frameTimeAtDrop = this.lastAvgFrameTime;
        }
    };
    /**
     * Move to the next higher quality level that actually has an impact. i.e. if the defined
     * quality change isn't applicable to the current scene, we'll skip it and move on.
     */
    DynamicOptimizer.prototype.stepRenderingQualityUp = function () {
        var needsStep = true;
        while (needsStep && this.currentLevel < this.qualityChangeLevels.length) {
            needsStep = !this.stepRenderingQuality(true);
            this.currentLevel = Math.min(this.currentLevel + 1, this.qualityChangeLevels.length);
        }
    };
    /** @inheritdoc */
    DynamicOptimizer.prototype.onEnable = function () {
        this.autoOptimize = true;
    };
    /** @inheritdoc */
    DynamicOptimizer.prototype.onDisable = function () {
        this.autoOptimize = false;
        this.setMaxQuality();
    };
    /** Turn off the auto-optimization and turn all disabled rendering features back on. */
    DynamicOptimizer.prototype.setMaxQuality = function () {
        this.autoOptimize = false;
        while (this.currentLevel < this.qualityChangeLevels.length) {
            this.stepRenderingQualityUp();
        }
    };
    /**
     * Get the next value to set on an entity/component, given the current quality level.
     * @param qualityLevel  The quality level change to consider.
     * @param id            The ID of the BaseEntity or BaseComponent to change.
     * @param currentValue  The current value of the property/attribute
     * @param stepUp        True if we're stepping up a performance level
     * @returns             The next value of the property/attribute
     */
    DynamicOptimizer.prototype.stepValue = function (qualityLevel, id, currentValue, stepUp) {
        if (stepUp) {
            return qualityLevel.previousValues[id];
        }
        qualityLevel.previousValues[id] = currentValue;
        return qualityLevel.targetValue;
    };
    /**
     * Using a quality level definition, set the appropriate values on the entity, depending
     * whether we're dropping a quality level or going up a level.
     * @param entity        The entity to apply the changes to.
     * @param qualityLevel  The description of the quality changes for this level
     * @param stepUp        True if we're stepping up a quality level. Otherwise,
     *                      we're stepping down.
     * @returns             True if applying the quality change actually had an affect.
     *                      That is, the quality settings actually resulted in changes to the entity.
     */
    DynamicOptimizer.prototype.applyLevelToEntity = function (entity, qualityLevel, stepUp) {
        var _this = this;
        var stepSuccess = false;
        // If the component name is defined, we're modifying a component attribute.
        if (qualityLevel.targetComponentName) {
            var components = entity.getComponentsByScriptName(qualityLevel.targetComponentName);
            components.forEach(function (component) {
                var currentValue = component.getAttribute(qualityLevel.propertyName);
                var newValue = _this.stepValue(qualityLevel, component.getId(), currentValue, stepUp);
                // If the current and new values are the same, skip setting it.
                if (currentValue !== newValue) {
                    component.setAttribute(qualityLevel.propertyName, newValue);
                    stepSuccess = true;
                }
            });
            // Otherwise, we're modifying a property of an entity.
        }
        else {
            var currentValue = entity.getProperty(qualityLevel.propertyName);
            var newValue = this.stepValue(qualityLevel, entity.id, currentValue, stepUp);
            // If the current and new values are the same, skip setting it.
            if (currentValue !== newValue) {
                entity.setProperty(qualityLevel.propertyName, newValue);
                stepSuccess = true;
            }
        }
        return stepSuccess;
    };
    /**
     * Apply the next step in the rendering quality.
     * @param stepUp True if we want to step the quality up. Otherwise, we step down.
     * @returns      True if the stepping was successful.
     */
    DynamicOptimizer.prototype.stepRenderingQuality = function (stepUp) {
        var _this = this;
        // Find the target entities that we'll apply the quality change to.
        var qualityLevel = this.qualityChangeLevels[this.currentLevel];
        var entities = this.getEngine().getEntitiesByType(qualityLevel.targetEntityType);
        var stepSuccess = false;
        // For each entity, make the change.
        entities.forEach(function (entity) {
            if (_this.applyLevelToEntity(entity, qualityLevel, stepUp)) {
                stepSuccess = true;
            }
        });
        return stepSuccess;
    };
    return DynamicOptimizer;
}(BaseComponent_1.default));
exports.default = DynamicOptimizer;


/***/ }),
/* 89 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseComponent_1 = __webpack_require__(2);
var functions_1 = __webpack_require__(5);
var BaseEntity_1 = __webpack_require__(9);
/**
 * Calls an event of the given name with the supplied parameters.
 * @param entity      The entity to trigger the event on
 * @param eventName   The name of the event
 * @param parameters  The supplied parameters
 */
function callEvent(entity, eventName, parameters) {
    var events;
    var data = [];
    if (entity instanceof BaseEntity_1.default) {
        events = entity.getEvents();
        data.push(eventName);
        if (events[eventName]) {
            for (var i in events[eventName].params) {
                if (parameters[i] !== undefined && parameters[i] !== null) {
                    data.push(parameters[i]);
                }
                else {
                    data.push(events[eventName].params[i].default);
                }
            }
        }
        entity.trigger.apply(entity, data);
    }
    else {
        data.push(eventName);
        entity.trigger.apply(entity, data.concat(parameters));
    }
}
/**
 * @vid event_handler
 * @vname Event Handler
 * @vcategory Interaction
 */
var EventHandler = (function (_super) {
    tslib_1.__extends(EventHandler, _super);
    function EventHandler() {
        return _super !== null && _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    EventHandler.prototype.onStartup = function () {
        var sourceEvent = this.listen;
        var entity;
        var bindEventName;
        if (sourceEvent && this.isEnabled()) {
            if (sourceEvent.scope === 'local') {
                entity = this.getEntity();
                this.listenTo(entity, sourceEvent.name, this.onEvent);
            }
            else if (sourceEvent.scope === 'entity') {
                entity = this.getEngine().getEntityById(sourceEvent.entityId);
                if (entity) {
                    this.listenTo(entity, sourceEvent.name, this.onEvent);
                }
            }
            else {
                // global
                entity = this.getGlobalEvents();
                this.listenTo(entity, sourceEvent.name, this.onEvent);
            }
            bindEventName = sourceEvent.name + ':bound';
            this.getEngine().trigger(bindEventName, entity);
        }
    };
    /** Handles an incoming event. */
    EventHandler.prototype.onEvent = function () {
        var _this = this;
        if (this.isEnabled()) {
            var actions = this.triggers;
            functions_1.forEach(actions, function (action) {
                if (action) {
                    var eventName = action.name;
                    var parameters = action.parameters;
                    var entity = void 0;
                    if (action.scope === 'local') {
                        callEvent(_this.getEntity(), eventName, parameters);
                    }
                    else if (action.scope === 'entity') {
                        entity = _this.getEngine().getEntityById(action.entityId);
                        if (entity) {
                            callEvent(entity, eventName, parameters);
                        }
                    }
                    else {
                        // global
                        callEvent(_this.getGlobalEvents(), eventName, parameters);
                    }
                }
            });
        }
    };
    return EventHandler;
}(BaseComponent_1.default));
exports.default = EventHandler;


/***/ }),
/* 90 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var tmpVec = new THREE.Vector3();
/**
 * http://javascript.info/tutorial/animation
 * This function works as the bow: first we push back the string and then shoot.
 * @param progress  The current progress as a number between 0.0 and 1.0.
 * @param x         The coefficient of elasticity.
 * @returns         The translated value.
 */
function back(progress, x) {
    return Math.pow(progress, 2) * ((x + 1) * progress - x);
}
/**
 * http://javascript.info/tutorial/animation
 * Applies an EaseInOut calculation an input progress number. This applies the
 * easing to both the start and the end of the animation.
 * @param progress  The current progress as a number between 0.0 and 1.0.
 * @returns         The resulting value after being eased.
 */
function makeEaseInOut(progress) {
    if (progress < .5) {
        return back(2 * progress, 2.0) / 2;
    }
    else {
        return (2 - back(2 * (1 - progress), 2.0)) / 2;
    }
}
/**
 * A function which is used to transform meshes in a grid formation.
 * @param length    The total number of items.
 * @param center    The center of the animation.
 * @param scale     The scale of the animation.
 * @param rotation  The initial rotation.
 * @returns         A function which is used for the animation.
 */
function gridFormation(length, center, scale, rotation) {
    // get the length of both sides of the grid! All grids want to be square
    var square = Math.floor(Math.sqrt(length));
    var xInc = 1 / square;
    var yInc = 1 / square;
    var startX = -xInc * (square - 1) * 0.5;
    var startY = (square - 1) / 2 * yInc;
    var row = 0;
    return function (index, outVec) {
        var x = startX + (index % square * xInc);
        var y = startY - row * yInc;
        outVec.set(x, y, 0).applyQuaternion(rotation);
        outVec.copy(center.clone().add(outVec.multiply(scale)));
        if (index % square === square - 1) {
            row++;
        }
    };
}
/**
 * A function which is used to transform meshes in a scale formation.
 * @param center  The center of the animation.
 * @param scale   The scale of the animation.
 * @returns       A function which is used for the animation.
 */
function scaleFormation(center, scale) {
    return function (_index, outVec, child) {
        child.getRuntimeData().updateMatrixWorld(true);
        outVec.setFromMatrixPosition(child.getRuntimeData().matrixWorld);
        var distVec = outVec.clone().sub(center);
        outVec.copy(center).add(distVec.multiply(scale));
    };
}
/**
 * Returns a function which is used to translate the mesh parts in a circle formation.
 * @param length    The number of items.
 * @param center    The center point of the meshes.
 * @param scale     The scale of the transformation.
 * @param rotation  The initial rotation
 * @returns         A function which takes an index and a
 */
function circleFormation(length, center, scale, rotation) {
    return function (index, outVec) {
        var x = center.x + (scale.x * Math.cos(2 * Math.PI * index / length));
        var y = center.y + (scale.y * Math.sin(2 * Math.PI * index / length));
        outVec.set(x, y, center.z).applyQuaternion(rotation);
    };
}
/**
 * Explodes your objects and their hierarchies into different formations. Great
 * for showing off parts in a model!
 * @vid exploder
 * @vname Exploder
 * @vreserved
 * @vdescription Explodes your objects and their hierarchies into different formations.
 *               Great for showing off parts in a model!
 * @vfilter object
 * @vcategory Animation
 */
var Exploder = (function (_super) {
    tslib_1.__extends(Exploder, _super);
    /**
     * Creates an instance of Exploder.
     */
    function Exploder() {
        var _this = _super.call(this) || this;
        _this.currentTime = 0;
        // dest and src positions
        _this.objects = [];
        _this.sources = [];
        _this.destinations = [];
        _this.direction = -1;
        return _this;
    }
    /** @inheritdoc */
    Exploder.prototype.onStartup = function () {
        // event listeners
        this.listenTo(this.getEntity(), 'playExplode', this.explode);
        this.listenTo(this.getEntity(), 'playContract', this.contract.bind(this));
        this.listenTo(this.getEntity(), 'toggleExplode', this.toggleExplode.bind(this));
        this.listenTo(this.getEntity(), 'resetExploder', this.reset.bind(this));
        this.listenTo(this.getEntity(), 'playCircleExplode', this.explode.bind(this, 'Circle'));
        this.listenTo(this.getEntity(), 'playGridExplode', this.explode.bind(this, 'Grid'));
        this.listenTo(this.getEntity(), 'playScaleExplode', this.explode.bind(this, 'Scale'));
    };
    /** @inheritdoc */
    Exploder.prototype.onUpdate = function (delta) {
        var _this = this;
        if (this.hasRuntimeData() && this.currentTime < this.time) {
            this.currentTime += delta;
            var percent_1 = this.currentTime > this.time ? 1.0 : makeEaseInOut(Math.max(0.0, Math.min(1.0, this.currentTime / this.time)));
            this.objects.forEach(function (obj, idx) {
                var dst = obj.runtimeData.parent.worldToLocal(tmpVec.copy(_this.destinations[idx])).clone();
                var srcPos = _this.direction > 0 ? _this.sources[idx] : dst;
                var destPos = _this.direction > 0 ? dst : _this.sources[idx];
                tmpVec.lerpVectors(srcPos, destPos, percent_1);
                obj.setPosition(tmpVec.x, tmpVec.y, tmpVec.z);
            });
            if (this.currentTime > this.time) {
                this.getEntity().trigger(this.direction > 0 ? 'endExplode' : 'endContract');
            }
        }
    };
    /**
     * Reset the component state.
     */
    Exploder.prototype.reset = function () {
        var _this = this;
        this.objects.forEach(function (obj, idx) {
            obj.setPosition(_this.sources[idx].x, _this.sources[idx].y, _this.sources[idx].z);
        });
        this.objects.length = 0;
        this.sources.length = 0;
        this.destinations.length = 0;
        this.currentTime = this.time;
    };
    /**
     * Begin contraction.
     */
    Exploder.prototype.contract = function () {
        if (!this.isEnabled()) {
            return;
        }
        this.direction = -1;
        this.currentTime = 0;
        this.getEntity().trigger('beginContract');
    };
    /**
     * Initiates explosion.
     * @param [formation] The formation to use.
     * @param [scale]     The scale for the transformation.
     */
    Exploder.prototype.explode = function (formation, scale) {
        var _this = this;
        if (!this.isEnabled()) {
            return;
        }
        this.reset();
        var children = this.getEntity().getDescendantsByType('mesh');
        var center = this.getEntity().getCenter();
        center.applyMatrix4(this.getRuntimeData().matrixWorld);
        var rotation = new THREE.Quaternion();
        rotation.setFromRotationMatrix(this.getRuntimeData().matrixWorld);
        var formationFunc = this.getFormationFunc(formation || this.formation, children.length, center, rotation, scale || this.scale).bind(this);
        // Explode each child mesh...
        children.forEach(function (childObject, idx) {
            formationFunc(idx, tmpVec, childObject);
            _this.objects.push(childObject);
            _this.sources.push(childObject.getPosition());
            _this.destinations.push(tmpVec.clone());
        });
        this.currentTime = 0;
        this.direction = 1;
        this.getEntity().trigger('beginExplode');
    };
    /**
     * Toggles the mode contraction/explosion.
     */
    Exploder.prototype.toggleExplode = function () {
        if (this.direction > 0) {
            this.contract();
        }
        else {
            this.explode();
        }
    };
    /**
     * Returns a function used to animate the mesh parts based on the provided formation enum.
     * @param formation The formation  to uses
     * @param length    The total number of items
     * @param center    The center point of the animation
     * @param rotation  The initial rotation
     * @param scale     The scale of the animation
     * @returns         A function which is used for animating the mesh parts
     */
    Exploder.prototype.getFormationFunc = function (formation, length, center, rotation, scale) {
        switch (formation) {
            case 'Grid':
                return gridFormation(length, center, scale, rotation);
            case 'Scale':
                return scaleFormation(center, scale);
            default:
            case 'Circle':
                return circleFormation(length, center, scale, rotation);
        }
    };
    return Exploder;
}(BaseComponent_1.default));
/**
 * Event definitions:
 * @vevent local playExplode {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent local playContract {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent local toggleExplode {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent local resetExploder {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent local playCircleExplode {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: [
 *     {
 *       name: 'Scale',
 *       type: 'v3',
 *       description: 'The scale to apply to the explosion',
 *       default: { x:1, y:1, z:1 }
 *     }
 *   ]
 * }
 * @vevent local playGridExplode {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: [
 *     {
 *       name: 'Scale',
 *       type: 'v3',
 *       description: 'The scale to apply to the explosion',
 *       default: { 'x':1, 'y':1, 'z':1 }
 *     }
 *   ]
 * }
 * @vevent local playScaleExplode {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: [
 *     {
 *       name: 'Scale',
 *       type: 'v3',
 *       description: 'The scale to apply to the explosion',
 *       default: { 'x':2, 'y':2, 'z':2 }
 *     }
 *   ]
 * }
 * @vevent other beginExplode {
 *   action: false,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent other endExplode {
 *   action: false,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent other beginContract {
 *   action: false,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent other endContract {
 *   action:false,
 *   category: 'Exploder',
 *   parameters: []
 * }
 */
exports.default = Exploder;


/***/ }),
/* 91 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/**
 * This will fullscreen the canvas' parent element, so your UI can be fullscreen as well!
 * If a selector is provided, then we will fullscreen that element instead.
 * @vid fullscreen
 * @vname Fullscreen
 * @vfilter application
 * @vdescription Harnesses the fullscreen API to make your app fullscreen!
 * @vcategory Rendering
 */
var BaseComponent_1 = __webpack_require__(2);
var Fullscreen = (function (_super) {
    tslib_1.__extends(Fullscreen, _super);
    /** Creates an instance of Fullscreen. */
    function Fullscreen() {
        var _this = _super.call(this) || this;
        _this.el = undefined;
        _this.fsEnabled = false;
        return _this;
    }
    /** @inheritdoc */
    Fullscreen.prototype.onStartup = function () {
        this.toggle = this.toggle.bind(this);
        this.getEntity().on('toggleFullscreen', this.toggle, this);
        this.listenTo(this.getGlobalEvents(), 'fullscreen::toggle', this.toggle);
        this.listenTo(this.getGlobalEvents(), 'fullscreen::enable', this.enableFullscreen);
        this.listenTo(this.getGlobalEvents(), 'fullscreen::disable', this.disableFullscreen);
    };
    /** Toggle fullscreen on and off */
    Fullscreen.prototype.toggle = function () {
        if (this.fsEnabled) {
            this.disableFullscreen();
        }
        else {
            this.enableFullscreen();
        }
    };
    /** Enables fullscreen mode */
    Fullscreen.prototype.enableFullscreen = function () {
        if (!this.el) {
            this.attachFullscreenAPI();
        }
        this.el.requestFullscreen();
        this.fsEnabled = true;
    };
    /** Disables fullscreen mode */
    Fullscreen.prototype.disableFullscreen = function () {
        if (!this.el) {
            this.attachFullscreenAPI();
        }
        if (this.fsEnabled) {
            document.exitFullscreen();
        }
        this.fsEnabled = false;
    };
    /**
     * Attaches all event listeners for fullscreen changes to the parent container element
     * of the Engine instance.
     */
    Fullscreen.prototype.attachFullscreenAPI = function () {
        this.el = this.getEngine().container;
        this.el.requestFullscreen = this.el.requestFullscreen || this.el.requestFullScreen ||
            this.el.mozRequestFullscreen || this.el.mozRequestFullScreen ||
            this.el.webkitRequestFullscreen || this.el.webkitRequestFullScreen ||
            this.el.msRequestFullscreen || this.el.msRequestFullScreen;
        document.exitFullscreen = document.exitFullscreen || document.exitFullScreen ||
            document.mozCancelFullscreen || document.mozCancelFullScreen ||
            document.webkitExitFullscreen || document.webkitExitFullScreen ||
            document.msExitFullscreen || document.msExitFullScreen;
        document.addEventListener('fullscreenchange', this.onFullscreenChange.bind(this), false);
        document.addEventListener('mozfullscreenchange', this.onFullscreenChange.bind(this), false);
        document.addEventListener('webkitfullscreenchange', this.onFullscreenChange.bind(this), false);
        document.addEventListener('msfullscreenchange', this.onFullscreenChange.bind(this), false);
    };
    /**
     * Trigger fullscreen change events on the runtime
     * @param event The event created by the DOM
     */
    Fullscreen.prototype.onFullscreenChange = function (event) {
        this.getGlobalEvents().trigger('fullscreen::change', event);
    };
    return Fullscreen;
}(BaseComponent_1.default));
/**
 * Event definitions:
 *
 * @vevent local toggleFullscreen {
 *   scope: 'local',
 *   action: true,
 *   category: 'Rendering',
 *   parameters: []
 * }
 */
exports.default = Fullscreen;


/***/ }),
/* 92 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var functions_1 = __webpack_require__(5);
/**
 * A component for animating an object based on gamepad input. e.g. a model of the gamepad or surrogate.
 * @vid gamepad_animator
 * @vname Gamepad Animator
 * @vfilter object
 * @vcategory Input
 */
var GamepadAnimator = (function (_super) {
    tslib_1.__extends(GamepadAnimator, _super);
    function GamepadAnimator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Array of structures that represent animation information of each button when fully pressed in local space.
         * @vattr array buttons {
         *   'type': 'a',
         *   'subType': {
         *      'type': 'a',
         *      'subType': {
         *        'type': 'custom',
         *        'attributes': {
         *          'mesh': {
         *            'type': 'object',
         *          },
         *          'movementType': {
         *            'type': 's',
         *            'default': 'translate'
         *          },
         *          'offset': {
         *            'type': 'v3'
         *          },
         *          'pivot': {
         *            'type': 'v3'
         *          },
         *          'rotation': {
         *            'type': 'v3'
         *          },
         *          'renderOnTouchOnly': {
         *            'type': 'b',
         *            'default': false
         *          }
         *        }
         *      },
         *      default: []
         *    },
         *    default: []
         * }
         */
        _this.buttons = [];
        /**
         * Array of structures that represent animation information of each axes when fully pressed in local space.
         * @vattr array axes {
         *   'type': 'a',
         *   'subType': {
         *      'type': 'a',
         *      'subType': {
         *        'type': 'custom',
         *        'attributes': {
         *          'mesh': {
         *            'type': 'object',
         *          },
         *          'movementType': {
         *            'type': 's',
         *            'default': 'translate'
         *          },
         *          'offset': {
         *            'type': 'v3'
         *          },
         *          'pivot': {
         *            'type': 'v3'
         *          },
         *          'rotation': {
         *            'type': 'v3'
         *          },
         *          'renderOnTouchOnly': {
         *            'type': 'b',
         *            'default': false
         *          }
         *        }
         *      },
         *      default: []
         *    },
         *    default: []
         * }
         */
        _this.axes = [];
        /** Internal vector for calculations */
        _this.workVector1 = new THREE.Vector3();
        /** Internal vector for calculations */
        _this.workVector2 = new THREE.Vector3();
        /** Internal quaternion for calculations */
        _this.workQuaternion1 = new THREE.Quaternion();
        /** Internal quaternion for calculations */
        _this.workQuaternion2 = new THREE.Quaternion();
        /** Internal euler rotation for calculations */
        _this.workEuler = new THREE.Euler();
        /** Map of mesh ID's to axes and buttons that are tied to that mesh. */
        _this.meshControlMap = {};
        /** Internal flag for whether the axes rendering needs to be updated. */
        _this.updateAxes = false;
        /** Internal flag for whether the rendering of each button needs to be updated. */
        _this.updateButtons = [];
        /** Internal reference to gamepad to be used for getting gamepad state. */
        _this.gamepadDevice = null;
        return _this;
    }
    /** @inheritdoc */
    GamepadAnimator.prototype.onUpdate = function (_delta) {
        var _this = this;
        if (!this.gamepadDevice) {
            this.gamepadDevice = this.getGamepadDevice();
            if (this.gamepadDevice) {
                this.listenTo(this.gamepadDevice, 'gamepadButtonChanged', this.onGamepadButtonEvent);
                this.listenTo(this.gamepadDevice, 'gamepadButtonTouched', this.onGamepadButtonEvent);
                this.listenTo(this.gamepadDevice, 'gamepadButtonReleased', this.onGamepadButtonEvent);
                this.listenTo(this.gamepadDevice, 'gamepadAxisChanged', this.onGamepadAxisEvent);
            }
        }
        this.updateButtons.forEach(function (update, idx) {
            if (update) {
                _this.updateButtonTransform(idx);
            }
        });
        // We only update the axes a maximum of once per frame by doing the update here
        // rather than in the event callback.
        if (this.updateAxes) {
            this.updateAxes = false;
            this.updateAxesTransforms();
        }
    };
    /**
     * Get an array of meshes linked to axes in this controller.
     * @param axisIndex The axis ID that you want the meshes for.
     * @returns         Array of meshes, indexed by axis number.
     */
    GamepadAnimator.prototype.getAxisMeshes = function (axisIndex) {
        return this.axes[axisIndex].map(function (buttonMovement) { return buttonMovement.mesh; });
    };
    /**
     * Get an array of meshes linked to buttons in this controller.
     * @param buttonIndex The button ID that you want the meshes for.
     * @returns           Array of meshes, indexed by button number.
     */
    GamepadAnimator.prototype.getButtonMeshes = function (buttonIndex) {
        return this.buttons[buttonIndex].map(function (buttonMovement) { return buttonMovement.mesh; });
    };
    /** @inheritdoc */
    GamepadAnimator.prototype.onAttributesChanged = function (changes) {
        var _this = this;
        if (changes.indexOf('axes') !== -1 || changes.indexOf('buttons') !== -1) {
            // Update mesh mapping that links a given mesh to the controls that are
            // associated with it.
            this.meshControlMap = {};
            this.axes.forEach(function (axis, axisIdx) {
                axis.forEach(function (movement, idx) {
                    var mesh = movement.mesh;
                    if (!mesh) {
                        return;
                    }
                    if (!_this.meshControlMap[mesh.id]) {
                        _this.meshControlMap[mesh.id] = { axes: [], axesMeshIdx: [], buttons: [], buttonMeshIdx: [] };
                    }
                    _this.meshControlMap[mesh.id].axes.push(axisIdx);
                    _this.meshControlMap[mesh.id].axesMeshIdx.push(idx);
                });
            });
            this.buttons.forEach(function (button, buttonIdx) {
                button.forEach(function (movement, idx) {
                    var mesh = movement.mesh;
                    if (!mesh) {
                        return;
                    }
                    // We don't need to create an entry for a mesh if only buttons are associated with it.
                    if (!_this.meshControlMap[mesh.id]) {
                        return;
                    }
                    _this.meshControlMap[mesh.id].buttons.push(buttonIdx);
                    _this.meshControlMap[mesh.id].buttonMeshIdx.push(idx);
                });
            });
        }
    };
    /**
     * Find and return the gamepad device associated with this component.
     * @returns The gamepad device, if any.
     */
    GamepadAnimator.prototype.getGamepadDevice = function () {
        if (this.gamepadDevice) {
            return this.gamepadDevice;
        }
        var ancestors = this.getEntity().getAncestors();
        // FIXME: Getting the component by script ID isn't correct. We want to get any
        // component of type GamepadDevice, including MotionGamepadDevice. Fix this when
        // we are able to query like that.
        var handControllerObj = ancestors.find(function (entity) {
            return !!entity.getComponentByScriptId('motion_gamepad_device');
        });
        if (!handControllerObj) {
            this.gamepadDevice = null;
            return null;
        }
        this.gamepadDevice = handControllerObj.getComponentByScriptId('motion_gamepad_device');
        return this.gamepadDevice;
    };
    /**
     * Callback for when any gamepad button is pressed, released, touched, etc.
     * @param gamepad   The gamepad responsible for the event
     * @param buttonIdx The index of the button responsible for the event.
     */
    GamepadAnimator.prototype.onGamepadButtonEvent = function (gamepadState, buttonIdx) {
        this.currentGamepadState = gamepadState;
        this.updateButtons[buttonIdx] = true;
    };
    /**
     * Update the button's position and orientation to indicate presses.
     * @param buttonIdx The index of the button on the controller.
     */
    GamepadAnimator.prototype.updateButtonTransform = function (buttonIdx) {
        var _this = this;
        var pressValue = this.currentGamepadState.buttons[buttonIdx].value;
        var movements = this.buttons[buttonIdx];
        movements.forEach(function (movement) {
            if (!movement.mesh) {
                return;
            }
            switch (movement.movementType) {
                case 'translate':
                    _this.workVector1.copy(movement.offset).multiplyScalar(pressValue);
                    movement.mesh.setPosition(_this.workVector1.x, _this.workVector1.y, _this.workVector1.z);
                    break;
                case 'rotate':
                    // Create quaternion for the rotation.
                    _this.workVector2.copy(movement.rotation).multiplyScalar(pressValue);
                    _this.workEuler.setFromVector3(_this.workVector2);
                    _this.workQuaternion1.setFromEuler(_this.workEuler);
                    // Move position to pivot point, rotate, and then move back.
                    _this.workVector1.copy(movement.pivot);
                    _this.workVector2.copy(_this.workVector1).multiplyScalar(-1);
                    _this.workVector2.applyQuaternion(_this.workQuaternion1);
                    _this.workVector2.add(_this.workVector1);
                    // Apply new position and rotation.
                    movement.mesh.setQuaternion(_this.workQuaternion1.x, _this.workQuaternion1.y, _this.workQuaternion1.z, _this.workQuaternion1.w);
                    movement.mesh.setPosition(_this.workVector2.x, _this.workVector2.y, _this.workVector2.z);
                    break;
                default:
                    break;
            }
            if (movement.renderOnTouchOnly) {
                if (_this.currentGamepadState.buttons[buttonIdx].hasOwnProperty('touched')) {
                    movement.mesh.setProperty('visible', _this.currentGamepadState.buttons[buttonIdx].touched);
                }
            }
        });
    };
    /**
     * Callback for when any gamepad button is pressed, released, touched, etc.
     * @param gamepad   The gamepad responsible for the event
     * @param axisIdx The index of the axis responsible for the event.
     */
    GamepadAnimator.prototype.onGamepadAxisEvent = function (gamepad, _axisIdx) {
        this.currentGamepadState = gamepad;
        this.updateAxes = true;
    };
    /**
     * Update all axes positions and orientations to indicate movement.
     */
    GamepadAnimator.prototype.updateAxesTransforms = function () {
        var _this = this;
        functions_1.forEach(this.meshControlMap, function (controls, meshId) {
            var mesh = _this.getEngine().getObjectById(meshId);
            if (!mesh) {
                return;
            }
            var movementType = _this.axes[0][controls.axesMeshIdx[0]].movementType;
            // Figure out the translation needed to move the mesh to the pivot point before
            // applying any rotation.
            // The shared mesh should probably always have the same pivot point for each axis.
            // If we assume that it does, we can remove the `reduce` here.
            _this.workVector1.set(0, 0, 0);
            controls.axes.reduce(function (prev, axisIdx, idx) {
                var axis = _this.axes[axisIdx][controls.axesMeshIdx[idx]];
                if (axis.movementType !== movementType) {
                    log.error("Can't perform multiple types of axis transformations on same mesh.");
                    return prev;
                }
                if (movementType === 'translate') {
                    var pressValue = _this.currentGamepadState.axes[axisIdx];
                    _this.workVector2.copy(axis.offset).multiplyScalar(pressValue);
                }
                else if (movementType === 'rotate') {
                    _this.workVector2.copy(axis.pivot).multiplyScalar(-1);
                }
                return prev.lerp(_this.workVector2, idx === 0 ? 1.0 : 0.5);
            }, _this.workVector1);
            _this.workQuaternion1.set(0, 0, 0, 1);
            if (movementType === 'rotate') {
                // Figure out the rotation of the mesh based on the combined rotation of each axis.
                controls.axes.reduce(function (prev, axisIdx, idx) {
                    var axis = _this.axes[axisIdx][controls.axesMeshIdx[idx]];
                    var pressValue = _this.currentGamepadState.axes[axisIdx];
                    _this.workVector2.copy(axis.rotation).multiplyScalar(pressValue);
                    _this.workEuler.setFromVector3(_this.workVector2);
                    _this.workQuaternion2.setFromEuler(_this.workEuler);
                    // If we're on the first axis, just use the pure rotation. Otherwise, slerp with
                    // the previous one. This assumes that we'll have a maximum of two axes for one mesh.
                    return prev.slerp(_this.workQuaternion2, idx === 0 ? 1.0 : 0.5);
                }, _this.workQuaternion1);
                // Copy the translation before rotating it.
                _this.workVector2.copy(_this.workVector1);
                // Rotate at the pivot point.
                _this.workVector1.applyQuaternion(_this.workQuaternion1);
                // Translate back away from pivot.
                _this.workVector2.multiplyScalar(-1);
                _this.workVector1.add(_this.workVector2);
            }
            mesh.setQuaternion(_this.workQuaternion1.x, _this.workQuaternion1.y, _this.workQuaternion1.z, _this.workQuaternion1.w);
            mesh.setPosition(_this.workVector1.x, _this.workVector1.y, _this.workVector1.z);
            // If the mesh is also shared by a button, handle the offset for the button here.
            // This code assumes only one button is associated with a mesh and that that
            // button only has one associated mesh. If this isn't the case at some point,
            // this should change.
            if (controls.buttons.length) {
                var buttonIdx = controls.buttons[0];
                var pressValue = _this.currentGamepadState.buttons[buttonIdx].value;
                var offset = _this.buttons[buttonIdx][0].offset;
                _this.workVector2.copy(offset).multiplyScalar(pressValue);
                _this.workVector2.applyQuaternion(_this.workQuaternion1);
                _this.workVector2.add(_this.workVector1);
                mesh.setPosition(_this.workVector2.x, _this.workVector2.y, _this.workVector2.z);
            }
        });
    };
    return GamepadAnimator;
}(BaseComponent_1.default));
exports.default = GamepadAnimator;


/***/ }),
/* 93 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid gamepad_input
 * @vname Gamepad Input
 * @vfilter application
 * @vcategory Input
 */
var GamepadInput = (function (_super) {
    tslib_1.__extends(GamepadInput, _super);
    function GamepadInput() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The state of all gamepads on the controller. */
        _this.gamepadStates = [];
        return _this;
    }
    /** @inheritDoc */
    GamepadInput.prototype.onPreUpdate = function (_delta) {
        if (!this.isEnabled()) {
            return;
        }
        if (!navigator.getGamepads) {
            return;
        }
        var gamepads = navigator.getGamepads();
        // getGamepads() doesn't return a regular array in Chrome so we need to iterate
        // with a for loop. Firefox does return a normal array.
        for (var i = 0; i < gamepads.length; i++) {
            // If the gamepad isn't there, skip over it. Because it may have been disconnected, nullify the state.
            if (!gamepads[i]) {
                this.gamepadStates[i] = null;
                continue;
            }
            // If the state hasn't been created yet, create it with default values and with an appropriate
            // number of button and axes.
            if (!this.gamepadStates[i]) {
                this.gamepadStates[i] = { buttonState: null, axesState: null };
                this.gamepadStates[i].buttonState = gamepads[i].buttons.map(function () {
                    return {
                        pressed: false,
                        touched: false,
                        value: 0
                    };
                });
                this.gamepadStates[i].axesState = gamepads[i].axes.map(function () { return 0; });
            }
            this.updateState(gamepads[i], this.gamepadStates[i]);
        }
    };
    /** Update the states of all controller buttons and fire appropriate events. */
    GamepadInput.prototype.updateState = function (gamepad, state) {
        var engine = this.getEngine();
        // For each axis, check if the value has changed and then fire an event if it has.
        gamepad.axes.forEach(function (axis, idx) {
            if (axis !== state.axesState[idx]) {
                state.axesState[idx] = axis;
                engine.trigger('gamepadAxisChanged', gamepad);
            }
        });
        // For each button, check if its value has changed and fire an event if it has.
        gamepad.buttons.forEach(function (but, idx) {
            var button = but; // FIXME: When type defs for Gamepad extensions are released
            if (button.pressed !== state.buttonState[idx].pressed) {
                state.buttonState[idx].pressed = button.pressed;
                var eventName = state.buttonState[idx].pressed ?
                    'gamepadButtonDown' : 'gamepadButtonUp';
                engine.trigger(eventName, gamepad, idx);
            }
            if (button.value !== state.buttonState[idx].value) {
                state.buttonState[idx].value = button.value;
                engine.trigger('gamepadButtonChanged', gamepad, idx);
            }
            if (button.touched !== state.buttonState[idx].touched) {
                state.buttonState[idx].touched = button.touched;
                var eventName = state.buttonState[idx].touched ?
                    'gamepadButtonTouched' : 'gamepadButtonReleased';
                engine.trigger(eventName, gamepad, idx);
            }
        });
    };
    return GamepadInput;
}(BaseComponent_1.default));
exports.default = GamepadInput;


/***/ }),
/* 94 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* tslint:disable max-classes-per-file */
/* tslint:disable max-file-line-count */
/* tslint:disable no-string-literal */
/* tslint:disable prefer-literal */

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var BaseComponent_1 = __webpack_require__(2);
var InputEvent_1 = __webpack_require__(204);
var UserAgent_1 = __webpack_require__(22);
var THREE = __webpack_require__(1);
// Amount of time to wait, is milliseconds, for a double tap to occur. Used on Mobile Devices
var doubleTapTime = 300;
var percents = {
    scenePercentX: 0,
    scenePercentY: 0
};
var pos = {
    sceneX: 0,
    sceneY: 0
};
exports.keyCodes = {
    tab: 9,
    shift: 16,
    ctrl: 17,
    alt: 18,
    esc: 27,
    space: 32,
    rightArrow: 39,
    leftArrow: 37,
    upArrow: 38,
    downArrow: 40,
    delete: 46,
    0: 48,
    1: 49,
    2: 50,
    3: 51,
    4: 52,
    5: 53,
    6: 54,
    7: 55,
    8: 56,
    9: 57,
    a: 65,
    b: 66,
    c: 67,
    d: 68,
    e: 69,
    f: 70,
    g: 71,
    h: 72,
    i: 73,
    j: 74,
    k: 75,
    l: 76,
    m: 77,
    n: 78,
    o: 79,
    p: 80,
    q: 81,
    r: 82,
    s: 83,
    t: 84,
    u: 85,
    v: 86,
    w: 87,
    x: 88,
    y: 89,
    z: 90,
    A: 65,
    B: 66,
    C: 67,
    D: 68,
    E: 69,
    F: 70,
    G: 71,
    H: 72,
    I: 73,
    J: 74,
    K: 75,
    L: 76,
    M: 77,
    N: 78,
    O: 79,
    P: 80,
    Q: 81,
    R: 82,
    S: 83,
    T: 84,
    U: 85,
    V: 86,
    W: 87,
    X: 88,
    Y: 89,
    Z: 90,
    cmd: 91,
    numpad_0: 96,
    numpad_1: 97,
    numpad_2: 98,
    numpad_3: 99,
    numpad_4: 100,
    numpad_5: 101,
    numpad_6: 102,
    numpad_7: 103,
    numpad_8: 104,
    numpad_9: 105,
    '>': 187,
    '<': 188,
    _: 189,
    '.': 190,
    '/': 191,
    '[': 219,
    ']': 221
};
/**
 * The Box3D input component.
 * @vid input
 * @vname Input
 * @vfilter application
 * @vcategory Input
 */
var Input = (function (_super) {
    tslib_1.__extends(Input, _super);
    /** Creates an instance of Input. */
    function Input() {
        var _this = _super.call(this) || this;
        /** A mapping of string identifier to mouse button number. */
        _this.mouseButtons = { left: 0, middle: 1, right: 2 };
        _this.inputQueue = [];
        _this.inputPool = [];
        _this.mouseButtonState = new Array(3);
        _this.mouseButtonStatePrevious = new Array(3);
        _this.mousePosition = new THREE.Vector2();
        _this.mousePositionPercent = new THREE.Vector2();
        _this.mousePreviousPosition = new THREE.Vector2();
        _this.mouseDragState = new Array(3);
        _this.mouseDragStatePrevious = new Array(3);
        _this.mouseDragDistance = [
            new THREE.Vector2(),
            new THREE.Vector2(),
            new THREE.Vector2()
        ];
        _this.touchPosition = new THREE.Vector2();
        _this.touchPositionPercent = new THREE.Vector2();
        _this.touchPreviousPosition = new THREE.Vector2();
        _this.touchDragState = false;
        _this.touchDragStatePrevious = false;
        // Double tap handling
        _this.doubleTapHandle = null;
        _this.doubleTapPosition = new THREE.Vector2();
        _this.listenForTouchStart = false;
        _this.listenForTouchEnd = false;
        _this.touchesStart = [];
        _this.keyState = new Array(256);
        _this.keyStatePrevious = new Array(256);
        _this.canvas = null;
        _this.pointerLockEnabled = false;
        return _this;
    }
    /**
     * Checks whether a specified mouse button is down.
     * @param button The name of the button
     * @returns      True if the button is down
     */
    Input.prototype.mouseButtonDown = function (button) {
        if (button === 'any') {
            for (var i in this.mouseButtons) {
                if (this.mouseButtonState[this.mouseButtons[i]]) {
                    return true;
                }
            }
            return false;
        }
        return this.mouseButtonState[this.mouseButtons[button]];
    };
    /**
     * Checks whether the specified mouse button is up.
     * @param button The name of the button
     * @returns      True if the button is up
     */
    Input.prototype.mouseButtonUp = function (button) {
        return !this.mouseButtonState[this.mouseButtons[button]];
    };
    /**
     * Checks whether the mouse button has been pressed.
     * @param button The name of the button
     * @returns      True if the button has been pressed
     */
    Input.prototype.mouseButtonPressed = function (button) {
        return this.mouseButtonState[this.mouseButtons[button]] &&
            !this.mouseButtonStatePrevious[this.mouseButtons[button]] ? true : false;
    };
    /**
     * Checks whether the specified button has been released.
     * @param button The name of the button
     * @returns      True if the button has been released
     */
    Input.prototype.mouseButtonReleased = function (button) {
        return !this.mouseButtonState[this.mouseButtons[button]] &&
            this.mouseButtonStatePrevious[this.mouseButtons[button]] ? true : false;
    };
    /**
     * Checks whether the specified key has been pressed.
     * @param key The key
     * @returns   True if the key has been pressed
     */
    Input.prototype.keyPressed = function (key) {
        return this.keyState[exports.keyCodes[key]] &&
            !this.keyStatePrevious[exports.keyCodes[key]] ? true : false;
    };
    /**
     * Checks whether the specified key has been released.
     * @param key The key
     * @returns   True if the key has been pressed
     */
    Input.prototype.keyReleased = function (key) {
        return !this.keyState[exports.keyCodes[key]] &&
            this.keyStatePrevious[exports.keyCodes[key]] ? true : false;
    };
    /**
     * Checks whether the specified key is down.
     * @param key The key
     * @returns   True if the key has been pressed
     */
    Input.prototype.keyDown = function (key) {
        return !!this.keyState[exports.keyCodes[key]];
    };
    /**
     * Checks whether the specified key is up.
     * @param key The key
     * @returns   True if the key has been pressed
     */
    Input.prototype.keyUp = function (key) {
        return !this.keyState[exports.keyCodes[key]];
    };
    /**
     * Get the current drag state of the mouse
     * @param button The key for the button who's drag state we're checking.
     *               'left', 'right' or 'middle'. Uses left mouse button
     *               by default
     * @returns      True if the current state is dragging
     */
    Input.prototype.getMouseDragState = function (button) {
        return this.mouseDragState[this.mouseButtons[button || 'left']];
    };
    /**
     * Get the previous drag state of the mouse
     * @param button The key for the button who's drag state we're checking.
     *               'left', 'right' or 'middle'. Uses left mouse button
     *               by default
     * @returns      True if the previous state is dragging
     */
    Input.prototype.getPreviousMouseDragState = function (button) {
        return this.mouseDragStatePrevious[this.mouseButtons[button || 'left']];
    };
    /**
     * Get the current drag state of touch input
     * @returns True if current state is dragging
     */
    Input.prototype.getTouchDragState = function () {
        return this.touchDragState;
    };
    /**
     * Get the previous drag state of touch input
     * @returns {Bool} True if previous state is dragging
     */
    Input.prototype.getPreviousTouchDragState = function () {
        return this.touchDragStatePrevious;
    };
    /** Enables browser pointer lock. */
    Input.prototype.enablePointerLock = function () {
        this.pointerLockEnabled = true;
        this.canvas.requestPointerLock();
    };
    /** Disables browser pointer lock. */
    Input.prototype.disablePointerLock = function () {
        this.pointerLockEnabled = false;
        document.exitPointerLock();
    };
    /** Toggles browser pointer lock. */
    Input.prototype.togglePointerLock = function () {
        if (this.pointerLockEnabled) {
            this.enablePointerLock();
        }
        else {
            this.disablePointerLock();
        }
    };
    /** @inheritdoc */
    Input.prototype.onStartup = function () {
        this.canvas = this.getEngine().canvas;
        this.canvas.requestPointerLock = this.canvas.requestPointerLock ||
            this.canvas['mozRequestPointerLock'] ||
            this.canvas['webkitRequestPointerLock'];
        document.exitPointerLock = document.exitPointerLock ||
            document['mozExitPointerLock'] ||
            document['webkitExitPointerLock'];
        this.clearKeyStates = this.clearKeyStates.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseWheel = this.onMouseWheel.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
        this.onContextMenu = this.onContextMenu.bind(this);
        this.onKeyDown = this.onKeyDown.bind(this);
        this.onKeyUp = this.onKeyUp.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.onTouchCancel = this.onTouchCancel.bind(this);
        this.onTouchLeave = this.onTouchLeave.bind(this);
        this.onTouchMove = this.onTouchMove.bind(this);
        this.onDoubleClick = this.onDoubleClick.bind(this);
        this.onDoubleTap = this.onDoubleTap.bind(this);
        window.addEventListener('blur', this.clearKeyStates, false);
        if (this.isEnabled()) {
            if (this.mouseEvents.enable) {
                this.enableMouseEvents();
            }
            if (this.keyEvents.enable) {
                this.enableKeyEvents();
            }
            if (this.touchEvents.enable) {
                this.enableTouchEvents();
            }
        }
    };
    /** @inheritdoc */
    Input.prototype.onPreUpdate = function () {
        if (this.isEnabled()) {
            while (this.inputQueue.length > 0) {
                this.getEngine().trigger(this.inputQueue[0].name, this.inputQueue[0].event);
                this.recycleInputEvent(this.inputQueue.splice(0, 1)[0]);
            }
        }
    };
    /** @inheritdoc */
    Input.prototype.onPostUpdate = function () {
        if (this.isEnabled()) {
            if (this.keyEvents.enable) {
                for (var code = 0; code < this.keyState.length; code++) {
                    this.keyStatePrevious[code] = this.keyState[code];
                }
            }
            if (this.mouseEvents.enable) {
                for (var id = 0; id < this.mouseButtonState.length; id++) {
                    this.mouseButtonStatePrevious[id] = this.mouseButtonState[id];
                    this.mouseDragStatePrevious[id] = this.mouseDragState[id];
                }
                this.mousePreviousPosition.x = this.mousePosition.x;
                this.mousePreviousPosition.y = this.mousePosition.y;
            }
            if (this.touchEvents.enable) {
                this.touchDragStatePrevious = this.touchDragState;
            }
        }
    };
    /** @inheritdoc */
    Input.prototype.onShutdown = function () {
        if (this.canvas) {
            this.canvas.removeEventListener('touchstart', this.onTouchStart);
            this.canvas.removeEventListener('touchend', this.onTouchEnd);
            this.canvas.removeEventListener('touchcancel', this.onTouchCancel);
            this.canvas.removeEventListener('touchleave', this.onTouchLeave);
            this.canvas.removeEventListener('touchmove', this.onTouchMove);
            this.canvas.removeEventListener('mousemove', this.onMouseMove);
            document.removeEventListener('mouseup', this.onMouseUp);
            this.canvas.removeEventListener('mousedown', this.onMouseDown);
            this.canvas.removeEventListener('wheel', this.onMouseWheel);
            document.removeEventListener('keydown', this.onKeyDown);
            document.removeEventListener('keyup', this.onKeyUp);
            document.body.removeEventListener('mouseleave', this.onMouseLeave);
            this.canvas.removeEventListener('contextmenu', this.onContextMenu);
            this.canvas.removeEventListener('dblclick', this.onDoubleClick);
            this.canvas.removeEventListener('touchstart', this.onDoubleTap);
        }
        this.mouseButtonState = undefined;
        this.mouseButtonStatePrevious = undefined;
        this.mouseDragState = undefined;
        this.mouseDragStatePrevious = undefined;
        this.mousePosition = undefined;
        this.mousePreviousPosition = undefined;
        this.touchPosition = undefined;
        this.touchPreviousPosition = undefined;
        this.keyState = undefined;
        this.keyStatePrevious = undefined;
    };
    /**
     * If output is passed in, append scenePercent properties to it.
     * @param mouseEvent  The browser mouse event
     * @param output      An object which will be mutated and returned
     * @returns           The object passed in as output
     */
    Input.prototype.getScenePercent = function (mouseEvent, output) {
        var actualOutput = output || percents;
        this.getScenePos(mouseEvent, mouseEvent);
        actualOutput['scenePercentX'] = mouseEvent.sceneX / this.getEngine().getRenderer().getWidth();
        actualOutput['scenePercentY'] = mouseEvent.sceneY / this.getEngine().getRenderer().getHeight();
        return actualOutput;
    };
    /**
     * If output is passed in, we are going to append sceneX and sceneY properties to it
     * @param mouseEvent  The browser mouse event
     * @param output      An object
     * @returns
     */
    Input.prototype.getScenePos = function (mouseEvent, output) {
        var actualOutput = output || pos;
        var rect = mouseEvent.target.getBoundingClientRect();
        var top = rect.top + document.body.scrollTop;
        var left = rect.left + document.body.scrollLeft;
        actualOutput['sceneX'] = mouseEvent.clientX - left;
        actualOutput['sceneY'] = mouseEvent.clientY - top;
        return actualOutput;
    };
    /** If mouse enabled, turn on specific listeners. */
    Input.prototype.enableMouseEvents = function () {
        if (this.mouseEvents.move) {
            this.canvas.addEventListener('mousemove', this.onMouseMove);
        }
        if (this.mouseEvents.down) {
            this.canvas.addEventListener('mousedown', this.onMouseDown);
        }
        if (this.mouseEvents.scroll) {
            this.canvas.addEventListener('wheel', this.onMouseWheel);
        }
        if (this.mouseEvents.doubleClick) {
            this.canvas.addEventListener('dblclick', this.onDoubleClick);
        }
        document.body.addEventListener('mouseleave', this.onMouseLeave);
        this.canvas.addEventListener('contextmenu', this.onContextMenu);
    };
    /** If keys enabled, turn on specific listeners. */
    Input.prototype.enableKeyEvents = function () {
        if (this.keyEvents.down) {
            document.addEventListener('keydown', this.onKeyDown);
        }
        if (this.keyEvents.up) {
            document.addEventListener('keyup', this.onKeyUp);
        }
    };
    /** If touches enabled, turn on specific listeners */
    Input.prototype.enableTouchEvents = function () {
        if (this.touchEvents.start) {
            this.canvas.addEventListener('touchstart', this.onTouchStart);
        }
        if (this.touchEvents.end) {
            this.canvas.addEventListener('touchend', this.onTouchEnd);
        }
        if (this.touchEvents.doubleTap) {
            this.canvas.addEventListener('touchstart', this.onDoubleTap);
        }
        if (this.touchEvents.cancel) {
            this.canvas.addEventListener('touchcancel', this.onTouchCancel);
        }
        if (this.touchEvents.leave) {
            this.canvas.addEventListener('touchleave', this.onTouchLeave);
        }
        if (this.touchEvents.move) {
            this.canvas.addEventListener('touchmove', this.onTouchMove);
        }
    };
    /** Clears the internal key state. */
    Input.prototype.clearKeyStates = function () {
        if (this.keyState) {
            for (var code = 0; code < this.keyState.length; ++code) {
                this.keyState[code] = false;
            }
        }
    };
    /**
     * Handles mouse movement events.
     * @param e The mouse event
     */
    Input.prototype.onMouseMove = function (e) {
        this.getScenePercent(e, e);
        this.mousePosition.x = e.sceneX || e.clientX;
        this.mousePosition.y = e.sceneY || e.clientY;
        this.mousePositionPercent.x = e.scenePercentX;
        this.mousePositionPercent.y = e.scenePercentY;
        e.mouseDelta = {
            x: e.movementX || e.mozMovementX || e.webkitMovementX || 0,
            y: e.movementY || e.mozMovementY || e.webkitMovementY || 0
        };
        if (!e.mouseDelta.y && !e.mouseDelta.x) {
            e.mouseDelta.x = (this.mousePosition.x - this.mousePreviousPosition.x);
            e.mouseDelta.y = (this.mousePosition.y - this.mousePreviousPosition.y);
        }
        e.scenePercentDeltaX = e.mouseDelta.x / this.getEngine().getRenderer().getWidth();
        e.scenePercentDeltaY = e.mouseDelta.y / this.getEngine().getRenderer().getHeight();
        for (var b = 0; b < this.mouseButtonState.length; b++) {
            if (this.mouseButtonState[b] === true) {
                this.mouseDragDistance[b].x += e.mouseDelta.x;
                this.mouseDragDistance[b].y += e.mouseDelta.y;
                var distance = this.mouseDragDistance[b];
                // Drag state check
                if (distance.x * distance.x + distance.y * distance.y >
                    this.mouseEvents.dragBufferDistance) {
                    this.mouseDragState[b] = true;
                }
            }
            else {
                this.mouseDragState[b] = false;
            }
        }
        this.inputQueue.push(this.getInputEvent(e, 'mouseMove'));
    };
    /**
     * Handles mouse down events.
     * @param e The mouse event
     */
    Input.prototype.onMouseDown = function (e) {
        this.getScenePercent(e, e);
        if (!this.mouseUpBound) {
            this.mouseUpBound = true;
            document.addEventListener('mouseup', this.onMouseUp);
        }
        Array.prototype.forEach.call(document.querySelectorAll('input, textarea, select, option'), function (el) {
            el.blur();
        });
        if (this.mouseEvents.preventDownDefault) {
            e.preventDefault();
        }
        this.mouseButtonState[e.button] = true;
        this.inputQueue.push(this.getInputEvent(e, 'mouseDown'));
        if (this.mouseEvents.eventHandler) {
            var button = this.getKeyByValue(this.mouseButtons, e.button);
            if (button) {
                this.getGlobalEvents().trigger('mouse_down_' + button);
            }
        }
    };
    /**
     * Handles mouse up events.
     * @param e The mouse event
     */
    Input.prototype.onMouseUp = function (e) {
        this.getScenePercent(e, e);
        this.mouseButtonState[e.button] = false;
        this.mouseDragState[e.button] = false;
        this.mouseDragDistance[e.button].x = 0;
        this.mouseDragDistance[e.button].y = 0;
        if (this.mouseButtonUp('left') &&
            this.mouseButtonUp('right') &&
            this.mouseButtonUp('middle')) {
            this.mouseUpBound = false;
            document.removeEventListener('mouseup', this.onMouseUp);
        }
        this.inputQueue.push(this.getInputEvent(e, 'mouseUp'));
        if (this.mouseEvents.eventHandler) {
            var button = this.getKeyByValue(this.mouseButtons, e.button);
            if (button) {
                this.getGlobalEvents().trigger('mouse_up_' + button);
            }
        }
    };
    /**
     * Handles double click events.
     * @param e The mouse event
     */
    Input.prototype.onDoubleClick = function (e) {
        this.getScenePercent(e, e);
        Array.prototype.forEach.call(document.querySelectorAll('input, textarea, select, option'), function (el) {
            el.blur();
        });
        this.inputQueue.push(this.getInputEvent(e, 'doubleClick'));
    };
    /**
     * Handles mouse wheel events.
     * @param e The mouse event
     */
    Input.prototype.onMouseWheel = function (e) {
        if (this.mouseEvents.preventScrollDefault) {
            e.preventDefault();
        }
        var delta;
        if (e.wheelDeltaY !== undefined) {
            delta = 1 / 40 * e.wheelDeltaY;
        }
        else if (UserAgent_1.isIE()) {
            delta = -e.deltaY / 40;
        }
        else {
            delta = -e.deltaY;
        }
        this.inputQueue.push(this.getInputEvent(delta, 'mouseScroll'));
    };
    /**
     * Handles mouse leave events.
     * @param e The mouse event
     */
    Input.prototype.onMouseLeave = function (e) {
        for (var _i = 0, _a = this.mouseButtonState; _i < _a.length; _i++) {
            var buttonState = _a[_i];
            // If a button is down, force the up event
            if (buttonState) {
                this.onMouseUp(e);
            }
        }
        this.clearKeyStates();
    };
    /**
     * Handles the context menu event.
     * @param e The mouse event
     */
    Input.prototype.onContextMenu = function (e) {
        if (this.mouseEvents.preventContextMenuDefault) {
            e.preventDefault();
        }
        this.inputQueue.push(this.getInputEvent(e, 'contextMenu'));
    };
    /**
     * Handles the keydown keyboard event.
     * @param e The keyboard event
     */
    Input.prototype.onKeyDown = function (e) {
        if (document.activeElement && (document.activeElement.getAttribute('contenteditable') === 'true' ||
            document.activeElement.tagName === 'DIV' ||
            document.activeElement.tagName === 'INPUT' ||
            document.activeElement.tagName === 'SELECT' ||
            document.activeElement.tagName === 'OPTION' ||
            document.activeElement.tagName === 'TEXTAREA')) {
            return;
        }
        if (this.keyEvents.preventDefault) {
            e.preventDefault();
        }
        this.keyState[e.keyCode] = true;
        this.inputQueue.push(this.getInputEvent(e, 'keyDown'));
        if (this.keyEvents.eventHandler) {
            var button = this.getKeyByValue(exports.keyCodes, e.keyCode);
            if (button) {
                this.getGlobalEvents().trigger('keypress_' + button);
            }
        }
    };
    /**
     * Handles the keyup keyboard event.
     * @param e The keyboard event
     */
    Input.prototype.onKeyUp = function (e) {
        this.keyState[e.keyCode] = false;
        this.inputQueue.push(this.getInputEvent(e, 'keyUp'));
    };
    /**
     * Handles the touch start touch event.
     * @param e The touch event
     */
    Input.prototype.onTouchStart = function (e) {
        if (this.touchEvents.preventStartDefault) {
            e.preventDefault();
        }
        var event = this.onTouchEvent(e, 'touchStart');
        this.touchesStart = event.touches;
        if (event.touches.length) {
            this.touchPosition.x = event.touches[event.touches.length - 1].sceneX;
            this.touchPosition.y = event.touches[event.touches.length - 1].sceneY;
            this.touchPositionPercent.x = event.touches[event.touches.length - 1].scenePercentX;
            this.touchPositionPercent.y = event.touches[event.touches.length - 1].scenePercentY;
        }
        if (this.touchEvents.eventHandler) {
            this.getGlobalEvents().trigger('touch_start');
        }
    };
    /**
     * Handles the touch end touch event.
     * @param e The touch event
     */
    Input.prototype.onTouchEnd = function (e) {
        if (this.touchEvents.preventEndDefault) {
            e.preventDefault();
        }
        this.touchDragState = false;
        this.onTouchEvent(e, 'touchEnd');
        if (this.touchEvents.eventHandler) {
            this.getGlobalEvents().trigger('touch_end');
        }
    };
    /**
     * Mobile device support for double click
     * @param e The event passed from the DOM event handler
     */
    Input.prototype.onDoubleTap = function (e) {
        // If any events, make sure position doesn't change EVER!
        if ((this.listenForTouchStart || this.listenForTouchEnd) &&
            this.doubleTapPosition.distanceTo(this.touchPosition) > this.touchEvents.dragBufferDistance) {
            this.clearDoubleTapState();
            return;
        }
        // Initial touch down, listen for up
        if (!this.listenForTouchStart && !this.listenForTouchEnd) {
            this.doubleTapPosition.copy(this.touchPosition);
            this.clearDoubleTapState();
            // Listen for next touch release to signify first tap completion
            this.canvas.addEventListener('touchend', this.onDoubleTap);
            this.listenForTouchEnd = true;
        }
        else if (!this.listenForTouchStart && this.listenForTouchEnd) {
            this.clearDoubleTapState();
            this.listenForTouchStart = true;
        }
        else if (this.listenForTouchStart && !this.listenForTouchEnd) {
            this.clearDoubleTapState();
            this.listenForTouchStart = true;
            this.listenForTouchEnd = true;
            // Last release refers to final touch completion
            this.canvas.addEventListener('touchend', this.onDoubleTap);
        }
        else {
            this.clearDoubleTapState();
            // Add to queue that will be flushed on next update
            this.onTouchEvent(e, 'doubleTap');
        }
        // Setup a deadline for the state transition to occur!
        this.doubleTapHandle = setTimeout(this.clearDoubleTapState.bind(this), doubleTapTime);
    };
    /** Clear and reset handles for double tap events. */
    Input.prototype.clearDoubleTapState = function () {
        clearTimeout(this.doubleTapHandle);
        this.doubleTapHandle = null;
        this.listenForTouchStart = false;
        this.listenForTouchEnd = false;
        this.canvas.removeEventListener('touchend', this.onDoubleTap);
    };
    /**
     * Handles the touchcancel touch event.
     * @param e The touch event
     */
    Input.prototype.onTouchCancel = function (e) {
        if (this.touchEvents.preventCancelDefault) {
            e.preventDefault();
        }
        this.touchDragState = false;
        var event = {};
        event.originalEvent = e;
        event.touches = [];
        this.inputQueue.push(this.getInputEvent(event, 'touchCancel'));
    };
    /**
     * Handles the touchleave touch event.
     * @param e The touch event
     */
    Input.prototype.onTouchLeave = function (e) {
        if (this.touchEvents.preventLeaveDefault) {
            e.preventDefault();
        }
        this.touchDragState = false;
        this.onTouchEvent(e, 'touchLeave');
    };
    /**
     * Handles the touchmove touch event.
     * @param e The touch event
     */
    Input.prototype.onTouchMove = function (e) {
        if (this.touchEvents.preventMoveDefault) {
            e.preventDefault();
        }
        var event = {};
        event.originalEvent = e;
        event.touches = [];
        for (var i = 0; i < e.touches.length; ++i) {
            var touchObj = {};
            this.getScenePos(e.touches[i], touchObj);
            this.getScenePercent(e.touches[i], touchObj);
            touchObj.originalTouch = e.touches[i];
            if (this.touchesStart[i] && this.distance(e.touches[i], this.touchesStart[i]) >
                this.touchEvents.dragBufferDistance) {
                this.touchDragState = true;
            }
            event.touches.push(touchObj);
        }
        // assign final touch to the position value
        if (event.touches.length) {
            this.touchPosition.x = event.touches[event.touches.length - 1].sceneX;
            this.touchPosition.y = event.touches[event.touches.length - 1].sceneY;
            this.touchPositionPercent.x = event.touches[event.touches.length - 1].scenePercentX;
            this.touchPositionPercent.y = event.touches[event.touches.length - 1].scenePercentY;
        }
        // TODO need touch drag distance state
        this.inputQueue.push(this.getInputEvent(event, 'touchMove'));
    };
    /**
     * Calculates positional data for touch events and adds the events to the
     * input queue.
     * @param e         The touch event
     * @param eventName The name of the event
     * @returns         The touch event
     */
    Input.prototype.onTouchEvent = function (e, eventName) {
        var event = {};
        event.originalEvent = e;
        event.touches = [];
        for (var i = 0; i < e.touches.length; ++i) {
            var touchObj = {};
            // save pos and percents to object
            this.getScenePos(e.touches[i], touchObj);
            this.getScenePercent(e.touches[i], touchObj);
            touchObj.originalTouch = e.touches[i];
            event.touches.push(touchObj);
        }
        this.inputQueue.push(this.getInputEvent(event, eventName));
        // if we need to do something with the end result (ie: touch start)
        return event;
    };
    /**
     * Recycles a used input event to reduce garbage collection churn.
     * @param obj The input event to recycle
     */
    Input.prototype.recycleInputEvent = function (obj) {
        obj.name = null;
        obj.event = null;
        this.inputPool.push(obj);
    };
    /**
     * Gets a recycled input event. In the case where none exist, a new one will be
     * created.
     * @param event The raw input event
     * @param name  The event name
     * @returns     The wrapped input event
     */
    Input.prototype.getInputEvent = function (event, name) {
        if (this.inputPool.length === 0) {
            this.inputPool.push(new InputEvent_1.default());
        }
        var vEvent = this.inputPool.pop();
        vEvent.event = event;
        vEvent.name = name;
        return vEvent;
    };
    /**
     * Determines the distance between two event locations.
     * @param eventA The first event
     * @param eventB The second event
     * @returns      The distance between the events
     */
    Input.prototype.distance = function (eventA, eventB) {
        var dx = eventA['sceneX'] - eventB['sceneX'];
        var dy = eventA['sceneY'] - eventB['sceneY'];
        return Math.sqrt(dx * dx + dy * dy);
    };
    /**
     * Gets the key of an object by the given value.
     * @param obj   The object to search
     * @param value The value
     * @returns     The key, if found
     */
    Input.prototype.getKeyByValue = function (obj, value) {
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop) && obj[prop] === value) {
                return prop;
            }
        }
        Logger_1.default.warn('Value not present in object: ', value);
        return null;
    };
    return Input;
}(BaseComponent_1.default));
exports.Input = Input;
/* tslint:disable max-line-length */
/**
 * Event Definitions:
 *
 * @vevent global mouse_down_left { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
 * @vevent global mouse_down_right { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
 * @vevent global mouse_down_middle { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
 * @vevent global mouse_up_left { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
 * @vevent global mouse_up_right { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
 * @vevent global mouse_up_middle { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
 * @vevent global keypress_a { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_b { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_c { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_d { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_f { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_g { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_e { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_h { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_i { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_j { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_k { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_l { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_m { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_n { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_o { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_p { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_q { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_r { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_s { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_t { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_u { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_v { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_w { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_x { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_y { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_z { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_up_arrow { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_down_arrow { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_left_arrow { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_right_arrow { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global keypress_space { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
 * @vevent global touch_start { 'scope': 'global', 'action': false, 'category':'Input - Touch', 'parameters': [] }
 * @vevent global touch_end { 'scope': 'global', 'action': false, 'category':'Input - Touch', 'parameters': [] }
 */
/* tslint:enable max-line-length */
exports.default = Input;


/***/ }),
/* 95 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var functions_1 = __webpack_require__(5);
/**
 * @vid intersection_checker
 * @vname Intersection Checker
 * @vfilter object
 * @vcategory Tools
 * This component checks if the entity that it's attached to intersects with any
 * other objects. It can be configured to filter the checked objects, the type of
 * intersection and when the intersection checks occur.
 */
var IntersectionChecker = (function (_super) {
    tslib_1.__extends(IntersectionChecker, _super);
    function IntersectionChecker() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * Array of type names to check for intersection with.
         * @vattr string[] objectTypeFilter { default: [] }
         */
        _this.objectTypeFilter = [];
        /**
         * The radius (in meters) around this object to use for checking object
         * intersection (overrides using this object's regular bounding sphere)
         * @vattr integer boundingSphereOverrideRadius { default: -1 }
         */
        _this.boundingSphereOverrideRadius = -1;
        /**
         * Option to stop checking intersections after the first one. True by default.
         * This means that only one intersection event will be fired for each check.
         * @vattr boolean firstIntersectionOnly { default: true }
         */
        _this.firstIntersectionOnly = true;
        /**
         * Option to turn on visualization of intersection sphere for this object.
         * @vattr boolean debugVisualization { default: false }
         */
        _this.debugVisualization = false;
        /** Current list of objects being intersected with (as of the most recent check). */
        _this.currentIntersections = {};
        /** Previous list of objects being intersected with (as of the second most recent check). */
        _this.previousIntersections = {};
        /** Internal matrix for calculations. */
        _this.workMatrix = new THREE.Matrix4();
        /** Internal sphere for calculations. */
        _this.workBoundsSphere = new THREE.Sphere();
        /** Internal box3 for calculations. */
        _this.workBoundingBox = new THREE.Box3();
        /** Internal sphere geometry for rendering debug visualization. */
        _this.sphereGeometry = new THREE.SphereGeometry(1);
        return _this;
    }
    /** @inheritdoc */
    IntersectionChecker.prototype.onAwake = function () {
        this.sphereMesh = new THREE.Mesh(this.sphereGeometry, new THREE.MeshBasicMaterial({ wireframe: true, color: 0x0000ff }));
    };
    /** @inheritdoc */
    IntersectionChecker.prototype.onStartup = function () {
        var _this = this;
        this.sourceBoundingSphere = new THREE.Sphere();
        this.sceneRoot = this.getEntity().getRootObject();
        this.sceneRoot.when('loadBase', function (scene) { return scene.runtimeData.add(_this.sphereMesh); });
    };
    /**
     * Check intersection of the hand controllers with objects in the scene
     * and then trigger intersection events.
     */
    IntersectionChecker.prototype.checkIntersection = function () {
        var _this = this;
        // Get a list of the objects to check.
        var objectList = this.generateObjectList();
        // Get the hand controller to check against.
        var thisObject = this.getRuntimeData();
        if (!thisObject) {
            return;
        }
        // Get the collision for this object in world space.
        if (this.getRuntimeData()) {
            this.getEntity().getSphericalBounds(this.sourceBoundingSphere);
            this.sourceBoundingSphere.center.setFromMatrixPosition(this.getRuntimeData().matrixWorld);
            if (this.boundingSphereOverrideRadius >= 0) {
                this.sourceBoundingSphere.radius = this.boundingSphereOverrideRadius;
            }
        }
        // Update the position of the bounding sphere visualization.
        if (this.sceneRoot.isBaseLoaded()) {
            if (this.sphereMesh) {
                this.sphereMesh.position.copy(this.sourceBoundingSphere.center);
                this.sphereMesh.scale.set(this.sourceBoundingSphere.radius, this.sourceBoundingSphere.radius, this.sourceBoundingSphere.radius);
            }
        }
        // Find the intersections, compare them to the previous check and fire
        // appropriate events.
        this.previousIntersections = this.currentIntersections;
        this.currentIntersections = {};
        if (this.firstIntersectionOnly) {
            var intersectObj = objectList.find(this.intersectObject.bind(this));
            if (intersectObj) {
                if (!this.previousIntersections[intersectObj.id]) {
                    this.trigger('beginIntersection', intersectObj);
                    this.getEntity().trigger('beginIntersection', intersectObj);
                }
                this.currentIntersections[intersectObj.id] = intersectObj;
            }
        }
        else {
            var intersections = objectList.filter(this.intersectObject.bind(this));
            intersections.forEach(function (intersectObj) {
                if (!_this.previousIntersections[intersectObj.id]) {
                    _this.trigger('beginIntersection', intersectObj);
                    _this.getEntity().trigger('beginIntersection', intersectObj);
                }
                _this.currentIntersections[intersectObj.id] = intersectObj;
            });
        }
        // Fire the endIntersection events when an object was previously being intersected
        // with but isn't anymore.
        functions_1.forEach(this.previousIntersections, function (intersectObj) {
            if (!_this.currentIntersections[intersectObj.id]) {
                _this.trigger('endIntersection', intersectObj);
                _this.getEntity().trigger('endIntersection', intersectObj);
            }
        });
        return this.currentIntersections;
    };
    /** @inheritdoc */
    IntersectionChecker.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('debugVisualization') !== -1) {
            this.sphereMesh.visible = this.debugVisualization;
        }
    };
    /** @inheritdoc */
    IntersectionChecker.prototype.onPreUpdate = function () {
        if (this.checkIntersectionAlways) {
            this.checkIntersection();
        }
    };
    /**
     * Compile a list of objects in the scene that will be checked against based
     * on the settings in this component.
     * @returns An array of objects to check against.
     */
    IntersectionChecker.prototype.generateObjectList = function () {
        var _this = this;
        if (this.objectFilter.length) {
            return this.objectFilter;
        }
        var objectList = [];
        this.sceneRoot.traverseSome(function (obj) {
            // If the object is this one, don't continue traversing this branch.
            if (obj === _this.getEntity()) {
                return true;
            }
            if (_this.objectTypeFilter.length && !_this.objectTypeFilter.some(function (type) { return obj.type === type; })) {
                return false;
            }
            objectList.push(obj);
        });
        return objectList;
    };
    /**
     * Intersect the current world space controller sphere with the given
     * object.
     * @param object  The object to check intersection with.
     * @returns       Whether or not the controller intersects with the object.
     */
    IntersectionChecker.prototype.intersectObject = function (object) {
        var threeObj = object.runtimeData;
        if (!threeObj) {
            return false;
        }
        // Since box3's are AABB, transform collider into the
        // same space as the mesh to do a test against mesh bounding box.
        this.workMatrix.getInverse(threeObj.matrixWorld);
        // Move source collision to same space as target shape.
        this.workBoundsSphere.copy(this.sourceBoundingSphere);
        this.workBoundsSphere.applyMatrix4(this.workMatrix);
        object.getBounds(this.workBoundingBox);
        return this.workBoundingBox.intersectsSphere(this.workBoundsSphere);
    };
    return IntersectionChecker;
}(BaseComponent_1.default));
exports.default = IntersectionChecker;


/***/ }),
/* 96 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseComponent_1 = __webpack_require__(2);
var MaterialAsset_1 = __webpack_require__(14);
/**
 * @vid light_environment
 * @vname Light Environment
 * @vcategory Rendering
 * @vfilter scene
 */
var LightEnvironment = (function (_super) {
    tslib_1.__extends(LightEnvironment, _super);
    /** Creates an instance of LightEnvironment. */
    function LightEnvironment() {
        var _this = _super.call(this) || this;
        _this.setupMaterial = _this.setupMaterial.bind(_this);
        return _this;
    }
    /** @inheritdoc */
    LightEnvironment.prototype.onAwake = function () {
        var _this = this;
        this.listenTo(this.getEngine(), 'entityCreated', function (entity) {
            if (entity instanceof MaterialAsset_1.default) {
                _this.setupMaterial(entity);
            }
        });
    };
    /** @inheritdoc */
    LightEnvironment.prototype.onAttributesChanged = function (_attributes) {
        this.setupAllMaterials();
    };
    /** @inheritdoc */
    LightEnvironment.prototype.onDisable = function () {
        this.getEngine().getAssetsByClass(MaterialAsset_1.default).forEach(function (material) {
            material.setProperty('envMapIrradiance', null);
            material.setProperty('envMapRadianceHalfGloss', null);
            material.setProperty('envMapRadiance', null);
        });
    };
    /** @inheritdoc */
    LightEnvironment.prototype.onEnable = function () {
        this.setupAllMaterials();
    };
    /**
     * Setup lighting for all materials. e.g. assigning IBL textures, disabling
     * scene lighting, etc.
     */
    LightEnvironment.prototype.setupAllMaterials = function () {
        this.getEngine().getAssetsByClass(MaterialAsset_1.default).forEach(this.setupMaterial);
    };
    /**
     * Setup lighting for the given material. e.g. assigning IBL textures, disabling
     * scene lighting, etc.
     * @param materialAsset
     */
    LightEnvironment.prototype.setupMaterial = function (materialAsset) {
        if (!materialAsset || !this.isEnabled()) {
            return;
        }
        materialAsset.setProperty('envMapIrradiance', this.getAttribute('irradianceMap'));
        materialAsset.setProperty('envMapRadiance', this.getAttribute('radianceMap'));
        materialAsset.setProperty('envMapRadianceHalfGloss', this.getAttribute('radianceMapHalfGloss'));
    };
    return LightEnvironment;
}(BaseComponent_1.default));
exports.default = LightEnvironment;


/***/ }),
/* 97 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var BaseObject_1 = __webpack_require__(10);
// tslint:disable max-line-length
/**
 * @vid look_at_target
 * @vname Look At Target
 * @vdescription A component that automatically points the object at a target. This can be used for billboarding an object to the camera, making a character look at another, etc.
 * @vcategory General
 * @vfilter Object
 */
// tslint:enable max-line-length
var LookAtTarget = (function (_super) {
    tslib_1.__extends(LookAtTarget, _super);
    function LookAtTarget() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** Whether or not the look-at functionality is currently running. */
        _this.playing = true;
        return _this;
    }
    /** @inheritdoc */
    LookAtTarget.prototype.onStartup = function () {
        this.tempVec = new THREE.Vector3();
        this.tempMatrix = new THREE.Matrix4();
        this.tempQuaternion = new THREE.Quaternion();
    };
    /** @inheritdoc */
    LookAtTarget.prototype.onAttributesChanged = function (_changes) {
        if (!this.playing) {
            var entity = this.getEntity();
            if (entity instanceof BaseObject_1.default) {
                this.getRuntimeData().position.copy(entity.getPosition());
                this.getRuntimeData().quaternion.copy(entity.getQuaternion());
            }
        }
    };
    /** @inheritdoc */
    LookAtTarget.prototype.onEnable = function () {
        this.playing = true;
    };
    /** @inheritdoc */
    LookAtTarget.prototype.onDisable = function () {
        this.playing = false;
        var entity = this.getEntity();
        if (entity instanceof BaseObject_1.default) {
            this.getRuntimeData().position.copy(entity.getPosition());
            this.getRuntimeData().quaternion.copy(entity.getQuaternion());
        }
    };
    /** @inheritdoc */
    LookAtTarget.prototype.onPostUpdate = function () {
        var runtimeData;
        if (this.hasRuntimeData() && this.playing && this.isEnabled()) {
            runtimeData = this.getRuntimeData();
            if (this.target && this.target.runtimeData) {
                this.getEngine().needsRender = true;
                var lookAtObject = this.target.runtimeData;
                this.tempVec.setFromMatrixPosition(lookAtObject.matrixWorld);
                if (runtimeData.parent) {
                    this.tempMatrix.getInverse(runtimeData.parent.matrixWorld);
                }
                else {
                    this.tempMatrix.identity();
                }
                this.tempVec.applyMatrix4(this.tempMatrix);
                if (this.local) {
                    runtimeData.lookAt(this.tempVec);
                    var entity = this.getEntity();
                    if (entity instanceof BaseObject_1.default) {
                        runtimeData.quaternion.multiply(entity.getQuaternion());
                    }
                }
                else {
                    runtimeData.lookAt(this.tempVec);
                }
            }
        }
    };
    /** @inheritdoc */
    LookAtTarget.prototype.onShutdown = function () {
        // make sure to clean up any events or other bindings that you have created
        // to avoid memory leaks
    };
    return LookAtTarget;
}(BaseComponent_1.default));
exports.default = LookAtTarget;


/***/ }),
/* 98 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-string-literal */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var LightObject_1 = __webpack_require__(37);
var sceneRadius = 0.5;
var sphereTessellation = 36;
var sceneNear = 1;
var sceneFar = 80;
/**
 * @vid material_capture
 * @vname Material Capture
 * @vfilter material
 * @vcategory Rendering
 * @vdescription A component that captures an image of a rendered material as a spherical map, complete
 *               with lighting. This image can then be applied (with a sphere map projection) to a mesh to achieve
 *               convincing material shading (although the mesh will appear with the same lighting from all directions).
 */
var MaterialCapture = (function (_super) {
    tslib_1.__extends(MaterialCapture, _super);
    /** Creates an instance of MaterialCapture. */
    function MaterialCapture() {
        var _this = _super.call(this) || this;
        _this.createScene();
        return _this;
    }
    /**
     * Setup lighting for rendering the material capture using lighting
     * from the given scene.
     * @param scene The scene to copy lighting info from.
     */
    MaterialCapture.prototype.setLightingFromThreeScene = function (scene) {
        var _this = this;
        this.resetSceneLighting();
        scene.traverse(function (light) {
            if (light instanceof THREE.Light) {
                _this.scene.add(light.clone());
            }
        });
        this.captureScene();
    };
    /**
     * Setup lighting for rendering the material capture using lighting
     * from the given scene.
     * @param scene The scene object to copy lighting info from.
     */
    MaterialCapture.prototype.setLightingFromScene = function (scene) {
        var _this = this;
        this.resetSceneLighting();
        scene.getDescendantsByClass(LightObject_1.default).forEach(function (light) {
            if (light.isUnloaded()) {
                light.loadBase();
            }
            _this.scene.add(light.getRuntimeData().clone());
        });
        this.captureScene();
    };
    /** @inheritdoc */
    MaterialCapture.prototype.onAwake = function () {
        this.listenTo(this.getEntity(), 'change:properties', this.onMaterialChanges);
    };
    /** @inheritdoc */
    MaterialCapture.prototype.onEnable = function () {
        this.captureScene();
    };
    /** @inheritdoc */
    MaterialCapture.prototype.onAttributesChanged = function (changes) {
        var _this = this;
        if (changes.indexOf('captureTexture') !== -1) {
            this.getEntity().on('load', function () {
                _this.captureScene();
            });
            if (this.getEntity().isLoaded()) {
                this.captureScene();
            }
        }
    };
    /**
     * Called when properties of the material asset change.
     * @param properties The changed property values for the entity.
     */
    MaterialCapture.prototype.onMaterialChanges = function (_properties) {
        this.captureScene();
    };
    /** Creates the scene and camera used to render the material capture. */
    MaterialCapture.prototype.createScene = function () {
        this.camera = new THREE.OrthographicCamera(-sceneRadius, sceneRadius, sceneRadius, -sceneRadius, sceneNear, sceneFar);
        this.scene = new THREE.Scene();
        this.createGeometry();
        this.scene.add(this.sphereMesh);
        this.scene.add(this.planeMesh);
        this.scene.add(this.camera);
        // Move the camera a significant fraction of the far clip plane away from the sphere.
        // This will get the camera vector within the shader closer to the ideal orthographic
        // projection that they should be. This won't be necessary when we support true, ortho
        // camera vectors in our shaders.
        this.camera.position.z = sceneFar * 0.5;
        // Also bump the xy position of the camera to get better lighting in the capture.
        // This obviously depends on the environment map setup so this should be made into a
        // component attribute at some point.
        this.camera.position.y = sceneFar * 0.25;
        this.camera.position.x = sceneFar * 0.25;
        this.camera.lookAt(new THREE.Vector3(0, 0, 0));
        this.planeMesh.lookAt(this.camera.position);
    };
    /** Create the geometry and meshes needed to render the matcap texture. */
    MaterialCapture.prototype.createGeometry = function () {
        this.geometry =
            new THREE.SphereBufferGeometry(sceneRadius, sphereTessellation, sphereTessellation);
        this.planeGeometry = new THREE.PlaneBufferGeometry(sceneRadius * 2, 2);
        // Adjust the plane's normals to point outward so they kind of match the edge of the sphere
        var xyLength = Math.sqrt(0.5);
        // FIXME: square bracket notation to avoid type error, is this an actual bug or an issue with the
        // typings?
        var normalBuffer = this.planeGeometry.attributes['normal'];
        // TODO - this should just copy the position array...
        normalBuffer.array = new Float32Array([-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]);
        for (var i = 0; i < normalBuffer.array.length; i++) {
            normalBuffer.array[i] *= xyLength;
        }
        this.sphereMesh = new THREE.Mesh(this.geometry);
        this.planeMesh = new THREE.Mesh(this.planeGeometry);
    };
    /** Reset (remove) all lights from the internal material capture scene. */
    MaterialCapture.prototype.resetSceneLighting = function () {
        var lights = [];
        this.scene.traverse(function (light) {
            if (light instanceof THREE.Light) {
                lights.push(light);
            }
        });
        lights.forEach(function (light) {
            light.parent.remove(light);
        });
    };
    /**
     * Render the scene to the texture
     * @method captureScene
     * @private
     * @return {void}
     */
    MaterialCapture.prototype.captureScene = function () {
        var _this = this;
        if (!this.isEnabled()) {
            return;
        }
        var threeMaterial = this.getRuntimeData().static;
        this.sphereMesh.material = threeMaterial;
        this.planeMesh.material = threeMaterial;
        var renderer = this.getThreeRenderer();
        if (this.captureTexture) {
            this.captureTexture.when('load', function (textureAsset) {
                renderer.render(_this.scene, _this.camera, textureAsset.runtimeData);
            });
            if (!this.captureTexture.isLoaded()) {
                this.captureTexture.load();
            }
        }
    };
    return MaterialCapture;
}(BaseComponent_1.default));
exports.default = MaterialCapture;


/***/ }),
/* 99 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-string-literal */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var NormalMapGeneratorVert = __webpack_require__(224);
var NormalMapGeneratorFrag = __webpack_require__(223);
/**
 * @vid normal_map_generator
 * @vname Normal Map Generator
 * @vcategory Rendering
 * @vfilter renderTexture2D
 */
var NormalMapGenerator = (function (_super) {
    tslib_1.__extends(NormalMapGenerator, _super);
    function NormalMapGenerator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The uniforms used by the shader. */
        _this.uniforms = {
            bumpTexture: {
                type: 't',
                value: null
            },
            resolution: {
                type: 'v2',
                value: new THREE.Vector2(256, 256)
            },
            smoothness: {
                type: 'f',
                value: 0.25
            },
            spread: {
                type: 'f',
                value: 4.0
            }
        };
        /** The shader material used to render the normal map. */
        _this.normalMaterial = null;
        /** True if the component has been initialized and is ready. */
        _this.initialized = false;
        return _this;
    }
    /**
     * Renders the normal map into the supplied texture asset.
     *
     * @param [smoothness] The smoothness value to use.
     */
    NormalMapGenerator.prototype.renderNormalMap = function (smoothness) {
        if (!this.isEnabled() || !this.sceneRTT) {
            return;
        }
        if (smoothness !== undefined) {
            this.uniforms['smoothness'].value = smoothness;
        }
        var renderer = this.getThreeRenderer();
        renderer.render(this.sceneRTT, this.cameraRTT, this.getEntity().runtimeData, true);
        renderer.setRenderTarget(null);
    };
    /** @inheritdoc */
    NormalMapGenerator.prototype.onStartup = function () {
        this.listenTo(this.getEntity(), 'renderNormalMap', this.renderNormalMap);
        // create noise material
        this.normalMaterial = new THREE.ShaderMaterial({
            uniforms: this.uniforms,
            vertexShader: NormalMapGeneratorVert,
            fragmentShader: NormalMapGeneratorFrag,
            blending: THREE.NoBlending
        });
        this.normalMaterial.depthTest = false;
        this.normalMaterial.depthWrite = false;
        this.cameraRTT = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10, 10);
        this.cameraRTT.position.z = 1;
        this.sceneRTT = new THREE.Scene();
        this.sceneRTT.add(this.cameraRTT);
        this.quadGeo = new THREE.PlaneGeometry(1, 1);
        this.quadRTT = new THREE.Mesh(this.quadGeo, this.normalMaterial);
        this.quadRTT.position.z = -5;
        this.sceneRTT.add(this.quadRTT);
        this.initialized = true;
    };
    /** @inheritdoc */
    NormalMapGenerator.prototype.onShutdown = function () {
        if (this.sceneRTT) {
            this.sceneRTT.remove(this.cameraRTT);
            this.sceneRTT.remove(this.quadRTT);
        }
        if (this.quadGeo) {
            this.quadGeo.dispose();
        }
        if (this.normalMaterial) {
            this.normalMaterial.dispose();
        }
        this.quadRTT = undefined;
        this.sceneRTT = undefined;
        this.uniforms = undefined;
    };
    /** @inheritdoc */
    NormalMapGenerator.prototype.onEntityReady = function () {
        var _this = this;
        this.updateUniforms(function () {
            if (_this.autoLoad) {
                _this.renderNormalMap();
            }
        });
    };
    /** @inheritdoc */
    NormalMapGenerator.prototype.onAttributesChanged = function () {
        var _this = this;
        if (this.initialized) {
            this.updateUniforms(function () {
                _this.renderNormalMap();
            });
        }
    };
    /**
     * Updates the uniforms based on the state of the component attributes.
     * @param callback A function which will be called upon completion.
     */
    NormalMapGenerator.prototype.updateUniforms = function (callback) {
        var _this = this;
        this.uniforms['smoothness'].value = this.smoothness;
        this.uniforms['spread'].value = this.spread;
        if (this.bumpTexture) {
            if (this.bumpTexture.runtimeData) {
                this.uniforms['bumpTexture'].value = this.bumpTexture.runtimeData;
                this.uniforms['resolution'].value.set(this.bumpTexture.getWidth(), this.bumpTexture.getHeight());
                if (typeof callback === 'function') {
                    callback();
                }
            }
            else {
                this.bumpTexture.once('load', function () {
                    _this.uniforms['bumpTexture'].value = _this.bumpTexture.runtimeData;
                    _this.uniforms['resolution'].value.set(_this.bumpTexture.getWidth(), _this.bumpTexture.getHeight());
                    if (typeof callback === 'function') {
                        callback();
                    }
                }, this);
                this.bumpTexture.load();
            }
        }
    };
    return NormalMapGenerator;
}(BaseComponent_1.default));
/**
 * Event definitions:
 *
 * @vevent local renderNormalMap {
 *   action: true,
 *   category: 'Rendering',
 *   parameters: []
 * }
 */
exports.default = NormalMapGenerator;


/***/ }),
/* 100 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-file-line-count */
/* tslint:disable no-param-reassign */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid object_animator
 * @vname Object Animator
 * @vcategory Animation
 * @vfilter Object
 */
var ObjectAnimator = (function (_super) {
    tslib_1.__extends(ObjectAnimator, _super);
    function ObjectAnimator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** True if the animation is currently playing. */
        _this.playingCurveAnimation = false;
        return _this;
    }
    /** @inheritdoc */
    ObjectAnimator.prototype.onStartup = function () {
        this.getEntity().on('playAnimateAlongCurve', this.animateAlongCurve, this);
        this.getEntity().on('playAnimateToObject', this.animateToObject, this);
        this.getEntity().on('playAnimateTranslation', this.animateTranslation, this);
        this.getEntity().on('playAnimateRotation', this.animateRotation, this);
        this.getEntity().on('playAnimateScale', this.animateScale, this);
        this.getEntity().on('pauseCurveAnimation', this.onPauseCurveAnimation, this);
        this.getEntity().on('unpauseCurveAnimation', this.onUnpauseCurveAnimation, this);
        this.getEntity().on('stopCurveAnimation', this.stopCurveAnimation, this);
    };
    /** @inheritdoc */
    ObjectAnimator.prototype.onShutdown = function () {
        this.getEntity().off('playAnimateAlongCurve', this.animateAlongCurve, this);
        this.getEntity().off('playAnimateToObject', this.animateToObject, this);
        this.getEntity().off('playAnimateTranslation', this.animateTranslation, this);
        this.getEntity().off('playAnimateRotation', this.animateRotation, this);
        this.getEntity().off('playAnimateScale', this.animateScale, this);
        this.getEntity().off('pauseCurveAnimation', this.onPauseCurveAnimation, this);
        this.getEntity().off('unpauseCurveAnimation', this.onUnpauseCurveAnimation, this);
        this.getEntity().off('stopCurveAnimation', this.stopCurveAnimation, this);
    };
    /** @inheritdoc */
    ObjectAnimator.prototype.onDisable = function () {
        this.getRuntimeData().position.copy(this.getEntity().getPosition());
        this.getRuntimeData().quaternion.copy(this.getEntity().getQuaternion());
        this.getRuntimeData().scale.copy(this.getEntity().getScale());
    };
    /** Stops the animation. */
    ObjectAnimator.prototype.stopCurveAnimation = function () {
        this.getEngine().off('update', this.curveAnim, this);
        this.curveAnim = undefined;
    };
    /**
     * Starts animating along a curve.
     * @param curveObjectId The object id which has the curve component
     * @param animationTime The amount of time to animate
     * @param easeIn        The percentage of the animation which should be eased in (between 0.0 and 1.0)
     * @param easeOut       The percentage of the animation which should be eased out (between 0.0 and 1.0)
     * @param orientation   Whether or not the animate the orientation of the object
     * @param loop          Whether or not to loop the animation
     */
    ObjectAnimator.prototype.animateAlongCurve = function (curveObjectId, animationTime, easeIn, easeOut, orientation, loop) {
        var _this = this;
        var engine = this.getEngine();
        var curveComponent;
        var curveObject;
        if (curveObjectId) {
            curveObject = this.getEngine().getEntityById(curveObjectId);
            curveComponent = curveObject.getComponentByScriptId('curve');
        }
        if (!curveComponent) {
            return;
        }
        var runtimeData = this.getRuntimeData();
        var currentTime = 0;
        var curveProgressPercent = 0.0;
        var tempVector1 = new THREE.Vector3();
        var tempVector2 = new THREE.Vector3();
        var tempVector3 = new THREE.Vector3();
        var tempMatrix = new THREE.Matrix4();
        var prevQuaternion = new THREE.Quaternion();
        var nextQuaternion = new THREE.Quaternion();
        var fullSpeedTime = 1.0 - easeIn - easeOut;
        var fullSpeed = 1.0 / (easeIn / 2 + easeOut / 2 + fullSpeedTime);
        var currentPrevNode = -1;
        var currentNextNode = -1;
        var curveAnim = function (delta) {
            if (!_this.getEntity() || !_this.isEnabled()) {
                engine.off('update', _this.curveAnim, _this);
                _this.curveAnim = undefined;
                return;
            }
            if (curveComponent && _this.playingCurveAnimation) {
                _this.getEngine().needsRender = true;
                currentTime += delta;
                var currentTimePercent = currentTime / animationTime;
                if (currentTimePercent >= 1.0) {
                    currentTimePercent -= 1.0;
                }
                var easeOutStart = 1 - easeOut;
                // Ease in
                if (easeIn && currentTimePercent < easeIn) {
                    var easeInProgress = currentTimePercent / easeIn;
                    curveProgressPercent += delta * fullSpeed / animationTime *
                        (Math.cos(easeInProgress * Math.PI + Math.PI) * 0.5 + 0.5);
                }
                else if (easeOut && currentTimePercent > easeOutStart) {
                    // Ease out
                    var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;
                    curveProgressPercent += delta * fullSpeed / animationTime *
                        Math.max(Math.cos(easeOutProgress * Math.PI + Math.PI) * 0.5 + 0.5, 0.0);
                }
                else {
                    // Full speed animation
                    curveProgressPercent += delta * fullSpeed / animationTime;
                }
                // If the animation is finished
                if (curveProgressPercent >= 1.0 || curveProgressPercent < 0.0) {
                    curveProgressPercent %= 1.0;
                    currentTime = 0.0;
                    if (!loop) {
                        curveProgressPercent = 0.99999999;
                        _this.playingCurveAnimation = false;
                        _this.getEngine().off('update', _this.curveAnim, _this);
                        _this.curveAnim = undefined;
                    }
                    _this.getEntity().trigger('endAnimateAlongCurve');
                }
                var curve = curveComponent.curve;
                var curveProgressNodeRelative = curve.getUtoTmapping(curveProgressPercent);
                runtimeData.position.copy(curve.getPoint(curveProgressNodeRelative));
                if (orientation === 'toCurve') {
                    var tangent = curve.getTangent(curveProgressNodeRelative);
                    tempVector1.set(0, -1, 0);
                    tempVector2.crossVectors(tangent, tempVector1);
                    tempVector3.crossVectors(tangent, tempVector2);
                    tempVector1.copy(runtimeData.position);
                    tempVector1.add(tangent);
                    tempMatrix.lookAt(runtimeData.position, tempVector1, tempVector3);
                    runtimeData.quaternion.setFromRotationMatrix(tempMatrix);
                }
                else if (orientation === 'toNode') {
                    var curveSegments = curveComponent.closed ? curve.points.length : curve.points.length - 1;
                    var prevNode = Math.floor(curveProgressNodeRelative * curveSegments);
                    var nextNode = Math.ceil(curveProgressNodeRelative * curveSegments) %
                        curve.points.length;
                    if (prevNode !== currentPrevNode) {
                        if (prevNode > 0) {
                            curveComponent.controlPoints[prevNode].getQuaternionInWorldSpace(prevQuaternion);
                        }
                        else {
                            curveComponent.controlPoints[0].getQuaternionInWorldSpace(prevQuaternion);
                        }
                    }
                    if (nextNode !== currentNextNode) {
                        if (nextNode > 0) {
                            curveComponent.controlPoints[nextNode].getQuaternionInWorldSpace(nextQuaternion);
                        }
                        else {
                            curveComponent.controlPoints[0].getQuaternionInWorldSpace(nextQuaternion);
                        }
                    }
                    var interp = curveProgressNodeRelative * curveSegments - prevNode;
                    runtimeData.quaternion.copy(prevQuaternion);
                    runtimeData.quaternion.slerp(nextQuaternion, interp);
                }
            }
        };
        if (easeIn + easeOut > 1.0) {
            Logger_1.default.warn('Ease-In and Ease-Out value can\'t total more than 1.0.');
            easeIn = 0.5;
            easeOut = 0.5;
        }
        if (animationTime > 0) {
            this.playingCurveAnimation = true;
            if (curveComponent.isCurveInit()) {
                this.curveAnim = curveAnim;
                this.getEngine().on('update', this.curveAnim, this);
            }
            else {
                curveComponent.on('curveInit', function () {
                    _this.curveAnim = curveAnim;
                    _this.getEngine().on('update', _this.curveAnim, _this);
                }, this);
            }
        }
    };
    /** Handles animation pause event. */
    ObjectAnimator.prototype.onPauseCurveAnimation = function () {
        this.playingCurveAnimation = false;
    };
    /** Handles animation unpause event. */
    ObjectAnimator.prototype.onUnpauseCurveAnimation = function () {
        this.playingCurveAnimation = true;
    };
    /**
     * Animates towards another object.
     * @param objectId      The other object id
     * @param animationTime The amount of time to animate
     * @param easeIn        The percentage of the animation which should be eased in (between 0.0 and 1.0)
     * @param easeOut       The percentage of the animation which should be eased out (between 0.0 and 1.0)
     * @param orientation   Whether or not to animate the orientation of the object
     */
    ObjectAnimator.prototype.animateToObject = function (objectId, animationTime, easeIn, easeOut, orientation) {
        var _this = this;
        var engine = this.getEngine();
        var animateTo = function (threeObject) {
            var entityData = _this.getRuntimeData();
            var tempMatrix = new THREE.Matrix4();
            var currTime = 0;
            var curveProgressPercent = 0.0;
            if (easeIn + easeOut > 1.0) {
                Logger_1.default.warn('Ease-In and Ease-Out value can\'t total more than 1.0.');
                easeIn = 0.5;
                easeOut = 0.5;
            }
            var fullSpeedTime = 1.0 - easeIn - easeOut;
            var fullSpeed = 1.0 / (easeIn / 2 + easeOut / 2 + fullSpeedTime);
            var startPos = new THREE.Vector3();
            var startQuat;
            startPos.copy(entityData.position);
            var targetPosition = threeObject.position;
            var targetQuaternion = threeObject.quaternion;
            if (targetQuaternion && orientation) {
                startQuat = new THREE.Quaternion();
                startQuat.copy(entityData.quaternion);
            }
            threeObject.updateMatrixWorld(true);
            targetPosition.setFromMatrixPosition(threeObject.matrixWorld);
            tempMatrix.extractRotation(threeObject.matrixWorld);
            targetQuaternion.setFromRotationMatrix(tempMatrix);
            if (animationTime > 0) {
                var objAnim_1 = function (delta) {
                    if (!_this.getEntity() || !_this.isEnabled()) {
                        engine.off('update', objAnim_1, _this);
                        return;
                    }
                    _this.getEngine().needsRender = true;
                    currTime += delta;
                    var currentTimePercent = currTime / animationTime;
                    var easeOutStart = 1 - easeOut;
                    if (easeIn && currentTimePercent < easeIn) {
                        // Ease in
                        var easeInProgress = currentTimePercent / easeIn;
                        curveProgressPercent += delta * fullSpeed / animationTime *
                            (Math.cos(easeInProgress * Math.PI + Math.PI) * 0.5 + 0.5);
                    }
                    else if (easeOut && currentTimePercent > easeOutStart) {
                        // Ease out
                        var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;
                        curveProgressPercent += delta * fullSpeed / animationTime *
                            Math.max(Math.cos(easeOutProgress * Math.PI + Math.PI) * 0.5 + 0.5, 0.0);
                    }
                    else {
                        // Full speed animation
                        curveProgressPercent += delta * fullSpeed / animationTime;
                    }
                    // clamp at 1
                    curveProgressPercent = Math.min(curveProgressPercent, 1.0);
                    if (curveProgressPercent >= 1.0 || curveProgressPercent < 0.0) {
                        _this.getEngine().off('update', objAnim_1, _this);
                        _this.getEntity().trigger('endAnimateToObject');
                    }
                    entityData.position.copy(startPos);
                    entityData.position.lerp(targetPosition, curveProgressPercent);
                    if (targetQuaternion && orientation) {
                        entityData.quaternion.copy(startQuat);
                        entityData.quaternion.slerp(targetQuaternion, curveProgressPercent);
                    }
                };
                _this.getEngine().on('update', objAnim_1, _this);
            }
            else {
                entityData.position.copy(targetPosition);
                if (targetQuaternion) {
                    entityData.quaternion.copy(targetQuaternion);
                }
                // complete
                _this.getEntity().trigger('endAnimateToObject');
            }
        };
        var object = this.getEngine().getEntityById(objectId);
        if (object.runtimeData) {
            animateTo(object.runtimeData);
        }
        else {
            object.once('loadBase', function () {
                animateTo(object.runtimeData);
            }, this);
            object.load();
        }
    };
    /**
     * Starts a translation animation.
     * @param animationTime The amount of time to animate
     * @param easeIn        The percentage of the animation which should be eased in (between 0.0 and 1.0)
     * @param easeOut       The percentage of the animation which should be eased out (between 0.0 and 1.0)
     * @param velocity      The velocity at which to translate the object
     * @param objectUsage   Either 'beginning', 'middle' or 'end'
     */
    ObjectAnimator.prototype.animateTranslation = function (animationTime, easeIn, easeOut, velocity, objectUsage) {
        var _this = this;
        var runtimeData = this.getRuntimeData();
        runtimeData.position.copy(this.getEntity().getPosition());
        runtimeData.quaternion.copy(this.getEntity().getQuaternion());
        runtimeData.scale.copy(this.getEntity().getScale());
        var currTime = 0;
        var engine = this.getEngine();
        if (easeIn + easeOut > 1.0) {
            Logger_1.default.warn('Ease-In and Ease-Out value can\'t total more than 1.0.');
            easeIn = 0.5;
            easeOut = 0.5;
        }
        var easeInTime = animationTime * easeIn;
        var currentVelocity = new THREE.Vector3();
        var direction = new THREE.Vector3();
        direction.copy(velocity);
        var speed = direction.length();
        runtimeData.updateMatrixWorld();
        direction.applyQuaternion(runtimeData.quaternion);
        direction.normalize();
        if (objectUsage) {
            var fullSpeedTime = (1.0 - easeIn - easeOut) * animationTime;
            var halfSpeedTime = (easeIn + easeOut) * 0.5 * animationTime;
            // Based on the object usage, set the original position so that the
            // animation plays forward from there...
            if (objectUsage === 'middle') {
                currentVelocity.copy(velocity);
                currentVelocity.multiplyScalar(-0.5 * (fullSpeedTime + halfSpeedTime));
                runtimeData.position.add(currentVelocity);
            }
            else if (objectUsage === 'end') {
                currentVelocity.copy(velocity);
                currentVelocity.multiplyScalar(-1.0 * (fullSpeedTime + halfSpeedTime));
                runtimeData.position.add(currentVelocity);
            }
        }
        if (animationTime > 0) {
            var objAnim_2 = function (delta) {
                if (!_this.getEntity() || !_this.isEnabled()) {
                    engine.off('update', objAnim_2, _this);
                    return;
                }
                currentVelocity.copy(direction);
                _this.getEngine().needsRender = true;
                currTime += delta;
                var currentTimePercent = Math.min(currTime / animationTime, 1.0); // clamp to 100%
                var easeOutStart = (1.0 - easeOut);
                var easeOutStartTime = animationTime * easeOutStart;
                if (easeIn && currTime < easeInTime) {
                    // Ease in
                    var easeInProgress = currentTimePercent / easeIn;
                    currentVelocity.multiplyScalar(delta * speed *
                        (Math.cos(easeInProgress * Math.PI + Math.PI) * 0.5 + 0.5));
                }
                else if (easeOut && currTime > easeOutStartTime) {
                    // Ease out
                    var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;
                    currentVelocity.multiplyScalar(delta * speed *
                        Math.max(Math.cos(easeOutProgress * Math.PI + Math.PI) * 0.5 + 0.5, 0.0));
                }
                else {
                    // Full speed animation
                    currentVelocity.multiplyScalar(delta * speed);
                }
                if (currTime >= animationTime) {
                    _this.getEngine().off('update', objAnim_2, _this);
                    _this.getEntity().trigger('endAnimateTranslation');
                }
                runtimeData.position.add(currentVelocity);
            };
            this.getEngine().on('update', objAnim_2, this);
        }
    };
    /**
     * Starts a rotational animation.
     * @param animationTime The amount of time to animate
     * @param easeIn        The percentage of the animation which should be eased in (between 0.0 and 1.0)
     * @param easeOut       The percentage of the animation which should be eased out (between 0.0 and 1.0)
     * @param velocity      The rotational velocity
     * @param objectUsage   Either 'beginning', 'middle', or 'end'
     * @param axisOrder     The order in which to apply the rotation around the axis
     */
    ObjectAnimator.prototype.animateRotation = function (animationTime, easeIn, easeOut, velocity, objectUsage, axisOrder) {
        var _this = this;
        var runtimeData = this.getRuntimeData();
        runtimeData.position.copy(this.getEntity().getPosition());
        runtimeData.quaternion.copy(this.getEntity().getQuaternion());
        runtimeData.scale.copy(this.getEntity().getScale());
        var currTime = 0;
        var engine = this.getEngine();
        if (easeIn + easeOut > 1.0) {
            Logger_1.default.warn('Ease-In and Ease-Out value can\'t total more than 1.0.');
            easeIn = 0.5;
            easeOut = 0.5;
        }
        var easeInTime = animationTime * easeIn;
        var currentVelocity = new THREE.Quaternion();
        var fullSpeedQuat = new THREE.Quaternion();
        var tempVector1 = new THREE.Vector3();
        var eulerVelocity = new THREE.Euler(velocity.x, velocity.y, velocity.z, axisOrder);
        // Convert the euler angles to quaternion
        currentVelocity.setFromEuler(eulerVelocity);
        fullSpeedQuat.copy(currentVelocity);
        runtimeData.updateMatrixWorld();
        if (objectUsage) {
            var fullSpeedTime = (1.0 - easeIn - easeOut) * animationTime;
            var halfSpeedTime = (easeIn + easeOut) * 0.5 * animationTime;
            // Based on the object usage, set the original rotation so that the
            // animation plays forward from there...
            if (objectUsage === 'middle') {
                tempVector1.copy(velocity);
                tempVector1.multiplyScalar(-0.5 * (fullSpeedTime + halfSpeedTime));
                eulerVelocity.set(tempVector1.x, tempVector1.y, tempVector1.z);
                currentVelocity.setFromEuler(eulerVelocity);
                runtimeData.quaternion.multiply(currentVelocity);
            }
            else if (objectUsage === 'end') {
                tempVector1.copy(velocity);
                tempVector1.multiplyScalar(-1.0 * (fullSpeedTime + halfSpeedTime));
                eulerVelocity.set(tempVector1.x, tempVector1.y, tempVector1.z);
                currentVelocity.setFromEuler(eulerVelocity);
                runtimeData.quaternion.multiply(currentVelocity);
            }
        }
        if (animationTime > 0) {
            var objAnim_3 = function (delta) {
                if (!_this.getEntity() || !_this.isEnabled()) {
                    engine.off('update', objAnim_3, _this);
                    return;
                }
                var speed = 1.0;
                _this.getEngine().needsRender = true;
                currTime += delta;
                var currentTimePercent = Math.min(currTime / animationTime, 1.0);
                var easeOutStart = (1.0 - easeOut);
                var easeOutStartTime = animationTime * easeOutStart;
                if (easeIn && currTime < easeInTime) {
                    // Ease in
                    var easeInProgress = currentTimePercent / easeIn;
                    speed *= delta * (Math.cos(easeInProgress * Math.PI + Math.PI) * 0.5 + 0.5);
                }
                else if (easeOut && currTime > easeOutStartTime) {
                    // Ease out
                    var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;
                    speed *= delta * Math.max(Math.cos(easeOutProgress * Math.PI + Math.PI) *
                        0.5 + 0.5, 0.0);
                }
                else {
                    // Full speed animation
                    speed *= delta;
                }
                if (currTime >= animationTime) {
                    _this.getEngine().off('update', objAnim_3, _this);
                    _this.getEntity().trigger('endAnimateTranslation');
                }
                currentVelocity.set(0.0, 0.0, 0.0, 1.0);
                currentVelocity.slerp(fullSpeedQuat, speed);
                runtimeData.quaternion.multiply(currentVelocity);
            };
            this.getEngine().on('update', objAnim_3, this);
        }
    };
    /**
     * Starts a scale animation.
     * @param animationTime The amount of time to animate.
     * @param easeIn        The percentage of the animation which should be eased in (between 0.0 and 1.0)
     * @param easeOut       The percentage of the animation which should be eased out (between 0.0 and 1.0)
     * @param velocity      The velocity at which to scale.
     * @param objectUsage   Either 'beginning', 'middle', or 'end'
     */
    ObjectAnimator.prototype.animateScale = function (animationTime, easeIn, easeOut, velocity, objectUsage) {
        var _this = this;
        var runtimeData = this.getRuntimeData();
        runtimeData.position.copy(this.getEntity().getPosition());
        runtimeData.quaternion.copy(this.getEntity().getQuaternion());
        runtimeData.scale.copy(this.getEntity().getScale());
        var currTime = 0;
        var engine = this.getEngine();
        if (easeIn + easeOut > 1.0) {
            Logger_1.default.warn('Ease-In and Ease-Out value can\'t total more than 1.0.');
            easeIn = 0.5;
            easeOut = 0.5;
        }
        var easeInTime = animationTime * easeIn;
        var currentVelocity = new THREE.Vector3();
        runtimeData.updateMatrixWorld();
        if (objectUsage) {
            var fullSpeedTime = (1.0 - easeIn - easeOut) * animationTime;
            var halfSpeedTime = (easeIn + easeOut) * 0.5 * animationTime;
            // Based on the object usage, set the original scale so that the
            // animation plays forward from there...
            if (objectUsage === 'middle') {
                currentVelocity.copy(velocity);
                currentVelocity.multiplyScalar(-0.5 * (fullSpeedTime + halfSpeedTime));
                runtimeData.scale.add(currentVelocity);
            }
            else if (objectUsage === 'end') {
                currentVelocity.copy(velocity);
                currentVelocity.multiplyScalar(-1.0 * (fullSpeedTime + halfSpeedTime));
                runtimeData.scale.add(currentVelocity);
            }
        }
        if (animationTime > 0) {
            var objAnim_4 = function (delta) {
                if (!_this.getEntity() || !_this.isEnabled()) {
                    engine.off('update', objAnim_4, _this);
                    return;
                }
                currentVelocity.copy(velocity);
                _this.getEngine().needsRender = true;
                currTime += delta;
                var currentTimePercent = Math.min(currTime / animationTime, 1.0); // clamp to 100%
                var easeOutStart = (1.0 - easeOut);
                var easeOutStartTime = animationTime * easeOutStart;
                if (easeIn && currTime < easeInTime) {
                    // Ease in
                    var easeInProgress = currentTimePercent / easeIn;
                    currentVelocity.multiplyScalar(delta * (Math.cos(easeInProgress *
                        Math.PI + Math.PI) * 0.5 + 0.5));
                }
                else if (easeOut && currTime > easeOutStartTime) {
                    // Ease out
                    var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;
                    currentVelocity.multiplyScalar(delta * Math.max(Math.cos(easeOutProgress *
                        Math.PI + Math.PI) * 0.5 + 0.5, 0.0));
                }
                else {
                    // Full speed animation
                    currentVelocity.multiplyScalar(delta);
                }
                if (currTime >= animationTime) {
                    _this.getEngine().off('update', objAnim_4, _this);
                    _this.getEntity().trigger('endAnimateTranslation');
                }
                runtimeData.scale.add(currentVelocity);
            };
            this.getEngine().on('update', objAnim_4, this);
        }
    };
    return ObjectAnimator;
}(BaseComponent_1.default));
/* tslint:disable max-line-length */
/**
 * Event definitions:
 *
 * @vevent local playAnimateAlongCurve {
 *   action: true,
 *   category: 'Animation',
 *   parameters: [
 *     {
 *       name: 'curve',
 *       type : 'object',
 *       componentFilter: {
 *         Curve: true
 *       }
 *     },
 *     {
 *       name: 'animationTime',
 *       type: 'f', 'description': 'Time to animate to object. Defined in seconds', 'default': 3
 *     },
 *     {
 *       name: 'easeIn',
 *       type : 'f',
 *       description: 'The percentage of animation time spent speeding up.',
 *       default: 0.25,
 *       min: 0.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'easeOut',
 *       type: 'f',
 *       description: 'The percentage of animation time spent slowing down.',
 *       default: 0.25,
 *       min: 0.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'orientation',
 *       description: 'Orient the object following the curve to either the direction of the curve or to the objects defining the curve.',
 *       type: 'opt',
 *       default: 'toCurve',
 *       options: {
 *         'None': 'None',
 *         'To Curve': 'toCurve',
 *         'To Nodes': 'toNode'
 *       }
 *     },
 *     {
 *       name: 'loop',
 *       type : 'b',
 *       default: false
 *     }
 *   ]
 * }
 *
 * @vevent local playAnimateToObject {
 *   action: true,
 *   category: 'Animation',
 *   parameters: [
 *     {
 *       name: 'object',
 *       type: 'object',
 *       default: null
 *     },
 *     {
 *       name: 'animationTime',
 *       type: 'f',
 *       description: 'Total time that the animation will take. Defined in seconds',
 *       default: 3
 *     },
 *     {
 *       name: 'easeIn',
 *       type: 'f',
 *       description: 'The percentage of animation time spent speeding up.',
 *       default: 0.25,
 *       min: 0.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'easeOut',
 *       type: 'f',
 *       description: 'The percentage of animation time spent slowing down.',
 *       default: 0.25,
 *       min: 0.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'update orientation',
 *       type: 'b',
 *       default: true
 *     }
 *   ]
 * }
 *
 * @vevent local playAnimateTranslation {
 *   action: true,
 *   category: 'Animation',
 *   parameters: [
 *     {
 *       name: 'animationTime',
 *       type: 'f',
 *       description: 'Time to animate. Defined in seconds',
 *       default: 3
 *     },
 *     {
 *       name: 'easeIn',
 *       type: 'f',
 *       description: 'The percentage of animation time spent speeding up.',
 *       default: 0.25,
 *       min: 0.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'easeOut',
 *       type: 'f',
 *       description: 'The percentage of animation time spent slowing down.',
 *       default: 0.25,
 *       min: 0.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'velocity',
 *       type: 'v3',
 *       default: {x:0,y:0,z:1.0},
 *       min: -1.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'objectUsage',
 *       type: 'opt',
 *       description: 'Specify what part of the animation the current object\'s position represents.',
 *       default: 'beginning',
 *       options: {
 *         Beginning: 'beginning',
 *         Middle: 'middle',
 *         End: 'end'
 *       }
 *     }
 *   ]
 * }
 *
 * @vevent local playAnimateRotation {
 *   action: true,
 *   category: 'Animation',
 *   parameters: [
 *     {
 *       name: 'animationTime',
 *       type: 'f',
 *       description: 'Time to animate to object. Defined in seconds',
 *       default: 3
 *     },
 *     {
 *       name: 'easeIn',
 *       type: 'f',
 *       description: 'The percentage of animation time spent speeding up.',
 *       default: 0.25,
 *       min: 0.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'easeOut',
 *       type: 'f',
 *       description: 'The percentage of animation time spent slowing down.',
 *       default: 0.25,
 *       min: 0.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'angularVelocity',
 *       type: 'v3',
 *       default: { x:0, y:0, z:1.0 },
 *       min: -100.0,
 *       max: 100.0
 *     },
 *     {
 *       name: 'objectUsage',
 *       type: 'opt',
 *       description: 'Specify what part of the animation the current object\'s rotation represents.',
 *       default: 'beginning',
 *       options: {
 *         Beginning: 'beginning',
 *         Middle: 'middle',
 *         End: 'end'
 *       }
 *     },
 *     {
 *       name: 'axisOrder',
 *       type: 'opt',
 *       description: 'Specify the axis order that the angular velocity will be applied in.',
 *       default: 'YXZ',
 *       options: {
 *         XYZ: 'XYZ',
 *         YXZ: 'YXZ',
 *         ZXY: 'ZXY',
 *         XZY: 'XZY',
 *         YZX: 'YZX',
 *         ZYX: 'ZYX'
 *       }
 *     }
 *   ]
 * }
 *
 * @vevent local playAnimateScale {
 *   action: true,
 *   category: 'Animation',
 *   parameters: [
 *     {
 *       name: 'animationTime',
 *       type: 'f',
 *       description: 'Time to animate to object. Defined in seconds',
 *       default: 3
 *     },
 *     {
 *       name: 'easeIn',
 *       type: 'f',
 *       description: 'The percentage of animation time spent speeding up.',
 *       default: 0.25,
 *       min: 0.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'easeOut',
 *       type: 'f',
 *       description: 'The percentage of animation time spent slowing down.',
 *       default: 0.25,
 *       min: 0.0,
 *       max: 1.0
 *     },
 *     {
 *       name: 'velocity',
 *       type: 'v3',
 *       default: {x:0,y:0,z:1.0},
 *       min: -10.0,
 *       max: 10.0
 *     },
 *     {
 *       name: 'objectUsage',
 *       type: 'opt',
 *       description: 'Specify what part of the animation the current object\'s scale represents.',
 *       default: 'beginning',
 *       options: {
 *         Beginning: 'beginning',
 *         Middle: 'middle',
 *         End: 'end'
 *       }
 *     }
 *   ]
 * }
 *
 * @vevent local pauseCurveAnimation {
 *   action: true,
 *   category: 'Animation',
 *   parameters: []
 * }
 *
 * @vevent local stopCurveAnimation {
 *   action: true,
 *   category: 'Animation',
 *   parameters: []
 * }
 *
 * @vevent local unpauseCurveAnimation {
 *   action: true,
 *   category: 'Animation',
 *   parameters: []
 * }
 *
 * @vevent local endAnimateAlongCurve {
 *   action: false,
 *   category: 'Animation',
 *   parameters: []
 * }
 *
 * @vevent local endAnimateToObject {
 *   action: false,
 *   category: 'Animation',
 *   parameters: []
 * }
 *
 * @vevent local endAnimateTranslation {
 *   action: false,
 *   category: 'Animation',
 *   parameters: []
 * }
 */
/* tslint:enable max-line-length */
exports.default = ObjectAnimator;


/***/ }),
/* 101 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var UserAgent_1 = __webpack_require__(22);
/**
 * Ease in out formula.
 * @param t The number to apply easing function to.
 * @returns Eased value.
 */
function easeInOut(t) {
    return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
}
/**
 * Linearly interpolate between two Vector3s.
 * @param src Source Vector3 to lerp from.
 * @param dst Destination Vector3 to lerp to.
 * @param val The percentage point from src to dst to lerp to (0 = src, 1 = dst, 0.5 = half way in between).
 * @param out The Vector3 to apply the resulting interpolated value to.
 */
function lerp(src, dst, val, out) {
    var x = src.x + (dst.x - src.x) * val;
    var y = src.y + (dst.y - src.y) * val;
    var z = src.z + (dst.z - src.z) * val;
    out.set(x, y, z);
}
/**
 * Used to check and see if the intersected object is visible or not.
 * @param intersect The intersection registered by a raycast.
 * @returns True if the object that has been intersected is visible.
 */
function intersectionFilter(intersect) {
    return intersect.object.visible && intersect.object.type === 'Mesh';
}
/**
 * @vid orbit_camera_focus
 * @vname Orbit Camera Focus
 * @vdescription A component that allows for easy navigation of a model.
 * @vfilter camera
 * @vcategory Camera Controllers
 */
var OrbitCameraFocus = (function (_super) {
    tslib_1.__extends(OrbitCameraFocus, _super);
    function OrbitCameraFocus() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * The speed that we move to focus on the target.
         * @vattr float speed {
         *    description: 'The speed that we move to focus on the target.',
         *    default: 0.8,
         *    max: 100,
         *    min: 0.1
         *  }
         */
        _this.speed = 0.8;
        /**
         * The number of steps it takes to zoom, from fully zoomed out to fully zoomed in.
         * @vattr int zoomSteps {
         *    description: 'The number of steps it takes to zoom, from fully zoomed out to fully zoomed in.',
         *    default: 5,
         *    max: 100,
         *    min: 0
         *  }
         */
        _this.zoomSteps = 5;
        /**
         * The distance between each focal point move. Used to decide whether or not to zoom in.
         * @vattr int zoomBuffer {
         *    description: 'The distance between each focal point move. Used to decide whether or not to zoom in.',
         *    default: 0.1,
         *    max: 1000,
         *    min: 0
         *  }
         */
        _this.zoomBuffer = 0.1;
        /** Interpolation timer */
        _this.time = -1;
        /** Used for triggering or interrupting focus event */
        _this.isMouseDown = false;
        /** Target zoom amount to zoom to */
        _this.targetZoom = 0;
        /** Zoom level before focus action */
        _this.srcZoom = 0;
        /** The last position that we focused on */
        _this.lastFocusPosition = new THREE.Vector3(-1, -1, -1);
        return _this;
    }
    /** @inheritdoc */
    OrbitCameraFocus.prototype.onDisable = function () {
        this.interrupt();
    };
    /** @inheritdoc */
    OrbitCameraFocus.prototype.onUpdate = function (dt) {
        if (!this.isEnabled() || this.time < 0) {
            return;
        }
        var runtimeData = this.getRuntimeData();
        var lerpVal = easeInOut(1 - 1 / (this.speed / this.time));
        lerp(this.srcLook, this.targetLook, lerpVal, this.currentLook);
        runtimeData.lookAt(this.currentLook);
        var zoomLevel = this.srcZoom + (this.targetZoom - this.srcZoom) * lerpVal;
        this.zoomComponent.lerpZoom(zoomLevel);
        this.time -= dt;
        if (this.time <= 0) {
            this.onEnd();
        }
        this.getEngine().needsRender = true;
    };
    /** @inheritdoc */
    OrbitCameraFocus.prototype.onStartup = function () {
        this.orbitCam = this.getEntity().getComponentByScriptName('Orbit Camera');
        if (!this.orbitCam) {
            throw new Error("Focus component requires OrbitCamera on the entity: " + this.getId());
        }
        var engine = this.getEngine();
        var entity = this.getEntity();
        if (UserAgent_1.isMobile()) {
            this.listenTo(engine, 'touchStart', this.onMouseDown);
            this.listenTo(engine, 'touchMove', this.onMouseMove);
            this.listenTo(engine, 'touchEnd', this.onMouseUp);
            this.listenTo(engine, 'doubleTap', this.onDoubleClick);
        }
        else {
            this.listenTo(engine, 'mouseScroll', this.interrupt);
            this.listenTo(engine, 'keyDown', this.interrupt);
            this.listenTo(engine, 'mouseMove', this.onMouseMove);
            this.listenTo(engine, 'mouseDown', this.onMouseDown);
            this.listenTo(engine, 'mouseUp', this.onMouseUp);
            this.listenTo(engine, 'doubleClick', this.onDoubleClick);
        }
        this.listenTo(entity, 'resetOrbitCamera', this.onReset);
        // Attach zoom component if it hasn't been done yet
        this.zoomComponent = entity.getComponentByScriptId('camera_zoom');
        if (!this.zoomComponent) {
            this.zoomComponent = entity.addComponent('camera_zoom');
        }
    };
    /**
     * Re-enable the preview camera controller and reset the time tracker.
     */
    OrbitCameraFocus.prototype.onReset = function () {
        this.orbitCam.enable();
        this.time = -1;
    };
    /**
     * Set mouse state to allow for focus event.
     */
    OrbitCameraFocus.prototype.onMouseDown = function () {
        if (this.isEnabled()) {
            this.isMouseDown = true;
        }
    };
    /**
     * Set mouse state to not allow focus event.
     */
    OrbitCameraFocus.prototype.onMouseUp = function () {
        this.isMouseDown = false;
    };
    /**
     * Depending on mouse state, interrupt camera transition if moving the mouse.
     */
    OrbitCameraFocus.prototype.onMouseMove = function () {
        if (this.isMouseDown) {
            this.interrupt();
        }
    };
    /**
     * On dobule click, trigger the focus transition to occur, and move the camera into position.
     * @param event The Box3DInput event created by the input controller, from the 'doubleClick' event.
     */
    OrbitCameraFocus.prototype.onDoubleClick = function (event) {
        if (!this.isEnabled() || !this.hasRuntimeData()) {
            return;
        }
        if (!this.raycaster) {
            this.initializeRaycaster();
        }
        var pointX = UserAgent_1.isMobile() ? this.getInput().touchPositionPercent.x : event.scenePercentX;
        var pointY = UserAgent_1.isMobile() ? this.getInput().touchPositionPercent.y : event.scenePercentY;
        this.mouseVector.set(pointX * 2 - 1, -pointY * 2 + 1);
        var intersection = this.getIntersection(this.mouseVector);
        // interrupt the current transition, continue to next target from the current look position and position
        this.interrupt();
        var srcLook = this.time > 0 ? this.currentLook : this.orbitCam.pivotPoint.position;
        this.srcLook.copy(srcLook);
        if (intersection) {
            this.lookAtPoint(intersection.point);
        }
        else {
            this.resetToOrigin();
        }
        // trigger the move to happen
        this.time = this.speed;
        this.srcZoom = this.zoomComponent.getZoomLevel();
    };
    /**
     * Start transition to look at a target position and check for zoom.
     * @param point The position to look at.
     */
    OrbitCameraFocus.prototype.lookAtPoint = function (point) {
        this.orbitCam.disable();
        this.targetLook.copy(point);
        // Indicates a reset when -1
        if (this.lastFocusPosition.x === -1) {
            this.lastFocusPosition.copy(this.targetLook);
        }
        if (this.targetLook.distanceTo(this.lastFocusPosition) < this.zoomBuffer) {
            this.stepZoom();
        }
        this.lastFocusPosition.copy(this.targetLook);
    };
    /**
     * Reset the camera to zoom to original level and look at origin point.
     */
    OrbitCameraFocus.prototype.resetToOrigin = function () {
        this.targetLook.set(0, 0, 0);
        // 0.5 is orbit cam's starting zoom level. See OrbitCamera.reset();
        this.targetZoom = 0.5;
        this.lastFocusPosition.set(-1, -1, -1);
    };
    /**
     * Make a single zoom step towards the focal point.
     */
    OrbitCameraFocus.prototype.stepZoom = function () {
        // Negative zoom is zooming in
        var newTarget = this.zoomComponent.getZoomLevel() - (1 / this.zoomSteps);
        this.targetZoom = Math.min(1, Math.max(0, newTarget));
    };
    /**
     * Initialize the raycaster and worker variables
     */
    OrbitCameraFocus.prototype.initializeRaycaster = function () {
        this.raycaster = new THREE.Raycaster();
        this.raycaster.near = 0;
        this.mouseVector = new THREE.Vector2();
        this.targetLook = new THREE.Vector3();
        this.srcLook = new THREE.Vector3();
        this.currentLook = new THREE.Vector3();
    };
    /**
     * Immediatly interrupt the transition, if it is occurring, and set the camera lookat and
     * position to current position and target.
     */
    OrbitCameraFocus.prototype.interrupt = function () {
        if (this.isEnabled() && this.time > 0) {
            this.onEnd();
        }
    };
    /**
     * Set the position of the camera and update OrbitCameraController properties based off of new
     * look target and position.
     */
    OrbitCameraFocus.prototype.onEnd = function () {
        this.time = -1;
        this.orbitCam.enable();
        this.orbitCam.setPivotPosition(this.currentLook);
        this.orbitCam.setOrbitDistance(this.getRuntimeData().position.distanceTo(this.currentLook));
        this.orbitCam.resetOrbitRotation();
    };
    /**
     * Check for intersections from a given input position onscreen.
     * @param inputPosition The position onscreen that in input event has occurred.
     * @returns The first intersection object if an intersection has occurred, otherwise undefined.
     */
    OrbitCameraFocus.prototype.getIntersection = function (inputPosition) {
        // a bit longer to accommodate being fully zoomed out
        this.raycaster.far = this.orbitCam.getOrbitDistance() + 1;
        this.raycaster.setFromCamera(inputPosition, this.getRuntimeData());
        var intersections = this.raycaster.intersectObjects(this.getRootThreeObject().children, true)
            .filter(intersectionFilter);
        return (intersections.length) > 0 ? intersections[0] : undefined;
    };
    return OrbitCameraFocus;
}(BaseComponent_1.default));
exports.default = OrbitCameraFocus;


/***/ }),
/* 102 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var OrbitCamera_1 = __webpack_require__(25);
/**
 * A component for feeding input events to the Orbit Camera Controller.
 * @vid orbit_desktop_controls
 * @vname Orbit Desktop Controls
 * @vdescription Desktop controls for Orbit Camera controller
 * @vfilter camera
 * @vcategory Camera Controllers
 */
var OrbitDesktopControls = (function (_super) {
    tslib_1.__extends(OrbitDesktopControls, _super);
    function OrbitDesktopControls() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** Used to track the position of the mouse */
        _this.position = new THREE.Vector2();
        return _this;
    }
    /**
     *  @inheritdoc
     */
    OrbitDesktopControls.prototype.onStartup = function () {
        var engine = this.getEngine();
        this.listenTo(engine, 'mouseDown', this.onMouseDown);
        this.listenTo(engine, 'mouseMove', this.onMouseMove);
        this.listenTo(engine, 'mouseScroll', this.onMouseScroll);
    };
    /**
     * Handle mouse down input event to initiate movement of the camera: 'start_orbit'.
     * @param inputEvent The input event provided by the mouse down input event.
     */
    OrbitDesktopControls.prototype.onMouseDown = function (inputEvent) {
        if (!this.isEnabled()) {
            return;
        }
        var leftButton = this.getInput().mouseButtonDown('left');
        // Save mouse position
        this.position.x = inputEvent.scenePercentX;
        this.position.y = inputEvent.scenePercentY;
        // No orbit action if right mouse
        var movementType = leftButton ? OrbitCamera_1.orbitEvents.startOrbit : undefined;
        if (movementType) {
            this.trigger(movementType, this.position);
        }
    };
    /**
     * Handle mose drag to notify listeners of 'pan' or 'orbit' events.
     * @param inputEventThe input event provided by the mouse drag input event.
     */
    OrbitDesktopControls.prototype.onMouseMove = function (inputEvent) {
        if (!this.isEnabled()) {
            return;
        }
        var leftButton = this.getInput().mouseButtonDown('left');
        this.position.x = leftButton ? inputEvent.scenePercentX : inputEvent.scenePercentDeltaX;
        this.position.y = leftButton ? inputEvent.scenePercentY : inputEvent.scenePercentDeltaY;
        var rightButton = this.getInput().mouseButtonDown('right');
        var movementType = rightButton ? OrbitCamera_1.orbitEvents.pan : (leftButton ? OrbitCamera_1.orbitEvents.orbit : undefined);
        if (movementType) {
            this.trigger(movementType, this.position);
        }
    };
    /**
     * Handle mouse scroll event to emit 'zoom' event.
     * @param delta The delta scrolled by the input device.
     */
    OrbitDesktopControls.prototype.onMouseScroll = function (delta) {
        if (!this.isEnabled()) {
            return;
        }
        this.trigger(OrbitCamera_1.orbitEvents.zoom, delta);
    };
    return OrbitDesktopControls;
}(BaseComponent_1.default));
exports.default = OrbitDesktopControls;


/***/ }),
/* 103 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var OrbitCamera_1 = __webpack_require__(25);
/**
 * A component for feeding input events to the Orbit Camera component.
 * @vid orbit_desktop_input
 * @vname Orbit Desktop Input
 * @vdescription Desktop input for Orbit Camera component
 * @vfilter camera
 * @vcategory Camera Components
 */
var OrbitDesktopControls = (function (_super) {
    tslib_1.__extends(OrbitDesktopControls, _super);
    function OrbitDesktopControls() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** Used to track the position of the mouse */
        _this.position = new THREE.Vector2();
        return _this;
    }
    /**
     *  @inheritdoc
     */
    OrbitDesktopControls.prototype.onStartup = function () {
        var engine = this.getEngine();
        this.listenTo(engine, 'mouseDown', this.onMouseDown);
        this.listenTo(engine, 'mouseMove', this.onMouseMove);
        this.listenTo(engine, 'mouseScroll', this.onMouseScroll);
    };
    /**
     * Handle mouse down input event to initiate movement of the camera.
     * @param inputEvent The input event provided by the mouse down input event.
     */
    OrbitDesktopControls.prototype.onMouseDown = function (inputEvent) {
        if (!this.isEnabled()) {
            return;
        }
        var leftButton = this.getInput().mouseButtonDown('left');
        // Save mouse position
        this.position.x = inputEvent.scenePercentX;
        this.position.y = inputEvent.scenePercentY;
        // No orbit action if right mouse
        var movementType = leftButton ? OrbitCamera_1.orbitEvents.startOrbit : undefined;
        if (movementType) {
            this.trigger(movementType, this.position);
        }
    };
    /**
     * Handle mouse drag to notify camera of pan and orbit events.
     * @param inputEventThe input event provided by the mouse drag input event.
     */
    OrbitDesktopControls.prototype.onMouseMove = function (inputEvent) {
        if (!this.isEnabled()) {
            return;
        }
        var leftButton = this.getInput().mouseButtonDown('left');
        this.position.x = leftButton ? inputEvent.scenePercentX : inputEvent.scenePercentDeltaX;
        this.position.y = leftButton ? inputEvent.scenePercentY : inputEvent.scenePercentDeltaY;
        var rightButton = this.getInput().mouseButtonDown('right');
        var movementType = rightButton ? OrbitCamera_1.orbitEvents.pan : (leftButton ? OrbitCamera_1.orbitEvents.orbit : undefined);
        if (movementType) {
            this.trigger(movementType, this.position);
        }
    };
    /**
     * Handle mouse scroll event to emit 'zoom' event.
     * @param delta The delta scrolled by the input device.
     */
    OrbitDesktopControls.prototype.onMouseScroll = function (delta) {
        if (!this.isEnabled()) {
            return;
        }
        this.trigger(OrbitCamera_1.orbitEvents.zoom, delta);
    };
    return OrbitDesktopControls;
}(BaseComponent_1.default));
exports.default = OrbitDesktopControls;


/***/ }),
/* 104 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var OrbitCamera_1 = __webpack_require__(25);
/** Used to get pinch zoom distance delta closer to wheel event differences */
var scrollWheelFactor = 20;
/**
 * A component for feeding touch input events to the Orbit Camera component.
 * One finger drag is orbit, two finger drag is pan, and two finger pinch is zoom.
 * @vid orbit_touch_input
 * @vname Orbit Touch Input
 * @vdescription Touch input for Orbit Camera component
 * @vfilter camera
 * @vcategory Camera Components
 */
var OrbitDesktopControls = (function (_super) {
    tslib_1.__extends(OrbitDesktopControls, _super);
    function OrbitDesktopControls() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** Tracks whether or not we currently are in the orbit action */
        _this.isOrbiting = false;
        /** Tracks whether or not we currently are in the orbit action */
        _this.isPanning = false;
        /** Tracks whether or not we currently are in the orbit action */
        _this.isZooming = false;
        /** Used to track pan movement. Panning movement is calculated from the midpoint of both fingers. */
        _this.panMidpoint = new THREE.Vector2();
        /** Used to calculate pan delta movement */
        _this.lastPanMidpoint = new THREE.Vector2();
        /** The delta created by panning */
        _this.panDelta = new THREE.Vector2();
        /** Tracks distance between fingers to calculate zoom amount and, prevent over zoom when switching fingers */
        _this.lastZoomDistance = 0;
        return _this;
    }
    /**
     *  @inheritdoc
     */
    OrbitDesktopControls.prototype.onStartup = function () {
        var engine = this.getEngine();
        this.listenTo(engine, 'touchStart', this.cancelActions);
        this.listenTo(engine, 'touchCancel', this.cancelActions);
        this.listenTo(engine, 'touchLeave', this.cancelActions);
        this.listenTo(engine, 'touchEnd', this.cancelActions);
        this.listenTo(engine, 'touchMove', this.onTouchMove);
    };
    /**
     * Whenever the user releases or adds a touch to the input screen, this will
     * reset the current state of all actions.
     */
    OrbitDesktopControls.prototype.cancelActions = function () {
        this.isOrbiting = false;
        this.isPanning = false;
        this.isZooming = false;
        this.panMidpoint.set(0, 0);
        this.lastPanMidpoint.set(0, 0);
        this.panDelta.set(0, 0);
        this.lastZoomDistance = 0;
    };
    /**
     * Handle touch moves to  notify camera of pan and orbit events.
     * @param event The object created by the touchMove event in the input controller.
     */
    OrbitDesktopControls.prototype.onTouchMove = function (event) {
        if (!this.isEnabled() || !event.touches.length) {
            return;
        }
        // If only one finger is down
        if (event.touches.length === 1) {
            this.onSingleTouchMove(event.touches[0]);
        }
        else {
            this.onMultiTouchMove(event.touches[0], event.touches[1]);
        }
    };
    /**
     * Initiate and resume orbit action on single touch movement.
     * @param touch The touch object created by the Input component.
     */
    OrbitDesktopControls.prototype.onSingleTouchMove = function (touch) {
        var position = new THREE.Vector2(touch.scenePercentX, touch.scenePercentY);
        if (!this.isOrbiting) {
            this.isOrbiting = true;
            this.startOrbit(position);
        }
        else {
            this.orbit(position);
        }
    };
    /**
     * Initiate and resume pan and zoom actions on multi touch movement.
     * @param touchOne The touch object of one finger created by the Input component.
     * @param touchTwo The touch object of another finger created by the Input component.
     */
    OrbitDesktopControls.prototype.onMultiTouchMove = function (touchOne, touchTwo) {
        var touchOnePosition = new THREE.Vector2(touchOne.scenePercentX, touchOne.scenePercentY);
        var touchTwoPosition = new THREE.Vector2(touchTwo.scenePercentX, touchTwo.scenePercentY);
        this.pan(touchOnePosition, touchTwoPosition);
        this.zoom(touchOnePosition, touchTwoPosition);
    };
    /**
     * Trigger startOrbit event to listeners.
     * @param position The position of the touch on screen.
     */
    OrbitDesktopControls.prototype.startOrbit = function (position) {
        this.trigger(OrbitCamera_1.orbitEvents.startOrbit, position);
    };
    /**
     * Trigger orbit event to listeners.
     * @param touchPosition The position of the touch on screen.
     */
    OrbitDesktopControls.prototype.orbit = function (touchPosition) {
        this.trigger(OrbitCamera_1.orbitEvents.orbit, touchPosition);
    };
    /**
     * Trigger Pan event to listeners and calculate delta movement.
     * @param touchPosOne The position of the first touch on screen.
     * @param touchPosTwo The position of the second touch on screen.
     */
    OrbitDesktopControls.prototype.pan = function (touchPosOne, touchPosTwo) {
        // Calculate midpoint
        this.panMidpoint.addVectors(touchPosOne, touchPosTwo);
        this.panMidpoint.multiplyScalar(0.5);
        if (!this.isPanning) {
            this.isPanning = true;
            this.lastPanMidpoint.copy(this.panMidpoint);
        }
        // Delta between last position and this position
        this.panDelta.subVectors(this.panMidpoint, this.lastPanMidpoint);
        if (this.panDelta.length()) {
            this.trigger(OrbitCamera_1.orbitEvents.pan, this.panDelta);
        }
        this.lastPanMidpoint.copy(this.panMidpoint);
        this.panDelta.set(0, 0);
    };
    /**
     * Trigger zoom event to listeners and calculate delta distance between touches.
     * @param touchPosOne The position of the first touch on screen.
     * @param touchPosTwo The position of the second touch on screen.
     */
    OrbitDesktopControls.prototype.zoom = function (touchPosOne, touchPosTwo) {
        var distance = touchPosOne.distanceTo(touchPosTwo);
        if (!distance) {
            return;
        }
        if (!this.isZooming) {
            this.isZooming = true;
            this.lastZoomDistance = distance;
        }
        var pinchDelta = distance - this.lastZoomDistance;
        if (pinchDelta) {
            // Multiplying zoom diff to get it closer to zoom amounts.
            // #TODO @jholdstock: After normalizing scroll wheel amounts, normalize this!
            this.trigger(OrbitCamera_1.orbitEvents.zoom, pinchDelta * scrollWheelFactor);
        }
        this.lastZoomDistance = distance;
    };
    return OrbitDesktopControls;
}(BaseComponent_1.default));
exports.default = OrbitDesktopControls;


/***/ }),
/* 105 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-string-literal */
// Rule disabled as uniforms is used as a mapping of strings to uniforms rather
// than a strongly typed object.
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid panorama_to_cube_map
 * @vname Panorama To Cube Map
 * @vdescription Converts a panorama to a cube map.
 * @vfilter renderTextureCube
 * @vcategory Rendering
 */
var PanoramaToCubeMap = (function (_super) {
    tslib_1.__extends(PanoramaToCubeMap, _super);
    function PanoramaToCubeMap() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The scene which is used for rendering the cube map.  */
        _this.skyboxScene = undefined;
        /** An array of cameras, one for each side of the cube. */
        _this.cameras = [null, null, null, null, null, null];
        return _this;
    }
    /** @inheritdoc */
    PanoramaToCubeMap.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('inputTexture') !== -1) {
            var prevTex = this.getPreviousAttribute('inputTexture');
            this.unregisterDependency(prevTex);
            this.registerDependency(this.inputTexture);
            this.updateTexture();
        }
    };
    /** @inheritdoc */
    PanoramaToCubeMap.prototype.onStartup = function () {
        this.skyboxScene = new THREE.Scene();
        this.registerDependency(this.inputTexture);
        this.initCameras();
        this.createSkybox();
    };
    /** @inheritdoc */
    PanoramaToCubeMap.prototype.onEntityReady = function () {
        this.updateTexture();
    };
    /** @inheritdoc */
    PanoramaToCubeMap.prototype.onShutdown = function () {
        if (this.inputTexture) {
            this.unregisterDependency(this.inputTexture);
            this.inputTexture.off('load', this.renderToCube, this);
        }
        if (this.skyboxGeometry) {
            this.skyboxGeometry.dispose();
        }
        if (this.equirectMaterial) {
            this.equirectMaterial.dispose();
        }
        this.skyboxScene = undefined;
        this.skyboxMesh = undefined;
        this.inputTexture = undefined;
    };
    /**
     * Prepares the texture on change or startup.
     */
    PanoramaToCubeMap.prototype.updateTexture = function () {
        if (this.inputTexture && !this.getEntity().isUnloaded()) {
            this.inputTexture.off('load', this.renderToCube, this);
            this.inputTexture.when('load', this.renderToCube, this);
            if (this.inputTexture.isBaseUnloaded()) {
                this.inputTexture.load();
            }
        }
    };
    /**
     * Creates the skybox.
     */
    PanoramaToCubeMap.prototype.createSkybox = function () {
        var equirectShader = THREE.ShaderLib.equirect;
        equirectShader.uniforms['tFlip'].value = 1.0;
        this.equirectMaterial = new THREE.ShaderMaterial({
            fragmentShader: equirectShader.fragmentShader,
            vertexShader: equirectShader.vertexShader,
            uniforms: equirectShader.uniforms,
            depthWrite: false,
            side: THREE.BackSide
        });
        this.skyboxGeometry = new THREE.BoxGeometry(100, 100, 100, 1, 1, 1);
        this.skyboxMesh = new THREE.Mesh(this.skyboxGeometry, this.equirectMaterial);
        this.skyboxMesh.frustumCulled = false;
        this.skyboxMesh.castShadow = false;
        this.skyboxMesh.receiveShadow = false;
        if (this.isEnabled()) {
            this.skyboxScene.add(this.skyboxMesh);
        }
    };
    /**
     * Initializes the cameras.
     */
    PanoramaToCubeMap.prototype.initCameras = function () {
        var fov = 90;
        var aspect = 1;
        this.cameras[0] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[0].up.set(0, -1, 0);
        this.cameras[0].lookAt(new THREE.Vector3(1, 0, 0));
        this.skyboxScene.add(this.cameras[0]);
        this.cameras[1] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[1].up.set(0, -1, 0);
        this.cameras[1].lookAt(new THREE.Vector3(-1, 0, 0));
        this.skyboxScene.add(this.cameras[1]);
        this.cameras[2] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[2].up.set(0, 0, 1);
        this.cameras[2].lookAt(new THREE.Vector3(0, 1, 0));
        this.skyboxScene.add(this.cameras[2]);
        this.cameras[3] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[3].up.set(0, 0, -1);
        this.cameras[3].lookAt(new THREE.Vector3(0, -1, 0));
        this.skyboxScene.add(this.cameras[3]);
        this.cameras[4] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[4].up.set(0, -1, 0);
        this.cameras[4].lookAt(new THREE.Vector3(0, 0, 1));
        this.skyboxScene.add(this.cameras[4]);
        this.cameras[5] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[5].up.set(0, -1, 0);
        this.cameras[5].lookAt(new THREE.Vector3(0, 0, -1));
        this.skyboxScene.add(this.cameras[5]);
    };
    /**
     * Renders the cube map.
     */
    PanoramaToCubeMap.prototype.renderToCube = function () {
        if (this.hasRuntimeData()) {
            this.equirectMaterial.uniforms['tEquirect'].value = this.inputTexture.getThreeTexture();
            var renderTarget = this.getRuntimeData();
            var renderer = this.getThreeRenderer();
            renderTarget.texture.generateMipmaps = false;
            renderer.setViewport(0, 0, renderTarget.width, renderTarget.height);
            for (var i = 0; i < 5; i++) {
                renderTarget.activeCubeFace = i;
                renderer.render(this.skyboxScene, this.cameras[i], renderTarget);
            }
            renderTarget.texture.generateMipmaps = this.getEntity().getProperty('generateMipmaps');
            renderTarget.activeCubeFace = 5;
            renderer.render(this.skyboxScene, this.cameras[5], renderTarget);
        }
    };
    return PanoramaToCubeMap;
}(BaseComponent_1.default));
exports.default = PanoramaToCubeMap;


/***/ }),
/* 106 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var degToRad = 0.0174532925;
var axisToVector3 = {
    '+X': new THREE.Vector3(1, 0, 0),
    '-X': new THREE.Vector3(-1, 0, 0),
    '+Y': new THREE.Vector3(0, 1, 0),
    '-Y': new THREE.Vector3(0, -1, 0),
    '+Z': new THREE.Vector3(0, 0, 1),
    '-Z': new THREE.Vector3(0, 0, -1)
};
/**
 * @vid preview_axis_rotation
 * @vname Preview Axis Rotation
 * @vdescription Set the rotation of any axis.
 * @vfilter object
 */
var PreviewAxisRotation = (function (_super) {
    tslib_1.__extends(PreviewAxisRotation, _super);
    function PreviewAxisRotation() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The amount of time until the next update. */
        _this.time = 0;
        /** The target orientation. */
        _this.target = new THREE.Quaternion();
        /** A temporary quaternion used for calculations.  */
        _this.tempQuat = new THREE.Quaternion();
        return _this;
    }
    /**
     * Get the right vector from a matrix
     * @param {THREE.Matrix4} matrix The matrix to extract a right vector from
     * @returns {THREE.Vector3} A right vector extracted from the matrix
     */
    PreviewAxisRotation.prototype.getRightVector = function (matrix) {
        return new THREE.Vector3(matrix.elements[0], matrix.elements[1], matrix.elements[2]);
    };
    /**
     * Extract the up vector from a matrix
     * @param {THREE.Matrix4} matrix The matrix to extract from
     * @returns {THREE.Vector3} The extracted up vector
     */
    PreviewAxisRotation.prototype.getUpVector = function (matrix) {
        return new THREE.Vector3(matrix.elements[4], matrix.elements[5], matrix.elements[6]);
    };
    /**
     * Extract the forward vector from a matrix
     * @param {THREE.Matrix4} matrix The matrix to extract from
     * @returns {THREE.Vector3} The extracted forward vector
     */
    PreviewAxisRotation.prototype.getForwardVector = function (matrix) {
        return new THREE.Vector3(matrix.elements[8], matrix.elements[9], matrix.elements[10]);
    };
    /**
     * Set the right vector of a Matrix
     * @param {THREE.Matrix4} matrix The matrix who's right vector we want to set
     * @param {THREE.Vector3} vector The vector to set the matrix to
     * @returns {void}
     */
    PreviewAxisRotation.prototype.setRightVector = function (matrix, vector) {
        matrix.elements[0] = vector.x;
        matrix.elements[1] = vector.y;
        matrix.elements[2] = vector.z;
    };
    /**
     * Set the up vector of a Matrix
     * @param {THREE.Matrix4} matrix The matrix who's up vector we want to set
     * @param {THREE.Vector3} vector The vector to set the matrix to
     * @returns {void}
     */
    PreviewAxisRotation.prototype.setUpVector = function (matrix, vector) {
        matrix.elements[4] = vector.x;
        matrix.elements[5] = vector.y;
        matrix.elements[6] = vector.z;
    };
    /**
     * Set the forward vector of a Matrix
     * @param {THREE.Matrix4} matrix The matrix who's forward vector we want to set
     * @param {THREE.Vector3} vector The vector to set the matrix to
     * @returns {void}
     */
    PreviewAxisRotation.prototype.setForwardVector = function (matrix, vector) {
        matrix.elements[8] = vector.x;
        matrix.elements[9] = vector.y;
        matrix.elements[10] = vector.z;
    };
    /**
     * Given an set of axis keys, rotate to the correct axis
     * @param {string} up The up axis key
     * @param {string} forward The forward axis key
     * @param {bool} transition Whether or not to trigger a smooth transition
     * @returns {void}
     */
    PreviewAxisRotation.prototype.setAxes = function (up, forward, transition) {
        var upAxis = axisToVector3[up];
        var forwardAxis = axisToVector3[forward];
        if (!upAxis) {
            return Logger_1.default.error('No Up Axis available For ', up);
        }
        else if (!forwardAxis) {
            return Logger_1.default.error('No Forward Axis available For ', forward);
        }
        var rightVec = new THREE.Vector3();
        var rotationMatrix = new THREE.Matrix4();
        this.setUpVector(rotationMatrix, upAxis);
        this.setForwardVector(rotationMatrix, forwardAxis);
        rightVec.crossVectors(upAxis, forwardAxis);
        this.setRightVector(rotationMatrix, rightVec);
        this.target.setFromRotationMatrix(rotationMatrix);
        // Transition smoothly, over time
        if (transition) {
            this.time = this.speed;
        }
        else {
            this.setRotation(this.target);
            this.getEntity().trigger('axis_transition_complete');
        }
    };
    /**
     * Make the passed in rotation object useful
     * @param {Vector3Def} rotation Create an Euler from an object with x/y/z components
     * @return {THREE.Euler}
     */
    PreviewAxisRotation.prototype.eulerFromObject = function (rotation) {
        var x = isNaN(rotation.x) ? 0 : rotation.x * degToRad;
        var y = isNaN(rotation.y) ? 0 : rotation.y * degToRad;
        var z = isNaN(rotation.z) ? 0 : rotation.z * degToRad;
        var euler = new THREE.Euler(x, y, z);
        euler.order = 'YXZ';
        return euler;
    };
    /**
     * Easier interface for rotating about three axes
     * @param {Object} axis Axes to rotate on, by degrees
     * @param {boolean} additive Whether or not to add to the current rotation OR just set as world rotation
     * @param {boolean} force Force this to happen without a transition
     * @returns {void}
     */
    PreviewAxisRotation.prototype.rotateOnWorldAxis = function (axis, additive, force) {
        if (this.time > 0) {
            return;
        }
        // set at origin with origin scale
        var runtimeData = this.getRuntimeData();
        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();
        position.copy(runtimeData.position);
        scale.copy(runtimeData.scale);
        runtimeData.position.set(0, 0, 0);
        runtimeData.scale.set(1, 1, 1);
        runtimeData.updateMatrix();
        // setup rotation matrices
        var x = new THREE.Matrix4().makeRotationX((axis.x || 0) * degToRad);
        var y = new THREE.Matrix4().makeRotationY((axis.y || 0) * degToRad);
        var z = new THREE.Matrix4().makeRotationZ((axis.z || 0) * degToRad);
        // add matrices
        z.multiply(y);
        z.multiply(x);
        // additive to the current matrix?
        if (additive) {
            z.multiply(runtimeData.matrix);
        }
        this.target.setFromRotationMatrix(z);
        // Do it now...
        if (force) {
            this.setRotation(this.target);
            this.getEngine().needsRender = true;
        }
        else {
            // ...otherwise transition nicely, over time
            this.time = this.speed;
        }
        // Reset back to position
        runtimeData.position.copy(position);
        runtimeData.scale.copy(scale);
    };
    /**
     * Smoothly rotate around an axis
     * @param {VectorXYZ} rotation Euler rotation values for each axis.
     * @returns {void}
     */
    PreviewAxisRotation.prototype.rotateToEuler = function (rotation) {
        this.target.setFromEuler(this.eulerFromObject(rotation));
        this.time = this.speed;
    };
    /**
     * Set the rotation of an axis
     * @param Object rotation Euler rotation values for each axis. {x,y,z}
     */
    PreviewAxisRotation.prototype.setLocalRotation = function (rotation) {
        // interrupt if transitioning
        this.time = 0;
        // just reusing target here, not going to interpolate to it
        this.target.setFromEuler(this.eulerFromObject(rotation));
        this.setRotation(this.target);
    };
    /**
     * Apply a quaternion rotation to the entity!
     */
    PreviewAxisRotation.prototype.setRotation = function (target) {
        this.getEntity().setQuaternion(target.x, target.y, target.z, target.w);
        // alternative instead of forcing a change event on the entity
        if (this.hasRuntimeData() && !this.getRuntimeData().quaternion.equals(target)) {
            this.getRuntimeData().quaternion.copy(target);
        }
        this.getEngine().needsRender = true;
    };
    /**
     * Get the sign for the value provided.
     * @returns {string} + if a positive value, - if negative
     */
    PreviewAxisRotation.prototype.getSign = function (value) {
        return value > 0 ? '+' : '-';
    };
    /**
     * Get the up and forward axes, useable by preview
     * @param {Function} callback Receives the up and forward axes
     * @returns {Object} An object with an up and forward component. Used for Box Preview
     */
    PreviewAxisRotation.prototype.getAxes = function (callback) {
        var matrix = this.getRuntimeData().matrix;
        var upVec = this.getUpVector(matrix).normalize();
        var forwardVec = this.getForwardVector(matrix).normalize();
        var absX = Math.abs(upVec.x);
        var absY = Math.abs(upVec.y);
        var absZ = Math.abs(upVec.z);
        var up = absX < absZ ? (absZ < absY ? 'y' : 'z') : (absX < absY ? 'y' : 'x');
        absX = Math.abs(forwardVec.x);
        absY = Math.abs(forwardVec.y);
        absZ = Math.abs(forwardVec.z);
        var forward = absX < absZ ? (absZ < absY ? 'y' : 'z') : (absX < absY ? 'y' : 'x');
        // translate to values usable by preview
        var axes = {
            up: ("" + this.getSign(upVec[up]) + up).toUpperCase(),
            forward: ("" + this.getSign(forwardVec[forward]) + forward).toUpperCase()
        };
        if (callback) {
            callback(axes);
        }
        return axes;
    };
    /** @inheritdoc */
    PreviewAxisRotation.prototype.onStartup = function () {
        this.listenTo(this.getEngine(), 'rotate_to', this.rotateToEuler);
        this.listenTo(this.getEngine(), 'rotate_on_axis', this.rotateOnWorldAxis);
        this.listenTo(this.getEngine(), 'set_local_rotation', this.setLocalRotation);
        this.listenTo(this.getEngine(), 'set_axes', this.setAxes);
        this.listenTo(this.getEngine(), 'get_axes', this.getAxes);
        this.listenTo(this.getEntity(), 'rotate_to', this.rotateToEuler);
        this.listenTo(this.getEntity(), 'rotate_on_axis', this.rotateOnWorldAxis);
        this.listenTo(this.getEntity(), 'set_local_rotation', this.setLocalRotation);
        this.listenTo(this.getEntity(), 'set_axes', this.setAxes);
        this.listenTo(this.getEntity(), 'get_axes', this.getAxes);
    };
    /** @inheritdoc */
    PreviewAxisRotation.prototype.onUpdate = function (dt) {
        if (this.time >= 0 && this.hasRuntimeData()) {
            this.time -= dt;
            this.tempQuat.copy(this.getRuntimeData().quaternion);
            this.tempQuat.slerp(this.target, Math.min(1, Math.max(0, 1 - 1 / (this.speed / this.time))));
            this.getEntity().setQuaternion(this.tempQuat.x, this.tempQuat.y, this.tempQuat.z, this.tempQuat.w);
            // force render
            this.getEngine().needsRender = true;
            // transition over, notify user!
            if (this.time < 0) {
                this.setRotation(this.target);
                this.getEntity().trigger('axis_transition_complete');
            }
        }
    };
    return PreviewAxisRotation;
}(BaseComponent_1.default));
exports.default = PreviewAxisRotation;


/***/ }),
/* 107 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid reflection_capture_planar
 * @vname Reflection Capture Planar
 * @vfilter Object
 * @vcategory Rendering
 * @vreserved
 */
var ReflectionCapturePlanar = (function (_super) {
    tslib_1.__extends(ReflectionCapturePlanar, _super);
    function ReflectionCapturePlanar() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The number of frames that have elapsed since the last  update. */
        _this.framesElapsed = 0;
        /** The normal vector used for the reflection. */
        _this.reflectionNormal = new THREE.Vector3(0, 1, 0);
        /** The plane used to capture the reflection. */
        _this.reflectionPlane = new THREE.Plane();
        /** The clip plane used for the reflection capture. */
        _this.clipPlane = new THREE.Vector4();
        /** The position of the reflection.  */
        _this.reflectionPosition = new THREE.Vector3();
        /** THe world position of the camera. */
        _this.cameraWorldPosition = new THREE.Vector3();
        /** A rotation matrix used in the reflection capture. */
        _this.rotationMatrix = new THREE.Matrix4();
        /** The look at position used in the reflection capture. */
        _this.lookAtPosition = new THREE.Vector3(0, 0, -1);
        /** The up vector. */
        _this.up = new THREE.Vector3(0, 1, 0);
        /** A THREE perspective camera. */
        _this.perspectiveCamera = null;
        /** A THREE orthographic camera. */
        _this.orthoCamera = null;
        return _this;
    }
    /**
     * Render the scene to the texture.
     * @param scene   The scene that the reflection will render.
     * @param camera  The camera that the reflection will be rendered relative to (since
     *                reflections are dependent on view)
     */
    ReflectionCapturePlanar.prototype.captureScene = function (scene, camera) {
        if (!camera) {
            throw new Error('Call to ReflectionCapture.captureScene without specifying a camera.');
        }
        this.updateReflection(camera);
        // Render the mirrored view of the current scene into the target texture
        var threeTexture = this.captureTexture ? this.captureTexture.runtimeData : null;
        var target = threeTexture ? threeTexture : this.tempRenderTexture.runtimeData;
        this.getRenderer().renderView(scene, this.reflectionCamera, {
            renderTarget: target,
            clearDepth: true,
            enableShadows: false,
            enablePreRenderFunctions: false
        });
    };
    /** @inheritdoc */
    ReflectionCapturePlanar.prototype.onEntityReady = function () {
        this.initCameras();
        this.initTexture();
    };
    /** @inheritdoc */
    ReflectionCapturePlanar.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('captureTexture') !== -1) {
            this.initTexture();
        }
    };
    /** @inheritdoc */
    ReflectionCapturePlanar.prototype.onPreRenderView = function (scene, camera) {
        if (!this.isEnabled()) {
            return;
        }
        if (this.framesElapsed >= this.updateFrameInterval) {
            // render reflection
            this.captureScene(scene, camera);
            this.framesElapsed = 0;
        }
        else {
            this.framesElapsed++;
        }
    };
    /** Creates the temporary render texture. */
    ReflectionCapturePlanar.prototype.createTempRenderTexture = function () {
        this.tempRenderTexture = this.getEngine().createRenderTexture2d({
            width: 512,
            height: 512,
            format: 'rgba',
            type: 'uByte'
        }, 'render_tex_reflection');
        this.tempRenderTexture.load();
    };
    /** Initializes the capture texture. */
    ReflectionCapturePlanar.prototype.initTexture = function () {
        var _this = this;
        if (this.captureTexture) {
            this.captureTexture.when('load', function () {
                if (_this.tempRenderTexture) {
                    _this.tempRenderTexture.unload();
                }
            });
            if (this.captureTexture.isBaseUnloaded()) {
                this.captureTexture.load();
            }
        }
        else {
            this.createTempRenderTexture();
        }
    };
    /** Initializes the cameras. */
    ReflectionCapturePlanar.prototype.initCameras = function () {
        if (this.captureTexture) {
            this.captureTexture.load();
        }
        this.perspectiveCamera = new THREE.PerspectiveCamera();
        this.orthoCamera = new THREE.OrthographicCamera(-1, 1, -1, 1);
    };
    /**
     * Updates the reflection.
     * @param camera The camera to use.
     */
    ReflectionCapturePlanar.prototype.updateReflection = function (camera) {
        if (!this.isEnabled()) {
            return;
        }
        var sign = function (num) {
            return num < 0 ? -1 : 1;
        };
        this.getEntity().runtimeData.updateMatrixWorld();
        camera.updateMatrixWorld(false);
        this.reflectionPosition.setFromMatrixPosition(this.getEntity().runtimeData.matrixWorld);
        this.cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
        this.rotationMatrix.extractRotation(this.getEntity().runtimeData.matrixWorld);
        this.reflectionNormal.set(0, 1, 0);
        this.reflectionNormal.applyMatrix4(this.rotationMatrix);
        var view = this.reflectionPosition.clone().sub(this.cameraWorldPosition);
        var reflectView = view.reflect(this.reflectionNormal).negate();
        reflectView.add(this.reflectionPosition);
        this.rotationMatrix.extractRotation(camera.matrixWorld);
        this.lookAtPosition.set(0, 0, -1);
        this.lookAtPosition.applyMatrix4(this.rotationMatrix);
        this.lookAtPosition.add(this.cameraWorldPosition);
        var target = this.reflectionPosition.clone().sub(this.lookAtPosition);
        var reflectTarget = target.reflect(this.reflectionNormal).negate();
        reflectTarget.add(this.reflectionPosition);
        this.up.set(0, -1, 0);
        this.up.applyMatrix4(this.rotationMatrix);
        var reflectUp = this.up.reflect(this.reflectionNormal).negate();
        if (camera instanceof THREE.PerspectiveCamera && this.perspectiveCamera) {
            this.perspectiveCamera.aspect = camera.aspect;
            this.perspectiveCamera.fov = camera.fov;
            this.perspectiveCamera.near = camera.near;
            this.perspectiveCamera.far = camera.far;
            this.reflectionCamera = this.perspectiveCamera;
        }
        else if (camera instanceof THREE.OrthographicCamera && this.orthoCamera) {
            this.orthoCamera.left = camera.left;
            this.orthoCamera.right = camera.right;
            this.orthoCamera.top = camera.top;
            this.orthoCamera.bottom = camera.bottom;
            this.orthoCamera.near = camera.near;
            this.orthoCamera.far = camera.far;
            this.reflectionCamera = this.orthoCamera;
        }
        else {
            return;
        }
        this.reflectionCamera.position.copy(reflectView);
        this.reflectionCamera.up = reflectUp;
        this.reflectionCamera.lookAt(reflectTarget);
        this.reflectionCamera.updateProjectionMatrix();
        this.reflectionCamera.updateMatrixWorld(false);
        this.reflectionCamera.matrixWorldInverse.getInverse(this.reflectionCamera.matrixWorld);
        // Now update projection matrix with new clip plane, implementing code
        // from: http://www.terathon.com/code/oblique.html
        // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
        this.reflectionPlane.setFromNormalAndCoplanarPoint(this.reflectionNormal, this.reflectionPosition);
        this.reflectionPlane.applyMatrix4(this.reflectionCamera.matrixWorldInverse);
        this.clipPlane.set(this.reflectionPlane.normal.x, this.reflectionPlane.normal.y, this.reflectionPlane.normal.z, this.reflectionPlane.constant);
        var q = new THREE.Vector4();
        var projectionMatrix = this.reflectionCamera.projectionMatrix;
        projectionMatrix.copy(camera.projectionMatrix);
        // If any left-right asymmetry  exists in the fov, flip the projection.
        projectionMatrix.elements[8] *= -1;
        q.x = (sign(this.clipPlane.x) + projectionMatrix.elements[8]) /
            projectionMatrix.elements[0];
        q.y = (sign(this.clipPlane.y) + projectionMatrix.elements[9]) /
            projectionMatrix.elements[5];
        q.z = -1.0;
        q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
        // Calculate the scaled plane vector
        var c = this.clipPlane.multiplyScalar(2.0 / this.clipPlane.dot(q));
        // Replacing the third row of the projection matrix
        projectionMatrix.elements[2] = c.x;
        projectionMatrix.elements[6] = c.y;
        projectionMatrix.elements[10] = c.z + 1.0 - this.clipBias;
        projectionMatrix.elements[14] = c.w;
    };
    return ReflectionCapturePlanar;
}(BaseComponent_1.default));
exports.default = ReflectionCapturePlanar;


/***/ }),
/* 108 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-line-length */
var THREE = __webpack_require__(1);
var Logger_1 = __webpack_require__(3);
var BaseComponent_1 = __webpack_require__(2);
var UserAgent_1 = __webpack_require__(22);
var functions_1 = __webpack_require__(5);
var browserCaps_1 = __webpack_require__(183);
var MaterialAsset_1 = __webpack_require__(14);
/**
 * @class DefaultRenderer
 * @vid box3d_renderer
 * @vreserved
 * @vname Renderer
 * @vfilter application
 * @vcategory Rendering
 */
var DefaultRenderer = (function (_super) {
    tslib_1.__extends(DefaultRenderer, _super);
    function DefaultRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The THREE.js WebGL renderer instance. */
        _this.threeRenderer = null;
        /** The supported capabilities. */
        _this.caps = {};
        /**
         * Enable or disable anti aliasing of the rendered scene..
         * @vattr Boolean antialias {
         *   description: 'Enable or disable anti aliasing of the rendered scene.',
         *   default: true
         * }
         */
        _this.antialias = false;
        /**
         * Tells the browser to preserve drawing buffers between frames so that they are available to be read by the application.
         * @vattr Boolean preserveDrawingBuffer {
         *   description: 'Tells the browser to preserve drawing buffers between frames so that they are available to be read by the application.',
         *   default: true
         * }
         */
        _this.preserveDrawingBuffer = true;
        /**
         * The default floating point and integer precision to be used by the GPU.
         * @vattr Dropdown precision {
         *   description: 'The default floating point and integer precision to be used by the GPU.',
         *   default: 'mediump',
         *   options: {
         *     'Low': 'lowp',
         *     'Medium': 'mediump',
         *     'High':  'highp'
         *   }
         * }
         */
        _this.precision = 'highp';
        /**
         * Automatically clear the render target before each render.
         * @vattr Boolean autoClear {
         *   description: 'Automatically clear the render target before each render.',
         *   default: false
         * }
         */
        _this.autoClear = false;
        /**
         * Override the default pixel ratio of the system. Higher values will cause rendering at higher resolution while lower
         * values will force rendering at lower resolutions. You can also set this to use the device default (mobile devices
         * usually have values greater than 1).
         * @vattr Dropdown devicePixelRatio {
         *   default: 0.0,
         *   options: { 'Device Default': 0.0, 'One': 1.0, 'Two': 2.0 },
         *   description: 'Override the default pixel ratio of the system. Higher values will cause rendering at higher resolution while lower values will force rendering at lower resolutions. You can also set this to use the device default (mobile devices usually have values greater than 1).',
         * }
         */
        _this.devicePixelRatio = 1.0;
        /**
         * Enable or disable rendering of shadows.
         * @vattr Boolean shadowsEnabled {
         *   description: 'Enable or disable rendering of shadows.',
         *   default: true
         * }
         */
        _this.shadowsEnabled = true;
        /**
         * Enable or disable rendering of shadows on mobile devices.
         * @vattr Boolean shadowsEnabledMobile {
         *   description: 'Enable or disable rendering of shadows on mobile devices.',
         *   default: false
         * }
         */
        _this.shadowsEnabledMobile = false;
        /**
         * The type of shadow map to use. (PCF, Soft PCF or No Filtering)
         * @vattr Dropdown shadowType {
         *   options: {
         *     'Soft PCF': 2,
         *     'PCF': 1,
         *     'No Filtering': 0
         *   },
         *   default: 2
         * }
         */
        _this.shadowType = THREE.PCFSoftShadowMap;
        /**
         * Render shadows with reverse side of mesh.
         * @vattr Boolean shadowReverseSided {
         *   description: 'Render shadows with reverse side of mesh.',
         *   default: false
         * }
         */
        _this.shadowReverseSided = false;
        /**
         * Clamp the maximum allowed dimension of a 2d texture.
         * @vattr Integer maxTextureSize2d {
         *   description: 'Clamp the maximum allowed dimension of a 2d texture.',
         *   default: 32768,
         *   min: 1024,
         *   max: 32768
         * }
         */
        _this.maxTextureSize2d = Number.MAX_SAFE_INTEGER;
        /**
         * Clamp the maximum allowed dimension of a cube texture.
         * @vattr Integer maxTextureSizeCube {
         *   description: 'Clamp the maximum allowed dimension of a cube texture.',
         *   default: 32768,
         *   min: 512,
         *   max: 32768
         * }
         */
        _this.maxTextureSizeCube = Number.MAX_SAFE_INTEGER;
        /**
         * When the render target is cleared, this colour will be used.
         * @vattr Color clearColor {
         *   description: 'When the render target is cleared, this colour will be used',
         *   default: {r: 0, g: 0, b:0}
         * }
         */
        _this.clearColor = new THREE.Color();
        /**
         * When the render target is cleared, this value will be used to clear the transparency.
         * @vattr Float clearAlpha {
         *   description: 'When the render target is cleared, this value will be used to clear the transparency',
         *   default: 0,
         *   min: 0.0,
         *   max: 1.0,
         *   step: 0.001
         * }
         */
        _this.clearAlpha = 0.0;
        /**
         * When this is enabled, rendering will only happen when requested instead of every frame.
         * @vattr Boolean renderOnDemand {
         *   description: 'When this is enabled, rendering will only happen when requested instead of every frame.',
         *   default: true
         * }
         */
        _this.renderOnDemand = true;
        return _this;
    }
    /** @inheritdoc */
    DefaultRenderer.prototype.onAwake = function () {
        this.canvas = this.getEngine().canvas;
        this.initDefaultRenderer();
        this.getEngine().setRenderer(this);
        // Init scene sceneComposer
        var renderer = this.getThreeRenderer();
        renderer.gammaInput = false;
        renderer.gammaOutput = true;
    };
    /** @inheritdoc */
    DefaultRenderer.prototype.onStartup = function () {
        this.listenTo(this.getEngine(), 'resize', this.onContainerResize);
        this.getEngine().renderOnDemand = this.renderOnDemand;
        if (!this.shadowsEnabledMobile) {
            this.shadowsEnabled = UserAgent_1.isMobile() ? this.shadowsEnabledMobile &&
                this.shadowsEnabled : this.shadowsEnabled;
        }
        this.applyRenderSettings();
    };
    /** @inheritdoc */
    DefaultRenderer.prototype.onShutdown = function () {
        if (this.threeRenderer) {
            this.threeRenderer.context = null;
        }
        this.threeRenderer = null;
        this.canvas = undefined;
    };
    /** @inheritdoc */
    DefaultRenderer.prototype.onAttributesChanged = function (changes) {
        var rebuildMaterials = false;
        if (changes.indexOf('shadowsEnabledMobile') !== -1) {
            rebuildMaterials = true;
        }
        this.shadowsEnabled = UserAgent_1.isMobile() ? this.shadowsEnabledMobile &&
            this.shadowsEnabled : this.shadowsEnabled;
        this.applyRenderSettings();
        this.getEngine().renderOnDemand = this.renderOnDemand;
        if (changes.indexOf('clearAlpha') !== -1) {
            this.threeRenderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        if (changes.indexOf('clearColor') !== -1) {
            this.threeRenderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        if (changes.indexOf('gammaOutput') !== -1) {
            rebuildMaterials = true;
        }
        if (changes.indexOf('gammaInput') !== -1) {
            rebuildMaterials = true;
        }
        if (changes.indexOf('shadowsEnabled') !== -1) {
            rebuildMaterials = true;
        }
        if (changes.indexOf('shadowType') !== -1) {
            this.shadowType = parseInt(String(this.shadowType), 10);
            // TODO - need to recreate the shadow maps if the shadow
            // filtering has changed because PCFSoftShadowMap requires the shadow map
            // to be rendered with no filtering.
            rebuildMaterials = true;
        }
        if (changes.indexOf('devicePixelRatio') !== -1) {
            this.onContainerResize();
        }
        if (rebuildMaterials) {
            Logger_1.default.info('Rebuilding materials!!!');
            this.getEngine().trigger('rebuildMaterials');
        }
    };
    /**
     * Given the name of a GPU device capability (e.g. MAX_VERTEX_TEXTURE_IMAGE_UNITS ),
     * return the current system's value for this capability.
     * @param  {String} cap The capability name
     * @returns {number}     The value of the capability
     */
    DefaultRenderer.prototype.getGPUCapability = function (cap) {
        return this.caps[cap];
    };
    /**
     * Returns the maximum texture size supported by the device.
     * @method  getMaxTextureSize2d
     * @public
     * @returns {number} The maximum texture size.
     */
    DefaultRenderer.prototype.getMaxTextureSize2d = function () {
        if (!this.maxTextureSize2d) {
            return this.getGPUCapability('MAX_TEXTURE_SIZE');
        }
        return Math.min(this.maxTextureSize2d, this.getGPUCapability('MAX_TEXTURE_SIZE'));
    };
    /**
     * Returns the maximum cube texture size supported by the device.
     * @returns The cube map maximum texture size.
     */
    DefaultRenderer.prototype.getMaxTextureSizeCube = function () {
        if (!this.maxTextureSizeCube) {
            return this.getGPUCapability('MAX_CUBE_MAP_TEXTURE_SIZE');
        }
        return Math.min(this.maxTextureSizeCube, this.getGPUCapability('MAX_CUBE_MAP_TEXTURE_SIZE'));
    };
    /** @inheritdoc */
    DefaultRenderer.prototype.onPreRender = function () {
        // this.newRenderStarted = true;
        this.threeRenderer.setRenderTarget(null);
        this.threeRenderer.clear(true, true, true);
        this.threeRenderer.setViewport(0, 0, this.getWidth(), this.getHeight());
    };
    /**
     * Renders a given scene from the perspective of a given camera with the specified options.
     * @param {THREE.Scene} scene
     * @param {THREE.Camera} camera
     * @param {RenderViewOptions} [options={}]
     * @returns {void}
     */
    DefaultRenderer.prototype.renderView = function (scene, camera, options) {
        if (options === void 0) { options = {}; }
        var screenDimensions;
        if (camera) {
            if (options.enablePreRenderFunctions) {
                this.getEngine().trigger('preRenderView', scene, camera, options);
            }
            var canvasStyle = this.getCanvas().style;
            if (options.opacity !== undefined && (!options.viewPort ||
                options.viewPort.width === this.getWidth() &&
                    options.viewPort.height === this.getHeight())) {
                if (parseFloat(canvasStyle.opacity) !== options.opacity) {
                    canvasStyle.opacity = '' + options.opacity;
                }
            }
            else if (parseFloat(canvasStyle.opacity) !== 1) {
                canvasStyle.opacity = '1.0';
            }
            if (!options.renderTarget) {
                this.threeRenderer.setRenderTarget(null);
            }
            else {
                this.threeRenderer.setRenderTarget(options.renderTarget);
            }
            this.threeRenderer.clear(options.clearColor, options.clearDepth, options.clearStencil);
            if (options.viewPort) {
                /* tslint:disable no-string-literal */
                screenDimensions = MaterialAsset_1.default.sharedUniforms['screenDimensions'];
                /* tslint:enable no-string-literal */
                screenDimensions.value.x = options.viewPort.x;
                screenDimensions.value.y = options.viewPort.y;
                screenDimensions.value.z = options.viewPort.width * this.devicePixelRatio;
                screenDimensions.value.w = options.viewPort.height * this.devicePixelRatio;
                this.threeRenderer.setViewport(options.viewPort.x, options.viewPort.y, options.viewPort.width, options.viewPort.height);
            }
            var renderer = options.effect ? options.effect : this.threeRenderer;
            if (options.renderTarget) {
                renderer.render(scene, camera, options.renderTarget, false);
            }
            else {
                renderer.render(scene, camera);
            }
            this.getEngine().trigger('postRenderView', scene, camera, options);
        }
    };
    /**
     * Returns the size of the render target in device-independent pixels (dips)
     * @returns The width of the render target.
     */
    DefaultRenderer.prototype.getWidth = function () {
        return this.canvas.clientWidth;
    };
    /**
     * Returns the size of the render target in device-independent pixels (dips)
     * @returns The height of the render target.
     */
    DefaultRenderer.prototype.getHeight = function () {
        return this.canvas.clientHeight;
    };
    /**
     * Returns the width of the canvas element.
     * @returns The width of the canvas element.
     */
    DefaultRenderer.prototype.getCanvasWidth = function () {
        return this.canvas.width;
    };
    /**
     * Returns the height of the canvas element.
     * @returns The height of the canvas element.
     */
    DefaultRenderer.prototype.getCanvasHeight = function () {
        return this.canvas.height;
    };
    /**
     * Returns the canvas element.
     * @returns The canvas element.
     */
    DefaultRenderer.prototype.getCanvas = function () {
        return this.threeRenderer.domElement;
    };
    /** Handles the resize event. */
    DefaultRenderer.prototype.onContainerResize = function () {
        if (this.canvas.parentElement) {
            var w_1 = this.canvas.parentElement.clientWidth;
            var h_1 = this.canvas.parentElement.clientHeight;
            this.threeRenderer.setPixelRatio(this.devicePixelRatio);
            if (UserAgent_1.isIOS()) {
                // This hack works around a canvas resize related bug in iOS
                var canvas_1 = this.canvas;
                this.threeRenderer.setSize(w_1, h_1, false);
                canvas_1.style.width = (w_1 + 1) + 'px';
                canvas_1.style.height = (h_1 + 1) + 'px';
                setTimeout(function () {
                    canvas_1.style.width = w_1 + 'px';
                    canvas_1.style.height = h_1 + 'px';
                }, 100);
            }
            else {
                this.threeRenderer.setSize(w_1, h_1, true);
            }
            this.getEngine().trigger('rendererResize');
        }
    };
    /** Stores the capabilities in the caps member variable. */
    DefaultRenderer.prototype.storeGpuCaps = function () {
        var context = this.threeRenderer.getContext();
        Logger_1.default.info('WebGL VENDOR is ' + context.getParameter(context.VENDOR));
        Logger_1.default.info('WebGL SHADING_LANGUAGE_VERSION is ' +
            context.getParameter(context.SHADING_LANGUAGE_VERSION));
        Logger_1.default.info('WebGL RENDERER is ' + context.getParameter(context.RENDERER));
        var fShaderConst = context.FRAGMENT_SHADER;
        var lFloatConst = context.LOW_FLOAT;
        var mFloatConst = context.MEDIUM_FLOAT;
        var hFloatConst = context.HIGH_FLOAT;
        var shaderPrecFormat = context.getShaderPrecisionFormat(fShaderConst, lFloatConst);
        Logger_1.default.info('Fragment Shader lowp is ' + shaderPrecFormat.precision);
        shaderPrecFormat = context.getShaderPrecisionFormat(fShaderConst, mFloatConst);
        Logger_1.default.info('Fragment Shader mediump is ' + shaderPrecFormat.precision);
        shaderPrecFormat = context.getShaderPrecisionFormat(fShaderConst, hFloatConst);
        Logger_1.default.info('Fragment Shader highp is ' + shaderPrecFormat.precision);
        if (!navigator.isCocoonJS) {
            this.caps.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0;
            this.caps.MAX_CUBE_MAP_TEXTURE_SIZE = 0;
            this.caps.MAX_FRAGMENT_UNIFORM_VECTORS = 0;
            this.caps.MAX_RENDERBUFFER_SIZE = 0;
            this.caps.MAX_TEXTURE_IMAGE_UNITS = 0;
            this.caps.MAX_TEXTURE_SIZE = 0;
            this.caps.MAX_VARYING_VECTORS = 0;
            this.caps.MAX_VERTEX_ATTRIBS = 0;
            this.caps.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0;
            this.caps.MAX_VERTEX_UNIFORM_VECTORS = 0;
            this.caps.MAX_VIEWPORT_DIMS = 0;
            this.caps.ALIASED_POINT_SIZE_RANGE = 0;
            this.caps.ALIASED_LINE_WIDTH_RANGE = 0;
            this.caps.SAMPLES = 0;
            this.caps.SAMPLE_BUFFERS = 0;
            this.caps.RED_BITS = 0;
            this.caps.GREEN_BITS = 0;
            this.caps.BLUE_BITS = 0;
            this.caps.ALPHA_BITS = 0;
            this.caps.DEPTH_BITS = 0;
            this.caps.STENCIL_BITS = 0;
            this.caps.SUBPIXEL_BITS = 0;
            this.caps.COMPRESSED_TEXTURE_FORMATS = 0;
            this.caps = functions_1.map(this.caps, function (_value, key) {
                return context.getParameter(context[key]);
            });
            this.caps.EXTENSIONS = context.getSupportedExtensions();
            var glExtTexAniso = context.getExtension('EXT_texture_filter_anisotropic') ||
                context.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                context.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            this.caps.maxAnisotropy = glExtTexAniso ?
                context.getParameter(glExtTexAniso.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            Logger_1.default.info('GPU Capabilities:', this.caps);
        }
    };
    /** Initializes the default renderer. */
    DefaultRenderer.prototype.initDefaultRenderer = function () {
        if (browserCaps_1.default.isWebGLEnabled()) {
            this.threeRenderer = new THREE.WebGLRenderer({
                canvas: this.canvas,
                antialias: this.antialias,
                preserveDrawingBuffer: this.preserveDrawingBuffer,
                alpha: true,
                precision: this.precision,
                logarithmicDepthBuffer: this.logarithmicDepthBuffer
            });
            this.threeRenderer.physicallyCorrectLights = true;
            this.threeRenderer.setPixelRatio(this.devicePixelRatio > 0 ?
                this.devicePixelRatio : window.devicePixelRatio);
            this.storeGpuCaps();
        }
        else {
            // TODO: Is there something better we can do in the case that WebGL is not supported?
            throw new Error('WebGL is not supported, no fallbacks available.');
        }
    };
    /** Apply changed render settings. */
    DefaultRenderer.prototype.applyRenderSettings = function () {
        var _this = this;
        if (this.threeRenderer) {
            // TODO: Maybe we shouldn't iterate this object in this way?
            functions_1.forEach(this, function (value, key) {
                if (_this.threeRenderer[key] !== undefined) {
                    _this.threeRenderer[key] = value;
                }
            });
            if (!(this.devicePixelRatio > 0.0)) {
                this.devicePixelRatio = window.devicePixelRatio;
            }
            this.threeRenderer.setClearColor(this.clearColor, this.clearAlpha);
            if (this.shadowsEnabled) {
                this.threeRenderer.shadowMap.enabled = true;
                this.threeRenderer.shadowMap.type = this.shadowType;
                this.threeRenderer.shadowMap.renderReverseSided = this.shadowReverseSided;
            }
        }
    };
    return DefaultRenderer;
}(BaseComponent_1.default));
exports.default = DefaultRenderer;


/***/ }),
/* 109 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var BaseObject_1 = __webpack_require__(10);
var tmpVec = new THREE.Vector3();
var tmpEuler = new THREE.Euler();
/**
 * @vid rotate
 * @vname Rotate
 * @vdescription A simple component which rotates the attached object.
 * @vcategory Animation
 * @vfilter object
 * A simple component which rotates the attached object.
 */
var Rotate = (function (_super) {
    tslib_1.__extends(Rotate, _super);
    function Rotate() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** Quaternion used for local rotations. */
        _this.quaternion = new THREE.Quaternion();
        /** Quaternion used for global rotations. */
        _this.currentGlobalQuaternion = new THREE.Quaternion();
        return _this;
    }
    /** @inheritdoc */
    Rotate.prototype.onStartup = function () {
        this.rotate = this.autoRotate;
        this.getEntity().on('startRotate', this.onStartRotate, this);
        this.getEntity().on('stopRotate', this.onStopRotate, this);
        this.getEntity().on('toggleRotate', this.onToggleRotate, this);
    };
    /** @inheritdoc */
    Rotate.prototype.onShutdown = function () {
        this.getEntity().off('startRotate', this.onStartRotate, this);
        this.getEntity().off('stopRotate', this.onStopRotate, this);
        this.getEntity().off('toggleRotate', this.onToggleRotate, this);
    };
    /** @inheritdoc */
    Rotate.prototype.onEnable = function () {
        this.rotate = this.autoRotate;
        this.initRotation();
    };
    /** @inheritdoc */
    Rotate.prototype.onDisable = function () {
        var entity = this.getEntity();
        if (entity instanceof BaseObject_1.default) {
            this.getRuntimeData().position.copy(entity.getPosition());
            this.getRuntimeData().quaternion.copy(entity.getQuaternion());
            this.rotate = false;
        }
    };
    /** @inheritdoc */
    Rotate.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('rotation') && this.rotation) {
            this.initRotation();
        }
    };
    /** @inheritdoc */
    Rotate.prototype.onEntityReady = function () {
        this.initialQuaternion = new THREE.Quaternion();
        this.initialQuaternion.copy(this.getRuntimeData().quaternion);
        this.initRotation();
    };
    /** @inheritdoc */
    Rotate.prototype.onUpdate = function (delta) {
        if (this.rotate && this.isEnabled()) {
            this.getEngine().needsRender = true;
            if (this.getRuntimeData() && this.rotation) {
                tmpVec.copy(this.rotation).multiplyScalar(delta);
                tmpEuler.set(tmpVec.x, tmpVec.y, tmpVec.z);
                this.quaternion.setFromEuler(tmpEuler);
                if (this.local) {
                    this.getRuntimeData().quaternion.multiply(this.quaternion);
                }
                else {
                    this.currentGlobalQuaternion.multiply(this.quaternion);
                    this.getRuntimeData().quaternion.multiplyQuaternions(this.currentGlobalQuaternion, this.initialQuaternion);
                }
            }
        }
    };
    /** Initializes the rotational data. */
    Rotate.prototype.initRotation = function () {
        tmpEuler.set(this.rotation.x, this.rotation.y, this.rotation.z);
        if (this.local) {
            this.getRuntimeData().quaternion.copy(this.initialQuaternion);
        }
        else {
            this.currentGlobalQuaternion.set(0, 0, 0, 1);
        }
    };
    /** Handles the startRotate event. */
    Rotate.prototype.onStartRotate = function () {
        this.rotate = true;
    };
    /** Handles the stopRotate event. */
    Rotate.prototype.onStopRotate = function () {
        this.rotate = false;
    };
    /** Handles the toggleRotate event. */
    Rotate.prototype.onToggleRotate = function () {
        this.rotate = !this.rotate;
    };
    return Rotate;
}(BaseComponent_1.default));
/**
 * Event definitions:
 *
 * @vevent local startRotate {
 *   action: true,
 *   category: 'Rotate',
 *   parameters: []
 * }
 *
 * @vevent local stopRotate {
 *   action: true,
 *   category: 'Rotate',
 *   parameters: []
 * }
 *
 * @vevent local toggleRotate {
 *   action: true,
 *   category: 'Rotate',
 *   parameters: []
 * }
 */
exports.default = Rotate;


/***/ }),
/* 110 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-string-literal */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var SimplexNoiseGeneratorVert = __webpack_require__(226);
var SimplexNoiseGeneratorFrag = __webpack_require__(225);
/**
 * @vid simplex_noise_generator
 * @vname Simplex Noise Generator
 * @vcategory Rendering
 * @vfilter renderTexture2D
 */
var SimplexNoiseGenerator = (function (_super) {
    tslib_1.__extends(SimplexNoiseGenerator, _super);
    function SimplexNoiseGenerator() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * If true, the normal map will be generated automatically on entity availability.
         * @vattr Boolean autoLoad {
         *   default: true
         * }
         */
        _this.autoLoad = true;
        /** The shader uniforms. */
        _this.uniforms = null;
        /** The shader material used to render the noise.  */
        _this.noiseMat = null;
        /** True if the component has been initialized and is ready. */
        _this.initialized = false;
        return _this;
    }
    /** @inheritdoc */
    SimplexNoiseGenerator.prototype.onStartup = function () {
        this.listenTo(this.getEntity(), 'changeNoiseValues', this.changeNoiseValues);
        this.listenTo(this.getEntity(), 'renderNoise', this.changeNoiseValues);
        this.uniforms = {
            time: {
                type: 'f',
                value: 1.0
            },
            scale: {
                type: 'v2',
                value: this.scale
            },
            offset: {
                type: 'v2',
                value: this.offset
            },
            layerAmplitude: {
                type: 'v4',
                value: this.layerAmplitude
            },
            layerScale: {
                type: 'v4',
                value: this.layerScale
            }
        };
        // create noise material
        this.noiseMat = new THREE.ShaderMaterial({
            uniforms: this.uniforms,
            vertexShader: SimplexNoiseGeneratorVert,
            fragmentShader: SimplexNoiseGeneratorFrag
        });
        this.cameraRTT = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10, 10);
        this.cameraRTT.position.z = 1;
        this.sceneRTT = new THREE.Scene();
        this.sceneRTT.add(this.cameraRTT);
        this.quadGeo = new THREE.PlaneGeometry(1, 1);
        this.quadRTT = new THREE.Mesh(this.quadGeo, this.noiseMat);
        this.quadRTT.position.z = -5;
        this.sceneRTT.add(this.quadRTT);
        this.initialized = true;
    };
    /** @inheritdoc */
    SimplexNoiseGenerator.prototype.onShutdown = function () {
        if (this.sceneRTT) {
            this.sceneRTT.remove(this.cameraRTT);
            this.sceneRTT.remove(this.quadRTT);
        }
        this.sceneRTT = undefined;
        this.quadRTT = undefined;
        if (this.quadGeo) {
            this.quadGeo.dispose();
        }
        if (this.noiseMat) {
            this.noiseMat.dispose();
        }
        this.uniforms = undefined;
    };
    /** @inheritdoc */
    SimplexNoiseGenerator.prototype.onEntityReady = function () {
        if (this.autoLoad) {
            this.renderNoise();
        }
    };
    /** @inheritdoc */
    SimplexNoiseGenerator.prototype.onAttributesChanged = function (attributes) {
        if (this.initialized) {
            if (attributes.indexOf('scale') !== -1 && this.scale.x !== undefined) {
                this.uniforms['scale'].value.x = this.scale.x;
                this.uniforms['scale'].value.y = this.scale.y;
            }
            if (attributes.indexOf('offset') !== -1 && this.offset.x !== undefined) {
                this.uniforms['offset'].value.x = this.offset.x;
                this.uniforms['offset'].value.y = this.offset.y;
            }
            if (attributes.indexOf('layerScale') !== -1 && this.layerScale.x !== undefined) {
                this.uniforms['layerScale'].value.x = this.layerScale.x;
                this.uniforms['layerScale'].value.y = this.layerScale.y;
                this.uniforms['layerScale'].value.z = this.layerScale.z;
                this.uniforms['layerScale'].value.w = this.layerScale.w;
            }
            if (attributes.indexOf('layerAmplitude') !== -1 && this.layerAmplitude.x !== undefined) {
                this.uniforms['layerAmplitude'].value.x = this.layerAmplitude.x;
                this.uniforms['layerAmplitude'].value.y = this.layerAmplitude.y;
                this.uniforms['layerAmplitude'].value.z = this.layerAmplitude.z;
                this.uniforms['layerAmplitude'].value.w = this.layerAmplitude.w;
            }
            this.renderNoise();
        }
    };
    /** Renders the noise into the attached render texture asset. */
    SimplexNoiseGenerator.prototype.renderNoise = function () {
        this.getThreeRenderer().render(this.sceneRTT, this.cameraRTT, this.getRuntimeData(), true);
        this.getThreeRenderer().setRenderTarget(null);
    };
    /**
     * Handles the changeNoiseValues event.
     * @param layerAmplitude The layer amplitude uniform value for the shader.
     * @param layerScale     The layer scale uniform value for the shader.
     * @param scale          The scale uniform value for the shader.
     * @param offset         The offset uniform value for the shader.
     */
    SimplexNoiseGenerator.prototype.changeNoiseValues = function (layerAmplitude, layerScale, scale, offset) {
        this.layerAmplitude = layerAmplitude;
        this.layerScale = layerScale;
        this.scale = scale;
        this.offset = offset;
        this.onAttributesChanged(['layerAmplitude', 'layerScale', 'scale', 'offset']);
    };
    return SimplexNoiseGenerator;
}(BaseComponent_1.default));
/**
 * Event definitions:
 *
 * @vevent local renderNoise {
 *   action: true,
 *   category: 'Rendering',
 *   parameters: []
 * }
 *
 * @vevent local changeNoiseValues {
 *   action: true,
 *   category: 'Rendering',
 *   parameters: [
 *     {'name': 'layerAmplitude', 'type': 'v4', 'description': '', default: { x: 0.5, y: 0.4, z: 0.3, w: 0.125 }},
 *     {'name': 'layerScale', 'type': 'v4', 'description': '', default: { x: 0.5, y: 2.0, z: 3.0, w: 4.0 }},
 *     {'name': 'scale', 'type': 'v2', 'description': '', default: { x: 1.0, y: 1.0 }},
 *     {'name': 'offset', 'type': 'v2', 'description': '', default: { x: 0.0, y: 0.0 }}
 *   ]
 * }
 */
exports.default = SimplexNoiseGenerator;


/***/ }),
/* 111 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var BaseImageAsset_1 = __webpack_require__(11);
/**
 * @vid skybox_renderer
 * @vname Skybox
 * @vcategory Rendering
 * @vfilter scene
 */
var SkyboxRenderer = (function (_super) {
    tslib_1.__extends(SkyboxRenderer, _super);
    function SkyboxRenderer() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /**
         * The texture asset to use. Can be one of texture2D, textureCube,
         * renderTexture2d or renderTextureCube.
         * @vattr Asset skyboxTexture {
         *   'description': 'The texture asset to use.',
         *   'type': 'asset',
         *   'filter': {
         *     'textureCube': true,
         *     'texture2D': true,
         *     'renderTexture2D': true,
         *     'renderTextureCube': true
         *   },
         *   'default': null
         * }
         */
        _this.skyboxTexture = null;
        /**
         * Determines whether or not to render in stereoscopic mode.
         * @vattr Boolean stereoEnabled { 'default' : false }
         */
        _this.stereoEnabled = false;
        /**
         * The size (uniform scale) of the skybox.
         * @vattr Float size { 'default' : 1000, 'min' : 1.0, 'max' : 1000000.0 }
         */
        _this.size = 100.0;
        /** The skybox mesh used for the left eye. */
        _this.skyboxMesh = null;
        /** The skybox mesh used for the right eye. */
        _this.skyboxMeshRightEye = null;
        /** The skybox geometry used for the left eye. */
        _this.skyboxGeometry = null;
        /** The skybox geometry used for the right eye. */
        _this.skyboxGeometryRightEye = null;
        /** The skybox cube material. */
        _this.skyboxMaterialCube = null;
        /** Uniforms used by the skybox cube material. */
        _this.skyboxUniforms = null;
        /** The vertex shader used by the skybox cube material. */
        _this.skyboxVShader = null;
        /** The fragment shader used by the skybox cube material. */
        _this.skyboxPShader = null;
        /** The skybox 2d material. */
        _this.skyboxMaterial2D = null;
        return _this;
    }
    /** @inheritdoc */
    SkyboxRenderer.prototype.onStartup = function () {
        this.initMaterials();
    };
    /** @inheritdoc */
    SkyboxRenderer.prototype.onShutdown = function () {
        if (this.skyboxGeometry) {
            this.skyboxGeometry.dispose();
        }
        if (this.skyboxGeometryRightEye) {
            this.skyboxGeometryRightEye.dispose();
        }
        if (this.skyboxMaterialCube) {
            this.skyboxMaterialCube.dispose();
        }
        if (this.skyboxMaterial2D) {
            this.skyboxMaterial2D.dispose();
        }
        this.skyboxMesh = null;
        this.skyboxGeometry = null;
        this.skyboxGeometryRightEye = null;
        this.skyboxMaterialCube = null;
        this.skyboxMaterial2D = null;
        this.skyboxUniforms = null;
        this.skyboxTexture = null;
    };
    /**
     * Returns the Three.js mesh for the skybox.
     * @param [eye='left'] If skybox is stereo, return the mesh for a specific eye.
     * Either 'left' or 'right'
     */
    SkyboxRenderer.prototype.getMesh = function (eye) {
        if (eye === void 0) { eye = 'left'; }
        return eye === 'left' ? this.skyboxMesh : this.skyboxMeshRightEye;
    };
    /** @inheritdoc */
    SkyboxRenderer.prototype.onAttributesChanged = function (changed) {
        // Do dependency setup (should be automated in the future)
        if (changed.indexOf('skyboxTexture') !== -1) {
            var prevTextureId = this.getPreviousAttribute('skyboxTexture');
            if (prevTextureId) {
                var texture = this.getEngine().getEntityById(prevTextureId);
                this.stopListening(texture);
            }
            this.getEntity().unregisterDependencyById(this.getPreviousAttribute('skyboxTexture'));
            // Only register the texture if it wasn't already registered. This code can be removed
            // when we make this more automatic.
            var dependencies = this.getEntity().getOwnDependencyInfo();
            var newTextureId = this.getAttribute('skyboxTexture');
            if (!dependencies[newTextureId]) {
                this.getEntity().registerDependencyById(this.getAttribute('skyboxTexture'));
            }
        }
        // Don't do any setup unless the entity is loaded/loading
        if (!this.getEntity().isBaseLoaded()) {
            return;
        }
        if (changed.indexOf('skyboxTexture') !== -1 || changed.indexOf('stereoEnabled') !== -1) {
            this.initSkybox();
        }
        if (changed.indexOf('size') !== -1) {
            if (this.skyboxMesh) {
                this.skyboxMesh.scale.set(this.size, this.size, this.size);
                this.skyboxMeshRightEye.scale.set(this.size, this.size, this.size);
            }
        }
    };
    /** @inheritdoc */
    SkyboxRenderer.prototype.onEnable = function () {
        if (this.getRuntimeData()) {
            this.getRuntimeData().add(this.skyboxMesh);
            if (this.isStereo()) {
                this.getRuntimeData().add(this.skyboxMeshRightEye);
            }
            if (this.skyboxTexture && this.skyboxTexture.isUnloaded()) {
                this.skyboxTexture.load();
            }
        }
    };
    /** @inheritdoc */
    SkyboxRenderer.prototype.onDisable = function () {
        if (this.getRuntimeData()) {
            this.getRuntimeData().remove(this.skyboxMesh);
            if (this.isStereo()) {
                this.getRuntimeData().remove(this.skyboxMeshRightEye);
            }
        }
    };
    /** @inheritdoc */
    SkyboxRenderer.prototype.onEntityReady = function () {
        this.initSkybox();
    };
    /**
     * Returns true iff the texture layout is stereoscopic (i.e. contains left and right eye images).
     * @returns True iff the texture layout is stereoscopic
     */
    SkyboxRenderer.prototype.isStereo = function () {
        if (!this.skyboxTexture || !this.stereoEnabled) {
            return false;
        }
        switch (this.skyboxTexture.getLayout()) {
            case BaseImageAsset_1.ImageLayout.Stereo2dOverUnder:
            case BaseImageAsset_1.ImageLayout.Stereo2dUnderOver:
            case BaseImageAsset_1.ImageLayout.Stereo2dLeftRight:
            case BaseImageAsset_1.ImageLayout.Stereo2dRightLeft:
                return this.stereoEnabled;
            default:
                return false;
        }
    };
    /**
     * Create the geometry for the skybox
     */
    SkyboxRenderer.prototype.initGeometry = function () {
        if (this.skyboxGeometry) {
            this.skyboxGeometry.dispose();
            this.skyboxGeometryRightEye.dispose();
        }
        // TODO - this would be more efficient as a geodesic sphere...
        this.skyboxGeometry = new THREE.SphereBufferGeometry(1, 64, 64);
        this.skyboxGeometryRightEye = this.skyboxGeometry.clone();
    };
    /**
     * If the texture is stereoscopic, modify the UV's of the geometry to map the
     * texture correctly for each eye.
     */
    SkyboxRenderer.prototype.initStereoUvs = function () {
        if (this.skyboxTexture) {
            var leftEyeScale = new THREE.Vector2();
            var leftEyeBias = new THREE.Vector2();
            var rightEyeScale = new THREE.Vector2();
            var rightEyeBias = new THREE.Vector2();
            // Based on texture type and layout, start the UV's for the geometry.
            switch (this.skyboxTexture.getLayout()) {
                case BaseImageAsset_1.ImageLayout.Stereo2dOverUnder:
                    leftEyeScale.set(1.0, 0.5);
                    leftEyeBias.set(0.0, 0.0);
                    rightEyeScale.set(1.0, 0.5);
                    rightEyeBias.set(0.0, 0.5);
                    break;
                case BaseImageAsset_1.ImageLayout.Stereo2dUnderOver:
                    leftEyeScale.set(1.0, 0.5);
                    leftEyeBias.set(0.0, 0.5);
                    rightEyeScale.set(1.0, 0.5);
                    rightEyeBias.set(0.0, 0.0);
                    break;
                case BaseImageAsset_1.ImageLayout.Stereo2dLeftRight:
                    leftEyeScale.set(0.5, 1.0);
                    leftEyeBias.set(0.0, 0.0);
                    rightEyeScale.set(0.5, 1.0);
                    rightEyeBias.set(0.5, 0.0);
                    break;
                case BaseImageAsset_1.ImageLayout.Stereo2dRightLeft:
                    leftEyeScale.set(0.5, 1.0);
                    leftEyeBias.set(0.5, 0.0);
                    rightEyeScale.set(0.5, 1.0);
                    rightEyeBias.set(0.0, 0.0);
                    break;
                default:
                    // If the layout of the texture isn't a stereo type, don't modify the
                    // geometry UV's.
                    return;
            }
            var uvsLeft = this.skyboxGeometry.getAttribute('uv').array;
            var uvsRight = this.skyboxGeometryRightEye.getAttribute('uv').array;
            for (var i = 0; i < uvsLeft.length; i += 2) {
                uvsLeft[i] *= leftEyeScale.x;
                uvsLeft[i + 1] *= leftEyeScale.y;
                uvsLeft[i] += leftEyeBias.x;
                uvsLeft[i + 1] += leftEyeBias.y;
                uvsRight[i] *= rightEyeScale.x;
                uvsRight[i + 1] *= rightEyeScale.y;
                uvsRight[i] += rightEyeBias.x;
                uvsRight[i + 1] += rightEyeBias.y;
            }
        }
    };
    /**
     * Create the mesh used to render the skybox
     */
    SkyboxRenderer.prototype.initMesh = function () {
        if (this.skyboxMesh) {
            this.getRuntimeData().remove(this.skyboxMesh);
        }
        if (this.skyboxMeshRightEye) {
            this.getRuntimeData().remove(this.skyboxMeshRightEye);
        }
        this.skyboxMesh = new THREE.Mesh(this.skyboxGeometry, this.currentMaterial);
        this.skyboxMesh.frustumCulled = false;
        this.skyboxMesh.castShadow = false;
        this.skyboxMesh.receiveShadow = false;
        this.skyboxMesh.matrixAutoUpdate = true;
        this.skyboxMesh.name = 'Skybox';
        // Rotate the mesh so that the texture will appear with y-up.
        this.skyboxMesh.rotation.y = -Math.PI / 2;
        this.skyboxMesh.rotation.z = -Math.PI;
        this.skyboxMesh.scale.set(this.size, this.size, this.size);
        // Duplicate skybox for right eye (only used for stereo textures)
        this.skyboxMeshRightEye = this.skyboxMesh.clone();
        this.skyboxMeshRightEye.geometry = this.skyboxGeometryRightEye;
        this.skyboxMeshRightEye.layers.set(2);
        if (this.isEnabled()) {
            this.getRuntimeData().add(this.skyboxMesh);
            this.skyboxMesh.updateMatrix();
        }
    };
    /**
     * Based on the texture currently assigned, choose the appropriate material and initialize
     * or recreate the geometry and mesh if needed.
     */
    SkyboxRenderer.prototype.initSkybox = function () {
        this.currentMaterial = this.skyboxMaterial2D;
        this.currentMaterial.needsUpdate = true;
        if (!this.skyboxTexture) {
            this.currentMaterial.map = null;
            this.currentMaterial.needsUpdate = true;
        }
        else if (this.skyboxTexture.type === 'textureCube' ||
            this.skyboxTexture.type === 'renderTextureCube') {
            this.currentMaterial = this.skyboxMaterialCube;
        }
        this.initGeometry();
        this.initMesh();
        this.initStereoUvs();
        if (this.isStereo()) {
            this.skyboxMesh.layers.set(1);
            this.getRuntimeData().add(this.skyboxMeshRightEye);
        }
        else {
            this.skyboxMesh.layers.set(0);
            this.getRuntimeData().remove(this.skyboxMeshRightEye);
        }
        if (!this.skyboxTexture) {
            return;
        }
        this.listenTo(this.skyboxTexture, 'load', this.onSkyboxTextureLoad);
        if (this.skyboxTexture.isLoaded()) {
            this.onSkyboxTextureLoad();
        }
        if (this.isEnabled() && this.skyboxTexture.isUnloaded()) {
            this.skyboxTexture.load();
        }
    };
    /**
     * Called when the skybox texture's load event is fired. This links up the texture in
     * the skybox's material.
     */
    SkyboxRenderer.prototype.onSkyboxTextureLoad = function () {
        // @FIXME: this needs to handle cube textures.
        if (this.currentMaterial instanceof THREE.MeshBasicMaterial) {
            this.currentMaterial.map = this.skyboxTexture.getThreeTexture();
            this.currentMaterial.needsUpdate = true;
        }
    };
    /**
     * Create the materials needed to render the skybox
     */
    SkyboxRenderer.prototype.initMaterials = function () {
        this.skyboxUniforms = THREE.UniformsUtils.merge([
            {
                envMap: {
                    type: 't',
                    value: null
                }
            }
        ]);
        this.skyboxVShader = [
            'varying vec3 vCameraVector;',
            'void main() {',
            'vCameraVector = (modelMatrix * vec4( position, 1.0 )).xyz;',
            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
            '}'
        ].join('\n');
        this.skyboxPShader = [
            'uniform samplerCube environmentTexture;',
            'varying vec3 vCameraVector;',
            'void main() {',
            'vec3 cameraVecN = normalize( vCameraVector );',
            'vec4 environmentColor = textureCube(environmentTexture,' +
                ' vec3(cameraVecN.x, cameraVecN.yz));',
            'gl_FragColor = vec4( environmentColor.xyz, 1.0 );',
            '}'
        ].join('\n');
        this.skyboxMaterialCube = new THREE.ShaderMaterial({
            vertexShader: this.skyboxVShader,
            fragmentShader: this.skyboxPShader,
            uniforms: this.skyboxUniforms,
            depthTest: true,
            depthWrite: false,
            side: THREE.BackSide
        });
        this.skyboxMaterial2D = new THREE.MeshBasicMaterial({
            depthTest: false,
            depthWrite: false,
            side: THREE.BackSide
        });
    };
    return SkyboxRenderer;
}(BaseComponent_1.default));
exports.default = SkyboxRenderer;


/***/ }),
/* 112 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid text_renderer
 * @vname Text Renderer
 * @vdescription Render the desired text to the texture we are attached to
 * @vfilter renderTexture2D
 * @vcategory Text
 */
var TextRenderer = (function (_super) {
    tslib_1.__extends(TextRenderer, _super);
    /** Creates an instance of TextRenderer. */
    function TextRenderer() {
        var _this = _super.call(this) || this;
        _this.material = null;
        _this.canvas = null;
        _this.mesh = null;
        _this.camera = null;
        _this.scene = null;
        return _this;
    }
    /** @inheritdoc */
    TextRenderer.prototype.onStartup = function () {
        this.createLabel();
    };
    /** @inheritdoc */
    TextRenderer.prototype.onEntityReady = function () {
        this.renderText();
    };
    /** @inheritdoc */
    TextRenderer.prototype.onShutdown = function () {
        if (this.material) {
            this.material.dispose();
        }
        if (this.geometry) {
            this.geometry.dispose();
        }
        this.mesh = null;
    };
    /** @inheritdoc */
    TextRenderer.prototype.onAttributesChanged = function (_changes) {
        if (this.getEntity().isBaseLoaded()) {
            this.createLabel();
            this.renderText();
        }
    };
    /** Creates the text renderer. */
    TextRenderer.prototype.createLabel = function () {
        var text = this.text;
        var size = this.pointSize;
        var color = '#' + this.fontColor.getHexString();
        if (!this.canvas) {
            this.canvas = document.createElement('canvas');
        }
        var fontType = size + 'pt ' + this.fontFamily;
        var context = this.canvas.getContext('2d');
        context.font = fontType;
        this.canvas.width = this.getEntity().getWidth();
        this.canvas.height = this.getEntity().getHeight();
        context.font = size + 'pt ' + this.fontFamily;
        context.textAlign = 'left';
        context.textBaseline = 'hanging';
        context.fillStyle = color;
        this.wrapAndRender(context, text, this.pointSize * 0.5, this.pointSize * 0.5, this.canvas.width - this.pointSize * 0.5, this.pointSize * 1.5);
        var texture = new THREE.Texture(this.canvas);
        texture.mapping = null;
        texture.generateMipmaps = true;
        texture.magFilter = THREE.LinearFilter;
        texture.minFilter = THREE.LinearMipMapLinearFilter;
        texture.needsUpdate = true;
        if (this.material) {
            this.material.dispose();
        }
        this.material = new THREE.MeshBasicMaterial({
            map: texture
        });
        this.material.side = THREE.DoubleSide;
        if (this.geometry) {
            this.geometry.dispose();
        }
        this.geometry = new THREE.PlaneGeometry(this.canvas.width, this.canvas.height);
        if (this.mesh) {
            this.scene.remove(this.mesh);
            this.mesh = null;
        }
        this.mesh = new THREE.Mesh(this.geometry, this.material);
        this.mesh.position.z = 0;
        var halfWidth = this.canvas.width * 0.5;
        var halfHeight = this.canvas.height * 0.5;
        if (!this.camera) {
            this.camera = new THREE.OrthographicCamera(-halfWidth, halfWidth, -halfHeight, halfHeight, -10, 1000);
        }
        this.camera.position.z = 10;
        this.camera.rotation.z = Math.PI;
        // left, right, top, bottom
        this.camera.left = halfWidth;
        this.camera.right = -halfWidth;
        this.camera.top = halfHeight;
        this.camera.bottom = -halfHeight;
        this.camera.updateProjectionMatrix();
        if (!this.scene) {
            this.scene = new THREE.Scene();
            this.scene.add(this.camera);
        }
        this.scene.add(this.mesh);
    };
    /** Renders the text. */
    TextRenderer.prototype.renderText = function () {
        if (!this.text) {
            this.text = ' ';
        }
        this.getThreeRenderer().render(this.scene, this.camera, this.getRuntimeData());
    };
    /**
     * Renders the text.
     * @param context     The 2d canvas context.
     * @param text        The text to render
     * @param x           The x position
     * @param y           The y position
     * @param maxWidth    The maximum width
     * @param lineHeight  The text line height
     */
    TextRenderer.prototype.wrapAndRender = function (context, text, x, y, maxWidth, lineHeight) {
        var words = text.split(' ');
        var line = '';
        var currY = y;
        words.forEach(function (word, n) {
            var testLine = line + word + ' ';
            var metrics = context.measureText(testLine);
            var testWidth = metrics.width;
            if (testWidth > maxWidth && n > 0) {
                context.fillText(line, x, currY);
                line = word + ' ';
                currY += lineHeight;
            }
            else {
                line = testLine;
            }
        });
        context.fillText(line, x, currY);
    };
    return TextRenderer;
}(BaseComponent_1.default));
exports.default = TextRenderer;


/***/ }),
/* 113 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid vr_camera_controller
 * @vname VR Camera Controller
 * @vfilter camera
 * @vcategory Camera
 */
var VrCameraController = (function (_super) {
    tslib_1.__extends(VrCameraController, _super);
    function VrCameraController() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** Treat the viewer as standing rather than sitting. */
        _this.standing = true;
        /** The user's height to be used when standing is true and the VR device doesn't offer stage parameters. */
        _this.userHeight = 6;
        /** Stores the frame data to be updated each frame from the VR display  */
        _this.frameData = window.hasOwnProperty('VRFrameData') ? new VRFrameData() : {};
        /** Internal value for to store standing matrix from device */
        _this.standingMatrix = new THREE.Matrix4();
        /** Internal vector for calculations */
        _this.workVector = new THREE.Vector3();
        /** The scale of the scene FIXME: this should be set via some global scale value so that all
         * VR can abide by it.
         */
        _this.scale = 1.0;
        return _this;
    }
    /** @inheritDoc */
    VrCameraController.prototype.onPreUpdate = function (_delta) {
        if (!this.isEnabled() || !this.hasRuntimeData()) {
            return;
        }
        var engine = this.getEngine();
        var vrDisplay = engine.getVrDisplay();
        if (!vrDisplay) {
            return;
        }
        engine.needsRender = true;
        vrDisplay.getFrameData(this.frameData);
        var pose = this.frameData.pose;
        var object = this.getRuntimeData();
        var entity = this.getEntity();
        if (pose.orientation === null) {
            return;
        }
        entity.setQuaternion(pose.orientation[0], pose.orientation[1], pose.orientation[2], pose.orientation[3]);
        // In Firefox, losing tracking results in a null position so check that too.
        if (vrDisplay.capabilities.hasPosition && pose.position) {
            entity.setPosition(pose.position[0], pose.position[1], pose.position[2]);
        }
        if (this.standing) {
            if (vrDisplay.stageParameters) {
                // Use three.js value to calculate new position and orientation and then set it back on the
                // entity to communicate the values across engine instances.
                object.updateMatrix();
                this.standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
                object.applyMatrix(this.standingMatrix);
                entity.setQuaternion(object.quaternion.x, object.quaternion.y, object.quaternion.z, object.quaternion.w);
                object.position.multiplyScalar(this.scale);
                entity.setPosition(object.position.x, object.position.y, object.position.z);
            }
            else {
                // TODO: We're treating the user as standing but they aren't using a device with
                // room-scale support. So, we'll add the user's height manually.
                entity.getPosition(this.workVector);
                this.workVector.multiplyScalar(this.scale);
                entity.setPosition(this.workVector.x, this.workVector.y, this.workVector.z);
            }
        }
        else {
            entity.getPosition(this.workVector);
            this.workVector.multiplyScalar(this.scale);
            entity.setPosition(this.workVector.x, this.workVector.y, this.workVector.z);
        }
    };
    return VrCameraController;
}(BaseComponent_1.default));
exports.default = VrCameraController;


/***/ }),
/* 114 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var BaseComponent_1 = __webpack_require__(2);
var UserAgent_1 = __webpack_require__(22);
var Logger_1 = __webpack_require__(3);
/**
 * @vid vr_presenter
 * @vname VR Presenter
 * @vfilter application
 * @vcategory VR
 */
var VrPresenter = (function (_super) {
    tslib_1.__extends(VrPresenter, _super);
    function VrPresenter() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        /** The scale of the scene used by VR rendering. */
        _this.scale = 1.0;
        /** Indicates whether we're currently presenting to the VR display. */
        _this.isPresenting = false;
        /** Indicates whether we were just presenting to the VR display on the previous frame. */
        _this.wasPresenting = false;
        /** A list populated with the VR displays attached to the system. */
        _this.vrDisplays = null;
        /** The pixel ratio used by the renderer before presenting to the VR display. */
        _this.previousPixelRatio = 1.0;
        return _this;
    }
    /** Return the scale that VR rendering is using. */
    VrPresenter.prototype.getScale = function () {
        return this.scale;
    };
    /**
     * Set the scale that VR rendering will use.
     * @param scale The new scale of the VR world.
     */
    VrPresenter.prototype.setScale = function (scale) {
        this.scale = scale;
    };
    /** Return the list of VR Displays available. */
    VrPresenter.prototype.getDisplays = function () {
        return this.vrDisplays;
    };
    /** @inheritdoc */
    VrPresenter.prototype.onAwake = function () {
        var _this = this;
        this.listenTo(this.getEngine(), 'enableVrRendering', this.onEnableVr);
        this.listenTo(this.getEngine(), 'disableVrRendering', this.onDisableVr);
        this.listenTo(this.getEngine(), 'toggleVrRendering', this.onToggleVr);
        this.onVrDisplayPresentChange = this.onVrDisplayPresentChange.bind(this);
        window.addEventListener('vrdisplaypresentchange', this.onVrDisplayPresentChange, false);
        // Get a list of all the VR displays available to use.
        if (navigator.getVRDisplays) {
            navigator.getVRDisplays().then(function (devices) {
                _this.vrDisplays = devices;
                _this.trigger('displaysInitialized');
            });
        }
        else {
            this.vrDisplays = [];
        }
    };
    /** @inheritdoc */
    VrPresenter.prototype.onShutdown = function () {
        _super.prototype.onShutdown.call(this);
        window.removeEventListener('vrdisplaypresentchange', this.onVrDisplayPresentChange, false);
    };
    /** @inheritdoc */
    VrPresenter.prototype.onDisable = function () {
        if (this.isPresenting) {
            this.onDisableVr();
        }
    };
    /** Call the provided callback when VR Displays have been successfully queried */
    VrPresenter.prototype.whenDisplaysAvailable = function (callback) {
        var _this = this;
        if (this.vrDisplays) {
            callback.call(this, this.vrDisplays);
        }
        else {
            this.listenToOnce(this, 'displaysInitialized', function () {
                callback.call(_this, _this.vrDisplays);
            });
        }
    };
    /** @inheritdoc */
    VrPresenter.prototype.onPostRender = function (_delta) {
        var vrDisplay = this.getEngine().getVrDisplay();
        if (!vrDisplay) {
            return;
        }
        // Submit the frame to the VR display.
        if (this.isPresenting) {
            vrDisplay.submitFrame();
        }
    };
    /** Called when engine-level event for enabling VR is fired. */
    VrPresenter.prototype.onEnableVr = function () {
        if (!this.isEnabled()) {
            return;
        }
        // If the display list hasn't been setup yet, listen for the event.
        if (!this.vrDisplays) {
            this.listenToOnce(this, 'displaysInitialized', this.onEnableVr.bind(this));
            return;
        }
        if (!this.vrDisplays.length) {
            return;
        }
        // Set the display on the engine.
        var vrDisplay = this.vrDisplays[0];
        this.getEngine().setVrDisplay(vrDisplay);
        var canvas = this.getRenderer().getCanvas();
        // TODO: Support multiple layers here.
        vrDisplay.requestPresent([{ source: canvas }])
            .catch(function (err) {
            Logger_1.default.error('Failed to present to VR display', err.message);
        });
    };
    /** Called when engine-level event for disabling VR is fired. */
    VrPresenter.prototype.onDisableVr = function () {
        if (this.isPresenting) {
            var vrDisplay = this.getEngine().getVrDisplay();
            if (vrDisplay) {
                vrDisplay.exitPresent();
                this.getEngine().setVrDisplay(null);
            }
        }
    };
    /** Called when engine-level event for toggling VR is fired. */
    VrPresenter.prototype.onToggleVr = function () {
        if (this.isPresenting) {
            this.onDisableVr();
        }
        else {
            this.onEnableVr();
        }
    };
    /**
     * Called when there is a change in VR presenting state.
     * Resizes the canvas and sets up appropriate pixel ratio for VR display.
     */
    VrPresenter.prototype.onVrDisplayPresentChange = function () {
        this.wasPresenting = this.isPresenting;
        var vrDisplay = this.getEngine().getVrDisplay();
        this.isPresenting = vrDisplay && vrDisplay.isPresenting;
        var renderer = this.getThreeRenderer();
        if (this.isPresenting) {
            var eyeParamsL = vrDisplay.getEyeParameters('left');
            var eyeWidth = eyeParamsL.renderWidth;
            var eyeHeight = eyeParamsL.renderHeight;
            if (!this.wasPresenting) {
                this.previousPixelRatio = renderer.getPixelRatio();
                if (!UserAgent_1.isMobile()) {
                    renderer.setPixelRatio(1);
                }
                else {
                    // If using the devicePixelRatio of the mobile device, we must be
                    // careful not to exceed the max texture dimensions of the device.
                    var maxTextureSize = renderer.capabilities.maxTextureSize;
                    var vrWidth = 2.0 * eyeWidth;
                    if (vrWidth * this.previousPixelRatio > maxTextureSize) {
                        this.previousPixelRatio = Math.floor(maxTextureSize / vrWidth);
                    }
                    renderer.setPixelRatio(this.previousPixelRatio);
                }
                renderer.setSize(eyeWidth * 2, eyeHeight, false);
                this.getEngine().trigger('vrRenderingEnabled');
            }
        }
        else if (this.wasPresenting) {
            renderer.setPixelRatio(this.previousPixelRatio);
            // Set the VR display to null just in case we've exited VR through some method other than
            // onDisableVr. e.g. WebVR on mobile.
            this.getEngine().setVrDisplay(null);
            this.getEngine().trigger('resize');
            this.getEngine().trigger('vrRenderingDisabled');
        }
    };
    return VrPresenter;
}(BaseComponent_1.default));
exports.default = VrPresenter;


/***/ }),
/* 115 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var RenderView_1 = __webpack_require__(65);
/**
 * Render View component that enables a stereoscopic view when a VR display is available.
 * @vid vr_render_view
 * @vname VR Render View
 * @vfilter camera
 * @vcategory Rendering
 */
var VrRenderView = (function (_super) {
    tslib_1.__extends(VrRenderView, _super);
    function VrRenderView() {
        var _this = _super !== null && _super.apply(this, arguments) || this;
        // tslint:disable max-line-length */
        /**
         * Run pre-render functions with this view. These include things like real-time reflections,
         * which need to be rendered for each view separately.
         * @vattr Boolean enablePreRenderFunctions {
         *   description: 'Run pre-render functions with this view. These include things like real-time reflections, which need to be rendered for each view separately.',
         *   default : true,
         *   advanced: true
         * }
         */
        // tslint:enable max-line-length */
        _this.enablePreRenderFunctions = true;
        /**
         * Render shadows for this view.
         * @vattr Boolean enableShadows {
         *   description: 'Render shadows for this view.',
         *   default : true,
         *   advanced: true
         * }
         */
        _this.enableShadows = true;
        /** Stores the left eye offset amount  */
        _this.eyeTranslationL = new THREE.Vector3();
        /** Stores the right eye offset amount  */
        _this.eyeTranslationR = new THREE.Vector3();
        /** Stores the default left eye bounds  */
        _this.defaultLeftBounds = [0.0, 0.0, 0.5, 1.0];
        /** Stores the default right eye bounds  */
        _this.defaultRightBounds = [0.5, 0.0, 0.5, 1.0];
        /** Stores the viewport info for the left eye  */
        _this.renderRectL = { x: 0, y: 0, width: 256, height: 256 };
        /** Stores the viewport info for the right eye  */
        _this.renderRectR = { x: 128, y: 0, width: 256, height: 256 };
        /** The internal camera for the left eye  */
        _this.cameraL = new THREE.PerspectiveCamera();
        /** The internal camera for the right eye  */
        _this.cameraR = new THREE.PerspectiveCamera();
        /** Stores the frame data to be updated each frame from the VR display  */
        _this.frameData = window.hasOwnProperty('VRFrameData') ? new VRFrameData() : {};
        /** The scale of the scene FIXME: this should be set via some global scale value so that all
         * VR can abide by it.
         */
        _this.scale = 1.0;
        return _this;
    }
    /** @inheritdoc */
    VrRenderView.prototype.renderView = function (delta) {
        if (!this.isEnabled() || !this.hasRuntimeData()) {
            return;
        }
        var scene = this.getRootObject();
        if (!scene.isBaseLoaded()) {
            return;
        }
        var threeScene = scene.getRuntimeData();
        var vrDisplay = this.getEngine().getVrDisplay();
        if (!vrDisplay) {
            return _super.prototype.renderView.call(this, delta);
        }
        var autoUpdate = threeScene.autoUpdate;
        if (autoUpdate) {
            threeScene.updateMatrixWorld();
            threeScene.autoUpdate = false;
        }
        var eyeParamsL = vrDisplay.getEyeParameters('left');
        var eyeParamsR = vrDisplay.getEyeParameters('right');
        this.eyeTranslationL.fromArray(eyeParamsL.offset);
        this.eyeTranslationR.fromArray(eyeParamsR.offset);
        var renderer = this.getThreeRenderer();
        // When rendering we don't care what the recommended size is, only what the actual size
        // of the backbuffer is.
        var size = renderer.getSize();
        var layers = vrDisplay.getLayers();
        var leftBounds;
        var rightBounds;
        if (layers.length) {
            var layer = layers[0];
            leftBounds = layer.leftBounds !== null && layer.leftBounds.length === 4 ?
                layer.leftBounds : this.defaultLeftBounds;
            rightBounds = layer.rightBounds !== null && layer.rightBounds.length === 4 ?
                layer.rightBounds : this.defaultRightBounds;
        }
        else {
            leftBounds = this.defaultLeftBounds;
            rightBounds = this.defaultRightBounds;
        }
        this.renderRectL = {
            x: Math.round(size.width * leftBounds[0]),
            y: Math.round(size.height * leftBounds[1]),
            width: Math.round(size.width * leftBounds[2]),
            height: Math.round(size.height * leftBounds[3])
        };
        this.renderRectR = {
            x: Math.round(size.width * rightBounds[0]),
            y: Math.round(size.height * rightBounds[1]),
            width: Math.round(size.width * rightBounds[2]),
            height: Math.round(size.height * rightBounds[3])
        };
        var camera = this.getRuntimeData();
        if (camera.parent === null) {
            camera.updateMatrixWorld();
        }
        camera.matrixWorld.decompose(this.cameraL.position, this.cameraL.quaternion, this.cameraL.scale);
        camera.matrixWorld.decompose(this.cameraR.position, this.cameraR.quaternion, this.cameraR.scale);
        this.cameraL.translateOnAxis(this.eyeTranslationL, this.scale);
        this.cameraR.translateOnAxis(this.eyeTranslationR, this.scale);
        vrDisplay.depthNear = camera.near;
        vrDisplay.depthFar = camera.far;
        vrDisplay.getFrameData(this.frameData);
        this.cameraL.projectionMatrix.elements = this.frameData.leftProjectionMatrix;
        this.cameraR.projectionMatrix.elements = this.frameData.rightProjectionMatrix;
        // render left eye
        renderer.setScissor(this.renderRectL.x, this.renderRectL.y, this.renderRectL.width, this.renderRectL.height);
        this.getRenderer().renderView(threeScene, this.cameraL, {
            renderTarget: this.renderTarget,
            clearDepth: true,
            clearColor: true,
            viewPort: this.renderRectL,
            enablePreRenderFunctions: true
        });
        // render right eye
        renderer.setScissor(this.renderRectR.x, this.renderRectR.y, this.renderRectR.width, this.renderRectR.height);
        this.getRenderer().renderView(threeScene, this.cameraR, {
            renderTarget: this.renderTarget,
            clearDepth: false,
            clearColor: false,
            viewPort: this.renderRectR,
            enablePreRenderFunctions: true
        });
        if (autoUpdate) {
            threeScene.autoUpdate = true;
        }
    };
    return VrRenderView;
}(RenderView_1.default));
exports.default = VrRenderView;


/***/ }),
/* 116 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-file-line-count */
var THREE = __webpack_require__(1);
var Logger_1 = __webpack_require__(3);
var EntityDispatcher_1 = __webpack_require__(201);
var EntityCreation_1 = __webpack_require__(200);
var EntityRegistry_1 = __webpack_require__(202);
var GeometryUtilities_1 = __webpack_require__(197);
var MaterialUtilities_1 = __webpack_require__(207);
var RuntimeEvents_1 = __webpack_require__(27);
var ScriptRegistry_1 = __webpack_require__(77);
var ShaderAsset_1 = __webpack_require__(36);
var MaterialAsset_1 = __webpack_require__(14);
var globalEvents_1 = __webpack_require__(47);
var classComposer_1 = __webpack_require__(46);
var BaseEntity_1 = __webpack_require__(9);
var ApplicationAsset_1 = __webpack_require__(34);
var LoadingType_1 = __webpack_require__(16);
var LoadingEvent_1 = __webpack_require__(12);
var getElement = function (obj) {
    var els;
    if (obj && obj.jquery) {
        return obj.get(0);
    }
    else if (typeof obj === 'string') {
        els = document.querySelectorAll(obj);
        return els.length && els[0];
    }
    else {
        return obj;
    }
};
exports.engineMixins = classComposer_1.default({}, [EntityRegistry_1.default, EntityCreation_1.default, RuntimeEvents_1.default]);
/**
 * This is the Box3D Engine object.
 */
var Engine = (function (_super) {
    tslib_1.__extends(Engine, _super);
    /**
     * This class defines an engine for Box3D. Each engine instance corresponds to one canvas. If you
     * want to render to multiple canvases, you'll need to instantiate two engines that use the same
     * EntityDispatcher.
     * @param properties                    The engine properties
     * @param properties.resourceLoader     Used to load resources like
     *                                      geometry, textures and animation.
     * @param [properties.engineName]       The name of the engine.
     * @param properties.container          The container for the canvas element. If a
     *                                      string is passed, it is assumed to be a jQuery
     *                                      selector string.
     * @param [properties.canvas]           The element that the engine will draw into.
     *                                      If a string is passed, it is assumed to be a
     *                                      jQuery selector string. If no canvas is supplied,
     *                                      a new one will be created and added to the
     *                                      container.
     * @param [properties.entityDispatcher] Used for synchronizing entities
     *                                      when multiple engines are used. If no entity
     *                                      dispatcher is supplied, a new one will be created.
     * @param [properties.globalEvents]     Used to trigger and listen to global events.
     */
    function Engine(properties) {
        var _this = _super.call(this) || this;
        /** Whether or not the engine should render on demand. */
        _this.renderOnDemand = false;
        /** Whether or not the engine needs to render. */
        _this.needsRender = true;
        /** The Container element. */
        _this.container = undefined;
        /** The global event system which this Engine is configured to use. */
        _this.globalEvents = undefined;
        /** The name of the engine. */
        _this.engineName = 'Unnamed Instance of Box3D Engine';
        /** The context to use for audio. */
        _this.audioContext = undefined;
        /** Whether or not this engine is paused. */
        _this.paused = false;
        /** A mapping of SIDs to runtime names (@see getRuntimeName()). */
        _this.runtimeNames = {};
        /** A number used for the generation of runtime names. */
        _this.nextRuntimeName = 1;
        Logger_1.default.info('Engine Initialization');
        _this.globalScope = properties.globalScope || window;
        // Get and validate global events.
        var initGlobalEvents = function () {
            _this.globalEvents = (properties && properties.globalEvents) || globalEvents_1.default;
            if (!_this.globalEvents) {
                throw new Error('No global event system supplied or found');
            }
        };
        // Initialize the container.
        var initContainer = function () {
            _this.container = _this.container || getElement(properties.container);
            if (!properties.canvas && _this.container) {
                properties.canvas = document.createElement('canvas');
                _this.container.appendChild(properties.canvas);
                _this.canvasCreatedByEngine = true;
            }
        };
        // Validate the canvas.
        var initCanvas = function () {
            _this.canvas = getElement(properties.canvas);
            if (!(_this.canvas instanceof HTMLCanvasElement)) {
                throw new Error('Failed to create canvas element');
            }
        };
        // Validate the resource loader.
        var initResourceLoader = function () {
            _this.resourceLoader = properties.resourceLoader;
            if (!_this.resourceLoader) {
                throw new Error('No resource loader passed to Engine');
            }
        };
        // Initialize member variables.
        var initState = function () {
            _this.engineName = properties.engineName || _this.engineName;
            _this.clock = new THREE.Clock(true);
            _this.frameDelta = 0;
            _this.frameDeltaAggregate = 0;
            _this.frameCount = 0;
            _this.lastFrameDelta = _this.getTimeNow();
            _this.avgFrameTime = 0;
            _this.paused = false;
            _this.documentVisible = true;
            _this.state = 'initializing';
            // Initialize the entity dispatcher.
            _this.entityDispatcher = properties.entityDispatcher ||
                new EntityDispatcher_1.default();
            _this.entityDispatcher.addEngine(_this);
        };
        var initAssetRegistry = function () {
            // Initialize scripts first so that other assets can use them
            // This code is temporary until we remove all asset registry logic
            _this.scriptRegistry = new ScriptRegistry_1.default(_this);
            Object.keys(ShaderAsset_1.default.builtInAssetDescriptors).forEach(function (key) {
                _this.createEntity(ShaderAsset_1.default.builtInAssetDescriptors[key]);
            });
            Object.keys(MaterialAsset_1.default.builtInAssetDescriptors).forEach(function (key) {
                _this.createEntity(MaterialAsset_1.default.builtInAssetDescriptors[key]);
            });
        };
        var initMaterialUtilities = function () {
            _this.materialUtilities = new MaterialUtilities_1.default(_this);
        };
        var initGeometryUtilities = function () {
            _this.geometryUtilities = new GeometryUtilities_1.default();
        };
        var initListeners = function () {
            _this.onResize = function () {
                _this.needsRender = true;
            };
            _this.onBlur = function () {
                _this.trigger('blur');
            };
            _this.onFocus = function () {
                _this.trigger('focus');
            };
            _this.onVisibilityChange = function () {
                var hidden = document.hidden || document.mozHidden ||
                    document.msHidden || document.webkitHidden;
                if (_this.documentVisible && hidden) {
                    _this.documentVisible = false;
                }
                else if (!_this.documentVisible) {
                    _this.frameDelta = 0;
                    // Reset delta calculations.
                    _this.lastFrameDelta = _this.getTimeNow();
                    _this.documentVisible = true;
                }
            };
            window.addEventListener('blur', _this.onBlur);
            window.addEventListener('focus', _this.onFocus);
            _this.listenTo(_this, 'resize', _this.onResize);
            document.addEventListener('visibilitychange', _this.onVisibilityChange);
        };
        var initFinish = function () {
            // Add the engine to "window" to help with debugging.
            _this.globalScope[_this.engineName] = _this;
            // Run the update loop once.
            _this.update();
            _this.state = 'initialized';
        };
        // Run each initialize task.
        initGlobalEvents();
        initContainer();
        initCanvas();
        initResourceLoader();
        initState();
        initAssetRegistry();
        initMaterialUtilities();
        initGeometryUtilities();
        initListeners();
        initFinish();
        return _this;
    }
    /**
     * Destroy the engine, cleaning up all memory and un-registering
     * the engine from the entity dispatcher.
     */
    Engine.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        Logger_1.default.info(this.engineName + ' - Destroying engine.');
        if (window[this.engineName]) {
            delete window[this.engineName];
        }
        this.baseRenderer = undefined;
        // destroy the resource loader and abort all requests
        this.resourceLoader.destroy();
        this.materialUtilities.destroy();
        this.geometryUtilities.destroy();
        // Remove event listeners.
        window.removeEventListener('blur', this.onBlur);
        window.removeEventListener('focus', this.onFocus);
        this.stopListening(this, 'resize', this.onResize);
        document.removeEventListener('visibilitychange', this.onVisibilityChange);
        this.onBlur = undefined;
        this.onFocus = undefined;
        this.onResize = undefined;
        this.onVisibilityChange = undefined;
        this.trigger('shutdown');
        this.state = 'uninitializing';
        this.cancelAnimationFrame(this.animationRequestID);
        if (this.canvas && this.canvas.parentNode && this.canvasCreatedByEngine) {
            this.canvas.parentNode.removeChild(this.canvas);
        }
        if (this.entityDispatcher) {
            this.entityDispatcher.removeEngine(this);
        }
        this.clock = undefined;
        this.canvas = undefined;
        this.container = undefined;
        this.threeRenderer = undefined;
        this.baseRenderer = undefined;
        this.engineName = undefined;
        this.entityDispatcher = undefined;
        this.state = 'uninitialized';
    };
    /**
     * Return the name of the engine
     * @returns The name of this engine.
     */
    Engine.prototype.getName = function () {
        return this.engineName;
    };
    /**
     * Register all entities in the given collection into the runtime.
     * @param collection The entity collection
     * @returns An array of entity descriptors
     * that were added to the engine.
     */
    Engine.prototype.addEntities = function (entityArray) {
        return this.entityDispatcher.addEntities(entityArray);
    };
    /**
     * Adds entities from a remote url.
     * @param url
     * @returns A promise that resolves after the entities are all added.
     */
    Engine.prototype.addRemoteEntities = function (url, params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        return new Promise(function (resolve, reject) {
            _this.resourceLoader.load(url, LoadingType_1.default.ENTITIES, params)
                .on(LoadingEvent_1.default.LOAD, function (entities) {
                resolve(_this.addEntities(entities));
            })
                .on(LoadingEvent_1.default.ERROR, function (err) { return reject(err); });
        });
    };
    /**
     * Load the entities given by an array of entity ID's.
     * @param  {Array}   entityArray An array of entity ID's or an array of entities
     * @param  {Function} callback    Called when all of the given entities are completely loaded
     * @param {String} [loadEvent=load] The name of the loading event to listen for on each entity.
     * Default is 'load'.
     */
    Engine.prototype.loadEntities = function (entityArray, callback, loadEvent) {
        var _this = this;
        if (loadEvent === void 0) { loadEvent = 'load'; }
        Promise.all(entityArray.map(function (o) {
            var id = (o instanceof BaseEntity_1.default) ? o.id : o;
            return new Promise(function (resolve, reject) {
                var entity = _this.getEntityById(id);
                if (entity) {
                    entity.when(loadEvent, function () {
                        resolve();
                    });
                    if (entity.isUnloaded()) {
                        entity.load();
                    }
                }
                else {
                    reject(new Error('Entity can\'t be found.'));
                }
            });
        })).then(function () {
            if (typeof callback === 'function') {
                callback.call(_this);
            }
        }).catch(function (err) {
            if (typeof callback === 'function') {
                Logger_1.default.error('loadEntities error: ' + err);
                callback.call(_this, err);
            }
        });
    };
    /**
     * Mark the given device as the current VR device being rendered to. This allows
     * the render loop to be controlled by the requestAnimationFrame on the device rather
     * than the window.
     * @param device The device returned by navigator.getVrDisplays
     */
    Engine.prototype.setVrDisplay = function (device) {
        var _this = this;
        this.cancelAnimationFrame(this.animationRequestID);
        this.vrDevice = device;
        this.animationRequestID = this.requestAnimationFrame(function () {
            _this.needsRender = true;
            _this.update();
        });
    };
    /**
     * Return the current VRDisplay being used, if any.
     * @returns The current VRDisplay.
     */
    Engine.prototype.getVrDisplay = function () {
        return this.vrDevice;
    };
    /**
     * Returns the current active application.
     * @returns The application asset
     */
    Engine.prototype.getApplication = function () {
        var apps = this.getAssetsByClass(ApplicationAsset_1.default);
        return apps.find(function (app) { return app.isBaseLoaded(); });
    };
    /**
     * Return the rendering component currently assigned to the engine.
     * @return The rendering component.
     */
    Engine.prototype.getRenderer = function () {
        return this.baseRenderer;
    };
    /**
     * Assign a new component that will serve as the main renderer in this engine.
     * This renderer can be accessed from any other component via the component.getRenderer()
     * call or from the engine with the same call.
     * @param newRenderer The renderer component.
     */
    Engine.prototype.setRenderer = function (newRenderer) {
        if (this.baseRenderer) {
            this.baseRenderer.onShutdown();
            this.baseRenderer.stopListening();
        }
        this.baseRenderer = newRenderer;
        this.threeRenderer = newRenderer.threeRenderer;
    };
    /**
     * Get the THREE.WebGLRenderer associated with this Engine.
     * @returns The Three.js renderer currently in use.
     */
    Engine.prototype.getThreeRenderer = function () {
        return this.threeRenderer;
    };
    /**
     * Given the name of a GPU device capability (e.g. MAX_VERTEX_TEXTURE_IMAGE_UNITS ),
     * return the current system's value for this capability.
     * @returns The value of the capability.
     */
    Engine.prototype.getGPUCapability = function (cap) {
        return this.baseRenderer.caps[cap];
    };
    /**
     * Get the audio context currently in use.
     * @returns The current audio context.
     */
    Engine.prototype.getAudioContext = function () {
        if (!this.audioContext) {
            // moved this from engine startup to here this stops the engine
            // from going down if too many audio contexts have been created
            // as a bonus, it's only created when it's needed
            var audioContext = this.globalScope.AudioContext || this.globalScope.webkitAudioContext;
            if (audioContext) {
                this.audioContext = new audioContext();
                if (!this.audioContext) {
                    Logger_1.default.warn(this.engineName + ' - Failed to create Web Audio API context');
                }
            }
        }
        return this.audioContext;
    };
    /**
     * Get the runtime name for the specified SID. This method returns a unique name for each unique
     * SID. The returned name is guaranteed to be compatible with the runtime's animation system,
     * which requires object names to contain "word" characters (i.e., [a-zA-Z0-9] and '_'.
     * @param sid The SID to return a runtime name for.
     * @returns   The runtime name.
     */
    Engine.prototype.getRuntimeName = function (sid) {
        if (!this.runtimeNames.hasOwnProperty(sid)) {
            this.runtimeNames[sid] = this.nextRuntimeName.toString();
            this.nextRuntimeName++;
        }
        return this.runtimeNames[sid];
    };
    /**
     * Pause the engine
     */
    Engine.prototype.pause = function () {
        if (!this.paused) {
            this.paused = true;
            this.clock.stop();
            this.cancelAnimationFrame(this.animationRequestID);
            Logger_1.default.info(this.engineName + ' engine has been paused.');
        }
    };
    /**
     * Unpause the engine
     */
    Engine.prototype.unpause = function () {
        if (this.paused) {
            this.paused = false;
            this.frameDelta = 0;
            this.lastFrameDelta = this.getTimeNow();
            this.clock.start();
            Logger_1.default.info(this.engineName + ' engine has been unpaused.');
            this.update();
        }
    };
    /**
     * Sets the current application.
     * @param appId The application asset ID.
     */
    Engine.prototype.setCurrentApp = function (appId) {
        var app = this.getAssetById(appId);
        if (app) {
            if (this.currentApplication) {
                Logger_1.default.warn('Already an application running in this engine. Stop it before starting the '
                    + app.getName() + ' application.');
                this.currentApplication.unload();
            }
            this.currentApplication = app;
        }
    };
    /**
     * Get the current time.
     * @returns The current time.
     */
    Engine.prototype.getTimeNow = function () {
        return ((!!window.performance && !!window.performance.now)
            ? window.performance.now() : Date.now()) * 0.001;
    };
    /**
     * Updates the engine.
     */
    Engine.prototype.update = function () {
        var _this = this;
        // Remember to put visible check.
        if (this.paused) {
            return;
        }
        this.animationRequestID = this.requestAnimationFrame(function () {
            _this.update();
        });
        if (!this.documentVisible) {
            return;
        }
        this.frameCount++;
        this.frameDelta = this.getTimeNow() - this.lastFrameDelta;
        this.lastFrameDelta = this.getTimeNow();
        this.frameDeltaAggregate += this.frameDelta;
        this.avgFrameTime = this.frameDeltaAggregate / this.frameCount;
        this.trigger('preUpdate', this.frameDelta);
        this.trigger('update', this.frameDelta);
        this.trigger('postUpdate', this.frameDelta);
        if (!this.renderOnDemand || this.needsRender) {
            this.needsRender = false;
            this.trigger('preRender', this.frameDelta);
            this.trigger('render', this.frameDelta);
            this.trigger('renderGroup1', this.frameDelta);
            this.trigger('renderGroup2', this.frameDelta);
            this.trigger('renderGroup3', this.frameDelta);
            this.trigger('renderGroup4', this.frameDelta);
            this.trigger('renderGroup5', this.frameDelta);
            this.trigger('renderGroup6', this.frameDelta);
            this.trigger('renderGroup7', this.frameDelta);
            this.trigger('renderGroup8', this.frameDelta);
            this.trigger('renderGroup9', this.frameDelta);
            this.trigger('renderGroup10', this.frameDelta);
            this.trigger('postRender', this.frameDelta);
        }
    };
    /**
     * The engine's request animation callback. This just calls the browser's RAF
     * callback unless there is a WebVR device activated. Then, this calls the RAF
     * on the VR device.
     * @param fn Callback to be executed each frame
     */
    Engine.prototype.requestAnimationFrame = function (fn) {
        if (this.vrDevice) {
            return this.vrDevice.requestAnimationFrame(fn);
        }
        return requestAnimationFrame(fn);
    };
    /**
     * The engine's cancel animation callback. This just calls the browser's CAF
     * callback unless there is a WebVR device activated. Then, this calls the CAF
     * on the VR device.
     * @param requestId ID of the current RAF callback
     */
    Engine.prototype.cancelAnimationFrame = function (requestId) {
        if (this.vrDevice) {
            return this.vrDevice.cancelAnimationFrame(requestId);
        }
        return cancelAnimationFrame(requestId);
    };
    return Engine;
}(exports.engineMixins));
exports.default = Engine;


/***/ }),
/* 117 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var accessor = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'accessor',
    title: 'AccessorDef',
    type: 'object',
    description: 'A typed-view into raw binary data.',
    properties: {
        componentType: {
            type: 'string',
            enum: ['int8', 'uint8', 'int16', 'int32', 'uint32', 'float32', 'float64'],
            description: 'These correspond to typed arrays: Int8Array, Uint8Array, ' +
                'Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array.'
        },
        type: {
            type: 'string',
            enum: ['scalar', 'vec2', 'vec3', 'vec4', 'mat2', 'mat3', 'mat4'],
            description: 'Specifies if elements are scalars, vectors or matrices.'
        },
        byteOffset: {
            type: 'integer',
            description: 'Byte offset into the binary data.'
        },
        byteStride: {
            type: 'integer',
            description: 'The number of bytes between successive elements (0 indicates that ' +
                'the elements are tightly packed).'
        },
        count: {
            type: 'integer',
            description: 'The number of elements, not to be confused with the number of ' +
                'components or bytes. For example, the number of positions, not the number of floats.'
        }
    },
    additionalProperties: false
};
exports.default = accessor;


/***/ }),
/* 118 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var animationAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'animationAsset', title: 'AnimationAssetDef', type: 'object', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['animation']
        }, properties: {
            $ref: 'animationAssetProperties.json'
        } }) });
exports.default = animationAsset;


/***/ }),
/* 119 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var animationAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'animationAssetProperties', title: 'AnimationAssetPropertiesDef', type: 'object', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { clips: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'animationClip.json'
            },
            default: {}
        }, layers: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'animationLayer.json'
            },
            defualt: {}
        }, channels: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'animationChannel.json'
            },
            default: {}
        } }), required: [
        'clips',
        'layers',
        'channels'
    ] });
exports.default = animationAssetProperties;


/***/ }),
/* 120 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var animationChannel = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'animationChannel',
    title: 'AnimationChannelDef',
    type: 'object',
    description: 'An animation channel.',
    properties: {
        name: {
            type: 'string',
            description: 'The channel\'s name.'
        },
        targetObject: {
            type: 'array',
            description: 'The path of the object to animate.',
            items: {
                type: 'string'
            },
            default: []
        },
        targetProperty: {
            type: 'string',
            description: 'The path of the property to animate.'
        },
        values: {
            type: 'string',
            description: 'The ID of the accessor for the channel values.'
        },
        times: {
            type: 'string',
            description: 'The ID of the accessor for the channel times.'
        },
        interpolation: {
            type: 'string',
            enum: ['linear'],
            description: 'The interpolation type for the channel.'
        }
    },
    required: ['name', 'targetObject', 'targetProperty', 'values', 'times', 'interpolation'],
    additionalProperties: false
};
exports.default = animationChannel;


/***/ }),
/* 121 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var animationClip = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'animationClip',
    title: 'AnimationClipDef',
    type: 'object',
    description: 'An animation clip.',
    properties: {
        name: {
            type: 'string',
            description: 'The clip\'s name.'
        },
        start: {
            type: 'number',
            description: 'The take\'s start time, in seconds.',
            default: 0
        },
        stop: {
            type: 'number',
            description: 'The take\'s stop time, in seconds.',
            default: 0
        },
        layers: {
            type: 'array',
            items: {
                type: 'string'
            },
            default: []
        }
    },
    required: ['name', 'start', 'stop', 'layers'],
    additionalProperties: false
};
exports.default = animationClip;


/***/ }),
/* 122 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var animationLayer = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'animationLayer',
    title: 'AnimationLayerDef',
    type: 'object',
    description: 'An animation layer.',
    properties: {
        name: {
            type: 'string',
            description: 'The layer\'s name.'
        },
        blendMode: {
            enum: ['additive'],
            description: 'The layer\'s blend mode.',
            default: 'additive'
        },
        blendWeight: {
            type: 'number',
            description: 'The layer\'s blend weight.',
            default: 1
        },
        channels: {
            type: 'array',
            items: {
                type: 'string'
            },
            default: []
        }
    },
    required: ['name', 'blendMode', 'blendWeight', 'channels'],
    additionalProperties: false
};
exports.default = animationLayer;


/***/ }),
/* 123 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var applicationAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'applicationAsset', title: 'ApplicationAssetDef', type: 'object', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['application']
        }, properties: {
            $ref: 'applicationAssetProperties.json'
        } }) });
exports.default = applicationAsset;


/***/ }),
/* 124 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var applicationAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'applicationAssetProperties', title: 'ApplicationAssetPropertiesDef', type: 'object', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { startupSceneId: {
            type: 'string'
        } }), required: [
        'startupSceneId'
    ] });
exports.default = applicationAssetProperties;


/***/ }),
/* 125 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var audioAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'audioAsset', title: 'AudioAssetDef', type: 'object', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['audio']
        }, representations: tslib_1.__assign({}, baseAsset_1.default.properties.representations, { type: {
                $ref: 'audioRepresentation.json'
            } }), properties: {
            $ref: 'audioAssetProperties.json'
        } }) });
exports.default = audioAsset;


/***/ }),
/* 126 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var audioAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'audioAssetProperties', title: 'AudioAssetPropertiesDef' });
exports.default = audioAssetProperties;


/***/ }),
/* 127 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var representation_1 = __webpack_require__(31);
var audioRepresentation = tslib_1.__assign({}, representation_1.default, { id: 'audioRepresentation', title: 'AudioRepresentationDef', properties: tslib_1.__assign({}, representation_1.default.properties, { bitRate: {
            type: 'number'
        }, sampleRate: {
            type: 'number'
        }, stereo: {
            type: 'boolean'
        }, startTime: {
            type: 'number'
        }, duration: {
            type: 'number'
        } }) });
exports.default = audioRepresentation;


/***/ }),
/* 128 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseObject_1 = __webpack_require__(15);
var boneObject = tslib_1.__assign({}, baseObject_1.default, { id: 'boneObject', title: 'BoneObjectDef', properties: tslib_1.__assign({}, baseObject_1.default.properties, { type: {
            enum: ['bone']
        }, properties: {
            $ref: 'boneObjectProperties.json'
        } }) });
exports.default = boneObject;


/***/ }),
/* 129 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var nodeObjectProperties_1 = __webpack_require__(17);
var boneObjectProperties = tslib_1.__assign({}, nodeObjectProperties_1.default, { id: 'boneObjectProperties', title: 'BoneObjectPropertiesDef' });
exports.default = boneObjectProperties;


/***/ }),
/* 130 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var box3 = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'box3',
    title: 'Box3Def',
    type: 'object',
    properties: {
        min: {
            $ref: 'vector3.json'
        },
        max: {
            $ref: 'vector3.json'
        }
    },
    required: ['min', 'max'],
    additionalProperties: false
};
exports.default = box3;


/***/ }),
/* 131 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var bufferAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'bufferAsset', title: 'BufferAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['buffer']
        }, properties: {
            $ref: 'bufferAssetProperties.json'
        } }) });
exports.default = bufferAsset;


/***/ }),
/* 132 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var bufferAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'bufferAssetProperties', title: 'BufferAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { src: {
            type: 'string',
            description: 'The URL of the binary file.'
        }, isExternal: {
            type: 'boolean',
            description: 'True is the asset should be loaded from outside of the base data provider/content provider.',
            default: false
        }, contentLength: {
            type: 'number',
            description: 'The HTTP Content-Length.'
        }, accessors: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'accessor.json'
            },
            description: 'Typed-views into the binary file.'
        } }), required: [
        'src',
        'contentLength'
    ] });
exports.default = bufferAssetProperties;


/***/ }),
/* 133 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseObject_1 = __webpack_require__(15);
var cameraObject = tslib_1.__assign({}, baseObject_1.default, { id: 'cameraObject', title: 'CameraObjectDef', properties: tslib_1.__assign({}, baseObject_1.default.properties, { type: {
            enum: ['camera']
        }, properties: {
            $ref: 'cameraObjectProperties.json'
        } }) });
exports.default = cameraObject;


/***/ }),
/* 134 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var nodeObjectProperties_1 = __webpack_require__(17);
var cameraObjectProperties = tslib_1.__assign({}, nodeObjectProperties_1.default, { id: 'cameraObjectProperties', title: 'CameraObjectPropertiesDef', properties: tslib_1.__assign({}, nodeObjectProperties_1.default.properties, { cameraType: {
            type: 'string',
            description: '',
            default: 'perspective'
        }, fov: {
            type: 'number',
            default: 50
        }, aspect: {
            type: 'number',
            default: 1.77777777777777770
        }, near: {
            type: 'number',
            default: 0.1
        }, far: {
            type: 'number',
            default: 12000.0
        }, right: {
            type: 'number',
            default: 10.0
        }, left: {
            type: 'number',
            default: -10.0
        }, top: {
            type: 'number',
            default: 10.0
        }, bottom: {
            type: 'number',
            default: -10.0
        } }) });
exports.default = cameraObjectProperties;


/***/ }),
/* 135 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var component = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'component',
    title: 'ComponentDef',
    type: 'object',
    properties: {
        id: {
            type: 'string'
        },
        scriptId: {
            type: 'string'
        },
        name: {
            type: 'string'
        },
        enabled: {
            type: 'boolean'
        },
        attributes: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'componentAttribute.json'
            }
        }
    },
    additionalProperties: false
};
exports.default = component;


/***/ }),
/* 136 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var componentAttribute = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'componentAttribute',
    title: 'ComponentAttributeDef',
    type: 'object',
    properties: {
        type: {
            type: 'string'
        },
        subType: {
            type: 'object',
            properties: {
                type: {
                    type: 'string'
                },
                attributes: {}
            },
            additionalProperties: false
        },
        attributes: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    type: {
                        type: 'string'
                    },
                    attributes: {}
                },
                additionalProperties: false
            }
        }
    },
    additionalProperties: false
};
exports.default = componentAttribute;


/***/ }),
/* 137 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var documentAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'documentAsset', title: 'DocumentAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['document']
        }, properties: {
            $ref: 'documentAssetProperties.json'
        } }) });
exports.default = documentAsset;


/***/ }),
/* 138 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var documentAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'documentAssetProperties', title: 'DocumentAssetPropertiesDef' });
exports.default = documentAssetProperties;


/***/ }),
/* 139 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var dracoAttribute = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'dracoAttribute',
    title: 'DracoAttributeDef',
    type: 'object',
    description: 'Specifies the name and ID of a Draco attribute.',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the this attribute. For example, texture\'s have ' +
                'a uvSet property that contains the name of a UV attribute.'
        },
        id: {
            type: 'string',
            description: 'The ID of the Draco attribute.'
        }
    },
    required: ['name', 'id'],
    additionalProperties: false
};
exports.default = dracoAttribute;


/***/ }),
/* 140 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseGeometryAsset_1 = __webpack_require__(28);
var dracoGeometryAsset = tslib_1.__assign({}, baseGeometryAsset_1.default, { id: 'dracoGeometryAsset', title: 'DracoGeometryAssetDef', properties: tslib_1.__assign({}, baseGeometryAsset_1.default.properties, { type: {
            enum: ['dracoGeometry']
        }, properties: {
            $ref: 'dracoGeometryAssetProperties.json'
        } }) });
exports.default = dracoGeometryAsset;


/***/ }),
/* 141 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseGeometryAssetProperties_1 = __webpack_require__(29);
var dracoGeometryAssetProperties = tslib_1.__assign({}, baseGeometryAssetProperties_1.default, { id: 'dracoGeometryAssetProperties', title: 'DracoGeometryAssetPropertiesDef', properties: tslib_1.__assign({}, baseGeometryAssetProperties_1.default.properties, { accessorId: {
            type: ['string', 'null'],
            description: 'The ID of the accessor containing the draco geometry: <bufferId>#<accessorId>.'
        }, attributes: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'dracoAttribute.json'
            },
            description: 'A collection of vertex attributes. All attributes must have the same number of elements.'
        } }), required: ['accessorId'] });
exports.default = dracoGeometryAssetProperties;


/***/ }),
/* 142 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseImageAsset_1 = __webpack_require__(70);
var imageAsset = tslib_1.__assign({}, baseImageAsset_1.default, { id: 'imageAsset', title: 'ImageAssetDef', properties: tslib_1.__assign({}, baseImageAsset_1.default.properties, { type: {
            enum: ['image']
        }, representations: tslib_1.__assign({}, baseImageAsset_1.default.properties.representations, { type: {
                $ref: 'imageRepresentation.json'
            } }), properties: {
            $ref: 'imageAssetProperties.json'
        } }) });
exports.default = imageAsset;


/***/ }),
/* 143 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseImageAssetProperties_1 = __webpack_require__(42);
var imageAssetProperties = tslib_1.__assign({}, baseImageAssetProperties_1.default, { id: 'imageAssetProperties', title: 'ImageAssetPropertiesDef', properties: tslib_1.__assign({}, baseImageAssetProperties_1.default.properties, { useCompression: {
            type: 'boolean',
            description: 'True if we will try to use a hardware-compressed version ' +
                'of the image \'instead of a regular one. This depends on the hardware ' +
                'capabilities of the user and the data formats available.',
            default: false
        } }) });
exports.default = imageAssetProperties;


/***/ }),
/* 144 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var representation_1 = __webpack_require__(31);
var imageRepresentation = {
    id: 'imageRepresentation',
    title: 'ImageRepresentationDef',
    properties: tslib_1.__assign({}, representation_1.default.properties, { src: {
            type: 'string',
            description: 'The URL of the representation.'
        }, channels: {
            type: 'array',
            items: {
                type: 'string'
            }
        }, compression: {
            type: 'string',
            enum: ['dxt', 'dxt1', 'dxt5', 'jpeg', 'zip']
        }, isExternal: {
            type: 'boolean'
        }, width: {
            type: 'integer',
            description: 'The width, in pixels, of the representation.'
        }, height: {
            type: 'integer',
            description: 'The height, in pixels, of the representation.'
        } }),
    required: ['src'],
    additionalProperties: false
};
exports.default = imageRepresentation;


/***/ }),
/* 145 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseObject_1 = __webpack_require__(15);
var lightObject = tslib_1.__assign({}, baseObject_1.default, { id: 'lightObject', title: 'LightObjectDef', properties: tslib_1.__assign({}, baseObject_1.default.properties, { type: {
            enum: ['light']
        }, properties: {
            $ref: 'lightObjectProperties.json'
        } }) });
exports.default = lightObject;


/***/ }),
/* 146 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var nodeObjectProperties_1 = __webpack_require__(17);
var lightObjectProperties = tslib_1.__assign({}, nodeObjectProperties_1.default, { id: 'lightObjectProperties', title: 'LightObjectPropertiesDef', properties: tslib_1.__assign({}, nodeObjectProperties_1.default.properties, { lightType: {
            type: 'string',
            default: 'directional'
        }, color: {
            type: ['object', 'string', 'number'],
            properties: {
                r: {
                    type: 'number'
                },
                g: {
                    type: 'number'
                },
                b: {
                    type: 'number'
                }
            },
            default: {
                r: 0.7333,
                g: 0.7333,
                b: 0.7333
            }
        }, intensity: {
            type: 'number',
            default: 1.0
        }, distance: {
            type: 'number',
            default: 100.0
        }, castShadow: {
            type: 'boolean',
            default: false
        }, shadowCameraNear: {
            type: 'number',
            default: 0.1
        }, shadowCameraFar: {
            type: 'number',
            default: 20.0
        }, shadowCameraLeft: {
            type: 'number',
            default: -10.0
        }, shadowCameraRight: {
            type: 'number',
            default: 10.0
        }, shadowCameraTop: {
            type: 'number',
            default: 10.0
        }, shadowCameraBottom: {
            type: 'number',
            default: -10.0
        }, shadowBias: {
            type: 'number',
            default: -0.0015
        }, shadowMapWidth: {
            type: 'integer',
            default: 1024
        }, shadowMapHeight: {
            type: 'integer',
            default: 1024
        } }) });
exports.default = lightObjectProperties;


/***/ }),
/* 147 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var materialAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'materialAsset', title: 'MaterialAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['material']
        }, properties: {
            $ref: 'materialAssetProperties.json'
        } }) });
exports.default = materialAsset;


/***/ }),
/* 148 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var materialAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'materialAssetProperties', title: 'MaterialAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { shader: {
            type: 'string',
            default: 'box3d_pbr_shader'
        }, enabledFeatures: {
            type: ['object', 'null'],
            default: null,
            properties: {},
            additionalProperties: {
                type: 'boolean'
            }
        } }), additionalProperties: true });
exports.default = materialAssetProperties;


/***/ }),
/* 149 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var meshAttribute = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'meshAttribute',
    title: 'MeshAttributeDef',
    type: 'object',
    description: 'Specifies a range of attribute data for the vertices of a mesh.',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the this attribute. For example, texture\'s have ' +
                'a uvSet property that contains the name of a UV attribute.'
        },
        accessorId: {
            type: 'string',
            description: 'The ID of the buffer asset and accessor: <bufferId>#<accessorId>.'
        }
    },
    required: ['name', 'accessorId'],
    additionalProperties: false
};
exports.default = meshAttribute;


/***/ }),
/* 150 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseGeometryAsset_1 = __webpack_require__(28);
var meshGeometryAsset = tslib_1.__assign({}, baseGeometryAsset_1.default, { id: 'meshGeometryAsset', title: 'MeshGeometryAssetDef', properties: tslib_1.__assign({}, baseGeometryAsset_1.default.properties, { type: {
            enum: ['meshGeometry']
        }, properties: {
            $ref: 'meshGeometryAssetProperties.json'
        } }) });
exports.default = meshGeometryAsset;


/***/ }),
/* 151 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseGeometryAssetProperties_1 = __webpack_require__(29);
var meshGeometryAssetProperties = tslib_1.__assign({}, baseGeometryAssetProperties_1.default, { id: 'meshGeometryAssetProperties', title: 'MeshGeometryAssetPropertiesDef', properties: tslib_1.__assign({}, baseGeometryAssetProperties_1.default.properties, { attributes: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'meshAttribute.json'
            },
            description: 'A collection of vertex attributes. All attributes must have the same number of elements.'
        }, indices: {
            type: ['string', 'null'],
            description: 'The ID of the accessor containing the vertex indices: <bufferId>#<accessorId>.'
        }, primitives: {
            type: 'array',
            items: {
                $ref: 'meshPrimitive.json'
            },
            description: 'The primitives (points, lines, triangles) that make up the mesh.'
        } }), required: ['attributes', 'indices', 'primitives'] });
exports.default = meshGeometryAssetProperties;


/***/ }),
/* 152 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseObject_1 = __webpack_require__(15);
var meshObject = tslib_1.__assign({}, baseObject_1.default, { id: 'meshObject', title: 'MeshObjectDef', properties: tslib_1.__assign({}, baseObject_1.default.properties, { type: {
            enum: ['mesh']
        }, properties: {
            $ref: 'meshObjectProperties.json'
        } }) });
exports.default = meshObject;


/***/ }),
/* 153 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var nodeObjectProperties_1 = __webpack_require__(17);
var meshObjectProperties = tslib_1.__assign({}, nodeObjectProperties_1.default, { id: 'meshObjectProperties', title: 'MeshObjectPropertiesDef', properties: tslib_1.__assign({}, nodeObjectProperties_1.default.properties, { customDepthMaterial: {
            type: ['string', 'null'],
            default: null
        }, materials: {
            type: 'array',
            default: [
                'missingMaterial'
            ]
        }, geometryId: {
            type: ['string', 'null'],
            default: null
        }, skinId: {
            type: ['string', 'null'],
            default: null
        } }) });
exports.default = meshObjectProperties;


/***/ }),
/* 154 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'meshPrimitve',
    title: 'meshPrimitiveDef',
    type: 'object',
    description: 'A mesh primitive with an optional material assignment.',
    properties: {
        primitive: {
            enum: ['points', 'lines', 'triangles'],
            description: 'The type of primitive to render.',
            default: 'triangles'
        },
        count: {
            type: 'integer',
            description: 'The number of vertices to draw.',
            default: 0
        },
        start: {
            type: 'integer',
            description: 'The index of the first vertex to draw.',
            default: 0
        },
        offset: {
            type: 'integer',
            description: 'An offset to apply to each index. This can be used to overcome ' +
                ' the 16-bit index limit imposed by WebGL. For example, the first component ' +
                ' of a vertex attribute with a value size of 3 would be referenced as ' +
                ' follows: values[3 * (offset + indices[start + i])].',
            default: 0
        },
        materialIndex: {
            type: 'integer',
            description: 'The index of the material to apply to the primitive being rendered.',
            default: 0
        }
    },
    required: ['primitve', 'count'],
    additionalProperties: false
};


/***/ }),
/* 155 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseObject_1 = __webpack_require__(15);
var nodeObject = tslib_1.__assign({}, baseObject_1.default, { id: 'nodeObject', title: 'NodeObjectDef', properties: tslib_1.__assign({}, baseObject_1.default.properties, { type: {
            enum: ['node']
        } }) });
exports.default = nodeObject;


/***/ }),
/* 156 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var prefabAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'prefabAsset', title: 'PrefabAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['prefab']
        }, properties: {
            $ref: 'prefabAssetProperties.json'
        } }) });
exports.default = prefabAsset;


/***/ }),
/* 157 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var prefabAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'prefabAssetProperties', title: 'PrefabAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { rootObjectId: {
            type: ['string', 'null'],
            default: null,
            description: 'The ID of the BaseObject that serves as the root node of a hierarchy.'
        } }) });
exports.default = prefabAssetProperties;


/***/ }),
/* 158 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseGeometryAsset_1 = __webpack_require__(28);
var primitiveGeometryAsset = tslib_1.__assign({}, baseGeometryAsset_1.default, { id: 'primitiveGeometryAsset', title: 'PrimitiveGeometryAssetDef', properties: tslib_1.__assign({}, baseGeometryAsset_1.default.properties, { type: {
            enum: ['primitiveGeometry']
        }, properties: {
            $ref: 'primitiveGeometryAssetProperties.json'
        } }) });
exports.default = primitiveGeometryAsset;


/***/ }),
/* 159 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseGeometryAssetProperties_1 = __webpack_require__(29);
var primitiveGeometryAssetProperties = tslib_1.__assign({}, baseGeometryAssetProperties_1.default, { id: 'primitiveGeometryAssetProperties', title: 'PrimitiveGeometryAssetPropertiesDef', properties: tslib_1.__assign({}, baseGeometryAssetProperties_1.default.properties, { type: {
            type: 'string',
            default: 'sphere'
        }, radius: {
            type: 'number',
            default: 100
        }, segmentsU: {
            type: 'integer',
            default: 12
        }, segmentsV: {
            type: 'integer',
            default: 12
        }, sizeX: {
            type: 'number',
            default: 100
        }, sizeY: {
            type: 'number',
            default: 100
        }, sizeZ: {
            type: 'number',
            default: 100
        }, segmentsX: {
            type: 'integer',
            default: 1
        }, segmentsY: {
            type: 'integer',
            default: 1
        }, segmentsZ: {
            type: 'integer',
            default: 1
        }, radiusTop: {
            type: 'number',
            default: 50
        }, radiusBottom: {
            type: 'number',
            default: 50
        }, height: {
            type: 'number',
            default: 100
        }, open: {
            type: 'boolean',
            default: false
        }, tubeRadius: {
            type: 'number',
            default: 20
        }, arcAngle: {
            type: 'number',
            default: 6.2831853071795860
        } }) });
exports.default = primitiveGeometryAssetProperties;


/***/ }),
/* 160 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseRenderTextureAsset_1 = __webpack_require__(43);
var renderTexture2DAsset = tslib_1.__assign({}, baseRenderTextureAsset_1.default, { id: 'renderTexture2DAsset', title: 'RenderTexture2DAssetDef', properties: tslib_1.__assign({}, baseRenderTextureAsset_1.default.properties, { type: {
            enum: ['renderTexture2D']
        }, properties: {
            $ref: 'renderTexture2DAssetProperties.json'
        } }) });
exports.default = renderTexture2DAsset;


/***/ }),
/* 161 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseRenderTextureAssetProperties_1 = __webpack_require__(44);
var renderTexture2DAsset = tslib_1.__assign({}, baseRenderTextureAssetProperties_1.default, { id: 'renderTexture2DAssetProperties', title: 'RenderTexture2DAssetPropertiesDef' });
exports.default = renderTexture2DAsset;


/***/ }),
/* 162 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseRenderTextureAsset_1 = __webpack_require__(43);
var renderTextureCubeAsset = tslib_1.__assign({}, baseRenderTextureAsset_1.default, { id: 'renderTextureCubeAsset', title: 'RenderTextureCubeAssetDef', properties: tslib_1.__assign({}, baseRenderTextureAsset_1.default.properties, { type: {
            enum: ['renderTextureCube']
        }, properties: {
            $ref: 'renderTextureCubeAssetProperties.json'
        } }) });
exports.default = renderTextureCubeAsset;


/***/ }),
/* 163 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseRenderTextureAssetProperties_1 = __webpack_require__(44);
var renderTextureCubeAssetProperties = tslib_1.__assign({}, baseRenderTextureAssetProperties_1.default, { id: 'renderTextureCubeAssetProperties', title: 'RenderTextureCubeAssetPropertiesDef', properties: tslib_1.__assign({}, baseRenderTextureAssetProperties_1.default.properties, { mappingType: {
            type: 'string',
            description: 'his value is temporarily here for compatibility with ' +
                'three.js. Remove it when adding a separate transform object to textures.',
            default: 'cube'
        } }) });
exports.default = renderTextureCubeAssetProperties;


/***/ }),
/* 164 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseObject_1 = __webpack_require__(15);
var sceneObject = tslib_1.__assign({}, baseObject_1.default, { id: 'sceneObject', title: 'SceneObjectDef', properties: tslib_1.__assign({}, baseObject_1.default.properties, { type: {
            enum: ['scene']
        }, properties: {
            $ref: 'sceneObjectProperties.json'
        } }) });
exports.default = sceneObject;


/***/ }),
/* 165 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var nodeObjectProperties_1 = __webpack_require__(17);
var sceneObjectProperties = tslib_1.__assign({}, nodeObjectProperties_1.default, { id: 'sceneObjectProperties', title: 'SceneObjectPropertiesDef', properties: tslib_1.__assign({}, nodeObjectProperties_1.default.properties, { fogEnabled: {
            type: 'boolean',
            default: false
        }, fogType: {
            type: 'string',
            default: 'FogExp2'
        }, fogColor: {
            type: ['number', 'string'],
            default: 12303291
        }, fogDensity: {
            type: 'number',
            default: 0.0004
        } }) });
exports.default = sceneObjectProperties;


/***/ }),
/* 166 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var scriptAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'scriptAsset', title: 'ScriptAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['script']
        }, properties: {
            $ref: 'scriptAssetProperties.json'
        } }) });
exports.default = scriptAsset;


/***/ }),
/* 167 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var scriptAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'scriptAssetProperties', title: 'ScriptAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { attributes: {
            type: 'object',
            default: {}
        }, description: {
            type: 'string',
            default: ''
        }, events: {
            type: 'object',
            default: {}
        }, externalDependencies: {
            type: 'array',
            default: []
        }, filter: {
            type: 'array',
            default: []
        }, category: {
            type: 'string',
            default: ''
        } }) });
exports.default = scriptAssetProperties;


/***/ }),
/* 168 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var shaderAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'shaderAsset', title: 'ShaderAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['shader']
        }, properties: {
            $ref: 'shaderAssetProperties.json'
        } }) });
exports.default = shaderAsset;


/***/ }),
/* 169 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var shaderAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'shaderAssetProperties', title: 'ShaderAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { parameters: {
            type: 'object',
            default: {},
            additionalProperties: {
                $ref: 'shaderParameter.json'
            }
        }, uniforms: {
            type: 'object',
            default: {}
        }, vertexShader: {
            type: 'string',
            default: ''
        }, fragmentShader: {
            type: 'string',
            default: ''
        } }) });
exports.default = shaderAssetProperties;


/***/ }),
/* 170 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var shaderConditions = {
    type: 'object',
    id: 'shaderConditions',
    title: 'ShaderConditionsDef',
    properties: {
        or: {
            type: 'array',
            items: {
                // @FIXME: recursive definitions currently have issues, allowing any object for now
                type: 'object',
                properties: {},
                additionalProperties: true
            }
        },
        equals: {
            oneOf: [
                {
                    type: 'string'
                },
                {
                    type: 'number'
                },
                {
                    type: 'integer'
                },
                {
                    type: 'boolean'
                },
                {
                    type: 'object'
                }
            ]
        },
        notEquals: {
            oneOf: [
                {
                    type: 'string'
                },
                {
                    type: 'number'
                },
                {
                    type: 'integer'
                },
                {
                    type: 'boolean'
                },
                {
                    type: 'object'
                }
            ]
        },
        equalsDefault: {
            type: 'boolean'
        },
        notEqualsDefault: {
            type: 'boolean'
        }
    },
    additionalProperties: false
};
exports.default = shaderConditions;


/***/ }),
/* 171 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var shaderParameter = {
    id: 'shaderParameter',
    title: 'ShaderParameterDef',
    properties: {
        displayName: {
            type: 'string'
        },
        description: {
            type: 'string'
        },
        isRenderParam: {
            type: 'boolean'
        },
        isUniform: {
            type: 'boolean'
        },
        uniformName: {
            type: 'string'
        },
        type: {
            type: 'string',
            enum: ['b', 'c', 'f', 't', 'opt', 'v2']
        },
        min: {
            type: 'number'
        },
        max: {
            type: 'number'
        },
        options: {
            type: 'object',
            properties: {},
            additionalProperties: true
        },
        displayWhen: {
            properties: {},
            additionalProperties: {
                $ref: 'shaderConditions.json'
            }
        },
        enabledWhen: {
            properties: {},
            additionalProperties: {
                $ref: 'shaderConditions.json'
            }
        },
        defines: {
            properties: {},
            additionalProperties: {
                oneOf: [
                    {
                        type: 'string'
                    },
                    {
                        type: 'number'
                    },
                    {
                        type: 'integer'
                    },
                    {
                        type: 'boolean'
                    }
                ]
            }
        },
        derivatives: {
            type: 'boolean'
        },
        default: {
            anyOf: [
                {
                    type: 'null'
                },
                {
                    type: 'string'
                },
                {
                    type: 'number'
                },
                {
                    type: 'integer'
                },
                {
                    type: 'boolean'
                },
                {
                    // @TODO: Handles, color, v2, etc. We could define these specific
                    // types here if we wanted. (at the cost of larger json data size).
                    type: 'object',
                    properties: {},
                    additionalProperties: true
                }
            ]
        },
        transparency: {
            enum: [
                'LessThanOne',
                'GreaterThanOne'
            ]
        },
        textureUsage: {
            enum: [
                'bump',
                'normal'
            ]
        },
        forceUpdate: {
            type: 'boolean'
        },
        textureType: {
            enum: [
                'Cube'
            ]
        },
        step: {
            type: 'number'
        }
    },
    additionalProperties: false
};
exports.default = shaderParameter;


/***/ }),
/* 172 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var skinAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'skinAsset', title: 'SkinAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['skin']
        }, properties: {
            $ref: 'skinAssetProperties.json'
        } }) });
exports.default = skinAsset;


/***/ }),
/* 173 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var skinAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'skinAssetProperties', title: 'SkinAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { bindShapeMatrix: {
            type: 'array',
            description: 'Bind shape matrix specifying how the mesh should be ' +
                'transformed into the right coordinate system for use with the joints.',
            items: {
                type: 'number'
            },
            minItems: 16,
            maxItems: 16,
            default: [
                1.0,
                0.0,
                0.0,
                0.0,
                0.0,
                1.0,
                0.0,
                0.0,
                0.0,
                0.0,
                1.0,
                0.0,
                0.0,
                0.0,
                0.0,
                1.0
            ]
        }, inverseBindMatrices: {
            type: 'string',
            description: 'The ID of the accessor containing the inverse bind matrices: <bufferId>#<accessorId>.'
        }, jointNames: {
            type: 'array',
            description: 'Names of the joints in this skin.',
            items: {
                type: 'string'
            },
            uniqueItems: true,
            default: []
        } }), required: [
        'bindShapeMatrix',
        'inverseBindMatrices',
        'jointNames'
    ] });
exports.default = skinAssetProperties;


/***/ }),
/* 174 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseTextureAsset_1 = __webpack_require__(30);
var texture2DAsset = tslib_1.__assign({}, baseTextureAsset_1.default, { id: 'texture2DAsset', title: 'Texture2DAssetDef', properties: tslib_1.__assign({}, baseTextureAsset_1.default.properties, { type: {
            enum: ['texture2D']
        }, properties: {
            $ref: 'texture2DAssetProperties.json'
        } }) });
exports.default = texture2DAsset;


/***/ }),
/* 175 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseTextureAssetProperties_1 = __webpack_require__(21);
var texture2DAssetProperties = tslib_1.__assign({}, baseTextureAssetProperties_1.default, { id: 'texture2DAssetProperties', title: 'Texture2DAssetPropertiesDef' });
exports.default = texture2DAssetProperties;


/***/ }),
/* 176 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseTextureAsset_1 = __webpack_require__(30);
var textureCubeAsset = tslib_1.__assign({}, baseTextureAsset_1.default, { id: 'textureCubeAsset', title: 'TextureCubeAssetDef', properties: tslib_1.__assign({}, baseTextureAsset_1.default.properties, { type: {
            enum: ['textureCube']
        }, properties: {
            $ref: 'textureCubeAssetProperties.json'
        } }) });
exports.default = textureCubeAsset;


/***/ }),
/* 177 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseTextureAssetProperties_1 = __webpack_require__(21);
var textureCubeAssetProperties = tslib_1.__assign({}, baseTextureAssetProperties_1.default, { id: 'textureCubeAssetProperties', title: 'TextureCubeAssetPropertiesDef', properties: tslib_1.__assign({}, baseTextureAssetProperties_1.default.properties, { 
        // This value is temporarily here for compatibility with three.js
        // Remove it when adding a separate transform object to textures.
        mappingType: {
            type: 'string',
            default: 'cube'
        } }) });
exports.default = textureCubeAssetProperties;


/***/ }),
/* 178 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vector3 = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'vector3',
    title: 'Vector3Def',
    type: 'object',
    properties: {
        x: {
            type: 'number'
        },
        y: {
            type: 'number'
        },
        z: {
            type: 'number'
        }
    },
    required: ['x', 'y', 'z'],
    additionalProperties: false
};
exports.default = vector3;


/***/ }),
/* 179 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var vector4 = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'vector4',
    title: 'Vector4Def',
    type: 'object',
    properties: {
        x: {
            type: 'number'
        },
        y: {
            type: 'number'
        },
        z: {
            type: 'number'
        },
        w: {
            type: 'number'
        }
    },
    required: ['x', 'y', 'z', 'w'],
    additionalProperties: false
};
exports.default = vector4;


/***/ }),
/* 180 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(7);
var videoAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'videoAsset', title: 'VideoAssetDef', type: 'object', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['video']
        }, representations: tslib_1.__assign({}, baseAsset_1.default.properties.representations, { type: {
                $ref: 'videoRepresentation.json'
            } }), properties: {
            $ref: 'videoAssetProperties.json'
        } }) });
exports.default = videoAsset;


/***/ }),
/* 181 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var baseImageAssetProperties_1 = __webpack_require__(42);
var baseTextureAssetProperties_1 = __webpack_require__(21);
var videoAssetProperties = tslib_1.__assign({}, baseImageAssetProperties_1.default, baseTextureAssetProperties_1.default, { id: 'videoAssetProperties', title: 'VideoAssetPropertiesDef', properties: tslib_1.__assign({}, baseImageAssetProperties_1.default.properties, baseTextureAssetProperties_1.default.properties, { autoPlay: {
            type: 'boolean',
            default: true
        }, muted: {
            type: 'boolean',
            default: true
        }, state: {
            type: 'string',
            default: 'play'
        }, loop: {
            type: 'boolean',
            default: true
        }, querySelector: {
            type: 'string'
        } }) });
exports.default = videoAssetProperties;


/***/ }),
/* 182 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var representation_1 = __webpack_require__(31);
var videoRepresentation = tslib_1.__assign({}, representation_1.default, { id: 'videoRepresentation', title: 'VideoRepresentationDef', properties: tslib_1.__assign({}, representation_1.default.properties, { video: {
            type: 'object',
            properties: {
                height: {
                    type: 'integer'
                },
                width: {
                    type: 'integer'
                }
            }
        } }) });
exports.default = videoRepresentation;


/***/ }),
/* 183 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable no-string-literal */
exports.default = (function () {
    var webGLContext;
    try {
        webGLContext = (window['WebGLRenderingContext']) ?
            document.createElement('canvas').getContext('experimental-webgl') : undefined;
    }
    catch (e) {
        // nothing
    }
    var webGLEnabled = !!webGLContext;
    var floatingPointTexturesEnabeled = (webGLEnabled) ?
        !!webGLContext.getExtension('OES_texture_float') : false;
    var vertexTexturesEnabeled = (webGLEnabled) ?
        !!(webGLContext.getParameter(webGLContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS) !== 0) :
        false;
    webGLContext = undefined;
    return {
        isWebGLEnabled: function () {
            return webGLEnabled;
        },
        isFloatingPointTexturesEnabeled: function () {
            return floatingPointTexturesEnabeled;
        },
        isVertexTexturesEnabeled: function () {
            return vertexTexturesEnabeled;
        }
    };
})();


/***/ }),
/* 184 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Determine whether an entity descriptor represents an object entity.
 * @param entityDef The entity descriptor
 * @returns         True if the descriptor is for an object.
 */
exports.isObject = function (entityDef) {
    return entityDef.type === 'node' || entityDef.type === 'camera' ||
        entityDef.type === 'scene' || entityDef.type === 'light' ||
        entityDef.type === 'mesh' || entityDef.type === 'bone';
};
/**
 * Determine whether an entity descriptor represents an asset type.
 * @param entityDef The entity descriptor
 * @returns         True if the descriptor is that of an asset.
 */
exports.isAsset = function (entityDef) {
    return !exports.isObject(entityDef);
};


/***/ }),
/* 185 */
/***/ (function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ }),
/* 186 */
/***/ (function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(235);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ }),
/* 187 */
/***/ (function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ }),
/* 188 */
/***/ (function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ }),
/* 189 */
/***/ (function(module, exports, __webpack_require__) {

var store      = __webpack_require__(250)('wks')
  , uid        = __webpack_require__(188)
  , Symbol     = __webpack_require__(33).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ }),
/* 190 */
/***/ (function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;


/***/ }),
/* 191 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(75)))

/***/ }),
/* 192 */
/***/ (function(module, exports, __webpack_require__) {

var map = {
	"./accessor": 117,
	"./accessor.ts": 117,
	"./animationAsset": 118,
	"./animationAsset.ts": 118,
	"./animationAssetProperties": 119,
	"./animationAssetProperties.ts": 119,
	"./animationChannel": 120,
	"./animationChannel.ts": 120,
	"./animationClip": 121,
	"./animationClip.ts": 121,
	"./animationLayer": 122,
	"./animationLayer.ts": 122,
	"./applicationAsset": 123,
	"./applicationAsset.ts": 123,
	"./applicationAssetProperties": 124,
	"./applicationAssetProperties.ts": 124,
	"./audioAsset": 125,
	"./audioAsset.ts": 125,
	"./audioAssetProperties": 126,
	"./audioAssetProperties.ts": 126,
	"./audioRepresentation": 127,
	"./audioRepresentation.ts": 127,
	"./baseAsset": 7,
	"./baseAsset.ts": 7,
	"./baseAssetProperties": 8,
	"./baseAssetProperties.ts": 8,
	"./baseEntity": 40,
	"./baseEntity.ts": 40,
	"./baseEntityProperties": 41,
	"./baseEntityProperties.ts": 41,
	"./baseGeometryAsset": 28,
	"./baseGeometryAsset.ts": 28,
	"./baseGeometryAssetProperties": 29,
	"./baseGeometryAssetProperties.ts": 29,
	"./baseImageAsset": 70,
	"./baseImageAsset.ts": 70,
	"./baseImageAssetProperties": 42,
	"./baseImageAssetProperties.ts": 42,
	"./baseObject": 15,
	"./baseObject.ts": 15,
	"./baseObjectProperties": 71,
	"./baseObjectProperties.ts": 71,
	"./baseRenderTextureAsset": 43,
	"./baseRenderTextureAsset.ts": 43,
	"./baseRenderTextureAssetProperties": 44,
	"./baseRenderTextureAssetProperties.ts": 44,
	"./baseTextureAsset": 30,
	"./baseTextureAsset.ts": 30,
	"./baseTextureAssetProperties": 21,
	"./baseTextureAssetProperties.ts": 21,
	"./boneObject": 128,
	"./boneObject.ts": 128,
	"./boneObjectProperties": 129,
	"./boneObjectProperties.ts": 129,
	"./box3": 130,
	"./box3.ts": 130,
	"./bufferAsset": 131,
	"./bufferAsset.ts": 131,
	"./bufferAssetProperties": 132,
	"./bufferAssetProperties.ts": 132,
	"./cameraObject": 133,
	"./cameraObject.ts": 133,
	"./cameraObjectProperties": 134,
	"./cameraObjectProperties.ts": 134,
	"./commonImageProperties": 45,
	"./commonImageProperties.ts": 45,
	"./component": 135,
	"./component.ts": 135,
	"./componentAttribute": 136,
	"./componentAttribute.ts": 136,
	"./documentAsset": 137,
	"./documentAsset.ts": 137,
	"./documentAssetProperties": 138,
	"./documentAssetProperties.ts": 138,
	"./dracoAttribute": 139,
	"./dracoAttribute.ts": 139,
	"./dracoGeometryAsset": 140,
	"./dracoGeometryAsset.ts": 140,
	"./dracoGeometryAssetProperties": 141,
	"./dracoGeometryAssetProperties.ts": 141,
	"./imageAsset": 142,
	"./imageAsset.ts": 142,
	"./imageAssetProperties": 143,
	"./imageAssetProperties.ts": 143,
	"./imageRepresentation": 144,
	"./imageRepresentation.ts": 144,
	"./index": 4,
	"./index.ts": 4,
	"./lightObject": 145,
	"./lightObject.ts": 145,
	"./lightObjectProperties": 146,
	"./lightObjectProperties.ts": 146,
	"./materialAsset": 147,
	"./materialAsset.ts": 147,
	"./materialAssetProperties": 148,
	"./materialAssetProperties.ts": 148,
	"./meshAttribute": 149,
	"./meshAttribute.ts": 149,
	"./meshGeometryAsset": 150,
	"./meshGeometryAsset.ts": 150,
	"./meshGeometryAssetProperties": 151,
	"./meshGeometryAssetProperties.ts": 151,
	"./meshObject": 152,
	"./meshObject.ts": 152,
	"./meshObjectProperties": 153,
	"./meshObjectProperties.ts": 153,
	"./meshPrimitive": 154,
	"./meshPrimitive.ts": 154,
	"./nodeObject": 155,
	"./nodeObject.ts": 155,
	"./nodeObjectProperties": 17,
	"./nodeObjectProperties.ts": 17,
	"./prefabAsset": 156,
	"./prefabAsset.ts": 156,
	"./prefabAssetProperties": 157,
	"./prefabAssetProperties.ts": 157,
	"./primitiveGeometryAsset": 158,
	"./primitiveGeometryAsset.ts": 158,
	"./primitiveGeometryAssetProperties": 159,
	"./primitiveGeometryAssetProperties.ts": 159,
	"./renderTexture2DAsset": 160,
	"./renderTexture2DAsset.ts": 160,
	"./renderTexture2DAssetProperties": 161,
	"./renderTexture2DAssetProperties.ts": 161,
	"./renderTextureCubeAsset": 162,
	"./renderTextureCubeAsset.ts": 162,
	"./renderTextureCubeAssetProperties": 163,
	"./renderTextureCubeAssetProperties.ts": 163,
	"./representation": 31,
	"./representation.ts": 31,
	"./sceneObject": 164,
	"./sceneObject.ts": 164,
	"./sceneObjectProperties": 165,
	"./sceneObjectProperties.ts": 165,
	"./scriptAsset": 166,
	"./scriptAsset.ts": 166,
	"./scriptAssetProperties": 167,
	"./scriptAssetProperties.ts": 167,
	"./shaderAsset": 168,
	"./shaderAsset.ts": 168,
	"./shaderAssetProperties": 169,
	"./shaderAssetProperties.ts": 169,
	"./shaderConditions": 170,
	"./shaderConditions.ts": 170,
	"./shaderParameter": 171,
	"./shaderParameter.ts": 171,
	"./skinAsset": 172,
	"./skinAsset.ts": 172,
	"./skinAssetProperties": 173,
	"./skinAssetProperties.ts": 173,
	"./texture2DAsset": 174,
	"./texture2DAsset.ts": 174,
	"./texture2DAssetProperties": 175,
	"./texture2DAssetProperties.ts": 175,
	"./textureCubeAsset": 176,
	"./textureCubeAsset.ts": 176,
	"./textureCubeAssetProperties": 177,
	"./textureCubeAssetProperties.ts": 177,
	"./vector3": 178,
	"./vector3.ts": 178,
	"./vector4": 179,
	"./vector4.ts": 179,
	"./videoAsset": 180,
	"./videoAsset.ts": 180,
	"./videoAssetProperties": 181,
	"./videoAssetProperties.ts": 181,
	"./videoRepresentation": 182,
	"./videoRepresentation.ts": 182
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 192;


/***/ }),
/* 193 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
var THREE = __webpack_require__(1);
exports.THREE = THREE;
var Components = __webpack_require__(221);
exports.Components = Components;
var Schemas_1 = __webpack_require__(4);
exports.Schemas = Schemas_1.default;
var Engine_1 = __webpack_require__(116);
exports.Engine = Engine_1.default;
var ScriptRegistry_1 = __webpack_require__(77);
exports.ScriptRegistry = ScriptRegistry_1.default;
var BaseEntity_1 = __webpack_require__(9);
exports.BaseEntity = BaseEntity_1.default;
// Assets
var AnimationAsset_1 = __webpack_require__(49);
exports.AnimationAsset = AnimationAsset_1.default;
var ApplicationAsset_1 = __webpack_require__(34);
exports.ApplicationAsset = ApplicationAsset_1.default;
var AudioAsset_1 = __webpack_require__(50);
exports.AudioAsset = AudioAsset_1.default;
var BaseAsset_1 = __webpack_require__(6);
exports.BaseAsset = BaseAsset_1.default;
var BaseGeometryAsset_1 = __webpack_require__(23);
exports.BaseGeometryAsset = BaseGeometryAsset_1.default;
var BaseImageAsset_1 = __webpack_require__(11);
exports.BaseImageAsset = BaseImageAsset_1.default;
var BaseRenderTextureAsset_1 = __webpack_require__(51);
exports.BaseRenderTextureAsset = BaseRenderTextureAsset_1.default;
var BaseTextureAsset_1 = __webpack_require__(19);
exports.BaseTextureAsset = BaseTextureAsset_1.default;
var BufferAsset_1 = __webpack_require__(20);
exports.BufferAsset = BufferAsset_1.default;
var DocumentAsset_1 = __webpack_require__(76);
exports.DocumentAsset = DocumentAsset_1.default;
var DracoGeometryAsset_1 = __webpack_require__(52);
exports.DracoGeometryAsset = DracoGeometryAsset_1.default;
var ImageAsset_1 = __webpack_require__(35);
exports.ImageAsset = ImageAsset_1.default;
var MaterialAsset_1 = __webpack_require__(14);
exports.MaterialAsset = MaterialAsset_1.default;
var MeshGeometryAsset_1 = __webpack_require__(53);
exports.MeshGeometryAsset = MeshGeometryAsset_1.default;
var PrefabAsset_1 = __webpack_require__(54);
exports.PrefabAsset = PrefabAsset_1.default;
var PrimitiveGeometryAsset_1 = __webpack_require__(55);
exports.PrimitiveGeometryAsset = PrimitiveGeometryAsset_1.default;
var RenderTexture2DAsset_1 = __webpack_require__(56);
exports.RenderTexture2DAsset = RenderTexture2DAsset_1.default;
var RenderTextureCubeAsset_1 = __webpack_require__(57);
exports.RenderTextureCubeAsset = RenderTextureCubeAsset_1.default;
var ScriptAsset_1 = __webpack_require__(58);
exports.ScriptAsset = ScriptAsset_1.default;
var ShaderAsset_1 = __webpack_require__(36);
exports.ShaderAsset = ShaderAsset_1.default;
var SkinAsset_1 = __webpack_require__(59);
exports.SkinAsset = SkinAsset_1.default;
var Texture2DAsset_1 = __webpack_require__(60);
exports.Texture2DAsset = Texture2DAsset_1.default;
var TextureCubeAsset_1 = __webpack_require__(61);
exports.TextureCubeAsset = TextureCubeAsset_1.default;
var VideoAsset_1 = __webpack_require__(24);
exports.VideoAsset = VideoAsset_1.default;
// Objects
var BaseObject_1 = __webpack_require__(10);
exports.BaseObject = BaseObject_1.default;
var NodeObject_1 = __webpack_require__(68);
exports.NodeObject = NodeObject_1.default;
var BoneObject_1 = __webpack_require__(66);
exports.BoneObject = BoneObject_1.default;
var CameraObject_1 = __webpack_require__(67);
exports.CameraObject = CameraObject_1.default;
var LightObject_1 = __webpack_require__(37);
exports.LightObject = LightObject_1.default;
var MeshObject_1 = __webpack_require__(26);
exports.MeshObject = MeshObject_1.default;
var SceneObject_1 = __webpack_require__(38);
exports.SceneObject = SceneObject_1.default;
// Constants, Enums
var LoadingType_1 = __webpack_require__(16);
exports.LoadingType = LoadingType_1.default;
var LoadingEvent_1 = __webpack_require__(12);
exports.LoadingEvent = LoadingEvent_1.default;
var LoadingState_1 = __webpack_require__(69);
exports.LoadingState = LoadingState_1.default;
// Components
var BaseComponent_1 = __webpack_require__(2);
exports.BaseComponent = BaseComponent_1.default;
var MotionGamepadDevice_1 = __webpack_require__(63);
exports.Handedness = MotionGamepadDevice_1.Handedness;
var RenderModes_1 = __webpack_require__(64);
exports.RenderMode = RenderModes_1.RenderMode;
// Utilities
var Logger_1 = __webpack_require__(3);
exports.log = Logger_1.default;
var XhrResourceLoader_1 = __webpack_require__(218);
exports.XhrResourceLoader = XhrResourceLoader_1.default;
__export(__webpack_require__(22));
var globalEvents_1 = __webpack_require__(47);
exports.globalEvents = globalEvents_1.default;
var browserCaps_1 = __webpack_require__(183);
exports.browserCaps = browserCaps_1.default;


/***/ }),
/* 194 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(255);
module.exports = __webpack_require__(32).Array.find;

/***/ }),
/* 195 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(256);
module.exports = __webpack_require__(32).Math.log10;

/***/ }),
/* 196 */
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__(257);
module.exports = __webpack_require__(32).Math.log2;

/***/ }),
/* 197 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var THREE = __webpack_require__(1);
var GeometryUtilities = (function () {
    /** Create a registry to manage geometry assets. */
    function GeometryUtilities() {
        var _this = this;
        this.defaultGeometry = new THREE.BufferGeometry();
        this.defaultGeometry.setIndex(new THREE.BufferAttribute(new Uint16Array(0), 1));
        var attributes = {
            position: new THREE.BufferAttribute(new Float32Array(0), 3),
            normal: new THREE.BufferAttribute(new Float32Array(0), 3, true),
            skinWeight: new THREE.BufferAttribute(new Float32Array(0), 4, true),
            skinIndex: new THREE.BufferAttribute(new Uint16Array(0), 4, true)
        };
        Object.keys(attributes).forEach(function (name) {
            var attribute = attributes[name];
            _this.defaultGeometry.addAttribute(name, attribute);
        });
    }
    /** Destroys the geometry utilities instance, disposing any loaded data. */
    GeometryUtilities.prototype.destroy = function () {
        if (this.defaultGeometry) {
            this.defaultGeometry.dispose();
            this.defaultGeometry = undefined;
        }
    };
    /**
     * Get a default, empty geometry instance.
     * @returns The default geometry.
     */
    GeometryUtilities.prototype.getDefaultGeometry = function () {
        return this.defaultGeometry;
    };
    return GeometryUtilities;
}());
exports.default = GeometryUtilities;


/***/ }),
/* 198 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var THREE = __webpack_require__(1);
var functions_1 = __webpack_require__(5);
/**
 * @class  ComponentRegistry
 * @constructor
 */
var ComponentRegistry = (function () {
    function ComponentRegistry() {
        /** The components currently attached to the connected entity. */
        this.components = [];
    }
    /** Initialize component registry. */
    ComponentRegistry.prototype.initializeComponents = function () {
        this.listenTo(this.engine, 'scriptDeleted', this.onScriptDeleted);
        this.listenTo(this, 'change:component', this.onComponentChanged);
        this.listenTo(this, 'remove:component', this.onComponentRemoved);
        this.listenTo(this, 'add:component', this.onComponentAdded);
    };
    /**
     * Return an object describing the component on this entity that was matched
     * by the predicate function.
     * @param [predicate] Function called on each descriptor to find the component. Return
     *                    true from the function to validate the descriptor.
     * @returns           Component descriptor.
     */
    ComponentRegistry.prototype.getComponentDescriptor = function (predicate) {
        var all = typeof predicate !== 'function';
        var components = this.sharedData.components;
        return functions_1.deepClone(components.find(function (comp) { return all || predicate(comp); }));
    };
    /**
     * Return an object describing the previous state of the component on this entity
     * that was matched by the predicate function.
     * @param [predicate] Function called on each descriptor to find the component. Return
     *                    true from the function to validate the descriptor.
     * @returns           Previous component descriptor.
     */
    ComponentRegistry.prototype.getPreviousComponentDescriptor = function (predicate) {
        var all = typeof predicate !== 'function';
        var components = this.sharedData.previousComponents;
        return functions_1.deepClone(components.find(function (comp) { return all || predicate(comp); }));
    };
    /**
     * Return an array of objects describing the components currently on this entity (that are matched
     * by the predicate function). If no predicate is defined, all will be returned.
     * @param [predicate] Function called on each descriptor to filter results. Return
     *                    true from the function to include the descriptor in the results.
     * @returns           All matching component descriptors.
     */
    ComponentRegistry.prototype.getComponentDescriptors = function (predicate) {
        var all = typeof predicate !== 'function';
        var components = this.sharedData.components;
        return components.filter(function (comp) { return all || predicate(comp); })
            .map(function (comp) { return functions_1.deepClone(comp); });
    };
    /**
     * Return the descriptor of a component with the given id
     * @param id  ID of the component to find
     * @returns   Descriptor of the found component.
     */
    ComponentRegistry.prototype.getComponentDescriptorById = function (id) {
        return this.getComponentDescriptor(function (comp) { return comp.id === id; });
    };
    /**
     * Return the previous descriptor of a component with the given id
     * @param id  Component id
     * @returns   Previous descriptor of the found component.
     */
    ComponentRegistry.prototype.getPreviousComponentDescriptorById = function (id) {
        return this.getPreviousComponentDescriptor(function (comp) { return comp.id === id; });
    };
    /**
     * Adds a new component to the BaseEntity.
     * @param script            Either a string scriptId or a script asset
     * @param [attributeValues] The initial attribute values to pass into the component
     * @param [name]            The name of the new component
     * @returns                 The newly-created component.
     */
    ComponentRegistry.prototype.addComponent = function (script, attributeValues, name) {
        if (attributeValues === void 0) { attributeValues = {}; }
        if (name === void 0) { name = ''; }
        var newComponent = {
            scriptId: typeof script === 'string' ? script : script.id,
            attributes: attributeValues,
            enabled: true,
            name: name
        };
        var entityDispatcher = this.engine.entityDispatcher;
        entityDispatcher.dispatchComponentAdded(this.id, newComponent);
        return this.components[this.components.length - 1];
    };
    /**
     * Removes the given component from this entity, if it exists.
     * @param component The component object to remove.
     * @returns         True if the component was removed successfully.
     */
    ComponentRegistry.prototype.removeComponent = function (component) {
        var idxToRemove = component.getIndex();
        if (idxToRemove >= 0) {
            this.engine.entityDispatcher.dispatchComponentRemoved(this.id, idxToRemove);
            return true;
        }
        return false;
    };
    /**
     * Returns the component at the given index.
     * @param index The index of the component on this entity
     * @returns     The component at the given index. null otherwise.
     */
    ComponentRegistry.prototype.getComponentByIndex = function (index) {
        return this.components[index] || null;
    };
    /**
     * Returns first component with the provided name
     * @param name  The name of the component
     * @returns     The first component that matches the search.
     */
    ComponentRegistry.prototype.getComponentByName = function (name) {
        return this.getComponent(function (comp) { return comp.getName() === name; });
    };
    /**
     * Returns all components with the provided name
     * @param name  The name of the component
     * @returns     All components that match the search.
     */
    ComponentRegistry.prototype.getComponentsByName = function (name) {
        return this.getComponents(function (comp) { return comp.getName() === name; });
    };
    /**
     * Returns the first component found with the provided script Id
     * @param scriptId  The ID of the script asset used by the components
     * @returns         The first component matching the search.
     */
    ComponentRegistry.prototype.getComponentByScriptId = function (scriptId) {
        return this.getComponent(function (comp) { return comp.getScriptId() === scriptId; });
    };
    /**
     * Returns all components with the provided script Id
     * @param scriptId  The ID of the script asset used by the components
     * @returns         Array of all components matching the search.
     */
    ComponentRegistry.prototype.getComponentsByScriptId = function (scriptId) {
        return this.getComponents(function (comp) { return comp.getScriptId() === scriptId; });
    };
    /**
     * Returns first component with the provided script name
     * @param scriptName  The name of the script asset used by the components
     * @returns           The first component that matches the search.
     */
    ComponentRegistry.prototype.getComponentByScriptName = function (scriptName) {
        return this.getComponent(function (comp) { return comp.getScriptName() === scriptName; });
    };
    /**
     * Returns all components with the provided script name
     * @param scriptName  The name of the script asset used by the components
     * @returns           Array of all components matching the search.
     */
    ComponentRegistry.prototype.getComponentsByScriptName = function (scriptName) {
        return this.getComponents(function (comp) { return comp.getScriptName() === scriptName; });
    };
    /**
     * Return the first component attached to this entity that matches the specified filter
     * @param predicate Filter function that takes a component parameter and returns
     *                  true on match and false otherwise.
     * @returns         The component matching the filter
     */
    ComponentRegistry.prototype.getComponent = function (predicate) {
        var all = typeof predicate !== 'function';
        return this.components.find(function (comp) { return all || predicate(comp); });
    };
    /**
     * Return the component with the given ID, if there is one.
     * @param componentId Unique ID of the component
     * @returns           The component, if found, otherwise undefined.
     */
    ComponentRegistry.prototype.getComponentById = function (componentId) {
        return this.getComponent(function (comp) { return comp.getId() === componentId; });
    };
    /**
     * Return all of the components attached to this entity matching the specified filter
     * @param [predicate] Filter function that takes a component parameter and returns
     *                    true on match and false otherwise.
     * @returns           Array of components matching the filter
     */
    ComponentRegistry.prototype.getComponents = function (predicate) {
        var all = typeof predicate !== 'function';
        return this.components.filter(function (comp) { return all || predicate(comp); });
    };
    /**
     * Set the entire list of components for this entity. This will remove components
     * that are not specified, re-add components that might already exist and set the
     * component ordering to match the specified order.
     * @param componentDescriptors  Array of component descriptors of the form:
     *                              {id: <string>, scriptId: <string>, attributes: <Object>,
     *                                enabled: <boolean>}
     * @param [silent=false]        Suppress change event.
     */
    ComponentRegistry.prototype.setComponents = function (componentDescriptors, _silent) {
        var _this = this;
        if (_silent === void 0) { _silent = false; }
        var entityDispatcher = this.engine.entityDispatcher;
        for (var idx = this.sharedData.components.length; idx >= 0; idx--) {
            entityDispatcher.dispatchComponentRemoved(this.id, idx);
        }
        componentDescriptors.forEach(function (compDesc) {
            entityDispatcher.dispatchComponentAdded(_this.id, compDesc);
        });
    };
    /** Starts all components on this entity. */
    ComponentRegistry.prototype.startComponents = function () {
        var _this = this;
        this.components.forEach(function (comp) { return _this.startComponent(comp); });
    };
    /** Stops all components on the entity. */
    ComponentRegistry.prototype.stopComponents = function () {
        var _this = this;
        this.components.forEach(function (comp) { return _this.stopComponent(comp); });
    };
    /**
     * Called when a ScriptAsset has been deleted. This method will remove any
     * components that use the deleted ScriptAsset.
     * @param scriptId The ID of the deleted ScriptAsset
     */
    ComponentRegistry.prototype.onScriptDeleted = function (scriptId) {
        var _this = this;
        var comps = this.getComponentsByScriptId(scriptId);
        comps.forEach(function (comp) {
            _this.removeComponent(comp);
        });
    };
    /**
     * Called when a component on this entity has been modified.
     * @param index               Index of the component that just changed.
     * @param componentDescriptor The descriptor of the component changes.
     */
    ComponentRegistry.prototype.onComponentChanged = function (index, componentDescriptor) {
        var component = this.getComponentByIndex(index);
        if (!component) {
            throw new Error("Don't have a component at index " + index);
        }
        if (componentDescriptor.attributes) {
            this.assignAttributeValues(component, componentDescriptor.attributes);
            var changedAttributes = Object.keys(componentDescriptor.attributes);
            component.trigger('attributesChanged', changedAttributes);
        }
    };
    /**
     * Called when a component is added to this entity
     * @param componentDescriptor Descriptor for the new component
     */
    ComponentRegistry.prototype.onComponentAdded = function (componentDescriptor) {
        var component = this.createComponentObject(componentDescriptor);
        component.trigger('awake');
        this.assignAttributeValues(component);
        var scriptAsset = component.getScriptAsset();
        var changedAttributes = Object.keys(scriptAsset.getProperty('attributes'));
        component.trigger('attributesChanged', changedAttributes);
        // If the entity is already loaded when the component is created,
        // explicitly load the component.
        if (!this.isBaseUnloaded()) {
            this.startComponent(component, false);
        }
    };
    /**
     * Called when a component has been removed from this entity.
     * @param indexToRemove The index of the component to remove.
     */
    ComponentRegistry.prototype.onComponentRemoved = function (indexToRemove) {
        var component = this.components[indexToRemove];
        if (!component) {
            throw new Error("Can't find component at index " + indexToRemove + " to remove.");
        }
        this.stopComponent(component);
        this.components.splice(indexToRemove, 1);
    };
    /**
     * Translate an attribute value to a value that is assigned as a member of
     * the component. This function is called recursively for custom attributes.
     * @param obj             The object to set with the resulting member variable. This is
     *                        usually the component but, for custom attributes, it can be a
     *                        sub-object.
     * @param attributeName   Name of the attribute
     * @param attributeDef    Definition of the attribute
     * @param attributeValue  Raw value of the attribute before translation
     */
    ComponentRegistry.prototype.translateAttributeValue = function (obj, attributeName, attributeDef, attributeValue) {
        var _this = this;
        var runtime = this.engine;
        if (!attributeDef) {
            throw new Error("Attribute " + attributeName + " does not exist for this component.");
        }
        switch (attributeDef.type) {
            case 'asset':
                obj[attributeName] = runtime.getAssetById(attributeValue);
                break;
            case 'object':
                obj[attributeName] = runtime.getObjectById(attributeValue);
                break;
            case 'custom':
                obj[attributeName] = obj[attributeName] || {};
                Object.keys(attributeValue).forEach(function (key) {
                    _this.translateAttributeValue(obj[attributeName], key, attributeDef.attributes[key], attributeValue[key]);
                });
                break;
            case 'c':
                obj[attributeName] = obj[attributeName] || new THREE.Color();
                obj[attributeName].setRGB(attributeValue.r, attributeValue.g, attributeValue.b);
                break;
            case 'a':
                obj[attributeName] = obj[attributeName] || [];
                var defaultClass_1;
                // Handle arrays of different types
                switch (attributeDef.subType.type) {
                    case 'asset':
                        attributeValue.forEach(function (id, idx) {
                            obj[attributeName][idx] = runtime.getAssetById(id);
                        });
                        break;
                    case 'object':
                        attributeValue.forEach(function (id, idx) {
                            obj[attributeName][idx] = runtime.getObjectById(id);
                        });
                        break;
                    case 'custom':
                        attributeValue.forEach(function (subObj, idx) {
                            obj[attributeName][idx] = obj[attributeName][idx] || {};
                            Object.keys(subObj).forEach(function (key) {
                                _this.translateAttributeValue(obj[attributeName][idx], key, attributeDef.subType.attributes[key], attributeValue[idx][key]);
                            });
                        });
                        break;
                    case 'a':
                        attributeValue.forEach(function (subArray, idx) {
                            obj[attributeName][idx] = obj[attributeName][idx] || [];
                            subArray.forEach(function (_value, subIdx) {
                                _this.translateAttributeValue(obj[attributeName][idx], subIdx.toString(10), attributeDef.subType.subType, attributeValue[idx][subIdx]);
                            });
                        });
                        break;
                    case 'v2':
                        defaultClass_1 = THREE.Vector2;
                    /* falls through */
                    case 'v3':
                        defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Vector3;
                    /* falls through */
                    case 'v4':
                        defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Vector4;
                    /* falls through */
                    case 'q':
                        defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Quaternion;
                        attributeValue.forEach(function (value, idx) {
                            obj[attributeName][idx] = obj[attributeName][idx] || new defaultClass_1();
                            obj[attributeName][idx].copy(value);
                        });
                        break;
                    default:
                        attributeValue.forEach(function (value, idx) {
                            obj[attributeName][idx] = value;
                        });
                }
                break;
            case 'v2':
                defaultClass_1 = THREE.Vector2;
            /* falls through */
            case 'v3':
                defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Vector3;
            /* falls through */
            case 'v4':
                defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Vector4;
            /* falls through */
            case 'q':
                defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Quaternion;
                obj[attributeName] = obj[attributeName] || new defaultClass_1();
                obj[attributeName].copy(attributeValue);
                break;
            default:
                obj[attributeName] = attributeValue;
        }
    };
    /**
     * Take raw attribute values and create all member variables from them.
     * @param component     The component to update.
     * @param [attributes]  An object with keys that are the attribute names for
     *                      only the attributes that you wish to update.
     */
    ComponentRegistry.prototype.assignAttributeValues = function (component, attributes) {
        var _this = this;
        var all = typeof attributes !== 'object';
        var scriptAsset = component.getScriptAsset();
        var scriptAttributes = scriptAsset.getProperty('attributes') || {};
        Object.keys(scriptAttributes).forEach(function (attribName) {
            if (all || attributes.hasOwnProperty(attribName)) {
                var attrDef = scriptAttributes[attribName];
                var attribValue = component.getAttribute(attrDef.name);
                _this.translateAttributeValue(component, attrDef.name, attrDef, attribValue);
            }
        });
    };
    /**
     * Create the actual component using at the index with the given descriptor
     * @param componentDesc Descriptor for the new component
     * @returns             The newly-created component
     */
    ComponentRegistry.prototype.createComponentObject = function (componentDesc) {
        var scriptId = componentDesc.scriptId;
        var scriptAsset = this.engine.getAssetById(scriptId);
        if (!scriptAsset) {
            throw new Error("Unable to find script asset for " + scriptId);
        }
        if (scriptAsset.isUnloaded()) {
            scriptAsset.load();
        }
        var component = new scriptAsset.sharedData.classConstructor();
        this.components.push(component);
        Object.assign(component, {
            id: componentDesc.id,
            name: componentDesc.name,
            scriptName: scriptAsset.getName(),
            scriptId: scriptId,
            enabled: !!componentDesc.enabled,
            entity: this
        });
        return component;
    };
    /**
     * Starts the component, which calls 'start' and binds the other predefined functions.
     * @param component             The component to load.
     * @param [assignAttribs=true]  Initialize the attributes before starting the component.
     */
    ComponentRegistry.prototype.startComponent = function (component, assignAttribs) {
        if (assignAttribs === void 0) { assignAttribs = true; }
        // First, assign the attribute values and call the 'onAttributesChanged' function
        if (assignAttribs) {
            var scriptAsset = component.getScriptAsset();
            var changedAttributes = Object.keys(scriptAsset.getProperty('attributes'));
            this.assignAttributeValues(component);
            component.trigger('attributesChanged', changedAttributes);
        }
        // We'll call onStartup because we're loading the component
        component.trigger('startup');
    };
    /**
     * Stopping a component essentially shuts it down (kills event listeners and calls
     * the onShutdown function) but it doesn't remove it from the list.
     * @param component The component to remove.
     */
    ComponentRegistry.prototype.stopComponent = function (component) {
        component.trigger('shutdown');
    };
    return ComponentRegistry;
}());
;
exports.default = ComponentRegistry;


/***/ }),
/* 199 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var BaseEntity_1 = __webpack_require__(9);
var Logger_1 = __webpack_require__(3);
/**
 * @class DependencyRegistry
 * @constructor
 */
var DependencyRegistry = (function () {
    function DependencyRegistry() {
        /**
         * A mapping of id to dependency for the attached entity's direct dependencies.
         */
        this.ownDependencies = {};
        /**
         * A mapping of id to dependency for all of the attached entity's dependencies.
         */
        this.dependencies = {};
    }
    /**
     * Return array of dependencies referenced directly by this entity.
     * @returns Dependencies, keyed by asset ID and containing reference counts.
     */
    DependencyRegistry.prototype.getOwnDependencies = function () {
        var _this = this;
        return Object.keys(this.ownDependencies).map(function (id) { return _this.engine.getEntityById(id); })
            .filter(function (entity) { return entity; });
    };
    /**
     * Return dictionary of dependencies referenced directly by this entity, keyed by ID.
     * is an object that contains the dependency's ID and reference count.
     * @returns Dependencies, Objects containing asset ID and reference counts.
     */
    DependencyRegistry.prototype.getOwnDependencyInfo = function () {
        return this.ownDependencies;
    };
    /**
     * Return an array of entities that this entity is dependent on. e.g. materials, textures,
     * geometry, animations, etc. as well as any dependencies of those entities. i.e. this list
     * contains everything needed to fully load this entity.
     * @param predicate A function which returns 'true' or 'false'. Used to determine
     * which dependencies to return.
     * @returns         An array of entities that this entity is dependent on.
     */
    DependencyRegistry.prototype.getDependencies = function (predicate) {
        var _this = this;
        var all = typeof predicate !== 'function';
        return Object.keys(this.dependencies)
            .map(function (id) { return _this.engine.getEntityById(id); })
            .filter(function (entity) {
            return all || predicate(entity);
        });
    };
    /**
     * Return an array of entities of the given type that this entity is dependent
     * on as well as any dependencies of those entities.
     * @param type  The entity type of the dependencies to return.
     * @returns     An array of entities that this entity is dependent on.
     */
    DependencyRegistry.prototype.getDependenciesByClass = function (type) {
        return this.getDependencies(function (entity) { return entity instanceof type; });
    };
    /**
     * Return an array of entities of the given type that this entity is dependent
     * on as well as any dependencies of those entities.
     * @param type  The entity type of the dependencies to return.
     * @returns     An array of entities that this entity is dependent on.
     */
    DependencyRegistry.prototype.getDependenciesByType = function (type) {
        return this.getDependencies(function (entity) { return entity.type === type; });
    };
    /**
     * Return dictionary of all dependencies of this entity, keyed by ID.
     * Each entry is an object that contains the reference count.
     * @returns Objects containing asset ID and reference count for each dependency.
     */
    DependencyRegistry.prototype.getDependencyInfo = function () {
        return this.dependencies;
    };
    /**
     * Register the given entity as being a dependency of this entity as well as the parent
     * asset, if any. A count is maintained to track the number of times a given entity is referenced
     * by this entity. This allows easy calculation of data size of an asset or individual object.
     * Registering a dependency on an object that is already a dependency of another will
     * automatically register it with that entity as well.
     * @param entityId The id of the entity to register
     */
    DependencyRegistry.prototype.registerDependencyById = function (entityId) {
        this.registerDependency(this.engine.getEntityById(entityId));
    };
    /**
     * Register the given entity as being a dependency of this entity. A count is maintained
     * to track the number of times a given entity is referenced
     * by this entity. This allows easy calculation of data size of an asset or individual object.
     * Registering a dependency on an object that is already a dependency of another will
     * automatically register it with that entity as well.
     * @param entity The entity to register
     */
    DependencyRegistry.prototype.registerDependency = function (entity) {
        var _this = this;
        // Register the dependency with this entity
        // Register the dependency as a sub-dependency of our parent asset
        if (!entity) {
            Logger_1.default.warn('Trying to register invalid entity as a dependency.');
            return;
        }
        var dependencies = this.getOwnDependencyInfo();
        var entityId = entity.id;
        if (!dependencies[entityId]) {
            dependencies[entityId] = {
                count: 1
            };
            // Listen to:
            // A change of state on an 'own' dependency
            // A change in referenced dependencies of an 'own' dependency
            // Bind to dependency changes on this entity so that we can register or unregister
            // sub dependencies as needed.
            dependencies[entityId].onSubDependencyChange = function (newAssetId, oldAssetId) {
                if (!dependencies[entityId]) {
                    return;
                }
                for (var j = 0; j < dependencies[entityId].count; j++) {
                    if (newAssetId) {
                        _this.registerSubDependencyById(newAssetId);
                    }
                    if (oldAssetId) {
                        _this.unregisterSubDependencyById(oldAssetId);
                    }
                }
            };
            if (this instanceof BaseEntity_1.default) {
                if (!this.isUnloaded() && entity.isUnloaded()) {
                    entity.load();
                }
                // When each dependency is loaded, check if we're done and mark dependencies as
                // finished if we are done.
                this.listenTo(entity, 'loadStateChange', this.updateDependencyState);
                this.updateDependencyState(entity);
            }
            entity.on('change:dependency', dependencies[entityId].onSubDependencyChange, this);
        }
        else {
            dependencies[entityId].count++;
        }
        // Register all the current dependencies of the new entity with this entity.
        var subDependencies = entity.getDependencyInfo();
        Object.keys(subDependencies).forEach(function (id) {
            var dep = subDependencies[id];
            for (var i = 0; i < dep.count; i++) {
                _this.registerSubDependencyById(id);
            }
        });
        this.registerSubDependencyById(entityId);
    };
    /**
     * Unregister the given asset as being a dependency of this asset.
     * @param entityId The id of the entity to unregister
     */
    DependencyRegistry.prototype.unregisterDependencyById = function (entityId) {
        this.unregisterDependency(this.engine.getEntityById(entityId));
    };
    /**
     * Unregister the given asset as being a dependency of this asset.
     * @param asset The entity to unregister
     */
    DependencyRegistry.prototype.unregisterDependency = function (entity) {
        var _this = this;
        if (!entity) {
            return;
        }
        var entityId = entity.id;
        var ownDependencies = this.getOwnDependencyInfo();
        var dependency = ownDependencies[entityId];
        if (dependency) {
            // Decrement the reference count for this material
            dependency.count--;
            // If this material is no longer referenced, remove it completely.
            if (dependency.count === 0) {
                delete ownDependencies[entityId];
                // Unbind the event callback for texture changes on this material
                entity.off('change:dependency', dependency.onSubDependencyChange, this);
                this.stopListening(entity, 'loadStateChange', this.updateDependencyState);
                // If the removal of this dependency can cause a change in state for this entity,
                // make the state change.
                if (!entity.isLoaded()) {
                    if (this.checkIfOwnDependenciesLoaded()) {
                        this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Succeeded);
                    }
                }
                else if (!entity.isUnloaded()) {
                    if (this.checkIfOwnDependenciesUnloaded() && this.getOwnDependencies().length) {
                        this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Pending);
                    }
                }
            }
            // Unregister all the current dependencies of the entity from this entity
            var dependencies_1 = entity.getDependencyInfo();
            Object.keys(dependencies_1).forEach(function (id) {
                var dep = dependencies_1[id];
                for (var i = 0; i < dep.count; i++) {
                    _this.unregisterSubDependencyById(id);
                }
            });
            this.unregisterSubDependencyById(entityId);
        }
    };
    /**
     * Load only the dependencies for this entity. These are all the textures,
     * materials, geometries, animations, etc. that are referenced by this entity.
     * This also includes dependencies of dependencies.
     * @param callback callback function
     */
    DependencyRegistry.prototype.loadDependencies = function (callback) {
        var _this = this;
        if (this instanceof BaseEntity_1.default) {
            if (typeof callback === 'function') {
                this.once('loadDependencies', callback, this);
            }
            // Only start loading the dependencies if they're not already loaded.
            if (!this.isDependenciesLoaded()) {
                this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.InProgress);
                var dependencies = this.getDependencyInfo();
                var dependencyKeys = Object.keys(dependencies);
                this.engine.loadEntities(dependencyKeys, function () {
                    if (_this.checkIfDependenciesLoaded()) {
                        _this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Succeeded);
                    }
                });
            }
        }
    };
    /**
     * Unregister all dependencies for this entity.
     */
    DependencyRegistry.prototype.unregisterDependencies = function () {
        var _this = this;
        var currentDependencies = this.getDependencyInfo();
        // Unregister existing dependencies
        Object.keys(currentDependencies).forEach(function (id) {
            // It's possible that the previous dependency being unregistered also caused this
            // dependency to be unregistered (e.g. a renderTexture that uses another texture) so
            // dep may not exist anymore.
            var dep = currentDependencies[id];
            if (!dep) {
                return;
            }
            var length = dep.count;
            for (var i = 0; i < length; i++) {
                _this.unregisterDependencyById(id);
            }
        }, this);
    };
    /**
     * Go through all registered dependencies and check if they're all loaded.
     * @returns True iff all registered dependencies are loaded.
     */
    DependencyRegistry.prototype.checkIfOwnDependenciesLoaded = function () {
        var dependencies = this.getOwnDependencies();
        return dependencies.every(function (dep) { return dep && dep.isLoaded(); });
    };
    /**
     * Go through all registered dependencies and check if they're all unloaded.
     * @returns True iff all registered dependencies are unloaded.
     */
    DependencyRegistry.prototype.checkIfOwnDependenciesUnloaded = function () {
        var dependencies = this.getOwnDependencies();
        return dependencies.every(function (dep) { return dep && dep.isUnloaded(); });
    };
    /**
     * Go through all registered dependencies and check if they're all loaded.
     * @returns True iff all registered dependencies are loaded.
     */
    DependencyRegistry.prototype.checkIfDependenciesLoaded = function () {
        var dependencies = this.getDependencies();
        return dependencies.every(function (dep) { return dep && dep.isLoaded(); });
    };
    /**
     * Register the given entity as being a sub dependency of this one. A sub dependency
     * is a dependency that is indirectly referenced by this entity (i.e. a dependency has its
     * own dependency).
     * @param entityId The id of the entity to register
     */
    DependencyRegistry.prototype.registerSubDependencyById = function (entityId) {
        this.registerSubDependency(this.engine.getEntityById(entityId));
    };
    /**
     * Register the given entity as being a sub dependency of this one. A sub dependency
     * is a dependency that is indirectly referenced by this entity (i.e. a dependency has its
     * own dependency).
     * @param entity The entity to register
     */
    DependencyRegistry.prototype.registerSubDependency = function (entity) {
        if (!entity) {
            Logger_1.default.warn('Trying to register invalid entity as a sub-dependency.');
            return;
        }
        var entityId = entity.id;
        var dependency = this.dependencies[entityId];
        if (this instanceof BaseEntity_1.default) {
            if (!dependency) {
                this.dependencies[entityId] = { count: 1 };
            }
            else {
                dependency.count++;
            }
            // Inform entities referencing this entity as a dependency of the change
            this.trigger('change:dependency', entityId, null);
        }
    };
    /**
     * Given the state of the provided dependency, update the loading
     * state of this entity.
     * @param dependency The entity that this entity is dependent on.
     */
    DependencyRegistry.prototype.updateDependencyState = function (dependency) {
        if (dependency.isLoaded()) {
            if (this.checkIfOwnDependenciesLoaded()) {
                this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Succeeded);
                return;
            }
        }
        else if (dependency.isUnloaded()) {
            if (this.checkIfOwnDependenciesUnloaded()) {
                this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Pending);
                return;
            }
        }
        this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.InProgress);
    };
    /**
     * Unregister the given entity as being a sub dependency of this one. A sub dependency
     * is a dependency that is indirectly referenced by this entity (i.e. a dependency has its
     * own dependency).
     * @param entityId The id of the entity to unregister
     */
    DependencyRegistry.prototype.unregisterSubDependencyById = function (entityId) {
        this.unregisterSubDependency(this.engine.getEntityById(entityId));
    };
    /**
     * Unregister the given entity as being a sub dependency of this one. A sub dependency
     * is a dependency that is indirectly referenced by this entity (i.e. a dependency has its
     * own dependency).
     * @param entity The entity to unregister
     */
    DependencyRegistry.prototype.unregisterSubDependency = function (entity) {
        if (!entity) {
            return;
        }
        var entityId = entity.id;
        var dependency = this.dependencies[entityId];
        if (this instanceof BaseEntity_1.default) {
            if (dependency) {
                dependency.count--;
                if (dependency.count === 0) {
                    delete this.dependencies[entityId];
                }
                // Inform entities referencing this entity as a dependency of the change
                this.trigger('change:dependency', null, entityId);
            }
        }
    };
    return DependencyRegistry;
}());
;
exports.default = DependencyRegistry;


/***/ }),
/* 200 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var functions_1 = __webpack_require__(5);
var AnimationAsset_1 = __webpack_require__(49);
var ApplicationAsset_1 = __webpack_require__(34);
var AudioAsset_1 = __webpack_require__(50);
var BaseAsset_1 = __webpack_require__(6);
var BaseObject_1 = __webpack_require__(10);
var BoneObject_1 = __webpack_require__(66);
var BufferAsset_1 = __webpack_require__(20);
var CameraObject_1 = __webpack_require__(67);
var DracoGeometryAsset_1 = __webpack_require__(52);
var Engine_1 = __webpack_require__(116);
var ImageAsset_1 = __webpack_require__(35);
var LightObject_1 = __webpack_require__(37);
var MaterialAsset_1 = __webpack_require__(14);
var MeshObject_1 = __webpack_require__(26);
var MeshGeometryAsset_1 = __webpack_require__(53);
var NodeObject_1 = __webpack_require__(68);
var PrefabAsset_1 = __webpack_require__(54);
var PrimitiveGeometryAsset_1 = __webpack_require__(55);
var RenderTexture2DAsset_1 = __webpack_require__(56);
var RenderTextureCubeAsset_1 = __webpack_require__(57);
var SceneObject_1 = __webpack_require__(38);
var ScriptAsset_1 = __webpack_require__(58);
var ShaderAsset_1 = __webpack_require__(36);
var SkinAsset_1 = __webpack_require__(59);
var Texture2DAsset_1 = __webpack_require__(60);
var TextureCubeAsset_1 = __webpack_require__(61);
var VideoAsset_1 = __webpack_require__(24);
/**
 * A mixin providing entity creation, cataloging and querying capabilities.
 */
var EntityCreation = (function () {
    function EntityCreation() {
    }
    /**
     * Create an animation asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created animation asset.
     */
    EntityCreation.prototype.createAnimation = function (properties, id) {
        return this.createEntityByClass(AnimationAsset_1.default, properties, id);
    };
    /**
     * Create an application asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created application asset.
     */
    EntityCreation.prototype.createApplication = function (properties, id) {
        return this.createEntityByClass(ApplicationAsset_1.default, properties, id);
    };
    /**
     * Create an audio asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created audio asset.
     */
    EntityCreation.prototype.createAudio = function (properties, id) {
        return this.createEntityByClass(AudioAsset_1.default, properties, id);
    };
    /**
     * Create a bone object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created bone object.
     */
    EntityCreation.prototype.createBone = function (properties, id) {
        return this.createEntityByClass(BoneObject_1.default, properties, id);
    };
    /**
     * Create a buffer asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created buffer asset.
     */
    EntityCreation.prototype.createBuffer = function (properties, id) {
        return this.createEntityByClass(BufferAsset_1.default, properties, id);
    };
    /**
     * Create a camera object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created camera object.
     */
    EntityCreation.prototype.createCamera = function (properties, id) {
        return this.createEntityByClass(CameraObject_1.default, properties, id);
    };
    /**
     * Create a Draco geometry asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created mesh geometry asset.
     */
    EntityCreation.prototype.createDracoGeometry = function (properties, id) {
        return this.createEntityByClass(DracoGeometryAsset_1.default, properties, id);
    };
    /**
     * Create an image asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created image asset.
     */
    EntityCreation.prototype.createImage = function (properties, id) {
        return this.createEntityByClass(ImageAsset_1.default, properties, id);
    };
    /**
     * Create a light object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created light object.
     */
    EntityCreation.prototype.createLight = function (properties, id) {
        return this.createEntityByClass(LightObject_1.default, properties, id);
    };
    /**
     * Create a material asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created material asset.
     */
    EntityCreation.prototype.createMaterial = function (properties, id) {
        return this.createEntityByClass(MaterialAsset_1.default, properties, id);
    };
    /**
     * Create a mesh object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created mesh object.
     */
    EntityCreation.prototype.createMesh = function (properties, id) {
        return this.createEntityByClass(MeshObject_1.default, properties, id);
    };
    /**
     * Create a mesh geometry asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created mesh geometry asset.
     */
    EntityCreation.prototype.createMeshGeometry = function (properties, id) {
        return this.createEntityByClass(MeshGeometryAsset_1.default, properties, id);
    };
    /**
     * Create an empty node object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created node object.
     */
    EntityCreation.prototype.createNode = function (properties, id) {
        return this.createEntityByClass(NodeObject_1.default, properties, id);
    };
    /**
     * Create an empty scene object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created scene object.
     */
    EntityCreation.prototype.createScene = function (properties, id) {
        return this.createEntityByClass(SceneObject_1.default, properties, id);
    };
    /**
     * Create a prefab asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created prefab asset.
     */
    EntityCreation.prototype.createPrefab = function (properties, id) {
        return this.createEntityByClass(PrefabAsset_1.default, properties, id);
    };
    /**
     * Create a primitive geometry asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created primitive geometry asset.
     */
    EntityCreation.prototype.createPrimitiveGeometry = function (properties, id) {
        return this.createEntityByClass(PrimitiveGeometryAsset_1.default, properties, id);
    };
    /**
     * Create a 2D render texture asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created render texture 2d asset.
     */
    EntityCreation.prototype.createRenderTexture2d = function (properties, id) {
        return this.createEntityByClass(RenderTexture2DAsset_1.default, properties, id);
    };
    /**
     * Create a cube render texture asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created render texture cube asset.
     */
    EntityCreation.prototype.createRenderTextureCube = function (properties, id) {
        return this.createEntityByClass(RenderTextureCubeAsset_1.default, properties, id);
    };
    /**
     * Create a script asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created script asset.
     */
    EntityCreation.prototype.createScript = function (properties, id) {
        return this.createEntityByClass(ScriptAsset_1.default, properties, id);
    };
    /**
     * Create a shader asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created shader asset.
     */
    EntityCreation.prototype.createShader = function (properties, id) {
        return this.createEntityByClass(ShaderAsset_1.default, properties, id);
    };
    /**
     * Create a skin asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created skin asset.
     */
    EntityCreation.prototype.createSkin = function (properties, id) {
        return this.createEntityByClass(SkinAsset_1.default, properties, id);
    };
    /**
     * Create a 2D texture asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created 2d texture asset.
     */
    EntityCreation.prototype.createTexture2d = function (properties, id) {
        return this.createEntityByClass(Texture2DAsset_1.default, properties, id);
    };
    /**
     * Create a cube texture asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created cube texture asset.
     */
    EntityCreation.prototype.createTextureCube = function (properties, id) {
        return this.createEntityByClass(TextureCubeAsset_1.default, properties, id);
    };
    /**
     * Create a video asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created video asset.
     */
    EntityCreation.prototype.createVideo = function (properties, id) {
        return this.createEntityByClass(VideoAsset_1.default, properties, id);
    };
    /**
     * Create an entity with the defined type.
     * @param id    The ID for the new entity.
     * @param type  The type for the entity
     * @returns     The newly created entity.
     */
    EntityCreation.prototype.createEntityByClass = function (entityClass, properties, id) {
        if (!(this instanceof Engine_1.default)) {
            throw new Error('EntityCreation must be mixed with Engine to be used');
        }
        return this.createEntity({ id: id, type: this.getClassType(entityClass), properties: properties });
    };
    /**
     * Creates a new entity from a JSON descriptor.
     * @param entityDef Entity definition of the form:
     *                  {
     *                    id: <string>,
     *                    type: <string>,
     *                    properties: <Object>
     *                    components: <Array>
     *                  }
     * @returns         The newly created entity.
     */
    EntityCreation.prototype.createEntity = function (entityDef) {
        var _this = this;
        if (!(this instanceof Engine_1.default)) {
            throw new Error('EntityCreation must be mixed with Engine to work');
        }
        var entityDesc = tslib_1.__assign({ type: 'node', properties: {}, components: [] }, functions_1.deepClone(entityDef));
        var id = this.entityDispatcher.dispatchCreatedEntity(entityDef.id, entityDesc.type);
        var entity = this.getEntityById(id);
        if (entity instanceof BaseAsset_1.default) {
            this.entityDispatcher.dispatchAttributeChanged(id, 'representations', entityDesc.representations || []);
        }
        else {
            this.entityDispatcher.dispatchChildChanged(id, entityDesc.children || []);
            this.entityDispatcher.dispatchAttributeChanged(id, 'parentId', entityDesc.parentId || null);
            this.entityDispatcher.dispatchAttributeChanged(id, 'prefabAssetId', entityDesc.prefabAssetId || null);
            this.entityDispatcher.dispatchAttributeChanged(id, 'prefabObjectId', entityDesc.prefabObjectId || null);
            this.entityDispatcher.dispatchAttributeChanged(id, 'prefabInstanceId', entityDesc.prefabInstanceId || null);
        }
        this.entityDispatcher.dispatchInitEntity(id);
        this.entityDispatcher.dispatchPropertiesChanged(id, entityDesc.properties);
        entityDesc.components.forEach(function (compDesc) {
            return _this.entityDispatcher.dispatchComponentAdded(id, compDesc);
        });
        if (entityDesc.sid) {
            this.entityDispatcher.dispatchAttributeChanged(id, 'sid', entityDesc.sid || '');
        }
        this.trigger('entityCreated', entity);
        return this.getEntityById(id);
    };
    /**
     * Deletes the asset and its hierarchy from the project.
     * Force-unloads the asset, if it is loaded.
     * @param assetId The ID of the asset to destroy
     */
    EntityCreation.prototype.destroyAssetById = function (assetId) {
        if (!(this instanceof Engine_1.default)) {
            throw new Error('EntityCreation must be mixed with Engine to work');
        }
        var asset = this.getAssetById(assetId);
        this.destroyAsset(asset);
    };
    /**
     * Deletes the asset and its hierarchy from the project.
     * Force-unloads the asset, if it is loaded.
     * @param asset The BaseAsset to destroy
     */
    EntityCreation.prototype.destroyAsset = function (asset) {
        var _this = this;
        if (!asset || !(asset instanceof BaseAsset_1.default)) {
            throw new Error('destroyAsset : You must specify a valid asset to destroy.');
        }
        asset.unload();
        if (asset instanceof PrefabAsset_1.default) {
            var rootObject = asset.getRootObject();
            if (rootObject) {
                var objects = rootObject.getDescendants();
                objects.forEach(function (obj) {
                    _this.destroyObject(obj);
                });
                rootObject.destroy();
            }
        }
        this.entityDispatcher.dispatchDestroyedEntity(asset.id);
    };
    /**
     * Deletes the object and its hierarchy from this asset.
     * @param objectId The ID of the object to destroy
     */
    EntityCreation.prototype.destroyObjectById = function (objectId) {
        if (!(this instanceof Engine_1.default)) {
            throw new Error('EntityCreation must be mixed with Engine to work');
        }
        var object = this.getObjectById(objectId);
        this.destroyObject(object);
    };
    /**
     * Deletes the object and removes it from a hierarchy, if it was part of one.
     * @param object The BaseObject to destroy
     */
    EntityCreation.prototype.destroyObject = function (object) {
        if (!object || !(object instanceof BaseObject_1.default)) {
            throw new Error('destroyObject : You must specify a valid object to destroy.');
        }
        var parent = object.getParentObject();
        if (parent) {
            parent.removeChild(object);
        }
        this.entityDispatcher.dispatchDestroyedEntity(object.id);
    };
    return EntityCreation;
}());
exports.default = EntityCreation;


/***/ }),
/* 201 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Logger_1 = __webpack_require__(3);
var uuid_1 = __webpack_require__(18);
var functions_1 = __webpack_require__(5);
var globalEvents_1 = __webpack_require__(47);
var typeGuard_1 = __webpack_require__(184);
var EntityUpdatePackage_1 = __webpack_require__(203);
/**
 * EntityDispatcher handles dispatching entity changes between running engine instances
 * and external applications. EntityDispatcher can be created and passed to a multiple engine
 * instances, allowing multiple engines to share the same entity list.
 */
var EntityDispatcher = (function () {
    function EntityDispatcher() {
        /** List of Engines currently registered with this dispatcher. */
        this.engines = [];
        /** List of all entities registered. All engines share the same list of entities. */
        this.entities = {};
    }
    /**
     * Registers a new engine instance with the EntityDispatcher. This allows the engine
     * to receive entity updates, including property changes, added entities, etc.
     * @param {Object} newEngine A reference to the engine to register.
     */
    EntityDispatcher.prototype.addEngine = function (newEngine) {
        if (!newEngine) {
            return;
        }
        if (this.engines.indexOf(newEngine) === -1) {
            var entities = this.getEntityDescriptors();
            entities.forEach(function (desc) { return newEngine.registerEntity(desc); });
            // FIXME: Using as any to bypass protected on BaseEntity (evil)
            // Should we increase the visibility of initialize? Or is this an okay
            // workaround?
            entities.forEach(function (desc) { return newEngine.getEntityById(desc.id).initialize(); });
            entities.forEach(function (desc) {
                return newEngine.getEntityById(desc.id).trigger('change:properties', desc.properties);
            });
            entities.forEach(function (desc) {
                return newEngine.trigger('entityCreated', newEngine.getEntityById(desc.id));
            });
            this.engines.push(newEngine);
        }
        else {
            Logger_1.default.warn('The engine, ' + newEngine.getName() + ', has already been registered.');
        }
    };
    /**
     * Unregisters an engine instance from the EntityDispatcher. This will cut off the engine
     * from receiving entity updates, including property changes, added entities, etc.
     * @param {Object} engine A reference to the engine to unregister.
     */
    EntityDispatcher.prototype.removeEngine = function (engine) {
        var index;
        if (!engine) {
            return;
        }
        index = this.engines.indexOf(engine);
        if (index !== -1) {
            var removedEngine = this.engines.splice(index, 1);
            // If this was the last engine, force loss of WebGL context for this canvas.
            var threeRenderer = removedEngine[0].getThreeRenderer();
            if (this.engines.length === 0 && threeRenderer && threeRenderer.extensions.get('WEBGL_lose_context')) {
                threeRenderer.forceContextLoss();
            }
        }
        else {
            Logger_1.default.warn('The engine, ' + engine.getName() + ' isn\'t currently registered.');
        }
    };
    /**
     * Adds the given entities to all registered engines.
     * @method addEntities
     * @protected
     * @param {Array} entities Array of new entity descriptors
     * @return {Array}
     */
    EntityDispatcher.prototype.addEntities = function (entityArray) {
        var _this = this;
        // Filter out duplicate entities
        var newEntities = entityArray.filter(function (entityDesc) { return !_this.entities[entityDesc.id]; });
        // Create the entity object in each engine
        newEntities.forEach(function (entityDesc) {
            entityDesc.id = _this.dispatchCreatedEntity(entityDesc.id, entityDesc.type);
            if (entityDesc.sid) {
                _this.dispatchAttributeChanged(entityDesc.id, 'sid', entityDesc.sid || '');
            }
            if (typeGuard_1.isAsset(entityDesc) && entityDesc.representations) {
                _this.dispatchAttributeChanged(entityDesc.id, 'representations', entityDesc.representations || []);
            }
            else if (typeGuard_1.isObject(entityDesc)) {
                if (entityDesc.parentId) {
                    _this.dispatchAttributeChanged(entityDesc.id, 'parentId', entityDesc.parentId || null);
                }
                if (entityDesc.prefabAssetId) {
                    _this.dispatchAttributeChanged(entityDesc.id, 'prefabAssetId', entityDesc.prefabAssetId);
                }
                if (entityDesc.prefabObjectId) {
                    _this.dispatchAttributeChanged(entityDesc.id, 'prefabObjectId', entityDesc.prefabObjectId);
                }
                if (entityDesc.prefabInstanceId) {
                    _this.dispatchAttributeChanged(entityDesc.id, 'prefabInstanceId', entityDesc.prefabInstanceId);
                }
            }
        });
        // Initialize the entity in each engine
        newEntities.forEach(function (entityDesc) { return _this.dispatchInitEntity(entityDesc.id); });
        // Set the initial properties of the entity in each engine.
        newEntities.forEach(function (entityDesc) {
            return _this.dispatchPropertiesChanged(entityDesc.id, entityDesc.properties || {});
        });
        // Add the initial components of the entity in each engine.
        newEntities.forEach(function (entityDesc) {
            if (!entityDesc.components) {
                return;
            }
            entityDesc.components.forEach(function (compDesc) {
                return _this.dispatchComponentAdded(entityDesc.id, compDesc);
            });
        });
        // Set the initial children
        newEntities.forEach(function (entityDesc) {
            if (typeGuard_1.isObject(entityDesc)) {
                _this.dispatchChildChanged(entityDesc.id, entityDesc.children || []);
            }
        });
        newEntities.forEach(function (entityDesc) {
            return _this.engines.forEach(function (engine) {
                return engine.trigger('entityCreated', engine.getEntityById(entityDesc.id));
            });
        });
        return newEntities;
    };
    /**
     * Return direct references to all entity descriptors. These are shared
     * for each entity across engine instances.
     * @method getEntityDescriptors
     * @public
     * @return {Array} Array of json descriptors for all entities.
     */
    EntityDispatcher.prototype.getEntityDescriptors = function () {
        var _this = this;
        return Object.keys(this.entities).map(function (id) { return _this.entities[id]; });
    };
    /**
     * Initialize the entity with the given ID
     * @method dispatchInitEntity
     * @public
     * @param {string} entityId ID of the entity to initialize
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchInitEntity = function (entityId) {
        // Initialize objects
        this.engines.forEach(function (engine) {
            var entity = engine.getEntityById(entityId);
            if (entity) {
                // FIXME: Using as any to bypass protected on BaseEntity (evil) see other
                // fixme in this file.
                entity.initialize();
            }
        });
    };
    /**
     * Create a new entity using the given entity description
     * @method dispatchCreatedEntity
     * @public
     * @param  {Object} jsonDescriptor Description of the entity.
     * @return {string} The unique ID for the new entity.
     */
    EntityDispatcher.prototype.dispatchCreatedEntity = function (entityId, type) {
        if (this.entities[entityId]) {
            return entityId;
        }
        // If an ID hasn't been given or the ID is already in use, generate a new one.
        var id = !entityId ? uuid_1.v4() : entityId;
        var desc = {
            id: id,
            sid: id,
            type: type,
            properties: {},
            previousProperties: {},
            components: [],
            previousComponents: []
        };
        this.entities[desc.id] = desc;
        this.fireExternalUpdate(id, desc, 'createEntity');
        // Apply changes in each engine
        // Register object
        this.engines.forEach(function (engine) { return engine.registerEntity(desc); });
        return id;
    };
    /**
     * Delete an entity from all engine instances.
     * @method dispatchDestroyedEntity
     * @public
     * @param  {String} entityId Id of the entity to delete.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchDestroyedEntity = function (entityId) {
        if (!this.entities[entityId]) {
            Logger_1.default.error('Can\'t destroy an entity with ID, ' + entityId + ', that doesn\'t exist.');
            return;
        }
        this.fireExternalUpdate(entityId, {}, 'destroyEntity');
        // Apply changes in each engine
        this.engines.forEach(function (engine) { return engine.unregisterEntityById(entityId); });
        delete this.entities[entityId];
    };
    /**
     * Change an attribute on an entity in all engine instances.
     * @param entityId The ID of the entity to change.
     * @param attrib The name of the attribute to change.
     * @param value The new value of the attribute.
     */
    EntityDispatcher.prototype.dispatchAttributeChanged = function (entityId, attrib, value) {
        if (!this.entities[entityId]) {
            return;
        }
        var json = this.entities[entityId];
        json[attrib] = value;
        this.fireExternalUpdate(entityId, json);
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            entityToChange.trigger('change:' + attrib, value);
        });
    };
    /**
     * Change a property on an entity in all engine instances.
     * @param entityId The ID of the entity to change.
     * @param property The name of the property to change.
     * @param value The new value of the property.
     * @param silent Optionally make the call silent so that it doesn't inform each engine of the change.
     */
    EntityDispatcher.prototype.dispatchPropertyChanged = function (entityId, property, value, silent) {
        var propertyDescriptor = {};
        propertyDescriptor[property] = value;
        this.dispatchPropertiesChanged(entityId, propertyDescriptor, silent);
    };
    /**
     * Change properties on an entity in all engine instances.
     * @param entityId The ID of the entity to change.
     * @param newProperties The properties to change.
     * @param silent Optionally make the call silent so that it doesn't inform each engine of the change.
     */
    EntityDispatcher.prototype.dispatchPropertiesChanged = function (entityId, newProperties, silent) {
        if (newProperties === void 0) { newProperties = {}; }
        if (!this.entities[entityId]) {
            return;
        }
        var json = this.entities[entityId];
        Object.keys(newProperties).forEach(function (property) {
            json.previousProperties[property] = functions_1.deepClone(json.properties[property]);
            json.properties[property] = functions_1.deepClone(newProperties[property]);
        });
        this.fireExternalUpdate(entityId, { properties: json.properties });
        if (silent) {
            return;
        }
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            if (!entityToChange) {
                return;
            }
            Object.keys(json.properties).forEach(function (id) {
                var value = json.properties[id];
                entityToChange.trigger('change:properties.' + id, value);
            });
            entityToChange.trigger('change:properties', newProperties);
        });
    };
    /**
     * Inform all engines that a child was added to the specified entity.
     * @method dispatchChildAdded
     * @public
     * @param {string} entityId The ID of the entity to add the child to.
     * @param {string} newChildId The ID of the new child entity
     * @param {boolean} silent Suppress change event. Defaults to false.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchChildAdded = function (entityId, newChildId, silent) {
        var entityDesc = this.entities[entityId];
        if (!entityDesc) {
            return;
        }
        var children = entityDesc.children = entityDesc.children || [];
        entityDesc.previousChildren = entityDesc.children.slice();
        entityDesc.children.push(newChildId);
        this.fireExternalUpdate(entityId, { children: children });
        if (silent) {
            return;
        }
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            var childArray = [engine.getObjectById(newChildId)];
            entityToChange.trigger('change:children', childArray, []);
        });
    };
    /**
     * Inform all engines that a child was removed from the specified entity.
     * @method dispatchChildRemoved
     * @public
     * @param {string} entityId The ID of the entity to remove the child from.
     * @param {string} childToRemoveId The ID of the child entity to remove
     * @param {boolean} silent Suppress change event. Defaults to false.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchChildRemoved = function (entityId, childToRemoveId, silent) {
        var entityDesc = this.entities[entityId];
        if (!entityDesc) {
            return;
        }
        var children = entityDesc.children = entityDesc.children || [];
        entityDesc.previousChildren = entityDesc.children.slice();
        var index = entityDesc.children.indexOf(childToRemoveId);
        if (index !== -1) {
            entityDesc.children.splice(index, 1);
        }
        this.fireExternalUpdate(entityId, { children: children });
        if (silent) {
            return;
        }
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            var childArray = [engine.getObjectById(childToRemoveId)];
            entityToChange.trigger('change:children', [], childArray);
        });
    };
    /**
     * Inform all engines of child entities that were added and removed from
     * the specified entity.
     * @method dispatchChildChanged
     * @public
     * @param {string} entityId The ID of the parent entity
     * @param {array} addedChildren Array of child ID's that have been added.
     * @param {array} removedChildren Array of child ID's that have been removed.
     * @param {boolean} [silent] Suppress change event. Defaults to false.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchChildChanged = function (entityId, newChildren, silent) {
        var _this = this;
        if (newChildren === void 0) { newChildren = []; }
        var entityDesc = this.entities[entityId];
        if (!entityDesc) {
            return;
        }
        entityDesc.previousChildren = entityDesc.children ? entityDesc.children.slice() : [];
        var children = entityDesc.children = newChildren.slice();
        this.fireExternalUpdate(entityId, { children: children });
        if (silent) {
            return;
        }
        // Sort out a list of added and removed children to pass to each engine.
        var previousEntityMap = {};
        var newEntityMap = {};
        entityDesc.previousChildren.forEach(function (id) { return previousEntityMap[id] = _this.entities[id]; });
        children.forEach(function (id) { return newEntityMap[id] = _this.entities[id]; });
        var addedChildren = children.filter(function (id) {
            var entity = _this.entities[id];
            return entity && !previousEntityMap[id];
        });
        var removedChildren = entityDesc.previousChildren.filter(function (id) {
            var entity = _this.entities[id];
            return entity && !newEntityMap[id];
        });
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            // Translate the ID's to actual objects to pass to the engine.
            var addedObjs = addedChildren.map(function (id) { return engine.getObjectById(id); });
            var removedObjs = removedChildren.map(function (id) { return engine.getObjectById(id); });
            entityToChange.trigger('change:children', addedObjs, removedObjs);
        });
    };
    /**
     * Change a specified component with the given changes.
     * @method dispatchComponentChanged
     * @public
     * @param {string} entityId The ID of the entity that the change was made on.
     * @param {number} index The index of the component to change
     * @param {Object} componentChanges An object containing the values to change within the component
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchComponentChanged = function (entityId, index, componentChanges) {
        var entityDesc = this.entities[entityId];
        if (!entityDesc) {
            return;
        }
        var indexToChange = Math.min(Math.max(index, 0), entityDesc.components.length - 1);
        if (indexToChange < 0) {
            return;
        }
        if (!entityDesc.previousComponents) {
            entityDesc.previousComponents = [];
        }
        entityDesc.previousComponents[index] = functions_1.deepClone(entityDesc.components[index]);
        var componentDesc = entityDesc.components[indexToChange];
        // Figure out changes
        var changes = functions_1.deepClone(componentChanges);
        // Copy non-attributes
        Object.keys(changes).forEach(function (key) {
            if (key !== 'attributes') {
                componentDesc[key] = changes[key];
            }
        });
        // Copy attributes
        if (changes.attributes) {
            var attributes_1 = componentDesc.attributes || {};
            Object.keys(attributes_1).forEach(function (attribName) {
                // Delete the key if it has been set to undefined.
                if (changes.attributes.hasOwnProperty(attribName) &&
                    changes.attributes[attribName] === undefined) {
                    changes.attributes[attribName] = undefined;
                    delete attributes_1[attribName];
                }
            });
            Object.keys(changes.attributes).forEach(function (attribName) {
                attributes_1[attribName] = changes.attributes[attribName];
            });
        }
        this.fireExternalUpdate(entityId, { components: entityDesc.components });
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            entityToChange.trigger('change:component', indexToChange, changes);
        });
    };
    /**
     * Remove a component from the given entity and broadcast the change to all engines.
     * @method dispatchComponentRemoved
     * @public
     * @param {string} entityId The ID of the entity to remove the component from.
     * @param {number} index The index of the component in the components list.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchComponentRemoved = function (entityId, index) {
        var entityDesc = this.entities[entityId];
        if (!entityDesc && index >= entityDesc.components.length - 1) {
            return;
        }
        var indexToRemove = Math.min(Math.max(index, 0), entityDesc.components.length - 1);
        if (indexToRemove < 0) {
            return;
        }
        entityDesc.previousComponents = entityDesc.components ? entityDesc.components.slice() : [];
        entityDesc.components.splice(indexToRemove, 1);
        this.fireExternalUpdate(entityId, { components: entityDesc.components });
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            entityToChange.trigger('remove:component', indexToRemove);
        });
    };
    /**
     * Add a new component to the given entity and broadcast the change to all engines.
     * @method dispatchComponentAdded
     * @public
     * @param {string} entityId The ID of the entity to add the component to.
     * @param {Object} componentDesc Descriptor for the new component including id, attributes, etc.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchComponentAdded = function (entityId, componentDesc) {
        var entityDesc = this.entities[entityId];
        if (!entityDesc) {
            return;
        }
        entityDesc.previousComponents = entityDesc.components ? entityDesc.components.slice() : [];
        var addedComponent = functions_1.deepClone(componentDesc);
        addedComponent.id = addedComponent.id || uuid_1.v4();
        addedComponent.name = addedComponent.name || 'unnamed component';
        addedComponent.attributes = addedComponent.attributes || {};
        addedComponent.enabled = addedComponent.enabled !== false ? true : false;
        entityDesc.components.push(addedComponent);
        this.fireExternalUpdate(entityId, { components: entityDesc.components });
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            entityToChange.trigger('add:component', addedComponent);
        });
    };
    /**
     * Fire events for entity updates intended for external apps to listen to.
     * @method fireExternalUpdate
     * @private
     * @param {String} entityId       Id of the entity that changed.
     * @param {Object} jsonDescriptor Description of what changed.
     * @param {String} [type] The type of change ('destroyEntity', 'createEntity', 'updateEntity')
     */
    EntityDispatcher.prototype.fireExternalUpdate = function (entityId, jsonDescriptor, type) {
        // TODO - create a pool of these objects to avoid allocating a new one each time?
        var updatePkg = new EntityUpdatePackage_1.default();
        updatePkg.type = type ? type : 'updateEntity';
        updatePkg.entityId = entityId;
        updatePkg.entityData = jsonDescriptor;
        globalEvents_1.default.trigger('EntityUpdates', updatePkg);
    };
    return EntityDispatcher;
}());
exports.default = EntityDispatcher;


/***/ }),
/* 202 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var AnimationAsset_1 = __webpack_require__(49);
var ApplicationAsset_1 = __webpack_require__(34);
var AudioAsset_1 = __webpack_require__(50);
var BaseAsset_1 = __webpack_require__(6);
var BoneObject_1 = __webpack_require__(66);
var BufferAsset_1 = __webpack_require__(20);
var CameraObject_1 = __webpack_require__(67);
var DocumentAsset_1 = __webpack_require__(76);
var DracoGeometryAsset_1 = __webpack_require__(52);
var ImageAsset_1 = __webpack_require__(35);
var LightObject_1 = __webpack_require__(37);
var MaterialAsset_1 = __webpack_require__(14);
var MeshObject_1 = __webpack_require__(26);
var MeshGeometryAsset_1 = __webpack_require__(53);
var NodeObject_1 = __webpack_require__(68);
var PrefabAsset_1 = __webpack_require__(54);
var PrimitiveGeometryAsset_1 = __webpack_require__(55);
var RenderTexture2DAsset_1 = __webpack_require__(56);
var RenderTextureCubeAsset_1 = __webpack_require__(57);
var SceneObject_1 = __webpack_require__(38);
var ScriptAsset_1 = __webpack_require__(58);
var ShaderAsset_1 = __webpack_require__(36);
var SkinAsset_1 = __webpack_require__(59);
var Texture2DAsset_1 = __webpack_require__(60);
var TextureCubeAsset_1 = __webpack_require__(61);
var VideoAsset_1 = __webpack_require__(24);
/**
 * A mixin providing entity creation, cataloging and querying capabilities.
 */
var EntityRegistry = (function () {
    function EntityRegistry() {
        /** The list of all objects registered */
        this.objects = {};
        /** The list of all assets registered */
        this.assets = {};
    }
    /**
     * Shutdown the entity registry, destroying all entities.
     */
    EntityRegistry.prototype.destroy = function () {
        var _this = this;
        this.getAssets().forEach(function (asset) { return _this.unregisterEntity(asset); });
        this.getObjects().forEach(function (object) { return _this.unregisterEntity(object); });
    };
    /**
     * Returns the first asset that is validated by the provided function.
     * @param predicate A function which returns 'true' or 'false', used to determine
     * which asset to return.
     * @returns         The first asset that matches the query
     */
    EntityRegistry.prototype.getAsset = function (predicate) {
        return this.getEntity(predicate, this.assets);
    };
    /**
     * Returns an array of assets that satisfy the given filter function.
     * @param [predicate] A function which returns 'true' or 'false'. Used to determine
     * which assets to return.
     * @returns           Array of assets that match the query
     */
    EntityRegistry.prototype.getAssets = function (predicate) {
        return this.getEntities(predicate, this.assets);
    };
    /**
     * Returns the asset with the provided Id.
     * @param assetId The ID of the asset
     * @returns       The asset or null if not found.
     */
    EntityRegistry.prototype.getAssetById = function (assetId) {
        return this.assets[assetId] || null;
    };
    /**
     * Returns the first asset with the provided name.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not built for high performance.
     * @param assetName The name of the asset
     * @returns         The asset, if found, or null if not found.
     */
    EntityRegistry.prototype.getAssetByName = function (assetName) {
        return this.getAsset(function (obj) { return obj.getName() === assetName; });
    };
    /**
     * Returns the assets with the provided name.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not built for high performance.
     * @param assetName The name of the asset
     * @returns         Array of matching assets
     */
    EntityRegistry.prototype.getAssetsByName = function (assetName) {
        return this.getAssets(function (obj) { return obj.getName() === assetName; });
    };
    /**
     * Returns the first asset with the provided type.
     * @param assetType The type of the asset
     * @returns         The first matching asset
     */
    EntityRegistry.prototype.getAssetByClass = function (assetType) {
        return this.getAsset(function (obj) { return obj instanceof assetType; });
    };
    /**
     * Returns the first asset with the provided type name.
     * @param assetType The type name of the asset
     * @returns         The first matching asset
     */
    EntityRegistry.prototype.getAssetByType = function (assetType) {
        return this.getAsset(function (obj) { return obj.type === assetType; });
    };
    /**
     * Returns the assets with the provided type.
     * @param assetType   The type of the asset
     * @returns           Array of matching assets
     */
    EntityRegistry.prototype.getAssetsByClass = function (assetType) {
        return this.getAssets(function (obj) { return obj instanceof assetType; });
    };
    /**
     * Returns the assets with the provided type name.
     * @param assetType The type name of the asset
     * @returns         Array of matching assets
     */
    EntityRegistry.prototype.getAssetsByType = function (assetType) {
        return this.getAssets(function (obj) { return obj.type === assetType; });
    };
    /**
     * Returns the first object that is validated by the provided function.
     * @param predicate A function which returns 'true' or 'false', used to determine
     * which object to return.
     * @returns         The first object that matches the query
     */
    EntityRegistry.prototype.getObject = function (predicate) {
        return this.getEntity(predicate, this.objects);
    };
    /**
     * Returns an array of objects that satisfy the given filter function.
     * @param [predicate] A function which returns 'true' or 'false'. Used to determine
     * which objects to return.
     * @returns           Array of objects that match the query
     */
    EntityRegistry.prototype.getObjects = function (predicate) {
        return this.getEntities(predicate, this.objects);
    };
    /**
     * Returns the object with the provided Id.
     * @param objectId  The ID of the object
     * @returns         The object or null if not found.
     */
    EntityRegistry.prototype.getObjectById = function (objectId) {
        return this.objects[objectId] || null;
    };
    /**
     * Returns the first object with the provided name.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not built for high performance.
     * @param objectName  The name of the object
     * @returns           The object, if found, or null if not found.
     */
    EntityRegistry.prototype.getObjectByName = function (objectName) {
        return this.getObject(function (obj) { return obj.getName() === objectName; });
    };
    /**
     * Returns the objects with the provided name.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not built for high performance.
     * @param objectName  The name of the object
     * @returns           Array of matching objects
     */
    EntityRegistry.prototype.getObjectsByName = function (objectName) {
        return this.getObjects(function (obj) { return obj.getName() === objectName; });
    };
    /**
     * Returns the first object with the provided type.
     * @param objectType  The type of the object
     * @returns           The first matching object
     */
    EntityRegistry.prototype.getObjectByClass = function (objectType) {
        return this.getObject(function (obj) { return obj instanceof objectType; });
    };
    /**
     * Returns the first object with the provided type.
     * @param objectType  The type of the object
     * @returns           The first matching object
     */
    EntityRegistry.prototype.getObjectByType = function (objectType) {
        return this.getObject(function (obj) { return obj.type === objectType; });
    };
    /**
     * Returns the objects with the provided type.
     * @param objectType  The type of the object
     * @returns           Array of matching objects
     */
    EntityRegistry.prototype.getObjectsByType = function (objectType) {
        return this.getObjects(function (obj) { return obj.type === objectType; });
    };
    /**
     * Returns all objects with the provided type.
     * @param type  The type of the object (e.g. SceneObject, BaseObject, etc.)
     * @returns           Array of matching objects
     */
    EntityRegistry.prototype.getObjectsByClass = function (type) {
        return this.getObjects(function (entity) { return entity instanceof type; });
    };
    /**
     * Returns the first entity that is selected by the provided function.
     * @param predicate A function which returns 'true' or 'false'. Used to determine
     * which entity to return.
     * @param [entities]  Optional dictionary of entities, keyed by ID, to search within.
     * @returns           The first entity that matches the query
     */
    EntityRegistry.prototype.getEntity = function (predicate, entities) {
        if (!entities) {
            return this.getAsset(predicate) || this.getObject(predicate);
        }
        var entityId = Object.keys(entities).find(function (id) { return predicate(entities[id]); });
        return entities[entityId];
    };
    /**
     * Returns all entities that are selected by the provided function.
     * @param [predicate] A function which returns 'true' or 'false'. Used to determine
     * which entities to return.
     * @param [entities]  Optional dictionary of entities, keyed by ID, to search within.
     * @returns           Array of entities that matches the query
     */
    EntityRegistry.prototype.getEntities = function (predicate, entities) {
        if (!entities) {
            return this.getObjects(predicate).concat(this.getAssets(predicate));
        }
        var all = typeof predicate !== 'function';
        return Object.keys(entities)
            .filter(function (id) {
            return all || predicate(entities[id]);
        })
            .map(function (id) { return entities[id]; });
    };
    /**
     * Returns the entity with the provided Id. This includes ALL entities,
     * both assets and objects
     * @param entityId  The ID of the entity.
     * @returns         The entity or null if not found.
     */
    EntityRegistry.prototype.getEntityById = function (entityId) {
        return this.assets[entityId] || this.objects[entityId] || null;
    };
    /**
     * Returns the first entity with the provided type.
     * @param type  The type of the entity
     * @returns     The first matching entity
     */
    EntityRegistry.prototype.getEntityByClass = function (type) {
        return this.getEntity(function (obj) { return obj instanceof type; });
    };
    /**
     * Returns the first entity with the provided type name.
     * @param type  The type of the entity
     * @returns     The first matching entity
     */
    EntityRegistry.prototype.getEntityByType = function (type) {
        return this.getEntity(function (obj) { return obj.type === type; });
    };
    /**
     * Returns all entities with the provided type.
     * @param type  The type of the entity (e.g. MaterialAsset, SceneObject, etc.)
     * @returns           Array of matching entities
     */
    EntityRegistry.prototype.getEntitiesByClass = function (type) {
        return this.getEntities(function (entity) { return entity instanceof type; });
    };
    /**
     * Returns all entities with the provided type name.
     * @param type  The name of the entity type (e.g. 'material', 'scene', etc.)
     * @returns     An array of matching entities
     */
    EntityRegistry.prototype.getEntitiesByType = function (type) {
        return this.getEntities(function (entity) { return entity.type === type; });
    };
    /**
     * Returns the first entity with the provided name.
     * @param name  The name of the entity
     * @returns     The entity, if found, or null if not found.
     */
    EntityRegistry.prototype.getEntityByName = function (name) {
        return this.getEntity(function (obj) { return obj.getName() === name; });
    };
    /**
     * Returns all entities with the provided name.
     * @param name  The name of the entity
     * @returns     An array of matching entities
     */
    EntityRegistry.prototype.getEntitiesByName = function (name) {
        return this.getEntities(function (entity) { return entity.getName() === name; });
    };
    /**
     * This is called to remove the entity from this engine only. The entity will
     * still be available to other running engine instances.
     * @param entityId The ID of the entity to unregister.
     */
    EntityRegistry.prototype.unregisterEntityById = function (entityId) {
        this.unregisterEntity(this.getEntityById(entityId));
    };
    /**
     * This is called to remove the object from this engine only. The entity will
     * still be available to other running engine instances.
     * @param object The object to unregister.
     */
    EntityRegistry.prototype.unregisterEntity = function (entity) {
        if (!entity) {
            return;
        }
        // FIXME: Cast as any to bypass function privacy
        entity.uninitialize();
        if (this.objects[entity.id]) {
            delete this.objects[entity.id];
        }
        else {
            entity.off('load', this.onAssetLoaded, this);
            entity.off('unload', this.onAssetUnloaded, this);
            delete this.assets[entity.id];
        }
    };
    /**
     * Returns the type name for the given entity type.
     * @param entityClass The class type of the entity.
     * @returns           The name of the type.
     */
    EntityRegistry.prototype.getClassType = function (entityClass) {
        switch (entityClass) {
            case AnimationAsset_1.default:
                return 'animation';
            case ApplicationAsset_1.default:
                return 'application';
            case AudioAsset_1.default:
                return 'audio';
            case BoneObject_1.default:
                return 'bone';
            case BufferAsset_1.default:
                return 'buffer';
            case CameraObject_1.default:
                return 'camera';
            case DocumentAsset_1.default:
                return 'document';
            case DracoGeometryAsset_1.default:
                return 'dracoGeometry';
            case ImageAsset_1.default:
                return 'image';
            case LightObject_1.default:
                return 'light';
            case MaterialAsset_1.default:
                return 'material';
            case MeshObject_1.default:
                return 'mesh';
            case MeshGeometryAsset_1.default:
                return 'meshGeometry';
            case NodeObject_1.default:
                return 'node';
            case PrefabAsset_1.default:
                return 'prefab';
            case PrimitiveGeometryAsset_1.default:
                return 'primitiveGeometry';
            case RenderTexture2DAsset_1.default:
                return 'renderTexture2D';
            case RenderTextureCubeAsset_1.default:
                return 'renderTextureCube';
            case SceneObject_1.default:
                return 'scene';
            case ScriptAsset_1.default:
                return 'script';
            case ShaderAsset_1.default:
                return 'shader';
            case SkinAsset_1.default:
                return 'skin';
            case Texture2DAsset_1.default:
                return 'texture2D';
            case TextureCubeAsset_1.default:
                return 'textureCube';
            case VideoAsset_1.default:
                return 'video';
            default:
                return null;
        }
    };
    /**
     * Returns the class for the given entity type.
     * @param type  The name of the entity type. e.g. 'scene', 'material', etc.
     * @returns     A reference to the entity class
     */
    EntityRegistry.prototype.getEntityClass = function (type) {
        if (EntityRegistry.entityNameTypeMap[type]) {
            return EntityRegistry.entityNameTypeMap[type];
        }
        return null;
    };
    /**
     * Internal method for registering a new entity. This is called in each engine instance
     * after calling createEntity().
     * @param jsonDesc Descriptor of new entity
     */
    EntityRegistry.prototype.registerEntity = function (jsonDesc) {
        var newEntity = new (this.getEntityClass(jsonDesc.type))(jsonDesc);
        // Bypass type checking because `this` does not type check as Engine due to
        // mixin.
        newEntity.engine = this;
        if (newEntity instanceof BaseAsset_1.default) {
            this.assets[newEntity.id] = newEntity;
            newEntity.on('load', this.onAssetLoaded, this);
            newEntity.on('unload', this.onAssetUnloaded, this);
        }
        else {
            this.objects[newEntity.id] = newEntity;
        }
    };
    /**
     * Called when each registered asset loads and triggers an engine-wide
     * event that can be listened to.
     * @param asset The asset that just loaded.
     */
    EntityRegistry.prototype.onAssetLoaded = function (asset) {
        // Bypass type checking because `this` does not type check as RuntimeEvents
        // due to mixin.
        this.trigger('assetLoaded', asset);
    };
    /**
     * Called when each registered asset unloads and triggers an engine-wide
     * event that can be listened to.
     * @param asset The asset that just unloaded.
     */
    EntityRegistry.prototype.onAssetUnloaded = function (asset) {
        this.trigger('assetUnloaded', asset);
    };
    return EntityRegistry;
}());
/** Mapping from type name to entity class */
EntityRegistry.entityNameTypeMap = {
    animation: AnimationAsset_1.default,
    application: ApplicationAsset_1.default,
    audio: AudioAsset_1.default,
    bone: BoneObject_1.default,
    buffer: BufferAsset_1.default,
    camera: CameraObject_1.default,
    document: DocumentAsset_1.default,
    dracoGeometry: DracoGeometryAsset_1.default,
    image: ImageAsset_1.default,
    light: LightObject_1.default,
    material: MaterialAsset_1.default,
    mesh: MeshObject_1.default,
    meshGeometry: MeshGeometryAsset_1.default,
    node: NodeObject_1.default,
    prefab: PrefabAsset_1.default,
    primitiveGeometry: PrimitiveGeometryAsset_1.default,
    renderTexture2D: RenderTexture2DAsset_1.default,
    renderTextureCube: RenderTextureCubeAsset_1.default,
    scene: SceneObject_1.default,
    script: ScriptAsset_1.default,
    shader: ShaderAsset_1.default,
    skin: SkinAsset_1.default,
    texture2D: Texture2DAsset_1.default,
    textureCube: TextureCubeAsset_1.default,
    video: VideoAsset_1.default
};
exports.default = EntityRegistry;


/***/ }),
/* 203 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var EntityUpdatePackage = (function () {
    function EntityUpdatePackage() {
        this.type = 'updateEntity';
        this.entityId = '';
        this.entityData = {};
    }
    return EntityUpdatePackage;
}());
exports.default = EntityUpdatePackage;


/***/ }),
/* 204 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var InputEvent = (function () {
    function InputEvent() {
    }
    return InputEvent;
}());
exports.default = InputEvent;


/***/ }),
/* 205 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var THREE = __webpack_require__(1);
var Box3DShaderParameters_1 = __webpack_require__(206);
var uberPBRVertexShader = __webpack_require__(228);
var uberPBRFragmentShader = __webpack_require__(227);
var box3DShaderPBR = {
    id: 'box3d_pbr_shader',
    type: 'shader',
    properties: {
        name: 'PBR Shader',
        vertexShader: uberPBRVertexShader,
        fragmentShader: uberPBRFragmentShader,
        parameters: Box3DShaderParameters_1.default,
        uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.common,
            THREE.UniformsLib.emissivemap,
            THREE.UniformsLib.bumpmap,
            THREE.UniformsLib.normalmap,
            THREE.UniformsLib.roughnessmap,
            THREE.UniformsLib.metalnessmap,
            THREE.UniformsLib.displacementmap,
            THREE.UniformsLib.fog,
            THREE.UniformsLib.lights,
            {
                time: { value: 1.0 },
                emissive: { value: new THREE.Color(0x000000) },
                specular: { value: new THREE.Color(0x111111) },
                roughness: { value: 0 },
                metalness: { value: 0 },
                clearCoat: { value: 0 },
                clearCoatRoughness: { value: 0 },
                envMapIntensity: { value: 1 }
            }
        ])
    }
};
exports.default = box3DShaderPBR;


/***/ }),
/* 206 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var THREE = __webpack_require__(1);
var shaderParameters = {
    // Diffuse
    albedoColor: {
        displayName: 'Base Albedo',
        description: 'A color to tint the material with.',
        type: 'c',
        default: { r: 1.0, g: 1.0, b: 1.0 },
        min: 0.0,
        max: 1.0,
        isUniform: true,
        uniformName: 'diffuse'
    },
    albedoMap: {
        displayName: 'Albedo Map',
        description: 'A texture that modifies the diffuse color of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        uniformName: 'map',
        enabledWhen: {
            albedoMap: {
                notEqualsDefault: true
            }
        }
    },
    // Transparency
    opacity: {
        displayName: 'Opacity',
        description: 'This option controls the total opacity of the material.',
        type: 'f',
        default: 1.0,
        min: 0.0,
        max: 1.0,
        isUniform: true,
        isRenderParam: true,
        transparency: 'LessThanOne'
    },
    alphaMap: {
        displayName: 'Alpha Map',
        description: 'A texture that stores the transparency info of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            alphaMap: {
                notEqualsDefault: true
            }
        }
    },
    // Specular
    specularColor: {
        displayName: 'Specular Color',
        description: 'A color to tint the material with.',
        type: 'c',
        default: { r: 1.0, g: 1.0, b: 1.0 },
        min: 0.0,
        max: 1.0,
        isUniform: true,
        uniformName: 'specular'
    },
    specularMap: {
        displayName: 'Specular Map',
        description: 'A texture that contains the specular color of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            specularMap: {
                notEqualsDefault: true
            }
        }
    },
    metalness: {
        displayName: 'Metalness',
        description: 'How metallic the surface appears (multiplied by the metalness texture).',
        type: 'f',
        min: 0.0,
        max: 1.0,
        default: 0.0,
        isUniform: true,
        enabledWhen: {
            metalness: {
                notEqualsDefault: true
            }
        }
    },
    metalnessMap: {
        displayName: 'Metalness Map',
        description: 'A texture that contains the metalness of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            metalnessMap: {
                notEqualsDefault: true
            }
        }
    },
    glossMap: {
        displayName: 'Gloss Map',
        description: 'A texture that stores the gloss info of the material.',
        type: 't',
        default: null,
        isUniform: true,
        enabledWhen: {
            glossMap: {
                notEqualsDefault: true
            },
            roughnessMap: {
                equalsDefault: true
            }
        }
    },
    roughness: {
        displayName: 'Roughness',
        description: 'How rough the surface appears.',
        type: 'f',
        min: 0.0,
        max: 1.0,
        default: 0.0,
        isUniform: true,
        isRenderParam: true
    },
    roughnessMap: {
        displayName: 'Roughness Map',
        description: 'A texture that stores the roughness info of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            roughnessMap: {
                notEqualsDefault: true
            }
        }
    },
    reflectivity: {
        displayName: 'Reflectivity',
        description: 'Reflectivity at normal incidence. i.e. when viewing the surface directly.',
        type: 'f',
        min: 0.0,
        max: 1.0,
        default: 0.02,
        isUniform: true,
        isRenderParam: true,
        uniformName: 'reflectivity'
    },
    normalMap: {
        displayName: 'Normal Map',
        description: '',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        derivatives: true,
        textureUsage: 'normal',
        enabledWhen: {
            normalMap: {
                notEqualsDefault: true
            }
        }
    },
    normalScale: {
        displayName: 'Normal Scale',
        description: 'blah',
        type: 'v2',
        default: { x: 1.0, y: 1.0 },
        isUniform: true,
        isRenderParam: true
    },
    bumpMap: {
        displayName: 'Bump Map',
        description: '',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        derivatives: true,
        textureUsage: 'bump',
        enabledWhen: {
            normalMap: {
                equalsDefault: true
            },
            bumpMap: {
                notEqualsDefault: true
            }
        }
    },
    bumpScale: {
        displayName: 'Bump Scale',
        description: 'blah',
        type: 'f',
        min: 0.0,
        max: 20.0,
        default: 1.0,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            normalMap: {
                equalsDefault: true
            },
            bumpMap: {
                notEqualsDefault: true
            }
        },
        displayWhen: {
            useBump: {
                equals: true
            }
        }
    },
    clearCoat: {
        displayName: 'Clear Coat',
        type: 'f',
        min: 0.0,
        max: 1.0,
        isUniform: true,
        isRenderParam: true,
        default: 0.0,
        enabledWhen: {
            clearCoat: {
                notEquals: 0
            }
        }
    },
    clearCoatRoughness: {
        displayName: 'Clear Coat',
        type: 'f',
        min: 0.0,
        max: 1.0,
        isUniform: true,
        isRenderParam: true,
        default: 0.0,
        enabledWhen: {
            clearCoat: {
                notEquals: 0
            }
        }
    },
    envMapRadiance: {
        displayName: 'Specular Light Map',
        description: 'A map that represents the surrounding environment. Used for' +
            ' reflections.',
        type: 't',
        default: null,
        isUniform: true,
        forceUpdate: true,
        enabledWhen: {
            envMapRadiance: {
                notEqualsDefault: true
            }
        }
    },
    envMapRadianceHalfGloss: {
        displayName: 'Specular Light Map',
        description: 'A cube-map that represents the surrounding environment. Used for' +
            ' reflections.',
        type: 't',
        textureType: 'Cube',
        default: null,
        isUniform: true,
        enabledWhen: {
            envMapIrradiance: {
                notEqualsDefault: true
            },
            envMapRadiance: {
                notEqualsDefault: true
            },
            envMapRadianceHalfGloss: {
                notEqualsDefault: true
            }
        }
    },
    envMapIrradiance: {
        displayName: 'Specular Light Map',
        description: 'A cube-map that represents the surrounding environment. Used for' +
            ' reflections.',
        type: 't',
        textureType: 'Cube',
        default: null,
        isUniform: true,
        enabledWhen: {
            envMapIrradiance: {
                notEqualsDefault: true
            }
        },
        displayWhen: {
            envMapIrradiance: {
                notEqualsDefault: true
            }
        }
    },
    envMapGlossVariance: {
        displayName: 'Environment Map Gloss Variance',
        description: 'Turn on multi-sampling of environment map based on ' +
            'varying glossiness of surface.',
        type: 'b',
        default: true,
        forceUpdate: true,
        enabledWhen: {
            envMapGlossVariance: {
                equals: true
            }
        }
    },
    emissiveColor: {
        displayName: 'Emissive Color',
        description: 'A color that represents the light emitted by the material.',
        type: 'c',
        default: { r: 0.0, g: 0.0, b: 0.0 },
        isUniform: true,
        isRenderParam: true,
        uniformName: 'emissive',
        enabledWhen: {
            emissiveColor: {
                notEqualsDefault: true
            }
        }
    },
    emissiveMap: {
        displayName: 'Emissive Map',
        description: 'A texture that modifies the emissive color of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            emissiveMap: {
                notEqualsDefault: true
            }
        }
    },
    aoMap: {
        displayName: 'AO Map',
        description: 'The ambient occlusion of the material.',
        type: 't',
        default: null,
        isUniform: true,
        enabledWhen: {
            aoMap: {
                notEqualsDefault: true
            }
        }
    },
    side: {
        displayName: 'Cull Mode',
        description: 'This controls which side of the geometry will be visible.',
        type: 'opt',
        isRenderParam: true,
        options: {
            frontOnly: THREE.FrontSide,
            backOnly: THREE.BackSide,
            doubleSided: THREE.DoubleSide
        },
        default: 'doubleSided'
    },
    fog: {
        displayName: 'Enable Fog',
        description: 'This controls whether this material is affected by fog or not.',
        isRenderParam: true,
        forceUpdate: true,
        type: 'b',
        default: true
    },
    depthFunc: {
        displayName: 'Depth Function',
        description: '',
        isRenderParam: true,
        type: 'opt',
        options: {
            never: THREE.NeverDepth,
            always: THREE.AlwaysDepth,
            lessThan: THREE.LessDepth,
            lessThanOrEqual: THREE.LessEqualDepth,
            equal: THREE.EqualDepth,
            greaterThanOrEqual: THREE.GreaterEqualDepth,
            greaterThan: THREE.GreaterDepth,
            notEqual: THREE.NotEqualDepth
        },
        default: 'lessThanOrEqual'
    },
    depthWrite: {
        displayName: 'Enable Depth Write',
        description: 'This controls whether the depth values of a mesh rendered with this' +
            ' material are recorded.',
        isRenderParam: true,
        type: 'b',
        default: true
    },
    depthTest: {
        displayName: 'Enable Depth Test',
        description: 'This controls whether a depth check is done before this material is' +
            ' rendered so that it can be occluded.',
        isRenderParam: true,
        type: 'b',
        default: true
    },
    blending: {
        displayName: 'Blending Mode',
        description: 'This controls how the material will be blended with the color behind it.',
        isRenderParam: true,
        type: 'opt',
        options: {
            none: THREE.NoBlending,
            normal: THREE.NormalBlending,
            additive: THREE.AdditiveBlending,
            subtractive: THREE.SubtractiveBlending,
            multiplicative: THREE.MultiplyBlending,
            custom: THREE.CustomBlending
        },
        default: 'normal',
        transparency: 'GreaterThanOne'
    },
    blendEquation: {
        displayName: 'Blending Equation',
        description: 'TODO.',
        isRenderParam: true,
        type: 'opt',
        options: {
            add: THREE.AddEquation,
            subtract: THREE.SubtractEquation,
            reverseSubtract: THREE.ReverseSubtractEquation,
            minimum: THREE.MinEquation,
            maximum: THREE.MaxEquation
        },
        default: 'add',
        displayWhen: {
            blending: {
                equals: 'custom'
            }
        }
    },
    blendSrc: {
        displayName: 'Blend Source',
        description: 'TODO.',
        isRenderParam: true,
        type: 'opt',
        options: {
            zero: THREE.ZeroFactor,
            one: THREE.OneFactor,
            sourceColor: THREE.SrcColorFactor,
            oneMinusSourceColor: THREE.OneMinusSrcColorFactor,
            sourceAlpha: THREE.SrcAlphaFactor,
            oneMinusSourceAlpha: THREE.OneMinusSrcAlphaFactor,
            destinationAlpha: THREE.DstAlphaFactor,
            oneMinusDestinationAlpha: THREE.OneMinusDstAlphaFactor
        },
        default: 'sourceAlpha',
        displayWhen: {
            blending: {
                equals: 'custom'
            }
        }
    },
    blendDst: {
        displayName: 'Blend Destination',
        description: 'TODO.',
        isRenderParam: true,
        type: 'opt',
        options: {
            zero: THREE.ZeroFactor,
            one: THREE.OneFactor,
            sourceColor: THREE.SrcColorFactor,
            oneMinusSourceColor: THREE.OneMinusSrcColorFactor,
            sourceAlpha: THREE.SrcAlphaFactor,
            oneMinusSourceAlpha: THREE.OneMinusSrcAlphaFactor,
            destinationAlpha: THREE.DstAlphaFactor,
            oneMinusDestinationAlpha: THREE.OneMinusDstAlphaFactor,
            destinationColor: THREE.DstColorFactor,
            oneMinusDestinationColor: THREE.OneMinusDstColorFactor,
            sourceAlphaSaturate: THREE.SrcAlphaSaturateFactor
        },
        default: 'one',
        displayWhen: {
            blending: {
                equals: 'custom'
            }
        }
    },
    useSeparateAlphaBlend: {
        displayName: 'Separate Blend for Alpha',
        description: 'TODO',
        type: 'b',
        default: false,
        displayWhen: {
            blending: {
                equals: 'custom'
            }
        }
    },
    blendEquationAlpha: {
        displayName: 'Alpha Blend Equation',
        description: 'TODO',
        isRenderParam: true,
        type: 'opt',
        options: {
            add: THREE.AddEquation,
            subtract: THREE.SubtractEquation,
            reverseSubtract: THREE.ReverseSubtractEquation,
            minimum: THREE.MinEquation,
            maximum: THREE.MaxEquation
        },
        default: 'add',
        displayWhen: {
            blending: {
                equals: 'custom'
            },
            useSeparateAlphaBlend: {
                equals: true
            }
        },
        enabledWhen: {
            useSeparateAlphaBlend: {
                equals: true
            }
        }
    },
    blendSrcAlpha: {
        displayName: 'Alpha Blend Source',
        description: 'TODO.',
        isRenderParam: true,
        type: 'opt',
        options: {
            zero: THREE.ZeroFactor,
            one: THREE.OneFactor,
            sourceColor: THREE.SrcColorFactor,
            oneMinusSourceColor: THREE.OneMinusSrcColorFactor,
            sourceAlpha: THREE.SrcAlphaFactor,
            oneMinusSourceAlpha: THREE.OneMinusSrcAlphaFactor,
            destinationAlpha: THREE.DstAlphaFactor,
            oneMinusDestinationAlpha: THREE.OneMinusDstAlphaFactor
        },
        default: 'sourceAlpha',
        displayWhen: {
            blending: {
                equals: 'custom'
            },
            useSeparateAlphaBlend: {
                equals: true
            }
        },
        enabledWhen: {
            useSeparateAlphaBlend: {
                equals: true
            }
        }
    },
    blendDstAlpha: {
        displayName: 'Alpha Blend Destination',
        description: 'TODO.',
        isRenderParam: true,
        type: 'opt',
        options: {
            zero: THREE.ZeroFactor,
            one: THREE.OneFactor,
            sourceColor: THREE.SrcColorFactor,
            oneMinusSourceColor: THREE.OneMinusSrcColorFactor,
            sourceAlpha: THREE.SrcAlphaFactor,
            oneMinusSourceAlpha: THREE.OneMinusSrcAlphaFactor,
            destinationAlpha: THREE.DstAlphaFactor,
            oneMinusDestinationAlpha: THREE.OneMinusDstAlphaFactor,
            destinationColor: THREE.DstColorFactor,
            oneMinusDestinationColor: THREE.OneMinusDstColorFactor,
            sourceAlphaSaturate: THREE.SrcAlphaSaturateFactor
        },
        default: 'one',
        displayWhen: {
            blending: {
                equals: 'custom'
            },
            useSeparateAlphaBlend: {
                equals: true
            }
        },
        enabledWhen: {
            useSeparateAlphaBlend: {
                equals: true
            }
        }
    },
    polygonOffset: {
        displayName: 'Polygon Offset',
        description: 'Turns on rendering with polygon offsets. This can be used to work' +
            ' around z-fighting.',
        isRenderParam: true,
        type: 'b',
        default: false
    },
    polygonOffsetFactor: {
        displayName: 'Polygon Offset Factor',
        description: 'Scales the maximum Z slope, with respect to X or Y of the polygon.',
        isRenderParam: true,
        type: 'f',
        default: 1.0
    },
    polygonOffsetUnits: {
        displayName: 'Polygon Offset Units',
        description: 'Scales the minimum resolvable depth buffer value.',
        isRenderParam: true,
        type: 'f',
        default: 1.0
    },
    alphaTest: {
        displayName: 'Alpha Test',
        description: 'Pixels with an alpha value below the given value will not be rendered.' +
            ' This value will only be used when this material\'s Transparency blending mode' +
            ' is set to "Masked"',
        isRenderParam: true,
        forceUpdate: true,
        type: 'f',
        default: 0.2,
        min: 0.0,
        max: 1.0,
        step: 0.001
    }
};
exports.default = shaderParameters;


/***/ }),
/* 207 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable no-string-literal */
var MaterialAsset_1 = __webpack_require__(14);
var BaseTextureAsset_1 = __webpack_require__(19);
/**
 * Utilities for managing material assets
 */
var MaterialUtilities = (function () {
    /**
     * Creates an instance of MaterialUtilities.
     * @param engine The engine instance that this is connected to.
     */
    function MaterialUtilities(engine) {
        this.engine = engine;
        /** An array of standin texture definitions keyed by the StandinTexture enum. */
        this.standInTextures = [];
        this.engine = engine;
        this.engine.on('rebuildMaterials', this.rebuildAll, this);
        this.engine.on('rendererResize', this.onResize, this);
        this.engine.on('update', this.update, this);
        this.standInTextures[MaterialAsset_1.StandInTexture.STANDIN_TEXTURE_WHITE] = {
            texture: null,
            color: [255, 255, 255]
        };
        this.standInTextures[MaterialAsset_1.StandInTexture.STANDIN_TEXTURE_WHITE_CUBE] = {
            texture: null,
            color: [255, 255, 255],
            type: 'Cube'
        };
        this.standInTextures[MaterialAsset_1.StandInTexture.STANDIN_TEXTURE_BLACK] = {
            texture: null,
            color: [0, 0, 0]
        };
        this.standInTextures[MaterialAsset_1.StandInTexture.STANDIN_TEXTURE_BLACK_CUBE] = {
            texture: null,
            color: [0, 0, 0],
            type: 'Cube'
        };
        this.standInTextures[MaterialAsset_1.StandInTexture.STANDIN_TEXTURE_NORMAL] = {
            texture: null,
            color: [127, 127, 255]
        };
    }
    /** Called to cleanup data used by the utilities */
    MaterialUtilities.prototype.destroy = function () {
        this.engine.off('rebuildMaterials', this.rebuildAll, this);
        this.engine.off('rendererResize', this.onResize, this);
        this.engine.off('update', this.update, this);
        this.standInTextures.forEach(function (standInTexture) {
            if (standInTexture.texture) {
                standInTexture.texture.dispose();
            }
        });
    };
    /**
     * Returns a material asset to be used in place of missing assets.
     * @returns The missing material.
     */
    MaterialUtilities.prototype.getMissingMaterial = function () {
        return this.engine.getAssetById('missingMaterial');
    };
    /**
     * Returns a texture intended to be used as a placeholder while another texture loads.
     * e.g. MaterialAsset.STANDIN_TEXTURE_NORMAL results in a 1x1 normal map and can allow a
     * material to render without artifacts while a full-res normal map loads.
     * @param texEnum Texture stand-in type. MaterialAsset.STANDIN_TEXTURE_WHITE, etc.
     * @returns       THREE.DataTexture or THREE.CubeTexture
     */
    MaterialUtilities.prototype.getStandInTexture = function (texEnum) {
        if (!this.standInTextures[texEnum]) {
            return null;
        }
        if (!this.standInTextures[texEnum].texture) {
            var color = this.standInTextures[texEnum].color;
            if (this.standInTextures[texEnum].type === 'Cube') {
                this.standInTextures[texEnum].texture =
                    BaseTextureAsset_1.default.createColorTextureCube(color[0], color[1], color[2]);
            }
            else {
                this.standInTextures[texEnum].texture =
                    BaseTextureAsset_1.default.createColorTexture(color[0], color[1], color[2]);
            }
        }
        return this.standInTextures[texEnum].texture;
    };
    /**
     * Called each frame to update shared material data
     * @param delta The time elapsed since the last tick.
     */
    MaterialUtilities.prototype.update = function (delta) {
        if (MaterialAsset_1.default.timeValueInUse) {
            this.engine.needsRender = true;
        }
        MaterialAsset_1.default.sharedUniforms['time'].value = delta;
    };
    /** Called to trigger all material assets to update their corresponding three.js data. */
    MaterialUtilities.prototype.rebuildAll = function () {
        var materials = this.engine.getAssetsByClass(MaterialAsset_1.default);
        materials.forEach(function (matAsset) {
            if (matAsset.runtimeData) {
                Object.keys(MaterialAsset_1.default.materialObjectTypes).forEach(function (matObjType) {
                    matAsset.runtimeData[matObjType].needsUpdate = true;
                });
            }
        });
    };
    /** Called when the resize event is triggered. This will update relevant material data. */
    MaterialUtilities.prototype.onResize = function () {
        var screenDimensions = MaterialAsset_1.default.sharedUniforms['screenDimensions'];
        screenDimensions.value.x = 0;
        screenDimensions.value.y = 0;
        var renderer = this.engine.getRenderer();
        if (renderer) {
            screenDimensions.value.z = renderer.getCanvasWidth();
            screenDimensions.value.w = renderer.getCanvasHeight();
        }
        else {
            screenDimensions.value.z = 128;
            screenDimensions.value.w = 128;
        }
    };
    return MaterialUtilities;
}());
exports.default = MaterialUtilities;


/***/ }),
/* 208 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1.0 }
    },
    vertexShader: [
        'varying vec2 vUv;',
        'void main() {',
        'vUv = uv;',
        'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
        '}'
    ].join('\n'),
    fragmentShader: [
        'uniform float opacity;',
        'uniform sampler2D tDiffuse;',
        'varying vec2 vUv;',
        'void main() {',
        'vec4 texel = texture2D( tDiffuse, vUv );',
        'gl_FragColor = opacity * texel;',
        '}'
    ].join('\n')
};


/***/ }),
/* 209 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var THREE = __webpack_require__(1);
/**
 * @class ShaderPass
 */
var ShaderPass = (function () {
    /**
     * Creates an instance of ShaderPass.
     * @param {ShaderPassDef} shader
     * @param {string} [textureId='tDiffuse'] The texture id.
     */
    function ShaderPass(shader, textureId) {
        if (textureId === void 0) { textureId = 'tDiffuse'; }
        /**
         * Whether or not this shader pass is enabled.
         * @type {boolean}
         */
        this.enabled = true;
        /**
         * Whether or not the buffer should be swapped.
         * @type {boolean}
         */
        this.needsSwap = true;
        /**
         * Whether or not to render to screen.
         * @type {boolean}
         */
        this.renderToScreen = false;
        /**
         * Whether or not to clear on render.
         * @type {boolean}
         */
        this.clear = false;
        this.textureId = textureId;
        this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
        this.material = new THREE.ShaderMaterial({
            blending: THREE.NormalBlending,
            transparent: true,
            uniforms: this.uniforms,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
        });
        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.scene = new THREE.Scene();
        this.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null);
        this.scene.add(this.quad);
        this.prevViewPort = new THREE.Vector4();
    }
    /**
     * Render the pass.
     *
     * @param {THREE.WebGLRenderer} renderer
     * @param {THREE.RenderTarget} writeBuffer
     * @param {THREE.Texture} readBuffer
     * @param {number} _delta
     *
     * @memberOf ShaderPass
     */
    ShaderPass.prototype.render = function (renderer, writeBuffer, readBuffer, _delta) {
        if (this.uniforms[this.textureId]) {
            this.uniforms[this.textureId].value = readBuffer;
        }
        this.quad.material = this.material;
        if (this.renderToScreen) {
            if (this.viewPort) {
                renderer.setViewport(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height);
            }
            if (this.clearColor || this.clearDepth) {
                renderer.clear(!!this.clearColor, !!this.clearDepth, false);
            }
            renderer.render(this.scene, this.camera);
        }
        else if (this.renderToTexture) {
            if (this.clearColor || this.clearDepth) {
                renderer.clear(this.clearColor, this.clearDepth, false);
            }
            renderer.render(this.scene, this.camera, this.renderToTexture);
        }
        else {
            renderer.render(this.scene, this.camera, writeBuffer, this.clear);
        }
    };
    /**
     * Dispose of any data which belongs to this pass.
     *
     * @memberOf ShaderPass
     */
    ShaderPass.prototype.dispose = function () {
        this.quad.geometry.dispose();
        this.quad = undefined;
        this.camera = undefined;
        this.scene = undefined;
        this.material.dispose();
        this.material = undefined;
        this.uniforms = undefined;
    };
    return ShaderPass;
}());
exports.default = ShaderPass;


/***/ }),
/* 210 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/**
 * @author miibond
 *
 * Unpack HDR texture in a variety of packing formats to full, 16-bit colour
 */

Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    uniforms: {
        tDiffuse: { type: 't', value: null },
        rgbmMultiplier: { type: 'f', value: 9.0 }
    },
    vertexShader: [
        'varying vec2 vUv;',
        'void main() {',
        'vUv = uv;',
        '#ifdef FLIP_Y',
        'vUv.y = 1.0 - vUv.y;',
        '#endif',
        'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
        '}'
    ].join('\n'),
    fragmentShader: [
        'uniform sampler2D tDiffuse;',
        'uniform float rgbmMultiplier;',
        // Inverse logLuvMatrix matrix, for decoding
        'const mat3 InverseLogLuvMatrix = mat3(',
        '6.0014, -2.7008, -1.7996,',
        '-1.3320,  3.1029, -5.7721,',
        '0.3008, -1.0882,  5.6268);',
        'vec3 HDRDecodeLOGLUV(in vec4 vLogLuv)',
        '{',
        // Based on http://www.xnainfo.com/content.php?content=28
        'float Le = vLogLuv.z * 255.0 + vLogLuv.w;',
        'vec3 Xp_Y_XYZp;',
        'Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);',
        'Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;',
        'Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;',
        'vec3 vRGB = InverseLogLuvMatrix * Xp_Y_XYZp;',
        'return vRGB;',
        '}',
        'vec3 HDRDecodeRGBM( vec4 rgbm ) {',
        // Based on http://vemberaudio.se/graphics/RGBdiv8.pdf
        'return rgbmMultiplier * rgbm.rgb * rgbm.a;',
        '}',
        'vec3 HDRDecodeRGBD( vec4 rgbd ) {',
        // Based on http://vemberaudio.se/graphics/RGBdiv8.pdf
        'return rgbd.rgb / max(rgbd.a, 0.003);',
        '}',
        'vec3 HDRDecodeRGBE( vec4 rgbe ) {',
        // Based on http://www.graphics.cornell.edu/~bjw/rgbe/rgbe.c
        'float f = exp2( rgbe.w * 255.0 - (128.0 + 0.0) );',
        'return rgbe.rgb * f;',
        '}',
        'varying vec2 vUv;',
        'void main() {',
        'vec3 hdrColour;',
        '#ifdef HDR_RGBM',
        'hdrColour = HDRDecodeRGBM( texture2D( tDiffuse, vUv ) );',
        '#elif defined(HDR_RGBD)',
        'hdrColour = HDRDecodeRGBD( texture2D( tDiffuse, vUv ) );',
        '#elif defined(HDR_RGBE)',
        'hdrColour = HDRDecodeRGBE( texture2D( tDiffuse, vUv ) );',
        '#elif defined(HDR_LOGLUV)',
        'hdrColour = HDRDecodeLOGLUV( texture2D( tDiffuse, vUv ) );',
        '#else',
        'hdrColour = texture2D( tDiffuse, vUv ).xyz;',
        '#endif',
        'gl_FragColor = vec4( hdrColour, 1.0 );',
        '}'
    ].join('\n')
};


/***/ }),
/* 211 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var RuntimeEvents_1 = __webpack_require__(27);
var LoadingState_1 = __webpack_require__(69);
var LoadingEvent_1 = __webpack_require__(12);
var StateTransitionError_1 = __webpack_require__(217);
var classComposer_1 = __webpack_require__(46);
exports.loadableResourceMixins = classComposer_1.default({}, [RuntimeEvents_1.default]);
/**
 * This class encapsulates everything related to the loading of an asset.
 *
 * @class LoadableResource
 * @mixes RuntimeEvents
 */
var LoadableResource = (function (_super) {
    tslib_1.__extends(LoadableResource, _super);
    /**
     * @constructor
     * @param {String} path The path to the file to load.
     * @param {String} type The type of resource used to determine loading strategy.
     * @param {Object} params Additional options fed in to the loading strategy.
     */
    function LoadableResource(path, type, params) {
        if (params === void 0) { params = {}; }
        var _this = _super.call(this) || this;
        _this.path = path;
        _this.type = type;
        _this.params = params;
        /** The current state. */
        _this.state = LoadingState_1.default.STARTING;
        /** An error instance, if an error occurred. */
        _this.error = undefined;
        /** The loaded data, if successful. */
        _this.data = undefined;
        /** A bucket which is used by the loader for temporary data. */
        _this.loaderData = {};
        if (!path) {
            throw new Error('Missing required `path` argument');
        }
        if (!type) {
            throw new Error('Missing required `type` argument');
        }
        return _this;
    }
    /**
     * Sets the current state of the loading process assuming it is a valid
     * transition. Otherwise an error is thrown.
     *
     * @method setState
     * @public
     * @param {LoadingState} state The new state.
     * @return {LoadingState} The new state.
     */
    LoadableResource.prototype.setState = function (state) {
        switch (state) {
            case LoadingState_1.default.STARTING:
                throw new StateTransitionError_1.default(this.state, state);
            case LoadingState_1.default.LOADING:
                if (this.state !== LoadingState_1.default.STARTING) {
                    throw new StateTransitionError_1.default(this.state, state);
                }
                break;
            case LoadingState_1.default.PROCESSING:
                if (this.state !== LoadingState_1.default.LOADING) {
                    throw new StateTransitionError_1.default(this.state, state);
                }
                break;
            case LoadingState_1.default.COMPLETE:
                if (this.state !== LoadingState_1.default.PROCESSING) {
                    throw new StateTransitionError_1.default(this.state, state);
                }
                break;
            case LoadingState_1.default.CANCELLED:
                if (this.state !== LoadingState_1.default.STARTING &&
                    this.state !== LoadingState_1.default.LOADING &&
                    this.state !== LoadingState_1.default.PROCESSING) {
                    throw new StateTransitionError_1.default(this.state, state);
                }
                break;
            case LoadingState_1.default.ERROR:
                // Any state is permissable to change to ERROR.
                break;
            default:
                throw new Error('Unknown state: ' + state);
        }
        this.state = state;
        this.trigger(LoadingEvent_1.default.STATE_CHANGE, state);
        return state;
    };
    /**
     * Sets the state to loading.
     *
     * @method setLoading
     * @public
     * @return {void}
     */
    LoadableResource.prototype.setLoading = function () {
        this.setState(LoadingState_1.default.LOADING);
    };
    /**
     * Sets the state to processing.
     *
     * @method setProcessing
     * @public
     * @return {void}
     */
    LoadableResource.prototype.setProcessing = function () {
        this.setState(LoadingState_1.default.PROCESSING);
    };
    /**
     * Sets the state to complete.
     *
     * @method setComplete
     * @public
     * @param {Mixed} data The data which has been loaded and processed.
     * @return {void}
     */
    LoadableResource.prototype.setComplete = function (data) {
        this.setState(LoadingState_1.default.COMPLETE);
        this.data = data;
        this.trigger(LoadingEvent_1.default.LOAD, data);
        this.done();
    };
    /**
     * Sets the state to error.
     *
     * @method setError
     * @public
     * @param {Error} error The exception which caused this error.
     * @return {void}
     */
    LoadableResource.prototype.setError = function (error) {
        this.setState(LoadingState_1.default.ERROR);
        this.error = error;
        this.trigger(LoadingEvent_1.default.ERROR, error);
        this.done();
    };
    /**
     * Sets the state to cancelled.
     *
     * @method setCancelled
     * @public
     * @return {void}
     */
    LoadableResource.prototype.setCancelled = function () {
        this.setState(LoadingState_1.default.CANCELLED);
        this.trigger(LoadingEvent_1.default.CANCEL);
        this.done();
    };
    /**
     * Checks whether or not the loading has been cancelled.
     *
     * @method isCancelled
     * @public
     * @return {Boolean}
     */
    LoadableResource.prototype.isCancelled = function () {
        return this.state === LoadingState_1.default.CANCELLED;
    };
    /**
     * Called on completion with any status (complete, error, cancelled)
     * @method done
     * @private
     * @return {void}
     */
    LoadableResource.prototype.done = function () {
        this.trigger(LoadingEvent_1.default.DONE, this.state);
        this.off();
    };
    return LoadableResource;
}(exports.loadableResourceMixins));
exports.default = LoadableResource;


/***/ }),
/* 212 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(39);
/**
 * Takes the loaded data from the XHR object and converts it into data which can
 * be used by the runtime.
 * In the case of buffers we simply pass the loaded XHR response to the asset.
 * @function processBuffer
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @return {Promise}                   A promise which will allow for continuation of the
 *                                     processing.
 */
var processBuffer = function (resource) {
    resource.setProcessing();
    resource.setComplete(resource.loaderData.xhr.response);
    return Promise.resolve(resource);
};
/**
 * A promise chain which trakes a LoadableResource instance and performs a
 * series of actions to load and produce data for a BufferAsset.
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @param  {Function} configureXhr     A function which returns a Promise to resolve an configured
 *                                     XMLHttpRequest object.
 * @return {Promise}                   Returns the tail of the promise chaina.
 */
exports.default = function (resource, configureXhr) {
    return common_1.makeXhr(configureXhr)(resource)
        .then(common_1.unlessCancelled(common_1.setResponseType('arraybuffer')))
        .then(common_1.unlessCancelled(common_1.loadXhr))
        .then(common_1.unlessCancelled(common_1.requireStatus(function (s) { return s === 200; })))
        .then(common_1.unlessCancelled(processBuffer))
        .catch(common_1.handleError(resource));
};


/***/ }),
/* 213 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Box3DShim = __webpack_require__(230);
var typeGuard_1 = __webpack_require__(184);
var common_1 = __webpack_require__(39);
/**
 * Takes the loaded data from the XHR object and converts it into data which can
 * be used by the runtime.
 * In the case of entities we need to run the loaded entities through the box3d shim
 * in order to ensure that they are converted to the current version.
 * @function processEntities
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @return {Promise}                   A promise which will allow for continuation of the
 *                                     processing.
 */
var processEntities = function (resource) {
    resource.setProcessing();
    // Handle parsing response for IE11 compatibility since return value is a string in that case.
    var json = typeof resource.loaderData.xhr.response === 'string' ?
        JSON.parse(resource.loaderData.xhr.response) : resource.loaderData.xhr.response;
    var queryIndex = resource.path.indexOf('?');
    var fromIndex = queryIndex >= 0 ? queryIndex : resource.path.length;
    var baseUrl = resource.path.slice(0, resource.path.lastIndexOf('/', fromIndex) + 1);
    // Make sure the major version is 4 or less.
    if (json === undefined || json.version === undefined || json.version.major > 4) {
        return Promise.reject(new Error('Unsupported data version'));
    }
    // The absolute pattern should match URLs like:
    //
    //   * http://example.com
    //   * HTTP://EXAMPLE.COM
    //   * https://www.example.com
    //   * ftp://example.com/file.txt
    //   * //cdn.example.com/lib.js
    //
    // but should not match URLs like:
    //
    //   * /myFolder/test.txt
    //   * test
    var absolutePattern = new RegExp(/^(?:[a-z]+:)?\/\//i);
    // The domain relative pattern should match URLs like: /myFolder/test.txt
    var domainRelativePattern = new RegExp(/^\//);
    // This predicate should match URLs that are not absolute and not
    // domain-relative.
    var isFileRelative = function (url) {
        return !url.match(absolutePattern) && !url.match(domainRelativePattern);
    };
    // Translate the entities with Box3DShim.
    var entities = Box3DShim.mapEntities(json.entities, json.version);
    // Prefix all "src" properties with baseUrl.
    entities.forEach(function (entity) {
        // Prefix image representation "src" properties:
        if (typeGuard_1.isAsset(entity) && entity.representations) {
            entity.representations.forEach(function (representation) {
                if (representation.src && isFileRelative(representation.src)) {
                    representation.src = baseUrl + representation.src;
                }
            });
        }
        // Prefix buffer entity "src" properties:
        if (entity.type === 'buffer') {
            var props = entity.properties;
            if (props.src && isFileRelative(props.src)) {
                props.src = baseUrl + props.src;
            }
        }
    });
    resource.setComplete(entities);
    return Promise.resolve(resource);
};
/**
 * A promise chain which takes a LoadableResource instance and performs a
 * series of actions to load and produce data for a BufferAsset.
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @param  {Function} configureXhr     A function which returns a Promise to resolve an configured
 *                                     XMLHttpRequest object.
 * @return {Promise}                   Returns the tail of the promise chain.
 */
exports.default = function (resource, configureXhr) {
    return common_1.makeXhr(configureXhr)(resource)
        .then(common_1.unlessCancelled(common_1.setResponseType('json')))
        .then(common_1.unlessCancelled(common_1.loadXhr))
        .then(common_1.unlessCancelled(common_1.requireStatus(function (s) { return s === 200; })))
        .then(common_1.unlessCancelled(processEntities))
        .catch(common_1.handleError(resource));
};


/***/ }),
/* 214 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(39);
/**
 * Takes the loaded data from the XHR object and converts it into data which can
 * be used by the runtime.
 * @function processImage
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @return {Promise}                   A promise which will allow for continuation of the
 *                                     processing
 */
var processImage = function (resource) {
    return new Promise(function (resolve) {
        resource.setProcessing();
        if (resource.loaderData.xhr.response instanceof Blob) {
            var url = URL.createObjectURL(resource.loaderData.xhr.response);
            var img_1 = new Image();
            img_1.onload = function () {
                resource.setComplete(img_1);
                resolve(resource);
            };
            img_1.src = url;
        }
        else {
            resource.setComplete(resource.loaderData.xhr.response);
            resolve(resource);
        }
    });
};
/**
 * A promise chain which trakes a LoadableResource instance and performs a
 * series of actions to load and produce data for an ImageAsset.
 * @param  {LoadableResource} resource An object describing the resource which is being loaded
 *                                     as well as containing any required state for the load.
 * @param  {Function} configureXhr     A function which returns a Promise to resolve an configured
 *                                     XMLHttpRequest object.
 * @return {Promise}                   Returns the tail of the promise chain
 */
exports.default = function (resource, configureXhr) {
    return common_1.makeXhr(configureXhr)(resource)
        .then(common_1.unlessCancelled(common_1.setResponseType('blob')))
        .then(common_1.unlessCancelled(common_1.loadXhr))
        .then(common_1.unlessCancelled(common_1.requireStatus(function (s) { return s === 200; })))
        .then(common_1.unlessCancelled(processImage))
        .catch(common_1.handleError(resource));
};


/***/ }),
/* 215 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var common_1 = __webpack_require__(39);
/**
 * Takes the loaded data from the XHR object and converts it into data which can
 * be used by the runtime.
 * @function processVideo
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @return {Promise}                   A promise which will allow for continuation of the
 *                                     processing
 */
var processVideo = function (resource) {
    return new Promise(function (resolve, reject) {
        resource.setProcessing();
        var url = URL.createObjectURL(resource.loaderData.xhr.response);
        var video = document.createElement('video');
        video.addEventListener('loadeddata', function () {
            resource.setComplete(video);
            resolve(resource);
        });
        video.addEventListener('error', function () { return reject(new Error('Failed to load video')); });
        video.src = url;
        video.load();
    });
};
/**
 * A promise chain which trakes a LoadableResource instance and performs a
 * series of actions to load and produce data for an VideoAsset.
 * @param  {LoadableResource} resource An object describing the resource which is being loaded
 *                                     as well as containing any required state for the load.
 * @param  {Function} configureXhr     A function which returns a Promise to resolve an configured
 *                                     XMLHttpRequest object.
 * @return {Promise}                   Returns the tail of the promise chain
 */
exports.default = function (resource, configureXhr) {
    return common_1.makeXhr(configureXhr)(resource)
        .then(common_1.unlessCancelled(common_1.setResponseType('blob')))
        .then(common_1.unlessCancelled(common_1.loadXhr))
        .then(common_1.unlessCancelled(common_1.requireStatus(function (s) { return s === 200; })))
        .then(common_1.unlessCancelled(processVideo))
        .catch(common_1.handleError(resource));
};


/***/ }),
/* 216 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Logger_1 = __webpack_require__(3);
var LoadingEvent_1 = __webpack_require__(12);
var BaseEntity_1 = __webpack_require__(9);
/**
 * ResourceLifecycle manages the lifecycle of loading resources for assets
 * including keeping track of currently loading assets and cancelling them at
 * engine shutdown.
 * @mixin ResourceLifecycle
 */
var ResourceLifecycle = (function () {
    function ResourceLifecycle() {
        /**
         * An array of LoadableResources loaded by this object.
         * @private
         * @type {LoadableResource[]}
         */
        this.loadingResources = [];
    }
    /**
     * Loads a resource
     * @param {String} path The path to the resource
     * @param {String} type The type @see LoadingType.js
     * @param {Function} callback A function which will be called on completion
     *                            including Success, Error and Cancellation
     * @param {Object} params Any additional data for the loading process
     * @returns {LoadableResource}
     */
    ResourceLifecycle.prototype.loadResource = function (path, type, callback, params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        var resource = this.engine.resourceLoader.load(path, type, params);
        this.loadingResources.push(resource);
        resource.on(LoadingEvent_1.default.ERROR, function (err) {
            Logger_1.default.error(_this.engine.getName() +
                (" - ResourceLifecycle: Error loading " + _this.type + ",") +
                (_this.getName() + ", " + err.toString()));
            _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
        });
        resource.on(LoadingEvent_1.default.DONE, function () {
            _this.loadingResources = _this.loadingResources.filter(function (l) { return l !== resource; });
            if (typeof callback === 'function') {
                callback();
            }
        });
        return resource;
    };
    /**
     * Aborts any requests currently being tracked
     * @method abortRequests
     * @returns {void}
     */
    ResourceLifecycle.prototype.abortRequests = function () {
        this.loadingResources.forEach(function (resource) { return resource.setCancelled(); });
    };
    return ResourceLifecycle;
}());
exports.default = ResourceLifecycle;


/***/ }),
/* 217 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var tslib_1 = __webpack_require__(0);
var LoadingState_1 = __webpack_require__(69);
/**
 * A custom error which captures failures in state transition.
 *
 * @class StateTransitionError
 */
var StateTransitionError = (function (_super) {
    tslib_1.__extends(StateTransitionError, _super);
    /**
     * @constructor
     * @param {String} from The initial state
     * @param {String} to The target state
     */
    function StateTransitionError(from, to) {
        var _this = _super.call(this, "Illegal state transition \"" + LoadingState_1.default[from] + "\" -> \"" + LoadingState_1.default[to] + "\"") || this;
        _this.from = from;
        _this.to = to;
        return _this;
    }
    return StateTransitionError;
}(Error));
exports.default = StateTransitionError;


/***/ }),
/* 218 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var LoadableResource_1 = __webpack_require__(211);
var prioritizedConcurrentPromiseQueue_1 = __webpack_require__(220);
var bufferLoader_1 = __webpack_require__(212);
var imageLoader_1 = __webpack_require__(214);
var videoLoader_1 = __webpack_require__(215);
var entitiesLoader_1 = __webpack_require__(213);
var LoadingEvent_1 = __webpack_require__(12);
var LoadingType_1 = __webpack_require__(16);
var maxConcurrentDownloads = 4;
/**
 * Given a resource, resolve a Promise with an XHR object configured to request
 * via GET to the resource's path.
 * @param path      The path of the asset
 * @param _params   An optional map of parameters which can be used by the loading
 *                  process.
 * @returns         A promise with the configured XHR.
 */
var defaultXhrPromise = function (path, _params) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', path);
    return Promise.resolve(xhr);
};
var defaultStrategies = [];
defaultStrategies[LoadingType_1.default.BUFFER] = bufferLoader_1.default;
defaultStrategies[LoadingType_1.default.IMAGE] = imageLoader_1.default;
defaultStrategies[LoadingType_1.default.VIDEO] = videoLoader_1.default;
defaultStrategies[LoadingType_1.default.ENTITIES] = entitiesLoader_1.default;
/**
 * This loader specializes in loading data over XHR. It can be configured with
 * a custom function `xhrPromise` which can be used to handle tasks such as
 * path rewriting and authentication concerns.
 */
var XhrResourceLoader = (function () {
    /**
     * @constructor
     * @param xhrPromise  A function which returns a function which resolves
     *                    to a configured XMLHttpRequest object. This function
     *                    should accept a LoadableResource as its sole
     *                    parameter. eg:
     *                    xhrPromise(loadbleResource) => Promise.resolve([configured xhr object]);
     *                    Defaults to a simple XHR object configured with path only.
     * @param strategies  A mapping of Strategy name => Strategy function, for this
     *                    option it's best to use the default value.
     */
    function XhrResourceLoader(xhrPromise, strategies) {
        if (xhrPromise === void 0) { xhrPromise = defaultXhrPromise; }
        if (strategies === void 0) { strategies = defaultStrategies; }
        this.xhrPromise = xhrPromise;
        this.strategies = strategies;
        /**
         * A collection of loading resources used to ensure that the same resource
         * is not being downloaded twice.
         */
        this.resources = {};
        if (!xhrPromise) {
            throw new Error('Must provide argument `xhrPromise`!');
        }
        if (!strategies) {
            throw new Error('Must provide argument `strategies`!');
        }
        this.queue = prioritizedConcurrentPromiseQueue_1.default(maxConcurrentDownloads);
    }
    /** Shuts down the queue and any other necessary cleanup. */
    XhrResourceLoader.prototype.destroy = function () {
        this.queue.destroy();
    };
    /**
     * Loads a resource by specified path, type and parameters.
     *
     * @param path    The path to the resource which will be loaded.
     * @param type    The `LoadingType` to be used for this path.
     * @param params  Any additional parameters to pass along to the loader.
     * @returns       The LoadableResource instance for tracking this load.
     */
    XhrResourceLoader.prototype.load = function (path, type, params) {
        var _this = this;
        if (!this.strategies[type]) {
            throw new Error('Unsupported type: ' + type);
        }
        if (this.resources[path]) {
            return this.resources[path];
        }
        var resource = this.resources[path] = new LoadableResource_1.default(path, type, params);
        this.queue.add(function () { return new Promise(function (resolve) {
            var done = function () {
                delete _this.resources[path];
                resource.off(LoadingEvent_1.default.LOAD, done);
                resource.off(LoadingEvent_1.default.ERROR, done);
                resource.off(LoadingEvent_1.default.CANCEL, done);
                resolve(resource);
            };
            resource.once(LoadingEvent_1.default.LOAD, done);
            resource.once(LoadingEvent_1.default.ERROR, done);
            resource.once(LoadingEvent_1.default.CANCEL, done);
            _this.strategies[type](resource, _this.xhrPromise);
        }); }, params.priority);
        return resource;
    };
    return XhrResourceLoader;
}());
exports.default = XhrResourceLoader;


/***/ }),
/* 219 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Converts a camel case string into an upper-snake-case string eg
 * 'FOO_BAR_BAZ'
 * @param {string} str The input string
 * @returns {string}
 */
function unCamelCase(str) {
    return str
        .replace(/([a-z])([A-Z])/g, '$1_$2')
        .replace(/([A-Z]+)([A-Z])([a-z])/, '$1_$2$3')
        .toUpperCase();
}
/**
 * Converts a string name into a name suitable for use as a define.
 * @param name  The input string
 * @returns     A string suitable for use as a define.
 */
exports.default = function (name) {
    var friendlyStr = typeof name === 'string' ? name : '';
    friendlyStr = friendlyStr.replace(/_([a-z])/gi, function (_m, w) {
        return '_' + w.toUpperCase();
    });
    friendlyStr = friendlyStr.replace(/\s+/g, '_');
    // Find where a number follows a letter and insert an underscore
    friendlyStr = friendlyStr.replace(/([a-z])([0-9])/g, '$1_$2');
    // Find where a letter follows a number and insert an underscore
    // friendlyStr = friendlyStr.replace(/([0-9])([A-z])/g, '$1_$2');
    friendlyStr = unCamelCase(friendlyStr);
    return friendlyStr;
};


/***/ }),
/* 220 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
// The default maximum concurrency level
var defaultMaxConcurrencySetting = 4;
// The default priority level
var defaultPrioritySetting = 5;
;
/**
 * Creates a queue which runs functions which produce promises.
 * @param   {Number} [maxConcurrency=DEFAULT_MAX_CONCURRENCY]
 *                The number of concurrent promises to execute
 * @param   {Number} [defaultPriority=DEFAULT_PRIORITY]
 *                The default priority
 * @returns {Object} Returns a module with the following two functions:
 *                    add: (fn, priority) => void
 *                    shutdown: () => void
 */
var prioritizedConcurrentPromiseQueue = function (maxConcurrency, defaultPriority) {
    if (maxConcurrency === void 0) { maxConcurrency = defaultMaxConcurrencySetting; }
    if (defaultPriority === void 0) { defaultPriority = defaultPrioritySetting; }
    // A list of functions waiting to be executed.
    var queued = [];
    // A list of functions which are currently being executed.
    var executing = [];
    // Whether or not the queue is currently running.
    var running = true;
    /**
     * De-queues and starts a promise.
     * @private
     */
    var dequeue = function () {
        var _loop_1 = function () {
            var f = queued.pop();
            executing.push(f);
            f.fn().then(function () {
                var idx = executing.indexOf(f);
                if (idx >= 0) {
                    executing.splice(idx, 1);
                    dequeue();
                }
            });
        };
        while (queued.length > 0 && executing.length < maxConcurrency) {
            _loop_1();
        }
    };
    /**
     * Used to sort the promise queue.
     * @param   {Object} a An object containing a `priority` property.
     * @param   {Object} b An object containing a `priority` property.
     * @returns {Number} The difference between priority B and priority A
     */
    var sortFn = function (a, b) { return b.priority - a.priority; };
    return {
        /**
         * Adds a function to the queue.
         *
         * @method
         * @param {Function} fn A function which takes zero arguments and produces a Promise.
         * @param {Number} priority A number which represents the priority of this promise.
         */
        add: function (fn, priority) {
            if (priority === void 0) { priority = defaultPriority; }
            if (priority < 0) {
                throw new Error('Invalid priority ' + priority);
            }
            if (!running) {
                throw new Error('Queue is not running, cannot accept new promises');
            }
            queued.push({ fn: fn, priority: priority });
            queued.sort(sortFn);
            setTimeout(dequeue(), 0);
        },
        /**
         * Shuts down the queue.
         *
         * @method
         */
        destroy: function () {
            running = false;
            executing.splice(0, executing.length);
            queued.splice(0, queued.length);
        }
    };
};
exports.default = prioritizedConcurrentPromiseQueue;


/***/ }),
/* 221 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
var Animation_1 = __webpack_require__(78);
exports.Animation = Animation_1.default;
var AudioListener_1 = __webpack_require__(79);
exports.AudioListener = AudioListener_1.default;
var AudioSource_1 = __webpack_require__(80);
exports.AudioSource = AudioSource_1.default;
var BoundingBoxRenderer_1 = __webpack_require__(81);
exports.BoundingBoxRenderer = BoundingBoxRenderer_1.default;
var CameraZoom_1 = __webpack_require__(82);
exports.CameraZoom = CameraZoom_1.default;
var CubeMapCapture_1 = __webpack_require__(83);
exports.CubeMapCapture = CubeMapCapture_1.default;
var Curve_1 = __webpack_require__(84);
exports.Curve = Curve_1.default;
var DebugConsoleDisplay_1 = __webpack_require__(85);
exports.DebugConsoleDisplay = DebugConsoleDisplay_1.default;
var DebugPerformance_1 = __webpack_require__(86);
exports.DebugPerformance = DebugPerformance_1.default;
var DebugTextureViewer_1 = __webpack_require__(87);
exports.DebugTextureViewer = DebugTextureViewer_1.default;
var DynamicOptimizer_1 = __webpack_require__(88);
exports.DynamicOptimizer = DynamicOptimizer_1.default;
var EventHandler_1 = __webpack_require__(89);
exports.EventHandler = EventHandler_1.default;
var Exploder_1 = __webpack_require__(90);
exports.Exploder = Exploder_1.default;
var Fullscreen_1 = __webpack_require__(91);
exports.Fullscreen = Fullscreen_1.default;
var GamepadAnimator_1 = __webpack_require__(92);
exports.GamepadAnimator = GamepadAnimator_1.default;
var GamepadDevice_1 = __webpack_require__(62);
exports.GamepadDevice = GamepadDevice_1.default;
var GamepadInput_1 = __webpack_require__(93);
exports.GamepadInput = GamepadInput_1.default;
var Input_1 = __webpack_require__(94);
exports.Input = Input_1.default;
var IntersectionChecker_1 = __webpack_require__(95);
exports.IntersectionChecker = IntersectionChecker_1.default;
var LightEnvironment_1 = __webpack_require__(96);
exports.LightEnvironment = LightEnvironment_1.default;
var LookAtTarget_1 = __webpack_require__(97);
exports.LookAtTarget = LookAtTarget_1.default;
var MaterialCapture_1 = __webpack_require__(98);
exports.MaterialCapture = MaterialCapture_1.default;
var MotionGamepadDevice_1 = __webpack_require__(63);
exports.MotionGamepadDevice = MotionGamepadDevice_1.default;
var NormalMapGenerator_1 = __webpack_require__(99);
exports.NormalMapGenerator = NormalMapGenerator_1.default;
var ObjectAnimator_1 = __webpack_require__(100);
exports.ObjectAnimator = ObjectAnimator_1.default;
var OrbitCamera_1 = __webpack_require__(25);
exports.OrbitCamera = OrbitCamera_1.default;
var OrbitCameraFocus_1 = __webpack_require__(101);
exports.OrbitCameraFocus = OrbitCameraFocus_1.default;
var OrbitDesktopControls_1 = __webpack_require__(102);
exports.OrbitDesktopControls = OrbitDesktopControls_1.default;
var OrbitDesktopInput_1 = __webpack_require__(103);
exports.OrbitDesktopInput = OrbitDesktopInput_1.default;
var OrbitTouchInput_1 = __webpack_require__(104);
exports.OrbitTouchInput = OrbitTouchInput_1.default;
var PanoramaToCubeMap_1 = __webpack_require__(105);
exports.PanoramaToCubeMap = PanoramaToCubeMap_1.default;
var PreviewAxisRotation_1 = __webpack_require__(106);
exports.PreviewAxisRotation = PreviewAxisRotation_1.default;
var ReflectionCapturePlanar_1 = __webpack_require__(107);
exports.ReflectionCapturePlanar = ReflectionCapturePlanar_1.default;
var Renderer_1 = __webpack_require__(108);
exports.Renderer = Renderer_1.default;
var RenderModes_1 = __webpack_require__(64);
exports.RenderModes = RenderModes_1.default;
var RenderView_1 = __webpack_require__(65);
exports.RenderView = RenderView_1.default;
var Rotate_1 = __webpack_require__(109);
exports.Rotate = Rotate_1.default;
var SimplexNoiseGenerator_1 = __webpack_require__(110);
exports.SimplexNoiseGenerator = SimplexNoiseGenerator_1.default;
var Skybox_1 = __webpack_require__(111);
exports.Skybox = Skybox_1.default;
var TextRenderer_1 = __webpack_require__(112);
exports.TextRenderer = TextRenderer_1.default;
var VrCameraController_1 = __webpack_require__(113);
exports.VrCameraController = VrCameraController_1.default;
var VrPresenter_1 = __webpack_require__(114);
exports.VrPresenter = VrPresenter_1.default;
var VrRenderView_1 = __webpack_require__(115);
exports.VrRenderView = VrRenderView_1.default;


/***/ }),
/* 222 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

Object.defineProperty(exports, "__esModule", { value: true });
/* This file was generated with box3d-component-generator at Tue Apr 04 2017 11:27:16 GMT-0700 (PDT) */
/* tslint:disable */
/* eslint:disable */
var Animation_1 = __webpack_require__(78);
var AudioListener_1 = __webpack_require__(79);
var AudioSource_1 = __webpack_require__(80);
var BoundingBoxRenderer_1 = __webpack_require__(81);
var CameraZoom_1 = __webpack_require__(82);
var CubeMapCapture_1 = __webpack_require__(83);
var Curve_1 = __webpack_require__(84);
var DebugConsoleDisplay_1 = __webpack_require__(85);
var DebugPerformance_1 = __webpack_require__(86);
var DebugTextureViewer_1 = __webpack_require__(87);
var DynamicOptimizer_1 = __webpack_require__(88);
var EventHandler_1 = __webpack_require__(89);
var Exploder_1 = __webpack_require__(90);
var Fullscreen_1 = __webpack_require__(91);
var GamepadAnimator_1 = __webpack_require__(92);
var GamepadDevice_1 = __webpack_require__(62);
var GamepadInput_1 = __webpack_require__(93);
var Input_1 = __webpack_require__(94);
var IntersectionChecker_1 = __webpack_require__(95);
var LightEnvironment_1 = __webpack_require__(96);
var LookAtTarget_1 = __webpack_require__(97);
var MaterialCapture_1 = __webpack_require__(98);
var MotionGamepadDevice_1 = __webpack_require__(63);
var NormalMapGenerator_1 = __webpack_require__(99);
var ObjectAnimator_1 = __webpack_require__(100);
var OrbitCamera_1 = __webpack_require__(25);
var OrbitCameraFocus_1 = __webpack_require__(101);
var OrbitDesktopControls_1 = __webpack_require__(102);
var OrbitDesktopInput_1 = __webpack_require__(103);
var OrbitTouchInput_1 = __webpack_require__(104);
var PanoramaToCubeMap_1 = __webpack_require__(105);
var PreviewAxisRotation_1 = __webpack_require__(106);
var ReflectionCapturePlanar_1 = __webpack_require__(107);
var Renderer_1 = __webpack_require__(108);
var RenderModes_1 = __webpack_require__(64);
var RenderView_1 = __webpack_require__(65);
var Rotate_1 = __webpack_require__(109);
var SimplexNoiseGenerator_1 = __webpack_require__(110);
var Skybox_1 = __webpack_require__(111);
var TextRenderer_1 = __webpack_require__(112);
var VrCameraController_1 = __webpack_require__(113);
var VrPresenter_1 = __webpack_require__(114);
var VrRenderView_1 = __webpack_require__(115);
exports.default = [
    [{
            id: "animation",
            sid: "Animation",
            properties: {
                name: "Animation",
                attributes: {
                    asset: {
                        name: "asset",
                        type: "asset",
                        description: "Animation asset",
                        default: null,
                        filter: {
                            animation: true
                        }
                    },
                    clipId: {
                        name: "clipId",
                        type: "i",
                        description: "The animation clip ID",
                        default: null
                    },
                    loop: {
                        name: "loop",
                        type: "b",
                        description: "Continuously replay the animation",
                        default: true
                    },
                    speed: {
                        name: "speed",
                        type: "f",
                        description: "Playback speed",
                        default: 1,
                        min: 0,
                        max: 100
                    },
                    startTime: {
                        name: "startTime",
                        type: "f",
                        description: "Begin playback at this time offset",
                        default: 0,
                        min: 0
                    },
                    weight: {
                        name: "weight",
                        type: "f",
                        description: "Blending weight",
                        default: 1,
                        min: 0,
                        max: 1
                    }
                },
                events: {
                    playAnimation: {
                        scope: "local",
                        name: "playAnimation",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "asset",
                                type: "asset",
                                description: "The animation asset to play.",
                                default: null,
                                filter: {
                                    animation: true
                                }
                            },
                            {
                                name: "clipId",
                                type: "s",
                                description: "The ID of the clip to play.",
                                default: null
                            },
                            {
                                name: "loop",
                                type: "b",
                                description: "Continuously replay the animation.",
                                default: true
                            },
                            {
                                name: "speed",
                                type: "f",
                                description: "Playback speed.",
                                default: 1,
                                min: 0,
                                max: 100
                            },
                            {
                                name: "startTime",
                                type: "f",
                                description: "Begin playback at this time offset.",
                                default: 0,
                                min: 0
                            }
                        ]
                    },
                    pauseAnimation: {
                        scope: "local",
                        name: "pauseAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    stopAnimation: {
                        scope: "local",
                        name: "stopAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    toggleAnimation: {
                        scope: "local",
                        name: "toggleAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    animationLoaded: {
                        scope: "local",
                        name: "animationLoaded",
                        action: false,
                        category: "Animation",
                        parameters: []
                    },
                    endAnimation: {
                        scope: "local",
                        name: "endAnimation",
                        action: false,
                        category: "Animation",
                        parameters: []
                    }
                },
                filter: [
                    "object"
                ],
                category: "Animation"
            }
        }, Animation_1.default],
    [{
            id: "audio_listener",
            sid: "Audio Listener",
            properties: {
                name: "Audio Listener",
                description: "Audio listener for 3D, positional sound effects",
                category: "Audio"
            }
        }, AudioListener_1.default],
    [{
            id: "audio_source",
            sid: "Audio Source",
            properties: {
                name: "Audio Source",
                description: "Controls playback of audio assets",
                attributes: {
                    gain: {
                        name: "gain",
                        type: "f",
                        description: "Volume control",
                        default: 1,
                        min: 0,
                        max: 100
                    },
                    autoPlay: {
                        name: "autoPlay",
                        type: "b",
                        description: "Play the audio once loaded",
                        default: true
                    },
                    loop: {
                        name: "loop",
                        type: "b",
                        description: "Continuously replay the audio",
                        default: true
                    },
                    preload: {
                        name: "preload",
                        type: "b",
                        description: "Load the audio when the component is initialized",
                        default: true
                    },
                    positional: {
                        name: "positional",
                        type: "b",
                        description: "Enable/disable 3D, positional audio effects",
                        default: false
                    },
                    stream: {
                        name: "stream",
                        type: "b",
                        description: "Stream the audio",
                        default: false
                    },
                    asset: {
                        name: "asset",
                        type: "asset",
                        description: "Audio or video asset",
                        default: null,
                        filter: {
                            audio: true,
                            video: true
                        }
                    }
                },
                events: {
                    playAudio: {
                        scope: "local",
                        name: "playAudio",
                        action: true,
                        category: "Audio",
                        parameters: [
                            {
                                name: "offset",
                                type: "f",
                                description: "Defined in seconds",
                                default: 0
                            }
                        ]
                    },
                    pauseAudio: {
                        scope: "local",
                        name: "pauseAudio",
                        action: true,
                        category: "Audio",
                        parameters: []
                    },
                    stopAudio: {
                        scope: "local",
                        name: "stopAudio",
                        action: true,
                        category: "Audio",
                        parameters: []
                    },
                    toggleAudio: {
                        scope: "local",
                        name: "toggleAudio",
                        action: true,
                        category: "Audio",
                        parameters: []
                    }
                },
                category: "Audio"
            }
        }, AudioSource_1.default],
    [{
            id: "bounding_box_renderer",
            sid: "BoundingBox Renderer",
            properties: {
                name: "BoundingBox Renderer",
                attributes: {
                    recursive: {
                        name: "recursive",
                        type: "b",
                        default: true,
                        description: "Automatically render bounding boxes for all meshes in the hierarchy"
                    }
                },
                filter: [
                    "object"
                ],
                category: "Rendering"
            }
        }, BoundingBoxRenderer_1.default],
    [{
            id: "camera_zoom",
            sid: "Camera Zoom",
            properties: {
                name: "Camera Zoom",
                description: "Handles zooming with orthographic and perspective cameras.",
                attributes: {
                    perspectiveZoomMax: {
                        name: "perspectiveZoomMax",
                        type: "f",
                        description: "The maximum amount a perspective camera can be zoomed (out)",
                        default: 180,
                        max: 100000,
                        min: 0
                    },
                    perspectiveZoomMin: {
                        name: "perspectiveZoomMin",
                        type: "f",
                        description: "The minimum amount a perspective camera can be zoomed (in)",
                        default: 0,
                        max: 100000,
                        min: 0
                    },
                    orthoZoomMax: {
                        name: "orthoZoomMax",
                        type: "f",
                        description: "The maximum amount an orthographic camera can be zoomed (out)",
                        default: 5,
                        max: 100000,
                        min: 0
                    },
                    orthoZoomMin: {
                        name: "orthoZoomMin",
                        type: "f",
                        description: "The minimum amount an orthographic camera can be zoomed (in)",
                        default: 0,
                        max: 100000,
                        min: 0
                    },
                    perspectiveStep: {
                        name: "perspectiveStep",
                        type: "f",
                        description: "Used to unify zoom between ortho and perspective zoom (this.zoom(+-1))",
                        default: 4,
                        max: 100000,
                        min: 0
                    },
                    orthographicStep: {
                        name: "orthographicStep",
                        type: "f",
                        description: "Used to unify zoom between ortho and perspective zoom (this.zoom(+-1))",
                        default: 0.2,
                        max: 100000,
                        min: 0
                    }
                },
                filter: [
                    "camera"
                ],
                category: "Camera Controllers"
            }
        }, CameraZoom_1.default],
    [{
            id: "cube_map_capture",
            sid: "Cube-Map Capture",
            properties: {
                name: "Cube-Map Capture",
                attributes: {
                    captureTexture: {
                        name: "captureTexture",
                        type: "asset",
                        description: "The RenderTextureCube to render the reflection to.",
                        filter: {
                            renderTextureCube: true
                        },
                        default: null
                    },
                    near: {
                        name: "near",
                        type: "f",
                        description: "The closest distance to this object to render. Adjust this to avoid   rendering local geometry to the texture.",
                        default: 0.01
                    },
                    far: {
                        name: "far",
                        type: "f",
                        description: "The furthest distance from this object to render.",
                        default: 16
                    },
                    updateFrameInterval: {
                        name: "updateFrameInterval",
                        type: "i",
                        description: "The number of frames to skip in between updates of the reflection.   Default is 0.",
                        default: 0
                    },
                    renderPosX: {
                        name: "renderPosX",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    renderPosY: {
                        name: "renderPosY",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    renderNegZ: {
                        name: "renderNegZ",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    renderNegX: {
                        name: "renderNegX",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    renderNegY: {
                        name: "renderNegY",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    renderPosZ: {
                        name: "renderPosZ",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    debugView: {
                        name: "debugView",
                        type: "b",
                        description: "Render the camera helpers on the cube capture.",
                        default: false
                    }
                },
                filter: [
                    "Object"
                ],
                category: "Rendering"
            }
        }, CubeMapCapture_1.default],
    [{
            id: "curve",
            sid: "Curve",
            properties: {
                name: "Curve",
                description: "Creates a spline curve that can be used for various things, including making               objects follow it. Add controls points to shape the curve.",
                attributes: {
                    controlPoints: {
                        name: "controlPoints",
                        type: "a",
                        subType: {
                            type: "object"
                        },
                        description: "The list of objects that define the curve shape."
                    },
                    closed: {
                        name: "closed",
                        type: "b",
                        description: "If toggled, the start and end of the curve will be smoothly joined.",
                        default: false
                    },
                    enableVisualizations: {
                        name: "enableVisualizations",
                        type: "b",
                        description: "If true, visualization of the curve will be enabled.",
                        default: false
                    }
                },
                filter: [
                    "object"
                ],
                category: "General"
            }
        }, Curve_1.default],
    [{
            id: "debug_console_display",
            sid: "Debug Console Display",
            properties: {
                name: "Debug Console Display",
                filter: [
                    "Application"
                ],
                category: "Debug"
            }
        }, DebugConsoleDisplay_1.default],
    [{
            id: "debug_performance",
            sid: "Debug Performance",
            properties: {
                name: "Debug Performance",
                filter: [
                    "Application"
                ],
                category: "Debug"
            }
        }, DebugPerformance_1.default],
    [{
            id: "debug_texture_viewer",
            sid: "Debug Texture Viewer",
            properties: {
                name: "Debug Texture Viewer",
                attributes: {
                    viewportLeft: {
                        name: "viewportLeft",
                        type: "s",
                        description: "Left position of the viewport to be rendered by this camera.",
                        default: "25%"
                    },
                    viewportBottom: {
                        name: "viewportBottom",
                        type: "s",
                        description: "Bottom position of the viewport to be rendered by this camera.",
                        default: "0px"
                    },
                    viewportWidth: {
                        name: "viewportWidth",
                        type: "s",
                        description: "Width of the viewport to be rendered by this camera.",
                        default: "50%"
                    },
                    viewportHeight: {
                        name: "viewportHeight",
                        type: "s",
                        description: "Height of the viewport to be rendered by this camera.",
                        default: "50%"
                    },
                    renderGroup: {
                        name: "renderGroup",
                        type: "i",
                        description: "Render passes are done in order, based on the 'render group' value. Lower numbers render first.",
                        default: 9
                    }
                },
                filter: [
                    "Application"
                ],
                category: "Debug"
            }
        }, DebugTextureViewer_1.default],
    [{
            id: "dynamic_optimizer",
            sid: "Dynamic Performance Optimizer",
            properties: {
                name: "Dynamic Performance Optimizer",
                attributes: {
                    frameTimeThreshold: {
                        name: "frameTimeThreshold",
                        type: "f",
                        description: "The average time that a frame can take to render before the optimizer drops a   quality level. Default threshold is 30 FPS = 1000 ms / 30 frames",
                        default: 33.333333333333
                    },
                    testInterval: {
                        name: "testInterval",
                        type: "f",
                        description: "The amount of elapsed time (in ms) to average the frame time over.   i.e. an optimization decision can be made every time this interval elapses.",
                        default: 2000
                    }
                },
                filter: [
                    "Application"
                ],
                category: "Rendering"
            }
        }, DynamicOptimizer_1.default],
    [{
            id: "event_handler",
            sid: "Event Handler",
            properties: {
                name: "Event Handler",
                attributes: {
                    listen: {
                        name: "listen",
                        type: "event",
                        description: "The event to listen for. When this event is captured, all of the defined trigger events will be fired."
                    },
                    triggers: {
                        name: "triggers",
                        type: "a",
                        subType: {
                            type: "event"
                        },
                        description: "Fire each of these events in response to the captured listen event."
                    }
                },
                category: "Interaction"
            }
        }, EventHandler_1.default],
    [{
            id: "exploder",
            sid: "Exploder",
            properties: {
                name: "Exploder",
                description: "Explodes your objects and their hierarchies into different formations.               Great for showing off parts in a model!",
                attributes: {
                    time: {
                        name: "time",
                        type: "f",
                        default: 1.5,
                        min: 0.001,
                        description: "The amount of time to explode and contract the child meshes"
                    },
                    scale: {
                        name: "scale",
                        type: "v3",
                        default: {
                            x: 2,
                            y: 2,
                            z: 2
                        },
                        description: "The scale of the explosion"
                    },
                    formation: {
                        name: "formation",
                        type: "dd",
                        description: "Formation to use when exploding the hierarchy of this object.",
                        default: "Scale",
                        options: {
                            Circle: "Circle",
                            "Square Grid": "Grid",
                            "Scale Out": "Scale"
                        }
                    }
                },
                events: {
                    playExplode: {
                        scope: "local",
                        name: "playExplode",
                        action: true,
                        category: "Exploder",
                        parameters: []
                    },
                    playContract: {
                        scope: "local",
                        name: "playContract",
                        action: true,
                        category: "Exploder",
                        parameters: []
                    },
                    toggleExplode: {
                        scope: "local",
                        name: "toggleExplode",
                        action: true,
                        category: "Exploder",
                        parameters: []
                    },
                    resetExploder: {
                        scope: "local",
                        name: "resetExploder",
                        action: true,
                        category: "Exploder",
                        parameters: []
                    },
                    playCircleExplode: {
                        scope: "local",
                        name: "playCircleExplode",
                        action: true,
                        category: "Exploder",
                        parameters: [
                            {
                                name: "Scale",
                                type: "v3",
                                description: "The scale to apply to the explosion",
                                default: {
                                    x: 1,
                                    y: 1,
                                    z: 1
                                }
                            }
                        ]
                    },
                    playGridExplode: {
                        scope: "local",
                        name: "playGridExplode",
                        action: true,
                        category: "Exploder",
                        parameters: [
                            {
                                name: "Scale",
                                type: "v3",
                                description: "The scale to apply to the explosion",
                                default: {
                                    x: 1,
                                    y: 1,
                                    z: 1
                                }
                            }
                        ]
                    },
                    playScaleExplode: {
                        scope: "local",
                        name: "playScaleExplode",
                        action: true,
                        category: "Exploder",
                        parameters: [
                            {
                                name: "Scale",
                                type: "v3",
                                description: "The scale to apply to the explosion",
                                default: {
                                    x: 2,
                                    y: 2,
                                    z: 2
                                }
                            }
                        ]
                    },
                    beginExplode: {
                        scope: "other",
                        name: "beginExplode",
                        action: false,
                        category: "Exploder",
                        parameters: []
                    },
                    endExplode: {
                        scope: "other",
                        name: "endExplode",
                        action: false,
                        category: "Exploder",
                        parameters: []
                    },
                    beginContract: {
                        scope: "other",
                        name: "beginContract",
                        action: false,
                        category: "Exploder",
                        parameters: []
                    },
                    endContract: {
                        scope: "other",
                        name: "endContract",
                        action: false,
                        category: "Exploder",
                        parameters: []
                    }
                },
                filter: [
                    "object"
                ],
                category: "Animation"
            }
        }, Exploder_1.default],
    [{
            id: "fullscreen",
            sid: "Fullscreen",
            properties: {
                name: "Fullscreen",
                description: "Harnesses the fullscreen API to make your app fullscreen!",
                events: {
                    toggleFullscreen: {
                        scope: "local",
                        name: "toggleFullscreen",
                        action: true,
                        category: "Rendering",
                        parameters: []
                    }
                },
                filter: [
                    "application"
                ],
                category: "Rendering"
            }
        }, Fullscreen_1.default],
    [{
            id: "gamepad_animator",
            sid: "Gamepad Animator",
            properties: {
                name: "Gamepad Animator",
                attributes: {
                    buttons: {
                        name: "buttons",
                        type: "a",
                        subType: {
                            type: "a",
                            subType: {
                                type: "custom",
                                attributes: {
                                    mesh: {
                                        type: "object"
                                    },
                                    movementType: {
                                        type: "s",
                                        default: "translate"
                                    },
                                    offset: {
                                        type: "v3"
                                    },
                                    pivot: {
                                        type: "v3"
                                    },
                                    rotation: {
                                        type: "v3"
                                    },
                                    renderOnTouchOnly: {
                                        type: "b",
                                        default: false
                                    }
                                }
                            },
                            default: []
                        },
                        default: []
                    },
                    axes: {
                        name: "axes",
                        type: "a",
                        subType: {
                            type: "a",
                            subType: {
                                type: "custom",
                                attributes: {
                                    mesh: {
                                        type: "object"
                                    },
                                    movementType: {
                                        type: "s",
                                        default: "translate"
                                    },
                                    offset: {
                                        type: "v3"
                                    },
                                    pivot: {
                                        type: "v3"
                                    },
                                    rotation: {
                                        type: "v3"
                                    },
                                    renderOnTouchOnly: {
                                        type: "b",
                                        default: false
                                    }
                                }
                            },
                            default: []
                        },
                        default: []
                    }
                },
                filter: [
                    "object"
                ],
                category: "Input"
            }
        }, GamepadAnimator_1.default],
    [{
            id: "gamepad_device",
            sid: "Gamepad Device",
            properties: {
                name: "Gamepad Device",
                filter: [
                    "object"
                ],
                category: "Input"
            }
        }, GamepadDevice_1.default],
    [{
            id: "gamepad_input",
            sid: "Gamepad Input",
            properties: {
                name: "Gamepad Input",
                filter: [
                    "application"
                ],
                category: "Input"
            }
        }, GamepadInput_1.default],
    [{
            id: "input",
            sid: "Input",
            properties: {
                name: "Input",
                attributes: {
                    mouseEvents: {
                        name: "mouseEvents",
                        type: "custom",
                        attributes: {
                            enable: {
                                type: "b",
                                default: true,
                                description: "Enable mouse events"
                            },
                            scroll: {
                                type: "b",
                                default: true,
                                description: "Listen to scroll events?"
                            },
                            preventScrollDefault: {
                                type: "b",
                                default: false,
                                description: "Prevent default scroll behavior"
                            },
                            move: {
                                type: "b",
                                default: true,
                                description: "Listen to mouse move events"
                            },
                            down: {
                                type: "b",
                                default: true,
                                description: "Listen to mouse down event"
                            },
                            preventDownDefault: {
                                type: "b",
                                default: false,
                                description: "Prevent default mouse down behavior"
                            },
                            up: {
                                type: "b",
                                default: true,
                                description: "Listen to mouse up event"
                            },
                            doubleClick: {
                                type: "b",
                                default: true,
                                description: "Listen to double click event"
                            },
                            leave: {
                                type: "b",
                                default: true,
                                description: "Listen to mouse leave event"
                            },
                            contextMenu: {
                                type: "b",
                                default: true,
                                description: "Listen for the context menu event (ie, right click)"
                            },
                            preventContextMenuDefault: {
                                type: "b",
                                default: true,
                                description: "Prevent context menu default behavior (ie, the context menu popping open)"
                            },
                            dragBufferDistance: {
                                type: "f",
                                default: 12,
                                name: "Drag Buffer Distance",
                                description: "The distance from initial click that you need to move your mouse before a drag event is fired, in pixels"
                            },
                            eventHandler: {
                                type: "b",
                                default: true,
                                description: "Events fired from the mouse are picked up by the Event Handler"
                            }
                        }
                    },
                    touchEvents: {
                        name: "touchEvents",
                        type: "custom",
                        attributes: {
                            enable: {
                                type: "b",
                                default: true,
                                description: "Enable touch events?"
                            },
                            start: {
                                type: "b",
                                default: true,
                                description: "Listen for Touch Start"
                            },
                            preventStartDefault: {
                                type: "b",
                                default: false,
                                description: "Prevent default behavior of touch start event"
                            },
                            end: {
                                type: "b",
                                default: true,
                                description: "Listen for touch end event"
                            },
                            preventEndDefault: {
                                type: "b",
                                default: false
                            },
                            doubleTap: {
                                type: "b",
                                default: true,
                                description: "Listen for a touch double tap event"
                            },
                            cancel: {
                                type: "b",
                                default: true,
                                description: "Listen for touch cancel event"
                            },
                            preventCancelDefault: {
                                type: "b",
                                default: false
                            },
                            leave: {
                                type: "b",
                                default: true,
                                description: "Listen for touch leave event"
                            },
                            preventLeaveDefault: {
                                type: "b",
                                default: false
                            },
                            move: {
                                type: "b",
                                default: true,
                                description: "Listen for touch move event"
                            },
                            preventMoveDefault: {
                                type: "b",
                                default: true,
                                description: "Prevent default move behavior (ie, dragging the window)"
                            },
                            dragBufferDistance: {
                                type: "f",
                                default: 12,
                                name: "Drag Buffer Distance",
                                description: "The distance from initial touch down that you need to move your finger before a drag event is fired, in pixels"
                            },
                            eventHandler: {
                                type: "b",
                                default: true,
                                description: "Events fired from the touches are picked up by the Event Handler"
                            }
                        }
                    },
                    keyEvents: {
                        name: "keyEvents",
                        type: "custom",
                        attributes: {
                            enable: {
                                type: "b",
                                default: true,
                                description: "Enable keyboard events"
                            },
                            down: {
                                type: "b",
                                default: true,
                                description: "Listen to key down events"
                            },
                            up: {
                                type: "b",
                                default: true,
                                description: "Listen to key up events"
                            },
                            preventDefault: {
                                type: "b",
                                default: false,
                                description: "Prevent default keypress behavior"
                            },
                            eventHandler: {
                                type: "b",
                                default: true,
                                description: "Events fired from the keys are picked up by the Event Handler"
                            }
                        }
                    }
                },
                events: {
                    mouse_down_left: {
                        scope: "global",
                        name: "mouse_down_left",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    mouse_down_right: {
                        scope: "global",
                        name: "mouse_down_right",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    mouse_down_middle: {
                        scope: "global",
                        name: "mouse_down_middle",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    mouse_up_left: {
                        scope: "global",
                        name: "mouse_up_left",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    mouse_up_right: {
                        scope: "global",
                        name: "mouse_up_right",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    mouse_up_middle: {
                        scope: "global",
                        name: "mouse_up_middle",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    keypress_a: {
                        scope: "global",
                        name: "keypress_a",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_b: {
                        scope: "global",
                        name: "keypress_b",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_c: {
                        scope: "global",
                        name: "keypress_c",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_d: {
                        scope: "global",
                        name: "keypress_d",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_f: {
                        scope: "global",
                        name: "keypress_f",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_g: {
                        scope: "global",
                        name: "keypress_g",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_e: {
                        scope: "global",
                        name: "keypress_e",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_h: {
                        scope: "global",
                        name: "keypress_h",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_i: {
                        scope: "global",
                        name: "keypress_i",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_j: {
                        scope: "global",
                        name: "keypress_j",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_k: {
                        scope: "global",
                        name: "keypress_k",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_l: {
                        scope: "global",
                        name: "keypress_l",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_m: {
                        scope: "global",
                        name: "keypress_m",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_n: {
                        scope: "global",
                        name: "keypress_n",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_o: {
                        scope: "global",
                        name: "keypress_o",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_p: {
                        scope: "global",
                        name: "keypress_p",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_q: {
                        scope: "global",
                        name: "keypress_q",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_r: {
                        scope: "global",
                        name: "keypress_r",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_s: {
                        scope: "global",
                        name: "keypress_s",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_t: {
                        scope: "global",
                        name: "keypress_t",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_u: {
                        scope: "global",
                        name: "keypress_u",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_v: {
                        scope: "global",
                        name: "keypress_v",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_w: {
                        scope: "global",
                        name: "keypress_w",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_x: {
                        scope: "global",
                        name: "keypress_x",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_y: {
                        scope: "global",
                        name: "keypress_y",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_z: {
                        scope: "global",
                        name: "keypress_z",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_up_arrow: {
                        scope: "global",
                        name: "keypress_up_arrow",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_down_arrow: {
                        scope: "global",
                        name: "keypress_down_arrow",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_left_arrow: {
                        scope: "global",
                        name: "keypress_left_arrow",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_right_arrow: {
                        scope: "global",
                        name: "keypress_right_arrow",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_space: {
                        scope: "global",
                        name: "keypress_space",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    touch_start: {
                        scope: "global",
                        name: "touch_start",
                        action: false,
                        category: "Input - Touch",
                        parameters: []
                    },
                    touch_end: {
                        scope: "global",
                        name: "touch_end",
                        action: false,
                        category: "Input - Touch",
                        parameters: []
                    }
                },
                filter: [
                    "application"
                ],
                category: "Input"
            }
        }, Input_1.default],
    [{
            id: "intersection_checker",
            sid: "Intersection Checker",
            properties: {
                name: "Intersection Checker",
                attributes: {
                    objectTypeFilter: {
                        name: "objectTypeFilter",
                        type: "a",
                        subType: {
                            type: "s"
                        },
                        default: []
                    },
                    objectFilter: {
                        name: "objectFilter",
                        type: "a",
                        subType: {
                            type: "object"
                        },
                        default: []
                    },
                    checkIntersectionAlways: {
                        name: "checkIntersectionAlways",
                        type: "b",
                        default: false
                    },
                    boundingSphereOverrideRadius: {
                        name: "boundingSphereOverrideRadius",
                        type: "i",
                        default: -1
                    },
                    firstIntersectionOnly: {
                        name: "firstIntersectionOnly",
                        type: "b",
                        default: true
                    },
                    debugVisualization: {
                        name: "debugVisualization",
                        type: "b",
                        default: false
                    }
                },
                filter: [
                    "object"
                ],
                category: "Tools This component checks if the entity that it's attached to intersects with any other objects. It can be configured to filter the checked objects, the type of intersection and when the intersection checks occur."
            }
        }, IntersectionChecker_1.default],
    [{
            id: "light_environment",
            sid: "Light Environment",
            properties: {
                name: "Light Environment",
                attributes: {
                    irradianceMap: {
                        name: "irradianceMap",
                        type: "asset",
                        filter: {
                            renderTexture2D: true,
                            texture2D: true
                        }
                    },
                    radianceMapHalfGloss: {
                        name: "radianceMapHalfGloss",
                        type: "asset",
                        filter: {
                            renderTexture2D: true,
                            texture2D: true
                        }
                    },
                    radianceMap: {
                        name: "radianceMap",
                        type: "asset",
                        filter: {
                            renderTexture2D: true,
                            texture2D: true
                        }
                    }
                },
                filter: [
                    "scene"
                ],
                category: "Rendering"
            }
        }, LightEnvironment_1.default],
    [{
            id: "look_at_target",
            sid: "Look At Target",
            properties: {
                name: "Look At Target",
                description: "A component that automatically points the object at a target. This can be used for billboarding an object to the camera, making a character look at another, etc.",
                attributes: {
                    target: {
                        name: "target",
                        type: "object",
                        description: "The object that you want this object to point towards. e.g. for billboarding, this would be the camera used to render the scene."
                    },
                    local: {
                        name: "local",
                        type: "b",
                        description: "If toggled, whatever rotation you have already applied to this object will be taken into account.",
                        default: false
                    }
                },
                filter: [
                    "Object"
                ],
                category: "General"
            }
        }, LookAtTarget_1.default],
    [{
            id: "material_capture",
            sid: "Material Capture",
            properties: {
                name: "Material Capture",
                description: "A component that captures an image of a rendered material as a spherical map, complete               with lighting. This image can then be applied (with a sphere map projection) to a mesh to achieve               convincing material shading (although the mesh will appear with the same lighting from all directions).",
                attributes: {
                    captureTexture: {
                        name: "captureTexture",
                        type: "asset",
                        description: "",
                        filter: {
                            renderTexture2D: true
                        },
                        default: null
                    }
                },
                filter: [
                    "material"
                ],
                category: "Rendering"
            }
        }, MaterialCapture_1.default],
    [{
            id: "motion_gamepad_device",
            sid: "Motion Gamepad Device",
            properties: {
                name: "Motion Gamepad Device",
                attributes: {
                    handPreference: {
                        name: "handPreference",
                        type: "i",
                        default: 0
                    }
                },
                filter: [
                    "object"
                ],
                category: "Input"
            }
        }, MotionGamepadDevice_1.default],
    [{
            id: "normal_map_generator",
            sid: "Normal Map Generator",
            properties: {
                name: "Normal Map Generator",
                attributes: {
                    bumpTexture: {
                        name: "bumpTexture",
                        type: "asset",
                        filter: {
                            renderTexture2D: true,
                            texture2D: true
                        }
                    },
                    smoothness: {
                        name: "smoothness",
                        type: "f",
                        slider: true,
                        default: 0.25,
                        min: 0.0001,
                        max: 1
                    },
                    spread: {
                        name: "spread",
                        type: "f",
                        slider: true,
                        default: 4,
                        min: 1,
                        max: 10
                    },
                    autoLoad: {
                        name: "autoLoad",
                        type: "b",
                        default: true
                    }
                },
                events: {
                    renderNormalMap: {
                        scope: "local",
                        name: "renderNormalMap",
                        action: true,
                        category: "Rendering",
                        parameters: []
                    }
                },
                filter: [
                    "renderTexture2D"
                ],
                category: "Rendering"
            }
        }, NormalMapGenerator_1.default],
    [{
            id: "object_animator",
            sid: "Object Animator",
            properties: {
                name: "Object Animator",
                events: {
                    playAnimateAlongCurve: {
                        scope: "local",
                        name: "playAnimateAlongCurve",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "curve",
                                type: "object",
                                componentFilter: {
                                    Curve: true
                                }
                            },
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Time to animate to object. Defined in seconds",
                                default: 3
                            },
                            {
                                name: "easeIn",
                                type: "f",
                                description: "The percentage of animation time spent speeding up.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "easeOut",
                                type: "f",
                                description: "The percentage of animation time spent slowing down.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "orientation",
                                description: "Orient the object following the curve to either the direction of the curve or to the objects defining the curve.",
                                type: "opt",
                                default: "toCurve",
                                options: {
                                    None: "None",
                                    "To Curve": "toCurve",
                                    "To Nodes": "toNode"
                                }
                            },
                            {
                                name: "loop",
                                type: "b",
                                default: false
                            }
                        ]
                    },
                    playAnimateToObject: {
                        scope: "local",
                        name: "playAnimateToObject",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "object",
                                type: "object",
                                default: null
                            },
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Total time that the animation will take. Defined in seconds",
                                default: 3
                            },
                            {
                                name: "easeIn",
                                type: "f",
                                description: "The percentage of animation time spent speeding up.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "easeOut",
                                type: "f",
                                description: "The percentage of animation time spent slowing down.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "update orientation",
                                type: "b",
                                default: true
                            }
                        ]
                    },
                    playAnimateTranslation: {
                        scope: "local",
                        name: "playAnimateTranslation",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Time to animate. Defined in seconds",
                                default: 3
                            },
                            {
                                name: "easeIn",
                                type: "f",
                                description: "The percentage of animation time spent speeding up.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "easeOut",
                                type: "f",
                                description: "The percentage of animation time spent slowing down.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "velocity",
                                type: "v3",
                                default: {
                                    x: 0,
                                    y: 0,
                                    z: 1
                                },
                                min: -1,
                                max: 1
                            },
                            {
                                name: "objectUsage",
                                type: "opt",
                                description: "Specify what part of the animation the current object's position represents.",
                                default: "beginning",
                                options: {
                                    Beginning: "beginning",
                                    Middle: "middle",
                                    End: "end"
                                }
                            }
                        ]
                    },
                    playAnimateRotation: {
                        scope: "local",
                        name: "playAnimateRotation",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Time to animate to object. Defined in seconds",
                                default: 3
                            },
                            {
                                name: "easeIn",
                                type: "f",
                                description: "The percentage of animation time spent speeding up.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "easeOut",
                                type: "f",
                                description: "The percentage of animation time spent slowing down.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "angularVelocity",
                                type: "v3",
                                default: {
                                    x: 0,
                                    y: 0,
                                    z: 1
                                },
                                min: -100,
                                max: 100
                            },
                            {
                                name: "objectUsage",
                                type: "opt",
                                description: "Specify what part of the animation the current object's rotation represents.",
                                default: "beginning",
                                options: {
                                    Beginning: "beginning",
                                    Middle: "middle",
                                    End: "end"
                                }
                            },
                            {
                                name: "axisOrder",
                                type: "opt",
                                description: "Specify the axis order that the angular velocity will be applied in.",
                                default: "YXZ",
                                options: {
                                    XYZ: "XYZ",
                                    YXZ: "YXZ",
                                    ZXY: "ZXY",
                                    XZY: "XZY",
                                    YZX: "YZX",
                                    ZYX: "ZYX"
                                }
                            }
                        ]
                    },
                    playAnimateScale: {
                        scope: "local",
                        name: "playAnimateScale",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Time to animate to object. Defined in seconds",
                                default: 3
                            },
                            {
                                name: "easeIn",
                                type: "f",
                                description: "The percentage of animation time spent speeding up.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "easeOut",
                                type: "f",
                                description: "The percentage of animation time spent slowing down.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "velocity",
                                type: "v3",
                                default: {
                                    x: 0,
                                    y: 0,
                                    z: 1
                                },
                                min: -10,
                                max: 10
                            },
                            {
                                name: "objectUsage",
                                type: "opt",
                                description: "Specify what part of the animation the current object's scale represents.",
                                default: "beginning",
                                options: {
                                    Beginning: "beginning",
                                    Middle: "middle",
                                    End: "end"
                                }
                            }
                        ]
                    },
                    pauseCurveAnimation: {
                        scope: "local",
                        name: "pauseCurveAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    stopCurveAnimation: {
                        scope: "local",
                        name: "stopCurveAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    unpauseCurveAnimation: {
                        scope: "local",
                        name: "unpauseCurveAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    endAnimateAlongCurve: {
                        scope: "local",
                        name: "endAnimateAlongCurve",
                        action: false,
                        category: "Animation",
                        parameters: []
                    },
                    endAnimateToObject: {
                        scope: "local",
                        name: "endAnimateToObject",
                        action: false,
                        category: "Animation",
                        parameters: []
                    },
                    endAnimateTranslation: {
                        scope: "local",
                        name: "endAnimateTranslation",
                        action: false,
                        category: "Animation",
                        parameters: []
                    }
                },
                filter: [
                    "Object"
                ],
                category: "Animation"
            }
        }, ObjectAnimator_1.default],
    [{
            id: "orbit_camera",
            sid: "Orbit Camera",
            properties: {
                name: "Orbit Camera",
                description: "Allows a camera to easily orbit a point in space.",
                attributes: {
                    orbitDistance: {
                        name: "orbitDistance",
                        type: "f",
                        description: "How far the camera is positioned from the pivot point.",
                        default: 2.5,
                        max: 100000,
                        min: 0.001
                    },
                    zoomPerspectiveBounds: {
                        name: "zoomPerspectiveBounds",
                        type: "v2",
                        description: "Allows you to set how far the camera can zoom, for perspective cameras. X = min, Y = max",
                        default: {
                            x: 5,
                            y: 90
                        },
                        max: {
                            x: 180,
                            y: 180
                        },
                        min: {
                            x: 1,
                            y: 1
                        }
                    },
                    zoomOrthographicBounds: {
                        name: "zoomOrthographicBounds",
                        type: "v2",
                        description: "Allows you to set how far the camera can zoom, for ortho cameras. X = min, Y = max",
                        default: {
                            x: 0.125,
                            y: 2.5
                        },
                        max: {
                            x: 5,
                            y: 5
                        },
                        min: {
                            x: 0.01,
                            y: 0.01
                        }
                    },
                    panEnabled: {
                        name: "panEnabled",
                        type: "b",
                        default: true,
                        description: "Allow the user to pan side-to-side and up and down with the camera."
                    },
                    zoomEnabled: {
                        name: "zoomEnabled",
                        type: "b",
                        default: true,
                        description: "Allow the user to zoom in and out with the camera."
                    },
                    inertialDamping: {
                        name: "inertialDamping",
                        type: "f",
                        default: 0.2,
                        description: "How quickly the camera stops moving when input stops.",
                        min: 0,
                        max: 1
                    },
                    panSpeed: {
                        name: "panSpeed",
                        type: "f",
                        description: "The speed that the camera moves when panning.",
                        default: 2,
                        max: 2000,
                        min: 0.1
                    },
                    orbitSpeed: {
                        name: "orbitSpeed",
                        type: "f",
                        description: "The speed that the camera orbits the target.",
                        default: 2,
                        max: 1000,
                        min: 0.0001
                    },
                    zoomSpeed: {
                        name: "zoomSpeed",
                        type: "f",
                        description: "The speed that the camera moves while zooming in and out.",
                        default: 8,
                        max: 2000,
                        min: 0.1
                    },
                    pitchAngleBounds: {
                        name: "pitchAngleBounds",
                        type: "v2",
                        description: "Allows you to set how far the camera can pitch (tilt) from horizontal.",
                        default: {
                            x: 75,
                            y: -75
                        },
                        max: {
                            x: 90,
                            y: 90
                        },
                        min: {
                            x: -90,
                            y: -90.001
                        }
                    }
                },
                filter: [
                    "camera"
                ],
                category: "Camera Controllers"
            }
        }, OrbitCamera_1.default],
    [{
            id: "orbit_camera_focus",
            sid: "Orbit Camera Focus",
            properties: {
                name: "Orbit Camera Focus",
                description: "A component that allows for easy navigation of a model.",
                attributes: {
                    speed: {
                        name: "speed",
                        type: "f",
                        description: "The speed that we move to focus on the target.",
                        default: 0.8,
                        max: 100,
                        min: 0.1
                    },
                    zoomSteps: {
                        name: "zoomSteps",
                        type: "i",
                        description: "The number of steps it takes to zoom, from fully zoomed out to fully zoomed in.",
                        default: 5,
                        max: 100,
                        min: 0
                    },
                    zoomBuffer: {
                        name: "zoomBuffer",
                        type: "i",
                        description: "The distance between each focal point move. Used to decide whether or not to zoom in.",
                        default: 0.1,
                        max: 1000,
                        min: 0
                    }
                },
                filter: [
                    "camera"
                ],
                category: "Camera Controllers"
            }
        }, OrbitCameraFocus_1.default],
    [{
            id: "orbit_desktop_controls",
            sid: "Orbit Desktop Controls",
            properties: {
                name: "Orbit Desktop Controls",
                description: "Desktop controls for Orbit Camera controller",
                filter: [
                    "camera"
                ],
                category: "Camera Controllers"
            }
        }, OrbitDesktopControls_1.default],
    [{
            id: "orbit_desktop_input",
            sid: "Orbit Desktop Input",
            properties: {
                name: "Orbit Desktop Input",
                description: "Desktop input for Orbit Camera component",
                filter: [
                    "camera"
                ],
                category: "Camera Components"
            }
        }, OrbitDesktopInput_1.default],
    [{
            id: "orbit_touch_input",
            sid: "Orbit Touch Input",
            properties: {
                name: "Orbit Touch Input",
                description: "Touch input for Orbit Camera component",
                filter: [
                    "camera"
                ],
                category: "Camera Components"
            }
        }, OrbitTouchInput_1.default],
    [{
            id: "panorama_to_cube_map",
            sid: "Panorama To Cube Map",
            properties: {
                name: "Panorama To Cube Map",
                description: "Converts a panorama to a cube map.",
                attributes: {
                    inputTexture: {
                        name: "inputTexture",
                        type: "asset",
                        default: null,
                        filter: {
                            texture2D: true,
                            renderTexture2D: true
                        },
                        description: "The texture to convert to a cube map."
                    }
                },
                filter: [
                    "renderTextureCube"
                ],
                category: "Rendering"
            }
        }, PanoramaToCubeMap_1.default],
    [{
            id: "preview_axis_rotation",
            sid: "Preview Axis Rotation",
            properties: {
                name: "Preview Axis Rotation",
                description: "Set the rotation of any axis.",
                attributes: {
                    speed: {
                        name: "speed",
                        type: "f",
                        description: "The speed that we rotate the object, if a transition is triggered",
                        default: 0.4,
                        max: 100,
                        min: 0.1
                    }
                },
                filter: [
                    "object"
                ],
                category: "User Defined"
            }
        }, PreviewAxisRotation_1.default],
    [{
            id: "reflection_capture_planar",
            sid: "Reflection Capture Planar",
            properties: {
                name: "Reflection Capture Planar",
                attributes: {
                    captureTexture: {
                        name: "captureTexture",
                        type: "asset",
                        description: "The RenderTexture2D to render the reflection to.",
                        filter: {
                            renderTexture2D: true
                        }
                    },
                    clipBias: {
                        name: "clipBias",
                        type: "f",
                        description: "Pushes the rendered scene forward or backwards to adjust clipping with reflection plane.",
                        default: 0.01
                    },
                    updateFrameInterval: {
                        name: "updateFrameInterval",
                        type: "i",
                        description: "The number of frames to skip in between updates of the reflection. Default is 0.",
                        default: 0
                    }
                },
                filter: [
                    "Object"
                ],
                category: "Rendering"
            }
        }, ReflectionCapturePlanar_1.default],
    [{
            id: "box3d_renderer",
            sid: "Renderer",
            properties: {
                name: "Renderer",
                attributes: {
                    antialias: {
                        name: "antialias",
                        type: "b",
                        description: "Enable or disable anti aliasing of the rendered scene.",
                        default: true
                    },
                    preserveDrawingBuffer: {
                        name: "preserveDrawingBuffer",
                        type: "b",
                        description: "Tells the browser to preserve drawing buffers between frames so that they are available to be read by the application.",
                        default: true
                    },
                    precision: {
                        name: "precision",
                        type: "dd",
                        description: "The default floating point and integer precision to be used by the GPU.",
                        default: "mediump",
                        options: {
                            Low: "lowp",
                            Medium: "mediump",
                            High: "highp"
                        }
                    },
                    autoClear: {
                        name: "autoClear",
                        type: "b",
                        description: "Automatically clear the render target before each render.",
                        default: false
                    },
                    devicePixelRatio: {
                        name: "devicePixelRatio",
                        type: "dd",
                        default: 0,
                        options: {
                            "Device Default": 0,
                            One: 1,
                            Two: 2
                        },
                        description: "Override the default pixel ratio of the system. Higher values will cause rendering at higher resolution while lower values will force rendering at lower resolutions. You can also set this to use the device default (mobile devices usually have values greater than 1)."
                    },
                    shadowsEnabled: {
                        name: "shadowsEnabled",
                        type: "b",
                        description: "Enable or disable rendering of shadows.",
                        default: true
                    },
                    shadowsEnabledMobile: {
                        name: "shadowsEnabledMobile",
                        type: "b",
                        description: "Enable or disable rendering of shadows on mobile devices.",
                        default: false
                    },
                    shadowType: {
                        name: "shadowType",
                        type: "dd",
                        options: {
                            "Soft PCF": 2,
                            PCF: 1,
                            "No Filtering": 0
                        },
                        default: 2
                    },
                    shadowReverseSided: {
                        name: "shadowReverseSided",
                        type: "b",
                        description: "Render shadows with reverse side of mesh.",
                        default: false
                    },
                    maxTextureSize2d: {
                        name: "maxTextureSize2d",
                        type: "i",
                        description: "Clamp the maximum allowed dimension of a 2d texture.",
                        default: 32768,
                        min: 1024,
                        max: 32768
                    },
                    maxTextureSizeCube: {
                        name: "maxTextureSizeCube",
                        type: "i",
                        description: "Clamp the maximum allowed dimension of a cube texture.",
                        default: 32768,
                        min: 512,
                        max: 32768
                    },
                    clearColor: {
                        name: "clearColor",
                        type: "c",
                        description: "When the render target is cleared, this colour will be used",
                        default: {
                            r: 0,
                            g: 0,
                            b: 0
                        }
                    },
                    clearAlpha: {
                        name: "clearAlpha",
                        type: "f",
                        description: "When the render target is cleared, this value will be used to clear the transparency",
                        default: 0,
                        min: 0,
                        max: 1,
                        step: 0.001
                    },
                    renderOnDemand: {
                        name: "renderOnDemand",
                        type: "b",
                        description: "When this is enabled, rendering will only happen when requested instead of every frame.",
                        default: true
                    },
                    logarithmicDepthBuffer: {
                        name: "logarithmicDepthBuffer",
                        type: "b",
                        description: "Use logarithmic z values while rendering.",
                        default: false
                    }
                },
                filter: [
                    "application"
                ],
                category: "Rendering"
            }
        }, Renderer_1.default],
    [{
            id: "render_modes",
            sid: "Render Modes",
            properties: {
                name: "Render Modes",
                attributes: {
                    renderMode: {
                        name: "renderMode",
                        type: "number",
                        description: "How to render the scene",
                        default: 0
                    },
                    skeletonsVisible: {
                        name: "skeletonsVisible",
                        type: "b",
                        description: "Enable or disable skeleton rendering",
                        default: false
                    },
                    shapeTexture: {
                        name: "shapeTexture",
                        type: "asset",
                        description: "The texture to use with the \"Shape\" render mode",
                        filter: {
                            texture2D: true,
                            renderTexture2D: true
                        },
                        default: null
                    },
                    wireframesVisible: {
                        name: "wireframesVisible",
                        type: "b",
                        description: "Enable or disable wireframe rendering",
                        default: false
                    }
                },
                events: {
                    resetSkeletons: {
                        scope: "local",
                        name: "resetSkeletons",
                        action: true,
                        category: "Rendering",
                        parameters: []
                    },
                    setRenderMode: {
                        scope: "local",
                        name: "setRenderMode",
                        action: true,
                        category: "Rendering",
                        parameters: [
                            {
                                name: "renderMode",
                                type: "n",
                                description: "RenderMode.Lit, RenderMode.Unlit, etc.",
                                default: "Lit"
                            }
                        ]
                    },
                    setSkeletonsVisible: {
                        scope: "local",
                        name: "setSkeletonsVisible",
                        action: true,
                        category: "Rendering",
                        parameters: [
                            {
                                name: "visible",
                                type: "b",
                                description: "Whether or not skeletons are visible.",
                                default: false
                            }
                        ]
                    },
                    setWireframesVisible: {
                        scope: "local",
                        name: "setWireframesVisible",
                        action: true,
                        category: "Rendering",
                        parameters: [
                            {
                                name: "visible",
                                type: "b",
                                description: "Whether or not wireframes are visible.",
                                default: false
                            }
                        ]
                    }
                },
                filter: [
                    "Application"
                ],
                category: "Rendering"
            }
        }, RenderModes_1.default],
    [{
            id: "render_view",
            sid: "Render View",
            properties: {
                name: "Render View",
                attributes: {
                    viewportLeft: {
                        name: "viewportLeft",
                        type: "s",
                        description: "Left position of the viewport to be rendered by this camera.",
                        default: "0px"
                    },
                    viewportBottom: {
                        name: "viewportBottom",
                        type: "s",
                        description: "Bottom position of the viewport to be rendered by this camera.",
                        default: "0px"
                    },
                    viewportWidth: {
                        name: "viewportWidth",
                        type: "s",
                        description: "Width of the viewport to be rendered by this camera.",
                        default: "100%"
                    },
                    viewportHeight: {
                        name: "viewportHeight",
                        type: "s",
                        description: "Height of the viewport to be rendered by this camera.",
                        default: "100%"
                    },
                    renderGroup: {
                        name: "renderGroup",
                        type: "i",
                        description: "Render passes are done in order, based on the 'render group' value. Lower numbers render first.",
                        default: 0
                    },
                    renderLayer: {
                        name: "renderLayer",
                        type: "i",
                        description: ".",
                        default: 0,
                        min: 0
                    },
                    clearColor: {
                        name: "clearColor",
                        type: "b",
                        description: "Enable/disable color buffer clearing",
                        default: false,
                        advanced: false
                    },
                    clearDepth: {
                        name: "clearDepth",
                        type: "b",
                        description: "Enable/disable depth buffer clearing",
                        default: true,
                        advanced: false
                    },
                    renderTarget: {
                        name: "renderTarget",
                        type: "asset",
                        description: "The render texture asset to use as a render target.",
                        filter: {
                            renderTexture2D: true
                        },
                        default: null,
                        advanced: false
                    },
                    enablePreRenderFunctions: {
                        name: "enablePreRenderFunctions",
                        type: "b",
                        description: "Run pre-render functions with this view. These include things like real-time reflections, which need to be rendered for each view separately.",
                        default: true
                    },
                    enableShadows: {
                        name: "enableShadows",
                        type: "b",
                        description: "Render shadows for this view.",
                        default: true
                    },
                    opacity: {
                        name: "opacity",
                        type: "b",
                        description: "The opacity value to use while rendering.",
                        default: 1
                    },
                    overrideCameraAspect: {
                        name: "overrideCameraAspect",
                        type: "b",
                        description: "Override the aspect ratio of the camera using viewport settings.",
                        default: true
                    }
                },
                events: {
                    enableRenderView: {
                        scope: "local",
                        name: "enableRenderView",
                        category: "Rendering"
                    },
                    setViewport: {
                        scope: "local",
                        name: "setViewport",
                        category: "Rendering",
                        parameters: [
                            {
                                name: "viewportLeft",
                                description: "Left position of the viewport to be rendered by this camera.",
                                type: "s",
                                default: "0px"
                            },
                            {
                                name: "viewportBottom",
                                description: "Bottom position of the viewport to be rendered by this camera.",
                                type: "s",
                                default: "0px"
                            },
                            {
                                name: "viewportWidth",
                                description: "Width of the viewport to be rendered by this camera.",
                                type: "s",
                                default: "100%"
                            },
                            {
                                name: "viewportHeight",
                                description: "Height of the viewport to be rendered by this camera.",
                                type: "s",
                                default: "100%"
                            }
                        ]
                    },
                    disableRenderView: {
                        scope: "local",
                        name: "disableRenderView",
                        category: "Rendering"
                    },
                    toggleRenderView: {
                        scope: "local",
                        name: "toggleRenderView",
                        category: "Rendering"
                    }
                },
                filter: [
                    "camera"
                ],
                category: "Rendering"
            }
        }, RenderView_1.default],
    [{
            id: "rotate",
            sid: "Rotate",
            properties: {
                name: "Rotate",
                description: "A simple component which rotates the attached object.",
                attributes: {
                    autoRotate: {
                        name: "autoRotate",
                        type: "b",
                        description: "Automatically start the rotation upon load.",
                        default: true
                    },
                    rotation: {
                        name: "rotation",
                        type: "v3",
                        description: "Amount of rotation per second about the x, y and z axes.",
                        default: {
                            x: 0,
                            y: 0.5,
                            z: 0
                        }
                    },
                    local: {
                        name: "local",
                        type: "b",
                        description: "Rotate relative to the local quaternion of the object. If false, the rotation will be relative to the world.",
                        default: false
                    }
                },
                events: {
                    startRotate: {
                        scope: "local",
                        name: "startRotate",
                        action: true,
                        category: "Rotate",
                        parameters: []
                    },
                    stopRotate: {
                        scope: "local",
                        name: "stopRotate",
                        action: true,
                        category: "Rotate",
                        parameters: []
                    },
                    toggleRotate: {
                        scope: "local",
                        name: "toggleRotate",
                        action: true,
                        category: "Rotate",
                        parameters: []
                    }
                },
                filter: [
                    "object"
                ],
                category: "Animation"
            }
        }, Rotate_1.default],
    [{
            id: "simplex_noise_generator",
            sid: "Simplex Noise Generator",
            properties: {
                name: "Simplex Noise Generator",
                attributes: {
                    layerAmplitude: {
                        name: "layerAmplitude",
                        type: "v4",
                        default: {
                            x: 0.5,
                            y: 0.4,
                            z: 0.3,
                            w: 0.125
                        }
                    },
                    layerScale: {
                        name: "layerScale",
                        type: "v4",
                        default: {
                            x: 0.5,
                            y: 2,
                            z: 3,
                            w: 4
                        }
                    },
                    scale: {
                        name: "scale",
                        type: "v2",
                        default: {
                            x: 1,
                            y: 1
                        }
                    },
                    offset: {
                        name: "offset",
                        type: "v2",
                        default: {
                            x: 0,
                            y: 0
                        }
                    },
                    autoLoad: {
                        name: "autoLoad",
                        type: "b",
                        default: true
                    }
                },
                events: {
                    renderNoise: {
                        scope: "local",
                        name: "renderNoise",
                        action: true,
                        category: "Rendering",
                        parameters: []
                    },
                    changeNoiseValues: {
                        scope: "local",
                        name: "changeNoiseValues",
                        action: true,
                        category: "Rendering",
                        parameters: [
                            {
                                name: "layerAmplitude",
                                type: "v4",
                                description: "",
                                default: {
                                    x: 0.5,
                                    y: 0.4,
                                    z: 0.3,
                                    w: 0.125
                                }
                            },
                            {
                                name: "layerScale",
                                type: "v4",
                                description: "",
                                default: {
                                    x: 0.5,
                                    y: 2,
                                    z: 3,
                                    w: 4
                                }
                            },
                            {
                                name: "scale",
                                type: "v2",
                                description: "",
                                default: {
                                    x: 1,
                                    y: 1
                                }
                            },
                            {
                                name: "offset",
                                type: "v2",
                                description: "",
                                default: {
                                    x: 0,
                                    y: 0
                                }
                            }
                        ]
                    }
                },
                filter: [
                    "renderTexture2D"
                ],
                category: "Rendering"
            }
        }, SimplexNoiseGenerator_1.default],
    [{
            id: "skybox_renderer",
            sid: "Skybox",
            properties: {
                name: "Skybox",
                attributes: {
                    skyboxTexture: {
                        name: "skyboxTexture",
                        type: "asset",
                        description: "The texture asset to use.",
                        filter: {
                            textureCube: true,
                            texture2D: true,
                            renderTexture2D: true,
                            renderTextureCube: true
                        },
                        default: null
                    },
                    stereoEnabled: {
                        name: "stereoEnabled",
                        type: "b",
                        default: false
                    },
                    size: {
                        name: "size",
                        type: "f",
                        default: 1000,
                        min: 1,
                        max: 1000000
                    }
                },
                filter: [
                    "scene"
                ],
                category: "Rendering"
            }
        }, Skybox_1.default],
    [{
            id: "text_renderer",
            sid: "Text Renderer",
            properties: {
                name: "Text Renderer",
                description: "Render the desired text to the texture we are attached to",
                attributes: {
                    text: {
                        name: "text",
                        type: "s",
                        default: "My Text",
                        description: "Text you want to display"
                    },
                    fontColor: {
                        name: "fontColor",
                        type: "c",
                        default: {
                            r: 1,
                            g: 1,
                            b: 1
                        },
                        description: "Color of the text"
                    },
                    fontFamily: {
                        name: "fontFamily",
                        type: "s",
                        default: "Calibri",
                        description: "Font family to render"
                    },
                    pointSize: {
                        name: "pointSize",
                        type: "i",
                        default: 48,
                        description: "Font size",
                        min: 2,
                        max: 100
                    }
                },
                filter: [
                    "renderTexture2D"
                ],
                category: "Text"
            }
        }, TextRenderer_1.default],
    [{
            id: "vr_camera_controller",
            sid: "VR Camera Controller",
            properties: {
                name: "VR Camera Controller",
                filter: [
                    "camera"
                ],
                category: "Camera"
            }
        }, VrCameraController_1.default],
    [{
            id: "vr_presenter",
            sid: "VR Presenter",
            properties: {
                name: "VR Presenter",
                filter: [
                    "application"
                ],
                category: "VR"
            }
        }, VrPresenter_1.default],
    [{
            id: "vr_render_view",
            sid: "VR Render View",
            properties: {
                name: "VR Render View",
                attributes: {
                    viewportLeft: {
                        name: "viewportLeft",
                        type: "s",
                        description: "Left position of the viewport to be rendered by this camera.",
                        default: "0px"
                    },
                    viewportBottom: {
                        name: "viewportBottom",
                        type: "s",
                        description: "Bottom position of the viewport to be rendered by this camera.",
                        default: "0px"
                    },
                    viewportWidth: {
                        name: "viewportWidth",
                        type: "s",
                        description: "Width of the viewport to be rendered by this camera.",
                        default: "100%"
                    },
                    viewportHeight: {
                        name: "viewportHeight",
                        type: "s",
                        description: "Height of the viewport to be rendered by this camera.",
                        default: "100%"
                    },
                    renderGroup: {
                        name: "renderGroup",
                        type: "i",
                        description: "Render passes are done in order, based on the 'render group' value. Lower numbers render first.",
                        default: 0
                    },
                    renderLayer: {
                        name: "renderLayer",
                        type: "i",
                        description: ".",
                        default: 0,
                        min: 0
                    },
                    clearColor: {
                        name: "clearColor",
                        type: "b",
                        description: "Enable/disable color buffer clearing",
                        default: false,
                        advanced: false
                    },
                    clearDepth: {
                        name: "clearDepth",
                        type: "b",
                        description: "Enable/disable depth buffer clearing",
                        default: true,
                        advanced: false
                    },
                    renderTarget: {
                        name: "renderTarget",
                        type: "asset",
                        description: "The render texture asset to use as a render target.",
                        filter: {
                            renderTexture2D: true
                        },
                        default: null,
                        advanced: false
                    },
                    enablePreRenderFunctions: {
                        name: "enablePreRenderFunctions",
                        type: "b",
                        description: "Run pre-render functions with this view. These include things like real-time reflections, which need to be rendered for each view separately.",
                        default: true,
                        advanced: true
                    },
                    enableShadows: {
                        name: "enableShadows",
                        type: "b",
                        description: "Render shadows for this view.",
                        default: true,
                        advanced: true
                    }
                },
                filter: [
                    "camera"
                ],
                category: "Rendering"
            }
        }, VrRenderView_1.default]
];


/***/ }),
/* 223 */
/***/ (function(module, exports) {

module.exports = "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Normal map shader\n * - compute normals from bumpTexture\n */\nprecision lowp float;\nuniform float smoothness;\nuniform float spread;\nuniform vec2 resolution;\nuniform sampler2D bumpTexture;\n\nvarying vec2 vUv;\n\nvoid main() {\n  vec2 size = vec2( smoothness, 0.0 );\n  vec3 off = vec3(-spread / resolution.x, 0.0, spread / resolution.y);\n\n  vec4 wave = texture2D( bumpTexture, vUv);\n  float s11 = wave.x;\n  float s01 = texture2D( bumpTexture, vUv + off.xy ).x;\n  float s21 = texture2D( bumpTexture, vUv + off.zy ).x;\n  float s10 = texture2D( bumpTexture, vUv + off.yx ).x;\n  float s12 = texture2D( bumpTexture, vUv + off.yz ).x;\n  vec3 va = normalize(vec3( size.xy, s21-s01));\n  vec3 vb = normalize(vec3( size.yx, s12-s10));\n  vec3 norm = cross(va,vb);\n  gl_FragColor = vec4( norm * 0.5 + 0.5, s11 );\n}\n"

/***/ }),
/* 224 */
/***/ (function(module, exports) {

module.exports = "/**\n * @author alteredq / http://alteredqualia.com/\n *\n * Normal map shader\n * - compute normals from bumpTexture\n */\nvarying vec2 vUv;\n\nvoid main() {\n  vUv = uv;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n"

/***/ }),
/* 225 */
/***/ (function(module, exports) {

module.exports = "//\n// Description : Array and textureless GLSL 3D simplex noise function.\n//      Author : Ian McEwan, Ashima Arts.\n//  Maintainer : ijm\n//     Lastmod : 20110409 (stegu)\n//     License : Copyright (C) 2011 Ashima Arts. All rights reserved.\n//               Distributed under the MIT License. See LICENSE file.\n//\n//'precision lowp float;\nuniform float time;\nuniform vec4 layerAmplitude;\nuniform vec4 layerScale;\nvarying vec2 vUv;\n\nprecision highp float;\n\nvec4 permute( vec4 x ) {\n\n  return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );\n\n}\n\nvec4 taylorInvSqrt( vec4 r ) {\n\n  return 1.79284291400159 - 0.85373472095314 * r;\n\n}\n\nfloat snoise( vec3 v ) {\n\n  vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );\n  const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );\n\n  // First corner\n\n  vec3 i  = floor( v + dot( v, C.yyy ) );\n  vec3 x0 = v - i + dot( i, C.xxx );\n\n  // Other corners\n\n  vec3 g = step( x0.yzx, x0.xyz );\n  vec3 l = 1.0 - g;\n  vec3 i1 = min( g.xyz, l.zxy );\n  vec3 i2 = max( g.xyz, l.zxy );\n\n  vec3 x1 = x0 - i1 + 1.0 * C.xxx;\n  vec3 x2 = x0 - i2 + 2.0 * C.xxx;\n  vec3 x3 = x0 - 1. + 3.0 * C.xxx;\n\n  // Permutations\n\n  i = mod( i, 289.0 );\n  vec4 p = permute( permute( permute(\n    i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )\n    + i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )\n    + i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );\n\n  // Gradients\n  // ( N*N points uniformly over a square, mapped onto an octahedron.)\n\n  float n_ = 1.0 / 7.0; // N=7\n\n  vec3 ns = n_ * D.wyz - D.xzx;\n\n  vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)\n\n  vec4 x_ = floor( j * ns.z );\n  vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)\n\n  vec4 x = x_ *ns.x + ns.yyyy;\n  vec4 y = y_ *ns.x + ns.yyyy;\n  vec4 h = 1.0 - abs( x ) - abs( y );\n\n  vec4 b0 = vec4( x.xy, y.xy );\n  vec4 b1 = vec4( x.zw, y.zw );\n\n\n  vec4 s0 = floor( b0 ) * 2.0 + 1.0;\n  vec4 s1 = floor( b1 ) * 2.0 + 1.0;\n  vec4 sh = -step( h, vec4( 0.0 ) );\n\n  vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;\n  vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;\n\n  vec3 p0 = vec3( a0.xy, h.x );\n  vec3 p1 = vec3( a0.zw, h.y );\n  vec3 p2 = vec3( a1.xy, h.z );\n  vec3 p3 = vec3( a1.zw, h.w );\n\n  // Normalise gradients\n\n  vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ),\n      dot( p2, p2 ), dot( p3, p3 ) ) );\n  p0 *= norm.x;\n  p1 *= norm.y;\n  p2 *= norm.z;\n  p3 *= norm.w;\n\n  // Mix final noise value\n\n  vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ),\n      dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );\n  m = m * m;\n  return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),\n  dot( p2, x2 ), dot( p3, x3 ) ) );\n\n}\n\nfloat surface3( vec3 coord ) {\n\n  float n = 0.0;\n\n  n += layerAmplitude.x * abs( snoise( coord * layerScale.x ) );\n  n += layerAmplitude.y * abs( snoise( coord * layerScale.y ) );\n  n += layerAmplitude.z * abs( snoise( coord * layerScale.z ) );\n  n += layerAmplitude.w * abs( snoise( coord * layerScale.w ) );\n\n  return n;\n}\n\nvoid main( void ) {\n\n  vec3 coord = vec3( vUv, -time );\n  float n = surface3( coord );\n\n  gl_FragColor = vec4( vec3( n, n, n ), 1.0 );\n\n}\n"

/***/ }),
/* 226 */
/***/ (function(module, exports) {

module.exports = "varying vec2 vUv;\nuniform vec2 scale;\nuniform vec2 offset;\n\nvoid main() {\n  vUv = uv * scale + offset;\n  gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}\n"

/***/ }),
/* 227 */
/***/ (function(module, exports) {

module.exports = "#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform vec3 specular;\nuniform vec4 screenDimensions;\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n//Removed chunk from physical material <uv_pars_fragment>\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined(GLOSS_MAP) || defined(AO_MAP)\n\tvarying vec2 vUv;\n#endif\n//Removed chunk from physical material <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n//Removed chunk from physical material <aomap_pars_fragment>\n#ifdef AO_MAP\n\tuniform sampler2D aoMap;\n#endif\n//Removed chunk from physical material <lightmap_pars_fragment>\n#ifdef EMISSIVE_MAP\n#include <emissivemap_pars_fragment>\n#endif\n\n#if defined(GLOSS_MAP) && !defined(ROUGHNESS_MAP)\n\tuniform sampler2D glossMap;\n#endif\n\n#if defined(ENV_MAP_RADIANCE) || defined(ENV_MAP_IRRADIANCE)\n//Removed chunk from physical material <envmap_pars_fragment>\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform float refractionRatio;\n\n\t// This code assumes that all environment maps are of the same type (cube or 2D)\n\t// and use the same sampling transform (e.g. equirectangular projection, etc.\n\t// It is allowed that either irradiance or radiance maps can exist by themselves\n\t// but the radianceHalfGloss can only exist if the other two do.\n\t#if defined(ENV_MAP_RADIANCE_TYPE_CUBE) || defined(ENV_MAP_IRRADIANCE_TYPE_CUBE)\n\t\t#define SAMPLER_TYPE samplerCube\n\t#else\n\t\t#define SAMPLER_TYPE sampler2D\n\t#endif\n\n\t#ifdef ENV_MAP_RADIANCE\n\t\tuniform SAMPLER_TYPE envMapRadiance;\n\t#endif\n\t#if defined(ENV_MAP_RADIANCE_HALF_GLOSS) && defined(ENV_MAP_RADIANCE) && defined(ENV_MAP_IRRADIANCE)\n\t\tuniform SAMPLER_TYPE envMapRadianceHalfGloss;\n\t#endif\n\t#ifdef ENV_MAP_IRRADIANCE\n\t\tuniform SAMPLER_TYPE envMapIrradiance;\n\t#endif\n#endif\n\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n\n#undef MAXIMUM_SPECULAR_COEFFICIENT\n#define MAXIMUM_SPECULAR_COEFFICIENT 1.0\n\n\n// Overriding to remove weird reciprocal of PI factor.\nvoid RE_IndirectDiffuse_BoxPBR( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * material.diffuseColor;\n}\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nfloat BRDF_Specular_GGX_Environment_NonMetal( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tconst vec2 c0 = vec2(-1.0, -0.0275);\n\tconst vec2 c1 = vec2(1.0, 0.0425);\n\tvec2 r = roughness * c0 + c1;\n\treturn min( r.x * r.x, exp2( -9.28 * dotNV ) ) * r.x + r.y;\n}\n\nvoid RE_IndirectSpecular_BoxPBR( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight, out float fresnel ) {\n\n\t#ifdef CLEAR_COAT\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\t#if defined(METALNESS)\n\t\tfresnel = 0.0;\n\t\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#else\n\t\tfresnel = BRDF_Specular_GGX_Environment_NonMetal( geometry, material.specularColor, material.specularRoughness );\n\t\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * fresnel;\n\t#endif\n\n\n\t#ifdef CLEAR_COAT\n\t\tfresnel += BRDF_Specular_GGX_Environment_NonMetal( geometry, vec3( 1.0 ), material.clearCoatRoughness );\n\t\tfresnel = clamp(fresnel, 0.0, 1.0);\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * fresnel;\n\t#endif\n\n}\n\n#undef RE_IndirectDiffuse\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BoxPBR\n#undef RE_IndirectSpecular\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_BoxPBR\n\n#if defined(ENV_MAP_IRRADIANCE)\nvec3 getBox3DLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry ) {\n\n\t#include <normal_flip>\n\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t#ifdef ENV_MAP_IRRADIANCE_TYPE_CUBE\n\n\t\tvec3 queryVec = flipNormal * vec3( worldNormal.x, worldNormal.yz );\n\t\tvec4 envMapColor = textureCube( envMapIrradiance, queryVec );\n\n\t#elif defined( ENV_MAP_IRRADIANCE_TYPE_CUBE_UV )\n\n\t\tvec3 queryVec = flipNormal * vec3( worldNormal.x, worldNormal.yz );\n\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\n\t#else\n\n\t\tvec4 envMapColor = vec4( 0.0 );\n\n\t#endif\n\t#ifdef ENV_MAP_IRRADIANCE_ENCODING_SRGB\n\t\tenvMapColor.rgb = sRGBToLinear( envMapColor ).rgb;\n\t#endif\n\n\treturn envMapColor.rgb * envMapIntensity;\n\n}\n#endif\n\n#if defined(ENV_MAP_RADIANCE)\n\n\t#if defined(ENV_MAP_IRRADIANCE) && defined(ENV_MAP_RADIANCE_HALF_GLOSS)\n\t\tvec3 getReflectionFromRoughness(in vec3 refRadiance, in vec3 refRadianceHalf, in vec3 refIrradiance, in float roughness) {\n\t\t\tfloat interp = roughness * 2.0;\n\t\t\treturn mix(mix(refRadiance, refRadianceHalf, min(interp, 1.0)), refIrradiance, max(interp - 1.0, 0.0));\n\t\t}\n\t#else\n\t\tvec3 getReflectionFromRoughness(in vec3 refRadiance, in vec3 refIrradiance, in float roughness) {\n\t\t\tfloat interp = min(roughness * 1.5, 1.0);\n\t\t\treturn mix(refRadiance, refIrradiance, interp);\n\t\t}\n\t#endif\n\n\tvec3 getBox3DLightProbeIndirectRadiance( const in GeometricContext geometry, const in float roughness ) {\n\n\t\t#ifdef ENV_MAP_RADIANCE_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n\t\t#endif\n\n\t\t#include <normal_flip>\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tvec3 envMapColor = vec3(0.0);\n\t\tfloat radianceBias = roughness * float(ENV_MAP_RADIANCE_NUM_MIPS) * 0.5;\n\t\tvec4 envMapColorRadiance = vec4(0.0);\n\n\t\t#ifdef ENV_MAP_RADIANCE_HALF_GLOSS\n\t\t\tfloat halfGlossBias = max((roughness - 0.5) * float(ENV_MAP_RADIANCE_HALF_GLOSS_NUM_MIPS), 0.0);\n\t\t#endif\n\n\t\t// Sample the environment map(s)\n\t\t#ifdef ENV_MAP_RADIANCE_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( reflectVec.x, reflectVec.yz );\n\t\t\t#define ENV_MAP_SAMPLE_FUNCTION textureCube\n\t\t#else // PLANAR REFLECTION\n\t\t\tvec2 queryReflectVec = vec2(-1.0, 1.0) * (gl_FragCoord.xy - screenDimensions.xy) / screenDimensions.zw;\n\t\t\t#define ENV_MAP_SAMPLE_FUNCTION texture2D\n\t\t#endif\n\n\t\t// Sample env maps\n\t\tenvMapColorRadiance.rgb = ENV_MAP_SAMPLE_FUNCTION( envMapRadiance, queryReflectVec, radianceBias ).rgb;\n\n\t\t#ifdef ENV_MAP_GLOSS_VARIANCE\n\t\t\t#ifdef ENV_MAP_RADIANCE_HALF_GLOSS\n\t\t\t\tvec4 envMapColorRadianceHalf = ENV_MAP_SAMPLE_FUNCTION( envMapRadianceHalfGloss, queryReflectVec, halfGlossBias );\n\t\t\t#endif\n\t\t\t#ifdef ENV_MAP_IRRADIANCE\n\t\t\t\tvec4 envMapColorIrradiance = ENV_MAP_SAMPLE_FUNCTION( envMapIrradiance, queryReflectVec );\n\t\t\t#endif\n\t\t#endif\n\n\t\t// Blend depending on which env maps are defined.\n\t\t#ifdef ENV_MAP_RADIANCE_ENCODING_SRGB\n\t\t\tenvMapColorRadiance.rgb = sRGBToLinear( envMapColorRadiance ).rgb;\n\t\t#endif\n\n\t\t#ifdef ENV_MAP_GLOSS_VARIANCE\n\n\t\t\t#if defined(ENV_MAP_IRRADIANCE_ENCODING_SRGB)\n\t\t\t\tenvMapColorIrradiance.rgb = sRGBToLinear(envMapColorIrradiance).rgb;\n\t\t\t#endif\n\n\t\t\t#if defined(ENV_MAP_RADIANCE_HALF_GLOSS) && defined(ENV_MAP_IRRADIANCE)\n\t\t\t\t#if defined(ENV_MAP_RADIANCE_HALF_GLOSS_ENCODING_SRGB)\n\t\t\t\t\tenvMapColorRadianceHalf.rgb = sRGBToLinear( envMapColorRadianceHalf ).rgb;\n\t\t\t\t#endif\n\t\t\t\tenvMapColor = getReflectionFromRoughness(envMapColorRadiance.rgb, envMapColorRadianceHalf.rgb, envMapColorIrradiance.rgb, roughness);\n\t\t\t#elif defined(ENV_MAP_IRRADIANCE)\n\t\t\t\tenvMapColor = getReflectionFromRoughness(envMapColorRadiance.rgb, envMapColorIrradiance.rgb, roughness);\n\t\t\t#else\n\t\t\t\tenvMapColor = envMapColorRadiance.rgb;\n\t\t\t#endif\n\t\t#else\n\t\t\tenvMapColor = envMapColorRadiance.rgb;\n\t\t#endif\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n}\n#endif\n\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#ifndef METALNESS\n\t\tmetalnessFactor = 0.0;\n\t#endif\n\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\n\t#ifdef EMISSIVE_MAP\n\t\t#include <emissivemap_fragment>\n\t#endif\n\n\t// accumulation\n\t// Removed chunk from physical material <lights_physical_fragment>\n\tPhysicalMaterial material;\n\tmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\tmaterial.specularRoughness = clamp( roughnessFactor, 0.00, 1.0 );\n\t#ifdef METALNESS\n\t\tfloat reflectivityF0 = mix(DEFAULT_SPECULAR_COEFFICIENT, MAXIMUM_SPECULAR_COEFFICIENT, metalnessFactor);\n\t\tmaterial.specularColor = mix( vec3(reflectivityF0), diffuseColor.rgb, metalnessFactor );\n\t#else\n\t\tmaterial.specularColor = specular;\n\t#endif\n\tmaterial.clearCoat = saturate( clearCoat ); // Burley clearcoat model\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n\n\t// Sample gloss map and modify specular roughness\n\t#if defined(GLOSS_MAP) && !defined(ROUGHNESS_MAP)\n\t\tvec4 texelGloss = texture2D( glossMap, vUv );\n\t\tmaterial.specularRoughness = min(material.specularRoughness + 1.0 - texelGloss.r, 1.0);\n\t#endif\n\n\tGeometricContext geometry;\n\n\tgeometry.position = - vViewPosition;\n\tgeometry.normal = normal;\n\tgeometry.viewDir = normalize( vViewPosition );\n\n\tIncidentLight directLight;\n\n\t#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\t\tPointLight pointLight;\n\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\t\tpointLight = pointLights[ i ];\n\n\t\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t\t#ifdef USE_SHADOWMAP\n\t\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t\t#endif\n\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t}\n\n\t#endif\n\n\t#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\t\tSpotLight spotLight;\n\n\t\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\t\tspotLight = spotLights[ i ];\n\n\t\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t\t#ifdef USE_SHADOWMAP\n\t\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t\t#endif\n\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t}\n\n\t#endif\n\n\t#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\t\tDirectionalLight directionalLight;\n\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\n\t\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t\t#ifdef USE_SHADOWMAP\n\t\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t\t#endif\n\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t}\n\n\t#endif\n\n\t#if defined( RE_IndirectDiffuse )\n\n\t\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t\t#ifdef USE_LIGHTMAP\n\n\t\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n\t\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n\t\t\t#endif\n\n\t\t\tirradiance += lightMapIrradiance;\n\n\t\t#endif\n\n\t\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t\t}\n\n\t\t#endif\n\n\t\t#if defined(ENV_MAP_IRRADIANCE)\n\n\t\t\tirradiance += getBox3DLightProbeIndirectIrradiance( /*lightProbe,*/ geometry );\n\n\t\t#endif\n\n\t\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n\t#endif\n\n\t#if defined(ENV_MAP_RADIANCE) && defined( RE_IndirectSpecular )\n\n\t\tvec3 radiance = getBox3DLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, material.specularRoughness );\n\t\t#ifdef CLEAR_COAT\n\t\t\tvec3 clearCoatRadiance = getBox3DLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, material.clearCoatRoughness );\n\t\t#else\n\t\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t\t#endif\n\t\tfloat fresnel = 0.0;\n\t\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight, fresnel );\n\t\tdiffuseColor.a += 2.0 * fresnel; // The factor of 2 is just a rough guess and not based on anything...\n\t\tdiffuseColor.a = min(diffuseColor.a, 1.0);\n\n\t#endif\n\n\t#if defined(AO_MAP)\n\t\t//Removed chunk <aomap_fragment> Overriding so that we can use vUv instead of vUv2\n\t\tfloat ambientOcclusion = texture2D( aoMap, vUv ).r;\n\t\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t\t#endif\n\t#endif\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}\n"

/***/ }),
/* 228 */
/***/ (function(module, exports) {

module.exports = "#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n// Removed chunk from physical material <uv_pars_vertex>\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined( GLOSS_MAP ) || defined(AO_MAP)\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n// Removed chunk from physical material <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t// Removed chunk from physical material <uv_vertex>\n\t#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined( GLOSS_MAP ) || defined(AO_MAP)\n\t\tvUv = uv;\n\t\tvUv.y = 1.0 - vUv.y;\n\t#endif\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\n}"

/***/ }),
/* 229 */
/***/ (function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Ajv = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

module.exports = {
  setup: setupAsync,
  compile: compileAsync
};


var util = require('./compile/util');

var ASYNC = {
  '*': checkGenerators,
  'co*': checkGenerators,
  'es7': checkAsyncFunction
};

var TRANSPILE = {
  'nodent': getNodent,
  'regenerator': getRegenerator
};

var MODES = [
  { async: 'co*' },
  { async: 'es7', transpile: 'nodent' },
  { async: 'co*', transpile: 'regenerator' }
];


var regenerator, nodent;


function setupAsync(opts, required) {
  if (required !== false) required = true;
  var async = opts.async
    , transpile = opts.transpile
    , check;

  switch (typeof transpile) {
    case 'string':
      var get = TRANSPILE[transpile];
      if (!get) throw new Error('bad transpiler: ' + transpile);
      return (opts._transpileFunc = get(opts, required));
    case 'undefined':
    case 'boolean':
      if (typeof async == 'string') {
        check = ASYNC[async];
        if (!check) throw new Error('bad async mode: ' + async);
        return (opts.transpile = check(opts, required));
      }

      for (var i=0; i<MODES.length; i++) {
        var _opts = MODES[i];
        if (setupAsync(_opts, false)) {
          util.copy(_opts, opts);
          return opts.transpile;
        }
      }
      /* istanbul ignore next */
      throw new Error('generators, nodent and regenerator are not available');
    case 'function':
      return (opts._transpileFunc = opts.transpile);
    default:
      throw new Error('bad transpiler: ' + transpile);
  }
}


function checkGenerators(opts, required) {
  /* jshint evil: true */
  try {
    (new Function('(function*(){})()'))();
    return true;
  } catch(e) {
    /* istanbul ignore next */
    if (required) throw new Error('generators not supported');
  }
}


function checkAsyncFunction(opts, required) {
  /* jshint evil: true */
  try {
    (new Function('(async function(){})()'))();
    /* istanbul ignore next */
    return true;
  } catch(e) {
    if (required) throw new Error('es7 async functions not supported');
  }
}


function getRegenerator(opts, required) {
  try {
    if (!regenerator) {
      var name = 'regenerator';
      regenerator = require(name);
      regenerator.runtime();
    }
    if (!opts.async || opts.async === true)
      opts.async = 'es7';
    return regeneratorTranspile;
  } catch(e) {
    /* istanbul ignore next */
    if (required) throw new Error('regenerator not available');
  }
}


function regeneratorTranspile(code) {
  return regenerator.compile(code).code;
}


function getNodent(opts, required) {
  /* jshint evil: true */
  try {
    if (!nodent) {
      var name = 'nodent';
      nodent = require(name)({ log: false, dontInstallRequireHook: true });
    }
    if (opts.async != 'es7') {
      if (opts.async && opts.async !== true) console.warn('nodent transpiles only es7 async functions');
      opts.async = 'es7';
    }
    return nodentTranspile;
  } catch(e) {
    /* istanbul ignore next */
    if (required) throw new Error('nodent not available');
  }
}


function nodentTranspile(code) {
  return nodent.compile(code, '', { promises: true, sourcemap: false }).code;
}


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and node-style callback.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Function} callback node-style callback, it is always called with 2 parameters: error (or null) and validating function.
 */
function compileAsync(schema, callback) {
  /* eslint no-shadow: 0 */
  /* jshint validthis: true */
  var schemaObj;
  var self = this;
  try {
    schemaObj = this._addSchema(schema);
  } catch(e) {
    setTimeout(function() { callback(e); });
    return;
  }
  if (schemaObj.validate) {
    setTimeout(function() { callback(null, schemaObj.validate); });
  } else {
    if (typeof this._opts.loadSchema != 'function')
      throw new Error('options.loadSchema should be a function');
    _compileAsync(schema, callback, true);
  }


  function _compileAsync(schema, callback, firstCall) {
    var validate;
    try { validate = self.compile(schema); }
    catch(e) {
      if (e.missingSchema) loadMissingSchema(e);
      else deferCallback(e);
      return;
    }
    deferCallback(null, validate);

    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (self._refs[ref] || self._schemas[ref])
        return callback(new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved'));
      var _callbacks = self._loadingSchemas[ref];
      if (_callbacks) {
        if (typeof _callbacks == 'function')
          self._loadingSchemas[ref] = [_callbacks, schemaLoaded];
        else
          _callbacks[_callbacks.length] = schemaLoaded;
      } else {
        self._loadingSchemas[ref] = schemaLoaded;
        self._opts.loadSchema(ref, function (err, sch) {
          var _callbacks = self._loadingSchemas[ref];
          delete self._loadingSchemas[ref];
          if (typeof _callbacks == 'function') {
            _callbacks(err, sch);
          } else {
            for (var i=0; i<_callbacks.length; i++)
              _callbacks[i](err, sch);
          }
        });
      }

      function schemaLoaded(err, sch) {
        if (err) return callback(err);
        if (!(self._refs[ref] || self._schemas[ref])) {
          try {
            self.addSchema(sch, ref);
          } catch(e) {
            callback(e);
            return;
          }
        }
        _compileAsync(schema, callback);
      }
    }

    function deferCallback(err, validate) {
      if (firstCall) setTimeout(function() { callback(err, validate); });
      else return callback(err, validate);
    }
  }
}

},{"./compile/util":11}],2:[function(require,module,exports){
'use strict';


var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};

},{}],3:[function(require,module,exports){
'use strict';

//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
  '$ref': require('../dotjs/ref'),
  allOf: require('../dotjs/allOf'),
  anyOf: require('../dotjs/anyOf'),
  dependencies: require('../dotjs/dependencies'),
  'enum': require('../dotjs/enum'),
  format: require('../dotjs/format'),
  items: require('../dotjs/items'),
  maximum: require('../dotjs/_limit'),
  minimum: require('../dotjs/_limit'),
  maxItems: require('../dotjs/_limitItems'),
  minItems: require('../dotjs/_limitItems'),
  maxLength: require('../dotjs/_limitLength'),
  minLength: require('../dotjs/_limitLength'),
  maxProperties: require('../dotjs/_limitProperties'),
  minProperties: require('../dotjs/_limitProperties'),
  multipleOf: require('../dotjs/multipleOf'),
  not: require('../dotjs/not'),
  oneOf: require('../dotjs/oneOf'),
  pattern: require('../dotjs/pattern'),
  properties: require('../dotjs/properties'),
  required: require('../dotjs/required'),
  uniqueItems: require('../dotjs/uniqueItems'),
  validate: require('../dotjs/validate')
};

},{"../dotjs/_limit":14,"../dotjs/_limitItems":15,"../dotjs/_limitLength":16,"../dotjs/_limitProperties":17,"../dotjs/allOf":18,"../dotjs/anyOf":19,"../dotjs/dependencies":22,"../dotjs/enum":23,"../dotjs/format":24,"../dotjs/items":25,"../dotjs/multipleOf":26,"../dotjs/not":27,"../dotjs/oneOf":28,"../dotjs/pattern":29,"../dotjs/properties":31,"../dotjs/ref":32,"../dotjs/required":33,"../dotjs/uniqueItems":35,"../dotjs/validate":36}],4:[function(require,module,exports){
'use strict';

/*eslint complexity: 0*/

module.exports = function equal(a, b) {
  if (a === b) return true;

  var arrA = Array.isArray(a)
    , arrB = Array.isArray(b)
    , i;

  if (arrA && arrB) {
    if (a.length != b.length) return false;
    for (i = 0; i < a.length; i++)
      if (!equal(a[i], b[i])) return false;
    return true;
  }

  if (arrA != arrB) return false;

  if (a && b && typeof a === 'object' && typeof b === 'object') {
    var keys = Object.keys(a);
    if (keys.length !== Object.keys(b).length) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA && dateB) return a.getTime() == b.getTime();
    if (dateA != dateB) return false;

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA && regexpB) return a.toString() == b.toString();
    if (regexpA != regexpB) return false;

    for (i = 0; i < keys.length; i++)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = 0; i < keys.length; i++)
      if(!equal(a[keys[i]], b[keys[i]])) return false;

    return true;
  }

  return false;
};

},{}],5:[function(require,module,exports){
'use strict';

var util = require('./util');

var DATE = /^\d\d\d\d-(\d\d)-(\d\d)$/;
var DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
var HOSTNAME = /^[0-9a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\.[0-9a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*)?(?:\#(?:[a-z0-9\-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*)?$/i;
var UUID = /^(?:urn\:uuid\:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~\/]|~0|~1)*)*$|^\#(?:\/(?:[a-z0-9_\-\.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:\#|(?:\/(?:[^~\/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  var formatDefs = util.copy(formats[mode]);
  for (var fName in formats.compare) {
    formatDefs[fName] = {
      validate: formatDefs[fName],
      compare: formats.compare[fName]
    };
  }
  return formatDefs;
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*)?(?:\:|\/)\/?[^\s]*$/i,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  email: /^[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&''*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: hostname,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.compare = {
  date: compareDate,
  time: compareTime,
  'date-time': compareDateTime
};


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var month = +matches[1];
  var day = +matches[2];
  return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


function hostname(str) {
  // https://tools.ietf.org/html/rfc1034#section-3.5
  // https://tools.ietf.org/html/rfc1123#section-2
  return str.length <= 255 && HOSTNAME.test(str);
}


var NOT_URI_FRAGMENT = /\/|\:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


function regex(str) {
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}


function compareDate(d1, d2) {
  if (!(d1 && d2)) return;
  if (d1 > d2) return 1;
  if (d1 < d2) return -1;
  if (d1 === d2) return 0;
}


function compareTime(t1, t2) {
  if (!(t1 && t2)) return;
  t1 = t1.match(TIME);
  t2 = t2.match(TIME);
  if (!(t1 && t2)) return;
  t1 = t1[1] + t1[2] + t1[3] + (t1[4]||'');
  t2 = t2[1] + t2[2] + t2[3] + (t2[4]||'');
  if (t1 > t2) return 1;
  if (t1 < t2) return -1;
  if (t1 === t2) return 0;
}


function compareDateTime(dt1, dt2) {
  if (!(dt1 && dt2)) return;
  dt1 = dt1.split(DATE_TIME_SEPARATOR);
  dt2 = dt2.split(DATE_TIME_SEPARATOR);
  var res = compareDate(dt1[0], dt2[0]);
  if (res === undefined) return;
  return res || compareTime(dt1[1], dt2[1]);
}

},{"./util":11}],6:[function(require,module,exports){
'use strict';

var resolve = require('./resolve')
  , util = require('./util')
  , stableStringify = require('json-stable-stringify')
  , async = require('../async');

var beautify;

function loadBeautify(){
  if (beautify === undefined) {
    var name = 'js-beautify';
    try { beautify = require(name).js_beautify; }
    catch(e) { beautify = false; }
  }
}

var validateGenerator = require('../dotjs/validate');

/**
 * Functions below are used inside compiled validations function
 */

var co = require('co');
var ucs2length = util.ucs2length;
var equal = require('./equal');

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = require('./validation_error');

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = []
    , keepSourceCode = opts.sourceCode !== false;

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (keepSourceCode) cv.sourceCode = v.sourceCode;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  function callValidate() {
    var validate = compilation.validate;
    var result = validate.apply(null, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;
    if ($async && !opts.transpile) async.setup(opts);

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.beautify) {
      loadBeautify();
      /* istanbul ignore else */
      if (beautify) sourceCode = beautify(sourceCode, opts.beautify);
      else console.error('"npm install js-beautify" to use beautify option');
    }
    // console.log('\n\n\n *** \n', sourceCode);
    var validate, validateCode
      , transpile = opts._transpileFunc;
    try {
      validateCode = $async && transpile
                      ? transpile(sourceCode)
                      : sourceCode;

      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'co',
        'equal',
        'ucs2length',
        'ValidationError',
        validateCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        co,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      console.error('Error compiling schema, function code:', validateCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (keepSourceCode) validate.sourceCode = sourceCode;
    if (opts.sourceCode === true) {
      validate.source = {
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (!v) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v) {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    var validateSchema = rule.definition.validateSchema;
    if (validateSchema && self._opts.validateSchema !== false) {
      var valid = validateSchema(schema);
      if (!valid) {
        var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
        if (self._opts.validateSchema == 'log') console.error(message);
        else throw new Error(message);
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
    }

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] ? 'var refVal' + i + ' = refVal[' + i + '];' : '';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}

},{"../async":1,"../dotjs/validate":36,"./equal":4,"./resolve":7,"./util":11,"./validation_error":12,"co":47,"json-stable-stringify":48}],7:[function(require,module,exports){
'use strict';

var url = require('url')
  , equal = require('./equal')
  , util = require('./util')
  , SchemaObject = require('./schema_obj');

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = url.parse(ref, false, true)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(root.schema.id);
  if (refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(root.schema.id);
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    if (schema.id) baseId = resolveUrl(baseId, schema.id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.hash = parsedRef.hash || '';
  if (parsedRef.hash.slice(0,2) != '#/') return;
  var parts = parsedRef.hash.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (!schema) break;
      if (schema.id && !PREVENT_SCOPE_CHANGE[part]) baseId = resolveUrl(baseId, schema.id);
      if (schema.$ref) {
        var $ref = resolveUrl(baseId, schema.$ref);
        var res = resolveSchema.call(this, root, $ref);
        if (res) {
          schema = res.schema;
          root = res.root;
          baseId = res.baseId;
        }
      }
    }
  }
  if (schema && schema != root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = url.parse(id, false, true);
  return _getFullPath(p);
}


function _getFullPath(p) {
  var protocolSeparator = p.protocol || p.href.slice(0,2) == '//' ? '//' : '';
  return (p.protocol||'') + protocolSeparator + (p.host||'') + (p.path||'')  + '#';
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return url.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  /* eslint no-shadow: 0 */
  /* jshint validthis: true */
  var id = normalizeId(schema.id);
  var localRefs = {};
  _resolveIds.call(this, schema, getFullPath(id, false), id);
  return localRefs;

  /* @this Ajv */
  function _resolveIds(schema, fullPath, baseId) {
    /* jshint validthis: true */
    if (Array.isArray(schema)) {
      for (var i=0; i<schema.length; i++)
        _resolveIds.call(this, schema[i], fullPath+'/'+i, baseId);
    } else if (schema && typeof schema == 'object') {
      if (typeof schema.id == 'string') {
        var id = baseId = baseId
                          ? url.resolve(baseId, schema.id)
                          : schema.id;
        id = normalizeId(id);

        var refVal = this._refs[id];
        if (typeof refVal == 'string') refVal = this._refs[refVal];
        if (refVal && refVal.schema) {
          if (!equal(schema, refVal.schema))
            throw new Error('id "' + id + '" resolves to more than one schema');
        } else if (id != normalizeId(fullPath)) {
          if (id[0] == '#') {
            if (localRefs[id] && !equal(schema, localRefs[id]))
              throw new Error('id "' + id + '" resolves to more than one schema');
            localRefs[id] = schema;
          } else {
            this._refs[id] = fullPath;
          }
        }
      }
      for (var key in schema)
        _resolveIds.call(this, schema[key], fullPath+'/'+util.escapeFragment(key), baseId);
    }
  }
}

},{"./equal":4,"./schema_obj":9,"./util":11,"url":45}],8:[function(require,module,exports){
'use strict';

var ruleModules = require('./_rules')
  , toHash = require('./util').toHash;

module.exports = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ 'maximum', 'minimum', 'multipleOf'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'uniqueItems', 'items' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'properties' ] },
    { rules: [ '$ref', 'enum', 'not', 'anyOf', 'oneOf', 'allOf' ] }
  ];

  var ALL = [ 'type', 'additionalProperties', 'patternProperties' ];
  var KEYWORDS = [ 'additionalItems', '$schema', 'id', 'title', 'description', 'default' ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword]
      };
      return rule;
    });
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.types = toHash(TYPES);
  RULES.custom = {};

  return RULES;
};

},{"./_rules":3,"./util":11}],9:[function(require,module,exports){
'use strict';

var util = require('./util');

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}

},{"./util":11}],10:[function(require,module,exports){
'use strict';

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};

},{}],11:[function(require,module,exports){
'use strict';


module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  ucs2length: require('./ucs2length'),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  cleanUpVarErrors: cleanUpVarErrors,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  stableStringify: require('json-stable-stringify'),
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


var EMPTY_ELSE = /else\s*{\s*}/g
  , EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, '')
            .replace(EMPTY_IF_NO_ELSE, '')
            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
}


var ERRORS_REGEXP = /[^v\.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = 'return errors === 0;'
  , RETURN_TRUE = 'validate.errors = null; return true;'
  , RETURN_ASYNC = /if \(errors === 0\) return true;\s*else throw new ValidationError\(vErrors\);/
  , RETURN_TRUE_ASYNC = 'return true;';

function cleanUpVarErrors(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (!matches || matches.length !== 2) return out;
  return async
          ? out.replace(REMOVE_ERRORS_ASYNC, '')
               .replace(RETURN_ASYNC, RETURN_TRUE_ASYNC)
          : out.replace(REMOVE_ERRORS, '')
               .replace(RETURN_VALID, RETURN_TRUE);
}


function schemaHasRules(schema, rules) {
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/' \+ '/g, '');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}

},{"./ucs2length":10,"json-stable-stringify":48}],12:[function(require,module,exports){
'use strict';

module.exports = ValidationError;


function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;

},{}],13:[function(require,module,exports){
'use strict';
module.exports = function generate__formatLimit(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  out += 'var ' + ($valid) + ' = undefined;';
  if (it.opts.format === false) {
    out += ' ' + ($valid) + ' = true; ';
    return out;
  }
  var $schemaFormat = it.schema.format,
    $isDataFormat = it.opts.v5 && $schemaFormat.$data,
    $closingBraces = '';
  if ($isDataFormat) {
    var $schemaValueFormat = it.util.getData($schemaFormat.$data, $dataLvl, it.dataPathArr),
      $format = 'format' + $lvl,
      $compare = 'compare' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValueFormat) + '] , ' + ($compare) + ' = ' + ($format) + ' && ' + ($format) + '.compare;';
  } else {
    var $format = it.formats[$schemaFormat];
    if (!($format && $format.compare)) {
      out += '  ' + ($valid) + ' = true; ';
      return out;
    }
    var $compare = 'formats' + it.util.getProperty($schemaFormat) + '.compare';
  }
  var $isMax = $keyword == 'formatMaximum',
    $exclusiveKeyword = 'formatExclusive' + ($isMax ? 'Maximum' : 'Minimum'),
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.v5 && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $result = 'result' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' if (typeof ' + ($schemaValueExcl) + ' != \'boolean\' && ' + ($schemaValueExcl) + ' !== undefined) { ' + ($valid) + ' = false; ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_formatExclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' }  ';
    if ($breakOnError) {
      $closingBraces += '}';
      out += ' else { ';
    }
    if ($isData) {
      out += ' if (' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'string\') ' + ($valid) + ' = false; else { ';
      $closingBraces += '}';
    }
    if ($isDataFormat) {
      out += ' if (!' + ($compare) + ') ' + ($valid) + ' = true; else { ';
      $closingBraces += '}';
    }
    out += ' var ' + ($result) + ' = ' + ($compare) + '(' + ($data) + ',  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += ' ); if (' + ($result) + ' === undefined) ' + ($valid) + ' = false; var ' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true; if (' + ($valid) + ' === undefined) { ' + ($valid) + ' = ' + ($exclusive) + ' ? ' + ($result) + ' ' + ($op) + ' 0 : ' + ($result) + ' ' + ($op) + '= 0; } if (!' + ($valid) + ') var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\';';
  } else {
    var $exclusive = $schemaExcl === true,
      $opStr = $op;
    if (!$exclusive) $opStr += '=';
    var $opExpr = '\'' + $opStr + '\'';
    if ($isData) {
      out += ' if (' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'string\') ' + ($valid) + ' = false; else { ';
      $closingBraces += '}';
    }
    if ($isDataFormat) {
      out += ' if (!' + ($compare) + ') ' + ($valid) + ' = true; else { ';
      $closingBraces += '}';
    }
    out += ' var ' + ($result) + ' = ' + ($compare) + '(' + ($data) + ',  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += ' ); if (' + ($result) + ' === undefined) ' + ($valid) + ' = false; if (' + ($valid) + ' === undefined) ' + ($valid) + ' = ' + ($result) + ' ' + ($op);
    if (!$exclusive) {
      out += '=';
    }
    out += ' 0;';
  }
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_formatLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += ' , exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '}';
  return out;
}

},{}],14:[function(require,module,exports){
'use strict';
module.exports = function generate__limit(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.v5 && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<';
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var exclusive' + ($lvl) + '; if (typeof ' + ($schemaValueExcl) + ' != \'boolean\' && typeof ' + ($schemaValueExcl) + ' != \'undefined\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ((exclusive' + ($lvl) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ') || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = exclusive' + ($lvl) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\';';
  } else {
    var $exclusive = $schemaExcl === true,
      $opStr = $op;
    if (!$exclusive) $opStr += '=';
    var $opExpr = '\'' + $opStr + '\'';
    out += ' if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ' + ($data) + ' ' + ($notOp);
    if ($exclusive) {
      out += '=';
    }
    out += ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') {';
  }
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schema) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],15:[function(require,module,exports){
'use strict';
module.exports = function generate__limitItems(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'less';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],16:[function(require,module,exports){
'use strict';
module.exports = function generate__limitLength(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],17:[function(require,module,exports){
'use strict';
module.exports = function generate__limitProperties(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'less';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],18:[function(require,module,exports){
'use strict';
module.exports = function generate_allOf(it, $keyword) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],19:[function(require,module,exports){
'use strict';
module.exports = function generate_anyOf(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return it.util.schemaHasRules($sch, it.RULES.all);
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}

},{}],20:[function(require,module,exports){
'use strict';
module.exports = function generate_constant(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'constant') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  return out;
}

},{}],21:[function(require,module,exports){
'use strict';
module.exports = function generate_custom(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $validate = $rDef.validate,
    $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if ($validateSchema) {
    out += ' ' + ($valid) + ' = ' + ($definition) + '.validateSchema(' + ($schemaValue) + '); if (' + ($valid) + ') {';
  }
  if ($inline) {
    if ($rDef.statements) {
      out += ' ' + ($ruleValidate.validate) + ' ';
    } else {
      out += ' ' + ($valid) + ' = ' + ($ruleValidate.validate) + '; ';
    }
  } else if ($macro) {
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors === false) {
      out += ' ' + ($valid) + ' = ';
      if ($asyncKeyword) {
        out += '' + (it.yieldAwait);
      }
      out += '' + (def_callRuleValidate) + '; ';
    } else {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { ' + ($valid) + ' = ' + (it.yieldAwait) + (def_callRuleValidate) + '; } catch (e) { ' + ($valid) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($ruleErrs) + ' = null; ' + ($valid) + ' = ' + (def_callRuleValidate) + '; ';
      }
    }
  }
  if ($rDef.modifying) {
    out += ' ' + ($data) + ' = ' + ($parentData) + '[' + ($parentDataProperty) + '];';
  }
  if ($validateSchema) {
    out += ' }';
  }
  if ($rDef.valid) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  } else {
    out += ' if ( ';
    if ($rDef.valid === undefined) {
      out += ' !';
      if ($macro) {
        out += '' + ($nextValid);
      } else {
        out += '' + ($valid);
      }
    } else {
      out += ' ' + (!$rDef.valid) + ' ';
    }
    out += ') { ';
    $errorKeyword = $rule.keyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    var def_customError = out;
    out = $$outStack.pop();
    if ($inline) {
      if ($rDef.errors) {
        if ($rDef.errors != 'full') {
          out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } ';
        }
      } else {
        if ($rDef.errors === false) {
          out += ' ' + (def_customError) + ' ';
        } else {
          out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
          if (it.opts.verbose) {
            out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
          }
          out += ' } } ';
        }
      }
    } else if ($macro) {
      out += '   var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError(vErrors); ';
        } else {
          out += ' validate.errors = vErrors; return false; ';
        }
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';  ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } else { ' + (def_customError) + ' } ';
      }
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  }
  return out;
}

},{}],22:[function(require,module,exports){
'use strict';
module.exports = function generate_dependencies(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {};
  for ($property in $schema) {
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    out += ' if (' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
    if ($breakOnError) {
      out += ' && ( ';
      var arr1 = $deps;
      if (arr1) {
        var _$property, $i = -1,
          l1 = arr1.length - 1;
        while ($i < l1) {
          _$property = arr1[$i += 1];
          if ($i) {
            out += ' || ';
          }
          var $prop = it.util.getProperty(_$property);
          out += ' ( ' + ($data) + ($prop) + ' === undefined && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? _$property : $prop)) + ') ) ';
        }
      }
      out += ')) {  ';
      var $propertyPath = 'missing' + $lvl,
        $missingProperty = '\' + ' + $propertyPath + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should have ';
          if ($deps.length == 1) {
            out += 'property ' + (it.util.escapeQuotes($deps[0]));
          } else {
            out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
          }
          out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      out += ' ) { ';
      var arr2 = $deps;
      if (arr2) {
        var $reqProperty, i2 = -1,
          l2 = arr2.length - 1;
        while (i2 < l2) {
          $reqProperty = arr2[i2 += 1];
          var $prop = it.util.getProperty($reqProperty),
            $missingProperty = it.util.escapeQuotes($reqProperty);
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPath($currentErrorPath, $reqProperty, it.opts.jsonPointers);
          }
          out += ' if (' + ($data) + ($prop) + ' === undefined) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should have ';
              if ($deps.length == 1) {
                out += 'property ' + (it.util.escapeQuotes($deps[0]));
              } else {
                out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
              }
              out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
        }
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      $closingBraces += '}';
      out += ' else { ';
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if (it.util.schemaHasRules($sch, it.RULES.all)) {
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + (it.util.getProperty($property)) + ' !== undefined) { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],23:[function(require,module,exports){
'use strict';
module.exports = function generate_enum(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],24:[function(require,module,exports){
'use strict';
module.exports = function generate_format(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var isObject' + ($lvl) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; if (isObject' + ($lvl) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats === true || $allowUnknown) {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? ' + (it.yieldAwait) + ' ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats === true || ($allowUnknown && $unknownFormats.indexOf($schema) == -1)) {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      } else {
        if (!$allowUnknown) {
          console.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
          if ($unknownFormats !== 'ignore') console.warn('In the next major version it will throw exception. See option unknownFormats for more information');
        }
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(' + (it.yieldAwait) + ' ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],25:[function(require,module,exports){
'use strict';
module.exports = function generate_items(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],26:[function(require,module,exports){
'use strict';
module.exports = function generate_multipleOf(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schema) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],27:[function(require,module,exports){
'use strict';
module.exports = function generate_not(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
}

},{}],28:[function(require,module,exports){
'use strict';
module.exports = function generate_oneOf(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;var prevValid' + ($lvl) + ' = false;var ' + ($valid) + ' = false;';
  var $currentBaseId = $it.baseId;
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && prevValid' + ($lvl) + ') ' + ($valid) + ' = false; else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') ' + ($valid) + ' = prevValid' + ($lvl) + ' = true;';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
}

},{}],29:[function(require,module,exports){
'use strict';
module.exports = function generate_pattern(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],30:[function(require,module,exports){
'use strict';
module.exports = function generate_patternRequired(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $key = 'key' + $lvl,
    $matched = 'patternMatched' + $lvl,
    $closingBraces = '',
    $ownProperties = it.opts.ownProperties;
  out += 'var ' + ($valid) + ' = true;';
  var arr1 = $schema;
  if (arr1) {
    var $pProperty, i1 = -1,
      l1 = arr1.length - 1;
    while (i1 < l1) {
      $pProperty = arr1[i1 += 1];
      out += ' var ' + ($matched) + ' = false; for (var ' + ($key) + ' in ' + ($data) + ') {  ';
      if ($ownProperties) {
        out += ' if (!Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($key) + ')) continue; ';
      }
      out += ' ' + ($matched) + ' = ' + (it.usePattern($pProperty)) + '.test(' + ($key) + '); if (' + ($matched) + ') break; } ';
      var $missingPattern = it.util.escapeQuotes($pProperty);
      out += ' if (!' + ($matched) + ') { ' + ($valid) + ' = false;  var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'patternRequired') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingPattern: \'' + ($missingPattern) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should have property matching pattern \\\'' + ($missingPattern) + '\\\'\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  out += '' + ($closingBraces);
  return out;
}

},{}],31:[function(require,module,exports){
'use strict';
module.exports = function generate_properties(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt;
  var $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  if (it.opts.v5) {
    var $pgProperties = it.schema.patternGroups || {},
      $pgPropertyKeys = Object.keys($pgProperties);
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($checkAdditional) {
    out += ' for (var ' + ($key) + ' in ' + ($data) + ') {  ';
    if ($ownProperties) {
      out += ' if (!Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($key) + ')) continue; ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 5) {
          out += ' || validate.schema' + ($schemaPath) + '[' + ($key) + '] ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      if (it.opts.v5 && $pgPropertyKeys && $pgPropertyKeys.length) {
        var arr3 = $pgPropertyKeys;
        if (arr3) {
          var $pgProperty, $i = -1,
            l3 = arr3.length - 1;
          while ($i < l3) {
            $pgProperty = arr3[$i += 1];
            out += ' || ' + (it.usePattern($pgProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should NOT have additional properties\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr4 = $schemaKeys;
    if (arr4) {
      var $propertyKey, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $propertyKey = arr4[i4 += 1];
        var $sch = $schema[$propertyKey];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if (' + ($useData) + ' === undefined) { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if (' + ($useData) + ' === undefined) { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  var arr5 = $pPropertyKeys;
  if (arr5) {
    var $pProperty, i5 = -1,
      l5 = arr5.length - 1;
    while (i5 < l5) {
      $pProperty = arr5[i5 += 1];
      var $sch = $pProperties[$pProperty];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
        $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
        out += ' for (var ' + ($key) + ' in ' + ($data) + ') {  ';
        if ($ownProperties) {
          out += ' if (!Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($key) + ')) continue; ';
        }
        out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
        $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
        var $passData = $data + '[' + $key + ']';
        $it.dataPathArr[$dataNxt] = $key;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
        } else {
          out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
        }
        if ($breakOnError) {
          out += ' if (!' + ($nextValid) + ') break; ';
        }
        out += ' } ';
        if ($breakOnError) {
          out += ' else ' + ($nextValid) + ' = true; ';
        }
        out += ' }  ';
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if (it.opts.v5) {
    var arr6 = $pgPropertyKeys;
    if (arr6) {
      var $pgProperty, i6 = -1,
        l6 = arr6.length - 1;
      while (i6 < l6) {
        $pgProperty = arr6[i6 += 1];
        var $pgSchema = $pgProperties[$pgProperty],
          $sch = $pgSchema.schema;
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternGroups' + it.util.getProperty($pgProperty) + '.schema';
          $it.errSchemaPath = it.errSchemaPath + '/patternGroups/' + it.util.escapeFragment($pgProperty) + '/schema';
          out += ' var pgPropCount' + ($lvl) + ' = 0; for (var ' + ($key) + ' in ' + ($data) + ') {  ';
          if ($ownProperties) {
            out += ' if (!Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($key) + ')) continue; ';
          }
          out += ' if (' + (it.usePattern($pgProperty)) + '.test(' + ($key) + ')) { pgPropCount' + ($lvl) + '++; ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
          var $pgMin = $pgSchema.minimum,
            $pgMax = $pgSchema.maximum;
          if ($pgMin !== undefined || $pgMax !== undefined) {
            out += ' var ' + ($valid) + ' = true; ';
            var $currErrSchemaPath = $errSchemaPath;
            if ($pgMin !== undefined) {
              var $limit = $pgMin,
                $reason = 'minimum',
                $moreOrLess = 'less';
              out += ' ' + ($valid) + ' = pgPropCount' + ($lvl) + ' >= ' + ($pgMin) + '; ';
              $errSchemaPath = it.errSchemaPath + '/patternGroups/minimum';
              out += '  if (!' + ($valid) + ') {   ';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'patternGroups') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { reason: \'' + ($reason) + '\', limit: ' + ($limit) + ', pattern: \'' + (it.util.escapeQuotes($pgProperty)) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should NOT have ' + ($moreOrLess) + ' than ' + ($limit) + ' properties matching pattern "' + (it.util.escapeQuotes($pgProperty)) + '"\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
              if ($pgMax !== undefined) {
                out += ' else ';
              }
            }
            if ($pgMax !== undefined) {
              var $limit = $pgMax,
                $reason = 'maximum',
                $moreOrLess = 'more';
              out += ' ' + ($valid) + ' = pgPropCount' + ($lvl) + ' <= ' + ($pgMax) + '; ';
              $errSchemaPath = it.errSchemaPath + '/patternGroups/maximum';
              out += '  if (!' + ($valid) + ') {   ';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'patternGroups') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { reason: \'' + ($reason) + '\', limit: ' + ($limit) + ', pattern: \'' + (it.util.escapeQuotes($pgProperty)) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should NOT have ' + ($moreOrLess) + ' than ' + ($limit) + ' properties matching pattern "' + (it.util.escapeQuotes($pgProperty)) + '"\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += ' if (' + ($valid) + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],32:[function(require,module,exports){
'use strict';
module.exports = function generate_ref(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = 'can\'t resolve reference ' + $schema + ' from id ' + it.baseId;
      if (it.opts.missingRefs == 'fail') {
        console.log($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || '$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        console.log($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        var $error = new Error($message);
        $error.missingRef = it.resolve.url(it.baseId, $schema);
        $error.missingSchema = it.resolve.normalizeId(it.resolve.fullPath($error.missingRef));
        throw $error;
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true;
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
      $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
    out += ' , ' + ($parentData) + ' , ' + ($parentDataProperty) + ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      out += ' try { ';
      if ($breakOnError) {
        out += 'var ' + ($valid) + ' =';
      }
      out += ' ' + (it.yieldAwait) + ' ' + (__callValidate) + '; } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
}

},{}],33:[function(require,module,exports){
'use strict';
module.exports = function generate_required(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var _$property, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            _$property = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty(_$property);
            out += ' ( ' + ($data) + ($prop) + ' === undefined && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? _$property : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined) {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $reqProperty, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $reqProperty = arr3[i3 += 1];
            var $prop = it.util.getProperty($reqProperty),
              $missingProperty = it.util.escapeQuotes($reqProperty);
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $reqProperty, it.opts.jsonPointers);
            }
            out += ' if (' + ($data) + ($prop) + ' === undefined) {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
}

},{}],34:[function(require,module,exports){
'use strict';
module.exports = function generate_switch(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $ifPassed = 'ifPassed' + it.level,
    $currentBaseId = $it.baseId,
    $shouldContinue;
  out += 'var ' + ($ifPassed) + ';';
  var arr1 = $schema;
  if (arr1) {
    var $sch, $caseIndex = -1,
      l1 = arr1.length - 1;
    while ($caseIndex < l1) {
      $sch = arr1[$caseIndex += 1];
      if ($caseIndex && !$shouldContinue) {
        out += ' if (!' + ($ifPassed) + ') { ';
        $closingBraces += '}';
      }
      if ($sch.if && it.util.schemaHasRules($sch.if, it.RULES.all)) {
        out += ' var ' + ($errs) + ' = errors;   ';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        $it.schema = $sch.if;
        $it.schemaPath = $schemaPath + '[' + $caseIndex + '].if';
        $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/if';
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + ($ifPassed) + ' = ' + ($nextValid) + '; if (' + ($ifPassed) + ') {  ';
        if (typeof $sch.then == 'boolean') {
          if ($sch.then === false) {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'switch') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { caseIndex: ' + ($caseIndex) + ' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should pass "switch" keyword validation\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
          }
          out += ' var ' + ($nextValid) + ' = ' + ($sch.then) + '; ';
        } else {
          $it.schema = $sch.then;
          $it.schemaPath = $schemaPath + '[' + $caseIndex + '].then';
          $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/then';
          out += '  ' + (it.validate($it)) + ' ';
          $it.baseId = $currentBaseId;
        }
        out += '  } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } } ';
      } else {
        out += ' ' + ($ifPassed) + ' = true;  ';
        if (typeof $sch.then == 'boolean') {
          if ($sch.then === false) {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'switch') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { caseIndex: ' + ($caseIndex) + ' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should pass "switch" keyword validation\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
          }
          out += ' var ' + ($nextValid) + ' = ' + ($sch.then) + '; ';
        } else {
          $it.schema = $sch.then;
          $it.schemaPath = $schemaPath + '[' + $caseIndex + '].then';
          $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/then';
          out += '  ' + (it.validate($it)) + ' ';
          $it.baseId = $currentBaseId;
        }
      }
      $shouldContinue = $sch.continue
    }
  }
  out += '' + ($closingBraces) + 'var ' + ($valid) + ' = ' + ($nextValid) + '; ';
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],35:[function(require,module,exports){
'use strict';
module.exports = function generate_uniqueItems(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var ' + ($valid) + ' = true; if (' + ($data) + '.length > 1) { var i = ' + ($data) + '.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}

},{}],36:[function(require,module,exports){
'use strict';
module.exports = function generate_validate(it, $keyword) {
  var out = '';
  var $async = it.schema.$async === true;
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.root.schema.id);
    it.baseId = it.baseId || it.rootId;
    if ($async) {
      it.async = true;
      var $es7 = it.opts.async == 'es7';
      it.yieldAwait = $es7 ? 'await' : 'yield';
    }
    delete it.isTop;
    it.dataPathArr = [undefined];
    out += ' var validate = ';
    if ($async) {
      if ($es7) {
        out += ' (async function ';
      } else {
        if (it.opts.async == 'co*') {
          out += 'co.wrap';
        }
        out += '(function* ';
      }
    } else {
      out += ' (function ';
    }
    out += ' (data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data;';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if (it.schema.id) it.baseId = it.resolve.url(it.baseId, it.schema.id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '',
    $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.coerceTypes) {
    var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    if ($coerceToTypes) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') {  ';
      var $dataType = 'dataType' + $lvl,
        $coerced = 'coerced' + $lvl;
      out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
      if (it.opts.coerceTypes == 'array') {
        out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \'array\'; ';
      }
      out += ' var ' + ($coerced) + ' = undefined; ';
      var $bracesCoercion = '';
      var arr1 = $coerceToTypes;
      if (arr1) {
        var $type, $i = -1,
          l1 = arr1.length - 1;
        while ($i < l1) {
          $type = arr1[$i += 1];
          if ($i) {
            out += ' if (' + ($coerced) + ' === undefined) { ';
            $bracesCoercion += '}';
          }
          if (it.opts.coerceTypes == 'array' && $type != 'array') {
            out += ' if (' + ($dataType) + ' == \'array\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
          }
          if ($type == 'string') {
            out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
          } else if ($type == 'number' || $type == 'integer') {
            out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
            if ($type == 'integer') {
              out += ' && !(' + ($data) + ' % 1)';
            }
            out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
          } else if ($type == 'boolean') {
            out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
          } else if ($type == 'null') {
            out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
          } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
            out += ' if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
          }
        }
      }
      out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
        if ($typeIsArray) {
          out += '' + ($typeSchema.join(","));
        } else {
          out += '' + ($typeSchema);
        }
        out += '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be ';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } else {  ';
      var $parentData = $dataLvl ? 'data' + (($dataLvl - 1) || '') : 'parentData',
        $parentDataProperty = $dataLvl ? it.dataPathArr[$dataLvl] : 'parentDataProperty';
      out += ' ' + ($data) + ' = ' + ($coerced) + '; ';
      if (!$dataLvl) {
        out += 'if (' + ($parentData) + ' !== undefined)';
      }
      out += ' ' + ($parentData) + '[' + ($parentDataProperty) + '] = ' + ($coerced) + '; } } ';
    }
  }
  var $refKeywords;
  if (it.schema.$ref && ($refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'))) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '"');
    } else if (it.opts.extendRefs == 'ignore') {
      $refKeywords = false;
      console.log('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    } else if (it.opts.extendRefs !== true) {
      console.log('$ref: all keywords used in schema at path "' + it.errSchemaPath + '". It will change in the next major version, see issue #260. Use option { extendRefs: true } to keep current behaviour');
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
          }
          if (it.opts.useDefaults && !it.compositeRule) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    out += '  if (' + ($passData) + ' === undefined) ' + ($passData) + ' = ';
                    if (it.opts.useDefaults == 'shared') {
                      out += ' ' + (it.useDefault($sch.default)) + ' ';
                    } else {
                      out += ' ' + (JSON.stringify($sch.default)) + ' ';
                    }
                    out += '; ';
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    out += '  if (' + ($passData) + ' === undefined) ' + ($passData) + ' = ';
                    if (it.opts.useDefaults == 'shared') {
                      out += ' ' + (it.useDefault($sch.default)) + ' ';
                    } else {
                      out += ' ' + (JSON.stringify($sch.default)) + ' ';
                    }
                    out += '; ';
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                out += ' ' + ($rule.code(it, $rule.keyword)) + ' ';
                if ($breakOnError) {
                  $closingBraces1 += '}';
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type) {
              var $typeChecked = true;
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($typeSchema && !$typeChecked && !(it.opts.coerceTypes && $coerceToTypes)) {
    var $schemaPath = it.schemaPath + '.type',
      $errSchemaPath = it.errSchemaPath + '/type',
      $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
    out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
      if ($typeIsArray) {
        out += '' + ($typeSchema.join(","));
      } else {
        out += '' + ($typeSchema);
      }
      out += '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should be ';
        if ($typeIsArray) {
          out += '' + ($typeSchema.join(","));
        } else {
          out += '' + ($typeSchema);
        }
        out += '\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return true;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }); return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }
  out = it.util.cleanUpCode(out);
  if ($top && $breakOnError) {
    out = it.util.cleanUpVarErrors(out, $async);
  }

  function $shouldUseGroup($rulesGroup) {
    for (var i = 0; i < $rulesGroup.rules.length; i++)
      if ($shouldUseRule($rulesGroup.rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.keyword == 'properties' && (it.schema.additionalProperties === false || typeof it.schema.additionalProperties == 'object' || (it.schema.patternProperties && Object.keys(it.schema.patternProperties).length) || (it.opts.v5 && it.schema.patternGroups && Object.keys(it.schema.patternGroups).length)));
  }
  return out;
}

},{}],37:[function(require,module,exports){
'use strict';

var IDENTIFIER = /^[a-z_$][a-z0-9_$\-]*$/i;
var customRuleCode = require('./dotjs/custom');

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword
};

/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;

  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    if (definition.macro && definition.valid !== undefined)
      throw new Error('"valid" option cannot be used with macro keywords');

    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      var i, len = dataType.length;
      for (i=0; i<len; i++) checkDataType(dataType[i]);
      for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);
    } else {
      if (dataType) checkDataType(dataType);
      _addRule(keyword, dataType, definition);
    }

    var $data = definition.$data === true && this._opts.v5;
    if ($data && !definition.validate)
      throw new Error('$data support: "validate" function is not defined');

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if ($data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#/definitions/$data' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }


  function checkDataType(dataType) {
    if (!RULES.types[dataType]) throw new Error('Unknown type ' + dataType);
  }
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
}

},{"./dotjs/custom":21}],38:[function(require,module,exports){
module.exports={
    "id": "http://json-schema.org/draft-04/schema#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "Core schema meta-schema",
    "definitions": {
        "schemaArray": {
            "type": "array",
            "minItems": 1,
            "items": { "$ref": "#" }
        },
        "positiveInteger": {
            "type": "integer",
            "minimum": 0
        },
        "positiveIntegerDefault0": {
            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]
        },
        "simpleTypes": {
            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]
        },
        "stringArray": {
            "type": "array",
            "items": { "type": "string" },
            "minItems": 1,
            "uniqueItems": true
        }
    },
    "type": "object",
    "properties": {
        "id": {
            "type": "string",
            "format": "uri"
        },
        "$schema": {
            "type": "string",
            "format": "uri"
        },
        "title": {
            "type": "string"
        },
        "description": {
            "type": "string"
        },
        "default": {},
        "multipleOf": {
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": true
        },
        "maximum": {
            "type": "number"
        },
        "exclusiveMaximum": {
            "type": "boolean",
            "default": false
        },
        "minimum": {
            "type": "number"
        },
        "exclusiveMinimum": {
            "type": "boolean",
            "default": false
        },
        "maxLength": { "$ref": "#/definitions/positiveInteger" },
        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "pattern": {
            "type": "string",
            "format": "regex"
        },
        "additionalItems": {
            "anyOf": [
                { "type": "boolean" },
                { "$ref": "#" }
            ],
            "default": {}
        },
        "items": {
            "anyOf": [
                { "$ref": "#" },
                { "$ref": "#/definitions/schemaArray" }
            ],
            "default": {}
        },
        "maxItems": { "$ref": "#/definitions/positiveInteger" },
        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "uniqueItems": {
            "type": "boolean",
            "default": false
        },
        "maxProperties": { "$ref": "#/definitions/positiveInteger" },
        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "required": { "$ref": "#/definitions/stringArray" },
        "additionalProperties": {
            "anyOf": [
                { "type": "boolean" },
                { "$ref": "#" }
            ],
            "default": {}
        },
        "definitions": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "properties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "patternProperties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "dependencies": {
            "type": "object",
            "additionalProperties": {
                "anyOf": [
                    { "$ref": "#" },
                    { "$ref": "#/definitions/stringArray" }
                ]
            }
        },
        "enum": {
            "type": "array",
            "minItems": 1,
            "uniqueItems": true
        },
        "type": {
            "anyOf": [
                { "$ref": "#/definitions/simpleTypes" },
                {
                    "type": "array",
                    "items": { "$ref": "#/definitions/simpleTypes" },
                    "minItems": 1,
                    "uniqueItems": true
                }
            ]
        },
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" }
    },
    "dependencies": {
        "exclusiveMaximum": [ "maximum" ],
        "exclusiveMinimum": [ "minimum" ]
    },
    "default": {}
}

},{}],39:[function(require,module,exports){
module.exports={
    "id": "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "Core schema meta-schema (v5 proposals)",
    "definitions": {
        "schemaArray": {
            "type": "array",
            "minItems": 1,
            "items": { "$ref": "#" }
        },
        "positiveInteger": {
            "type": "integer",
            "minimum": 0
        },
        "positiveIntegerDefault0": {
            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]
        },
        "simpleTypes": {
            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]
        },
        "stringArray": {
            "type": "array",
            "items": { "type": "string" },
            "minItems": 1,
            "uniqueItems": true
        },
        "$data": {
            "type": "object",
            "required": [ "$data" ],
            "properties": {
                "$data": {
                    "type": "string",
                    "anyOf": [
                        { "format": "relative-json-pointer" }, 
                        { "format": "json-pointer" }
                    ]
                }
            },
            "additionalProperties": false
        }
    },
    "type": "object",
    "properties": {
        "id": {
            "type": "string",
            "format": "uri"
        },
        "$schema": {
            "type": "string",
            "format": "uri"
        },
        "title": {
            "type": "string"
        },
        "description": {
            "type": "string"
        },
        "default": {},
        "multipleOf": {
            "anyOf": [
                {
                    "type": "number",
                    "minimum": 0,
                    "exclusiveMinimum": true
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "maximum": {
            "anyOf": [
                { "type": "number" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "exclusiveMaximum": {
            "anyOf": [
                {
                    "type": "boolean",
                    "default": false
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "minimum": {
            "anyOf": [
                { "type": "number" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "exclusiveMinimum": {
            "anyOf": [
                {
                    "type": "boolean",
                    "default": false
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "maxLength": {
            "anyOf": [
                { "$ref": "#/definitions/positiveInteger" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "minLength": {
            "anyOf": [
                { "$ref": "#/definitions/positiveIntegerDefault0" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "pattern": {
            "anyOf": [
                {
                    "type": "string",
                    "format": "regex"
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "additionalItems": {
            "anyOf": [
                { "type": "boolean" },
                { "$ref": "#" },
                { "$ref": "#/definitions/$data" }
            ],
            "default": {}
        },
        "items": {
            "anyOf": [
                { "$ref": "#" },
                { "$ref": "#/definitions/schemaArray" }
            ],
            "default": {}
        },
        "maxItems": {
            "anyOf": [
                { "$ref": "#/definitions/positiveInteger" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "minItems": {
            "anyOf": [
                { "$ref": "#/definitions/positiveIntegerDefault0" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "uniqueItems": {
            "anyOf": [
                {
                    "type": "boolean",
                    "default": false
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "maxProperties": {
            "anyOf": [
                { "$ref": "#/definitions/positiveInteger" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "minProperties": {
            "anyOf": [
                { "$ref": "#/definitions/positiveIntegerDefault0" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "required": {
            "anyOf": [
                { "$ref": "#/definitions/stringArray" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "additionalProperties": {
            "anyOf": [
                { "type": "boolean" },
                { "$ref": "#" },
                { "$ref": "#/definitions/$data" }
            ],
            "default": {}
        },
        "definitions": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "properties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "patternProperties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "dependencies": {
            "type": "object",
            "additionalProperties": {
                "anyOf": [
                    { "$ref": "#" },
                    { "$ref": "#/definitions/stringArray" }
                ]
            }
        },
        "enum": {
            "anyOf": [
                {
                    "type": "array",
                    "minItems": 1,
                    "uniqueItems": true
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "type": {
            "anyOf": [
                { "$ref": "#/definitions/simpleTypes" },
                {
                    "type": "array",
                    "items": { "$ref": "#/definitions/simpleTypes" },
                    "minItems": 1,
                    "uniqueItems": true
                }
            ]
        },
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" },
        "format": {
            "anyOf": [
                { "type": "string" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "formatMaximum": {
            "anyOf": [
                { "type": "string" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "formatMinimum": {
            "anyOf": [
                { "type": "string" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "formatExclusiveMaximum": {
            "anyOf": [
                {
                    "type": "boolean",
                    "default": false
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "formatExclusiveMinimum": {
            "anyOf": [
                {
                    "type": "boolean",
                    "default": false
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "constant": {
            "anyOf": [
                {},
                { "$ref": "#/definitions/$data" }
            ]
        },
        "contains": { "$ref": "#" },
        "patternGroups": {
            "type": "object",
            "additionalProperties": {
                "type": "object",
                "required": [ "schema" ],
                "properties": {
                    "maximum": {
                        "anyOf": [
                            { "$ref": "#/definitions/positiveInteger" },
                            { "$ref": "#/definitions/$data" }
                        ]
                    },
                    "minimum": {
                        "anyOf": [
                            { "$ref": "#/definitions/positiveIntegerDefault0" },
                            { "$ref": "#/definitions/$data" }
                        ]
                    },
                    "schema": { "$ref": "#" }
                },
                "additionalProperties": false
            },
            "default": {}
        },
        "switch": {
            "type": "array",
            "items": {
                "required": [ "then" ],
                "properties": {
                    "if": { "$ref": "#" },
                    "then": {
                        "anyOf": [
                            { "type": "boolean" },
                            { "$ref": "#" }
                        ]
                    },
                    "continue": { "type": "boolean" }
                },
                "additionalProperties": false,
                "dependencies": {
                    "continue": [ "if" ]
                }
            }
        }
    },
    "dependencies": {
        "exclusiveMaximum": [ "maximum" ],
        "exclusiveMinimum": [ "minimum" ],
        "formatMaximum": [ "format" ],
        "formatMinimum": [ "format" ],
        "formatExclusiveMaximum": [ "formatMaximum" ],
        "formatExclusiveMinimum": [ "formatMinimum" ]
    },
    "default": {}
}

},{}],40:[function(require,module,exports){
'use strict';

var META_SCHEMA_ID = 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json';

module.exports = {
  enable: enableV5,
  META_SCHEMA_ID: META_SCHEMA_ID
};


function enableV5(ajv) {
  var inlineFunctions = {
    'switch': require('./dotjs/switch'),
    'constant': require('./dotjs/constant'),
    '_formatLimit': require('./dotjs/_formatLimit'),
    'patternRequired': require('./dotjs/patternRequired')
  };

  if (ajv._opts.meta !== false) {
    var metaSchema = require('./refs/json-schema-v5.json');
    ajv.addMetaSchema(metaSchema, META_SCHEMA_ID);
  }
  _addKeyword('constant');
  ajv.addKeyword('contains', { type: 'array', macro: containsMacro });

  _addKeyword('formatMaximum', 'string', inlineFunctions._formatLimit);
  _addKeyword('formatMinimum', 'string', inlineFunctions._formatLimit);
  ajv.addKeyword('formatExclusiveMaximum');
  ajv.addKeyword('formatExclusiveMinimum');

  ajv.addKeyword('patternGroups'); // implemented in properties.jst
  _addKeyword('patternRequired', 'object');
  _addKeyword('switch');


  function _addKeyword(keyword, types, inlineFunc) {
    var definition = {
      inline: inlineFunc || inlineFunctions[keyword],
      statements: true,
      errors: 'full'
    };
    if (types) definition.type = types;
    ajv.addKeyword(keyword, definition);
  }
}


function containsMacro(schema) {
  return {
    not: { items: { not: schema } }
  };
}

},{"./dotjs/_formatLimit":13,"./dotjs/constant":20,"./dotjs/patternRequired":30,"./dotjs/switch":34,"./refs/json-schema-v5.json":39}],41:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],42:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],43:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],44:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":42,"./encode":43}],45:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":46,"punycode":41,"querystring":44}],46:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],47:[function(require,module,exports){

/**
 * slice() reference.
 */

var slice = Array.prototype.slice;

/**
 * Expose `co`.
 */

module.exports = co['default'] = co.co = co;

/**
 * Wrap the given generator `fn` into a
 * function that returns a promise.
 * This is a separate function so that
 * every `co()` call doesn't create a new,
 * unnecessary closure.
 *
 * @param {GeneratorFunction} fn
 * @return {Function}
 * @api public
 */

co.wrap = function (fn) {
  createPromise.__generatorFunction__ = fn;
  return createPromise;
  function createPromise() {
    return co.call(this, fn.apply(this, arguments));
  }
};

/**
 * Execute the generator function or a generator
 * and return a promise.
 *
 * @param {Function} fn
 * @return {Promise}
 * @api public
 */

function co(gen) {
  var ctx = this;
  var args = slice.call(arguments, 1)

  // we wrap everything in a promise to avoid promise chaining,
  // which leads to memory leak errors.
  // see https://github.com/tj/co/issues/180
  return new Promise(function(resolve, reject) {
    if (typeof gen === 'function') gen = gen.apply(ctx, args);
    if (!gen || typeof gen.next !== 'function') return resolve(gen);

    onFulfilled();

    /**
     * @param {Mixed} res
     * @return {Promise}
     * @api private
     */

    function onFulfilled(res) {
      var ret;
      try {
        ret = gen.next(res);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    /**
     * @param {Error} err
     * @return {Promise}
     * @api private
     */

    function onRejected(err) {
      var ret;
      try {
        ret = gen.throw(err);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    /**
     * Get the next value in the generator,
     * return a promise.
     *
     * @param {Object} ret
     * @return {Promise}
     * @api private
     */

    function next(ret) {
      if (ret.done) return resolve(ret.value);
      var value = toPromise.call(ctx, ret.value);
      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '
        + 'but the following object was passed: "' + String(ret.value) + '"'));
    }
  });
}

/**
 * Convert a `yield`ed value into a promise.
 *
 * @param {Mixed} obj
 * @return {Promise}
 * @api private
 */

function toPromise(obj) {
  if (!obj) return obj;
  if (isPromise(obj)) return obj;
  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
  if ('function' == typeof obj) return thunkToPromise.call(this, obj);
  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
  if (isObject(obj)) return objectToPromise.call(this, obj);
  return obj;
}

/**
 * Convert a thunk to a promise.
 *
 * @param {Function}
 * @return {Promise}
 * @api private
 */

function thunkToPromise(fn) {
  var ctx = this;
  return new Promise(function (resolve, reject) {
    fn.call(ctx, function (err, res) {
      if (err) return reject(err);
      if (arguments.length > 2) res = slice.call(arguments, 1);
      resolve(res);
    });
  });
}

/**
 * Convert an array of "yieldables" to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param {Array} obj
 * @return {Promise}
 * @api private
 */

function arrayToPromise(obj) {
  return Promise.all(obj.map(toPromise, this));
}

/**
 * Convert an object of "yieldables" to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param {Object} obj
 * @return {Promise}
 * @api private
 */

function objectToPromise(obj){
  var results = new obj.constructor();
  var keys = Object.keys(obj);
  var promises = [];
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var promise = toPromise.call(this, obj[key]);
    if (promise && isPromise(promise)) defer(promise, key);
    else results[key] = obj[key];
  }
  return Promise.all(promises).then(function () {
    return results;
  });

  function defer(promise, key) {
    // predefine the key in the result
    results[key] = undefined;
    promises.push(promise.then(function (res) {
      results[key] = res;
    }));
  }
}

/**
 * Check if `obj` is a promise.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isPromise(obj) {
  return 'function' == typeof obj.then;
}

/**
 * Check if `obj` is a generator.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */

function isGenerator(obj) {
  return 'function' == typeof obj.next && 'function' == typeof obj.throw;
}

/**
 * Check if `obj` is a generator function.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */
function isGeneratorFunction(obj) {
  var constructor = obj.constructor;
  if (!constructor) return false;
  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
  return isGenerator(constructor.prototype);
}

/**
 * Check for plain object.
 *
 * @param {Mixed} val
 * @return {Boolean}
 * @api private
 */

function isObject(val) {
  return Object == val.constructor;
}

},{}],48:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":49}],49:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":50,"./lib/stringify":51}],50:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],51:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],"ajv":[function(require,module,exports){
'use strict';

var compileSchema = require('./compile')
  , resolve = require('./compile/resolve')
  , Cache = require('./cache')
  , SchemaObject = require('./compile/schema_obj')
  , stableStringify = require('json-stable-stringify')
  , formats = require('./compile/formats')
  , rules = require('./compile/rules')
  , v5 = require('./v5')
  , util = require('./compile/util')
  , async = require('./async')
  , co = require('co');

module.exports = Ajv;

Ajv.prototype.compileAsync = async.compile;

var customKeyword = require('./keyword');
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.ValidationError = require('./compile/validation_error');

var META_SCHEMA_ID = 'http://json-schema.org/draft-04/schema';
var SCHEMA_URI_FORMAT = /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i;
function SCHEMA_URI_FORMAT_FUNC(str) {
  return SCHEMA_URI_FORMAT.test(str);
}

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes' ];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  var self = this;

  opts = this._opts = util.copy(opts) || {};
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);
  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();

  // this is done on purpose, so that methods are bound to the instance
  // (without using bind) so that they can be used without the instance
  this.validate = validate;
  this.compile = compile;
  this.addSchema = addSchema;
  this.addMetaSchema = addMetaSchema;
  this.validateSchema = validateSchema;
  this.getSchema = getSchema;
  this.removeSchema = removeSchema;
  this.addFormat = addFormat;
  this.errorsText = errorsText;

  this._addSchema = _addSchema;
  this._compile = _compile;

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.async || opts.transpile) async.setup(opts);
  if (opts.beautify === true) opts.beautify = { indent_size: 2 };
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  this._metaOpts = getMetaSchemaOptions();

  if (opts.formats) addInitialFormats();
  addDraft4MetaSchema();
  if (opts.v5) v5.enable(this);
  if (typeof opts.meta == 'object') addMetaSchema(opts.meta);
  addInitialSchemas();


  /**
   * Validate data using schema
   * Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.
   * @param  {String|Object} schemaKeyRef key, ref or schema object
   * @param  {Any} data to be validated
   * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
   */
  function validate(schemaKeyRef, data) {
    var v;
    if (typeof schemaKeyRef == 'string') {
      v = getSchema(schemaKeyRef);
      if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
      var schemaObj = _addSchema(schemaKeyRef);
      v = schemaObj.validate || _compile(schemaObj);
    }

    var valid = v(data);
    if (v.$async === true)
      return self._opts.async == '*' ? co(valid) : valid;
    self.errors = v.errors;
    return valid;
  }


  /**
   * Create validating function for passed schema.
   * @param  {Object} schema schema object
   * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
   * @return {Function} validating function
   */
  function compile(schema, _meta) {
    var schemaObj = _addSchema(schema, undefined, _meta);
    return schemaObj.validate || _compile(schemaObj);
  }


  /**
   * Adds schema to the instance.
   * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
   * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
   * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
   * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
   */
  function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)){
      for (var i=0; i<schema.length; i++) addSchema(schema[i], undefined, _skipValidation, _meta);
      return;
    }
    // can key/id have # inside?
    key = resolve.normalizeId(key || schema.id);
    checkUnique(key);
    self._schemas[key] = _addSchema(schema, _skipValidation, _meta, true);
  }


  /**
   * Add schema that will be used to validate other schemas
   * options in META_IGNORE_OPTIONS are alway set to false
   * @param {Object} schema schema object
   * @param {String} key optional schema key
   * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
   */
  function addMetaSchema(schema, key, skipValidation) {
    addSchema(schema, key, skipValidation, true);
  }


  /**
   * Validate schema
   * @param {Object} schema schema to validate
   * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
   * @return {Boolean} true if schema is valid
   */
  function validateSchema(schema, throwOrLogError) {
    var $schema = schema.$schema || self._opts.defaultMeta || defaultMeta();
    var currentUriFormat = self._formats.uri;
    self._formats.uri = typeof currentUriFormat == 'function'
                        ? SCHEMA_URI_FORMAT_FUNC
                        : SCHEMA_URI_FORMAT;
    var valid;
    try { valid = validate($schema, schema); }
    finally { self._formats.uri = currentUriFormat; }
    if (!valid && throwOrLogError) {
      var message = 'schema is invalid: ' + errorsText();
      if (self._opts.validateSchema == 'log') console.error(message);
      else throw new Error(message);
    }
    return valid;
  }


  function defaultMeta() {
    var meta = self._opts.meta;
    self._opts.defaultMeta = typeof meta == 'object'
                              ? meta.id || meta
                              : self._opts.v5
                                ? v5.META_SCHEMA_ID
                                : META_SCHEMA_ID;
    return self._opts.defaultMeta;
  }


  /**
   * Get compiled schema from the instance by `key` or `ref`.
   * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
   * @return {Function} schema validating function (with property `schema`).
   */
  function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(keyRef);
    switch (typeof schemaObj) {
      case 'object': return schemaObj.validate || _compile(schemaObj);
      case 'string': return getSchema(schemaObj);
      case 'undefined': return _getSchemaFragment(keyRef);
    }
  }


  function _getSchemaFragment(ref) {
    var res = resolve.schema.call(self, { schema: {} }, ref);
    if (res) {
      var schema = res.schema
        , root = res.root
        , baseId = res.baseId;
      var v = compileSchema.call(self, schema, root, undefined, baseId);
      self._fragments[ref] = new SchemaObject({
        ref: ref,
        fragment: true,
        schema: schema,
        root: root,
        baseId: baseId,
        validate: v
      });
      return v;
    }
  }


  function _getSchemaObj(keyRef) {
    keyRef = resolve.normalizeId(keyRef);
    return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
  }


  /**
   * Remove cached schema(s).
   * If no parameter is passed all schemas but meta-schemas are removed.
   * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
   * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
   * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
   */
  function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
      _removeAllSchemas(self._schemas, schemaKeyRef);
      _removeAllSchemas(self._refs, schemaKeyRef);
      return;
    }
    switch (typeof schemaKeyRef) {
      case 'undefined':
        _removeAllSchemas(self._schemas);
        _removeAllSchemas(self._refs);
        self._cache.clear();
        return;
      case 'string':
        var schemaObj = _getSchemaObj(schemaKeyRef);
        if (schemaObj) self._cache.del(schemaObj.jsonStr);
        delete self._schemas[schemaKeyRef];
        delete self._refs[schemaKeyRef];
        return;
      case 'object':
        var jsonStr = stableStringify(schemaKeyRef);
        self._cache.del(jsonStr);
        var id = schemaKeyRef.id;
        if (id) {
          id = resolve.normalizeId(id);
          delete self._schemas[id];
          delete self._refs[id];
        }
    }
  }


  function _removeAllSchemas(schemas, regex) {
    for (var keyRef in schemas) {
      var schemaObj = schemas[keyRef];
      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
        self._cache.del(schemaObj.jsonStr);
        delete schemas[keyRef];
      }
    }
  }


  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != 'object') throw new Error('schema should be object');
    var jsonStr = stableStringify(schema);
    var cached = self._cache.get(jsonStr);
    if (cached) return cached;

    shouldAddSchema = shouldAddSchema || self._opts.addUsedSchema !== false;

    var id = resolve.normalizeId(schema.id);
    if (id && shouldAddSchema) checkUnique(id);

    var willValidate = self._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (willValidate && !(recursiveMeta = schema.id && schema.id == schema.$schema))
      validateSchema(schema, true);

    var localRefs = resolve.ids.call(self, schema);

    var schemaObj = new SchemaObject({
      id: id,
      schema: schema,
      localRefs: localRefs,
      jsonStr: jsonStr,
      meta: meta
    });

    if (id[0] != '#' && shouldAddSchema) self._refs[id] = schemaObj;
    self._cache.put(jsonStr, schemaObj);

    if (willValidate && recursiveMeta) validateSchema(schema, true);

    return schemaObj;
  }


  function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
      schemaObj.validate = callValidate;
      callValidate.schema = schemaObj.schema;
      callValidate.errors = null;
      callValidate.root = root ? root : callValidate;
      if (schemaObj.schema.$async === true)
        callValidate.$async = true;
      return callValidate;
    }
    schemaObj.compiling = true;

    var currentOpts;
    if (schemaObj.meta) {
      currentOpts = self._opts;
      self._opts = self._metaOpts;
    }

    var v;
    try { v = compileSchema.call(self, schemaObj.schema, root, schemaObj.localRefs); }
    finally {
      schemaObj.compiling = false;
      if (schemaObj.meta) self._opts = currentOpts;
    }

    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;


    function callValidate() {
      var _validate = schemaObj.validate;
      var result = _validate.apply(null, arguments);
      callValidate.errors = _validate.errors;
      return result;
    }
  }


  /**
   * Convert array of error message objects to string
   * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
   * @param  {Object} options optional options with properties `separator` and `dataVar`.
   * @return {String} human readable string with all errors descriptions
   */
  function errorsText(errors, options) {
    errors = errors || self.errors;
    if (!errors) return 'No errors';
    options = options || {};
    var separator = options.separator === undefined ? ', ' : options.separator;
    var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

    var text = '';
    for (var i=0; i<errors.length; i++) {
      var e = errors[i];
      if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
    }
    return text.slice(0, -separator.length);
  }


  /**
   * Add custom format
   * @param {String} name format name
   * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
   */
  function addFormat(name, format) {
    if (typeof format == 'string') format = new RegExp(format);
    self._formats[name] = format;
  }


  function addDraft4MetaSchema() {
    if (self._opts.meta !== false) {
      var metaSchema = require('./refs/json-schema-draft-04.json');
      addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
    }
  }


  function addInitialSchemas() {
    var optsSchemas = self._opts.schemas;
    if (!optsSchemas) return;
    if (Array.isArray(optsSchemas)) addSchema(optsSchemas);
    else for (var key in optsSchemas) addSchema(optsSchemas[key], key);
  }


  function addInitialFormats() {
    for (var name in self._opts.formats) {
      var format = self._opts.formats[name];
      addFormat(name, format);
    }
  }


  function checkUnique(id) {
    if (self._schemas[id] || self._refs[id])
      throw new Error('schema with key or id "' + id + '" already exists');
  }


  function getMetaSchemaOptions() {
    var metaOpts = util.copy(self._opts);
    for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
      delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
  }
}

},{"./async":1,"./cache":2,"./compile":6,"./compile/formats":5,"./compile/resolve":7,"./compile/rules":8,"./compile/schema_obj":9,"./compile/util":11,"./compile/validation_error":12,"./keyword":37,"./refs/json-schema-draft-04.json":38,"./v5":40,"co":47,"json-stable-stringify":48}]},{},[])("ajv")
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(75)))

/***/ }),
/* 230 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var uuid = __webpack_require__(18);
var v1 = __webpack_require__(231);
var v2 = __webpack_require__(232);
var v3 = __webpack_require__(233);
var v4 = __webpack_require__(234);
var identity = __webpack_require__(13).identity;
var indexBy = __webpack_require__(13).indexBy;
var flatMap = __webpack_require__(13).flatMap;

/**
 * Returns the maximum version number.
 * @function maxVersion
 * @param {Object} version1 The first version.
 * @param {Number} version1.major The first version's major version.
 * @param {Number} version1.minor The first version's minor version.
 * @param {Object} version2 The second version.
 * @param {Number} version2.major The second version's major version.
 * @param {Number} version2.minor The second version's minor version.
 * @returns {Object} Either version1 or version2, whichever is greater.
 */
function maxVersion(version1, version2) {
  if (version1.major > version2.major) {
    return version1;
  }

  if (version2.major > version1.major) {
    return version2;
  }

  if (version1.minor > version2.minor) {
    return version1;
  }

  return version2;
}

/**
 * Returns an array of mapping functions for the specified version. The
 * functions should be applied in sequential order, starting from index 0.
 * @function getMapFunctions
 * @param {Object} version The entity version.
 * @param {Number} version.major The "major" version number.
 * @param {Number} version.minor The "minor" version number.
 * @returns {Array} The array of mapping functions.
 */
function getMapFunctions(version) {
  var fns = [];

  if (version.major <= 1) {
    var v1From = maxVersion(version, { major: 1, minor: 0 });
    fns.push(function(entity) {
      return v1.mapToV2Entity(entity, v1From);
    });
  }

  if (version.major <= 2) {
    var v2From = maxVersion(version, { major: 2, minor: 0 });
    fns.push(function(entity) {
      return v2.mapToV3Entity(entity, v2From);
    });
  }

  if (version.major <= 3) {
    var v3From = maxVersion(version, { major: 3, minor: 0 });
    fns.push(function(entity) {
      return v3.mapToV4Entity(entity, v3From);
    });
  }

  if (version.major <= 4) {
    var v4From = maxVersion(version, { major: 4, minor: 0 });
    fns.push(function(entity) {
      return v4.mapToV5Entity(entity, v4From);
    });
  }

  return fns;
}

/**
 * Maps a collection of entities from the specified version to the current
 * runtime format.
 * @function mapEntities
 * @param {Array} entities An array of entities.
 * @param {Object} version The entity version.
 * @param {Number} version.major The "major" version number.
 * @param {Number} version.minor The "minor" version number.
 * @returns {Array} The mapped entities.
 */
function mapEntities(entities, version) {
  // First, map to the latest converter output.
  var mapFns = getMapFunctions(version);

  mapFns.forEach(function(mapFn) {
    entities = flatMap(entities, mapFn);
  });

  // Next, map to the runtime format.
  var entitiesById = indexBy(entities, 'id');

  return flatMap(entities, function(entity) {
    return ({
      material: mapMaterial,
      prefab: mapPrefab,
      texture2D: mapTexture
    }[entity.type] || identity)(entity, entitiesById);
  });
}

/**
 * Maps a material entity to the current runtime format.
 * @function mapMaterial
 * @param {Object} material The material entity to transform.
 * @returns {Object} The transformed material entity.
 */
function mapMaterial(material, entitiesById) {
  var matProps = material.properties;

  var properties = {
    name: matProps.name,
    shader: 'box3d_pbr_shader',
    enabledFeatures: {}
  };

  // Diffuse / albedo
  if (matProps.diffuse || matProps.diffuseTexture) {
    properties.enabledFeatures.albedo = true;

    Object.assign(properties, mapMaterialProperties(matProps, 'diffuse',
      'diffuseFactor', 'diffuseTexture', 'albedoColor', 'albedoMap'));
  }

  // Specular
  if (matProps.specular || matProps.specularTexture) {
    properties.enabledFeatures.specular = true;

    Object.assign(properties, mapMaterialProperties(matProps, 'specular',
      'specularFactor', 'specularTexture', 'specularColor', 'specularMap'));
  }

  // Reflections
  if (matProps.reflectionTexture) {
    properties.enabledFeatures.specular = true;

    Object.assign(properties, mapMaterialProperties(matProps, undefined,
      'reflectionFactor', 'reflectionTexture', 'reflectivity',
      'envMapRadiance', true));
  }

  if (matProps.shininess || matProps.shininessTexture) {
    Object.assign(properties, mapMaterialProperties(matProps, 'shininess', undefined,
      'shininessTexture', 'roughness', 'glossMap', true));

    setImageEncoding(matProps.shininessTexture, 'linear', entitiesById);

    if (properties.roughness) {
      // Convert phong shininess value to our 0-1 roughness value.
      // 512 is assumed to be the maximum specular power in our conversion
      properties.roughness = Math.log10(properties.roughness / 512) / 2.5 + 1.0;
      properties.roughness = Math.min(Math.max(properties.roughness, 0.0), 1.0);
      properties.roughness = 1.0 - properties.roughness;
    } else {
      // Turn off specular entirely if roughness is 1. For dielectric materials,
      // no specular is visible if the material is fully 'rough'.
      properties.enabledFeatures.specular = false;
    }
  }

  // Ambient
  if (matProps.ambientTexture) {
    properties.enabledFeatures.albedo = true;

    Object.assign(properties, mapMaterialProperties(matProps, 'ambientColor',
      'ambientFactor', 'ambientTexture', undefined, 'aoMap'));
  } else if (matProps.ambientFactorTexture) {
    properties.enabledFeatures.albedo = true;

    Object.assign(properties, mapMaterialProperties(matProps, 'ambientColor',
      'ambientFactor', 'ambientFactorTexture', undefined, 'aoMap'));
    setImageEncoding(matProps.ambientFactorTexture, 'linear', entitiesById);
  }

  // Emissive
  if (matProps.emissiveTexture) {
    properties.enabledFeatures.emissive = true;

    Object.assign(properties, mapMaterialProperties(matProps, 'emissive', null,
      'emissiveTexture', 'emissiveColor', 'emissiveMap'));

    // Separate intensity value for emissive
    if (matProps.emissiveFactor !== undefined) {
      properties.emissiveIntensity = matProps.emissiveFactor;
    }
  } else if (matProps.emissiveFactorTexture) {
    properties.enabledFeatures.emissive = true;

    Object.assign(properties, mapMaterialProperties(matProps, 'emissive', null,
      'emissiveFactorTexture', 'emissiveColor', 'emissiveMap'));

    setImageEncoding(matProps.emissiveFactorTexture, 'linear', entitiesById);

    // Separate intensity value for emissive
    if (matProps.emissiveFactor !== undefined) {
      properties.emissiveIntensity = matProps.emissiveFactor;
    }
  }

  // Transparency
  Object.assign(properties, mapMaterialProperties(matProps, 'transparentColor',
    'transparencyFactor', 'transparentTexture', 'opacity', 'alphaMap', true));

  setImageEncoding(matProps.transparentTexture, 'linear', entitiesById);

  if (properties.opacity !== undefined) {
    properties.opacity = Math.max(Math.min(1.0 - properties.opacity, 1.0), 0.0);
  }

  if ((properties.opacity && properties.opacity < 0.999) ||
      properties.alphaMap) {
    properties.enabledFeatures.transparency = true;
    properties.alphaBlendMode = 'alphaTransparency';
  } else {
    delete properties.opacity;
  }

  // Normals
  if (matProps.normalMapTexture) {
    properties.enabledFeatures.normals = true;

    Object.assign(properties, mapMaterialProperties(matProps, undefined,
      'bumpFactor', 'normalMapTexture', 'normalScale', 'normalMap', true));

    setImageEncoding(matProps.normalMapTexture, 'linear', entitiesById);
  }

  // Bumps
  // TODO - since artists frequently put normal maps into the bump channel
  // of their models we always interpret the texture as a normal map. Down
  // the road, we should run a sanity check on the texture to see if it's
  // really a bump map and take appropriate action.
  if (matProps.bumpTexture) {
    properties.enabledFeatures.normals = true;

    Object.assign(properties, mapMaterialProperties(matProps, undefined,
      'bumpFactor', 'bumpTexture', 'normalScale', 'normalMap', true));

    setImageEncoding(matProps.bumpTexture, 'linear', entitiesById);
  }

  // Convert normal scale to vec2 since that's what three.js wants.
  if (properties.normalScale) {
    properties.normalScale = {x: properties.normalScale, y: properties.normalScale};
  }

  // Displacement
  if (matProps.displacementColorTexture !== undefined) {
    properties.enabledFeatures.displacement = true;

    Object.assign(properties, mapMaterialProperties(matProps, 'displacementColor',
      'displacementFactor', 'displacementTexture', 'displacementScale',
      'displacementMap', true));

    setImageEncoding(matProps.displacementTexture, 'linear', entitiesById);
  }

  // Vector displacement
  if (matProps.vectorDisplacementColorTexture !== undefined) {
    properties.enabledFeatures.displacement = true;
    properties.useVectorDisplacement = true;

    Object.assign(properties, mapMaterialProperties(matProps,
      'vectorDisplacementColor', 'vectorDisplacementFactor',
      'vectorDisplacementColorTexture', 'displacementScale',
      'displacementMap'));

    setImageEncoding(matProps.vectorDisplacementColorTexture, 'linear', entitiesById);
  }

  material.properties = properties;

  return material;
}

/**
 * Maps a prefab entity to the current runtime format.
 * @function mapPrefab
 * @param {Object} prefab The prefab entity to transform.
 * @returns {Array} The transformed prefab entity and a new root node.
 */
function mapPrefab(prefab) {
  var rootObjectId = uuid.v4();

  var rootObject = {
    type: 'node',
    id: rootObjectId,
    parentAssetId: prefab.id,
    sid: rootObjectId,
    children: prefab.children,
    properties: {
      name: (prefab.properties.name || 'Prefab') + '_root'
    }
  };

  delete prefab.children;

  prefab.properties.rootObjectId = rootObjectId;

  return [prefab, rootObject];
}

/**
 * Given a texture ID, find the image that it references and set its encoding
 * to the one given. This should be replaced later when we have accurate colorspace
 * and usage info coming through the converter.
 * @method setImageEncoding
 * @private
 * @param {String} textureId  The ID of the texture that we're interested in.
 * @param {String} encoding Name of encoding to set image to ('linear', 'srgb', etc.)
 * @param {Object} entityMap  Map of all entities, keyed by ID
 */
function setImageEncoding(textureId, encoding, entityMap) {
  var texture = entityMap[textureId];
  if (texture) {
    var image = entityMap[texture.properties.imageId];
    if (image) {
      image.properties.encoding = encoding;
    }
  }
}

/**
 * Map the specified set of material properties to the current runtime format.
 * @function mapMaterialProperties
 * @param {Object} srcProperties The original material properties.
 * @param {String} srcColorName The old name of the color property.
 * @param {String} srcFactorName The old name of the factor property.
 * @param {String} srcTextureName The old name of the texture property.
 * @param {String} dstColorName The new name of the color property.
 * @param {String} dstTextureName The new name of the texture property.
 * @returns {Object} The new material properties.
 */
function mapMaterialProperties(
  srcProperties,
  srcColorName,
  srcFactorName,
  srcTextureName,
  dstColorName,
  dstTextureName,
  scalar
) {
  var dstProperties = {};

  if (srcProperties.hasOwnProperty(srcTextureName)) {
    dstProperties[dstTextureName] = srcProperties[srcTextureName];
  }

  if (dstColorName) {
    var factor = srcProperties[srcFactorName] !== undefined ?
      srcProperties[srcFactorName] : 1;

    if (srcProperties.hasOwnProperty(srcColorName)) {
      if (scalar) {
        // In case that the output is scalar but the input isn't, just take an
        // average.
        if (srcProperties[srcColorName] instanceof Object) {
          dstProperties[dstColorName] = (srcProperties[srcColorName].r +
            srcProperties[srcColorName].g + srcProperties[srcColorName].b) / 3.0 * factor;
        } else {
          dstProperties[dstColorName] = srcProperties[srcColorName] * factor;
        }
      } else {
        dstProperties[dstColorName] = {
          r: srcProperties[srcColorName].r * factor,
          g: srcProperties[srcColorName].g * factor,
          b: srcProperties[srcColorName].b * factor
        };
      }
      // Temp hack until we have access to texture blending info here. When a texture is assigned
      // and the colour is black, we obviously don't want to multiply them together. So, we'll just
      // assume the colour is white for now.
      if (dstProperties[dstColorName].r === 0
        && dstProperties[dstColorName].g === 0
        && dstProperties[dstColorName].b === 0
        && dstProperties[dstTextureName]) {
        dstProperties[dstColorName] = scalar ? 1 : {r: 1, g: 1, b: 1};
      }
    } else {
      dstProperties[dstColorName] = scalar ? 1 : {r: 1, g: 1, b: 1};
    }
  }

  return dstProperties;
}

/**
 * Map the texture entity to the current runtime format.
 * @function mapTexture
 * @param {Object} texture The texture entity to map.
 * @returns {Object} The mapped texture entity.
 */
function mapTexture(texture) {
  var textureProps = texture.properties;
  var properties = { name: textureProps.name, imageId: textureProps.imageId };

  if (textureProps.hasOwnProperty('wrapModeU')) {
    properties.uMapping = textureProps.wrapModeU === 'repeat' ?
      'wrap' : 'clamp';
  }

  if (textureProps.hasOwnProperty('wrapModeV')) {
    properties.vMapping = textureProps.wrapModeV === 'repeat' ?
      'wrap' : 'clamp';
  }

  if (textureProps.hasOwnProperty('wrapModeV')) {
    properties.vMapping = textureProps.wrapModeV === 'repeat' ?
      'wrap' : 'clamp';
  }

  texture.properties = properties;

  return texture;
}

module.exports = {
  mapEntities: mapEntities
};


/***/ }),
/* 231 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var identity = __webpack_require__(13).identity;
var each = __webpack_require__(13).each;

/**
 * Map "entity.payload" to "entity.properties". This applies to all v1 entities.
 * @function mapPayloadToProperties
 * @param {Object} entity The v1 entity to map.
 * @returns {Object} The mapped entity.
 */
function mapPayloadToProperties(entity) {
  if (entity.payload) {
    entity.properties = entity.payload;
    delete entity.payload;
  }

  return entity;
}

/**
 * Map a v1 entity to v2.
 * @function mapToV2Entity
 * @param {Object} entity The v1 entity to map.
 * @returns {Object|Array} The v2 entity (or entities).
 */
function mapToV2Entity(entity) {
  entity = mapPayloadToProperties(entity);

  return ({
    material: mapToV2Material
  }[entity.type] || identity)(entity);
}

/**
 * Map a v1 material to v2.
 * @function mapToV2Material
 * @param {Object} entity The material entity to map.
 * @returns {Object} The mapped material entity.
 */
function mapToV2Material(entity) {
  // Remove "nested" properties: material.properties.properties. Move these
  // properties into the first level of properties.
  if (entity.properties && entity.properties.properties) {
    each(entity.properties.properties, function(value, name) {
      entity.properties[name] = value;
    });

    delete entity.properties.properties;
  }

  return entity;
}

module.exports = {
  mapToV2Entity: mapToV2Entity
};



/***/ }),
/* 232 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var uuid = __webpack_require__(18);
var identity = __webpack_require__(13).identity;

/**
 * Returns the basename of a filename (i.e., the final element in the path).
 * @function basename
 * @param {String} filename The filename.
 * @returns {String} The basename of the filename.
 */
function basename(filename) {
  var tokens = filename.split(new RegExp(/\\|\//));
  return tokens.length === 0 ? filename : tokens[tokens.length - 1];
}

/**
 * Map top-level "name" to "sid" and make "name" a property.
 * @function mapNameToSid
 * @param {Object} entity The entity to map.
 * @returns {Object} The mapped entity.
 */
function mapNameToSid(entity) {
  if (entity.name) {
    entity.sid = entity.name;

    if (!entity.properties) {
      entity.properties = {};
    }

    entity.properties.name = entity.name;
    delete entity.name;
  }

  return entity;
}

/**
 * Map a v2 entity to v3.
 * @function mapToV3Entity
 * @param {Object} entity The v2 entity to map.
 * @returns {Object|Array} The v3 entity (or entities).
 */
function mapToV3Entity(entity) {
  entity = mapNameToSid(entity);

  return ({
    texture2D: mapToV3Texture2d
  }[entity.type] || identity)(entity);
}

/**
 * Map a v2 texture2D entity to a v3 texture2D entity and a document entity.
 * @function mapToV3Texture2d
 * @param {Object} entity The v2 texture2D entity to map.
 * @returns {Array} An array containing a v3 texture2D entity and a document
 * entity.
 */
function mapToV3Texture2d(entity) {
  var sid = basename(entity.properties.filename);

  var document = {
    type: 'document',
    id: uuid.v4(),
    sid: sid,
    properties: {
      name: sid,
      filename: entity.properties.filename
    }
  };

  entity.properties.imageId = document.id + '#' + sid;
  delete entity.properties.filename;

  return [entity, document];
}

module.exports = {
  mapToV3Entity: mapToV3Entity
};



/***/ }),
/* 233 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var uuid = __webpack_require__(18);
var identity = __webpack_require__(13).identity;
var each = __webpack_require__(13).each;

/**
 * Map a v3 entity to v4.
 * @function mapToV4Entity
 * @param {Object} entity The v3 entity to map.
 * @returns {Object|Array} The v4 entity (or entities).
 */
function mapToV4Entity(entity) {
  return ({
    meshGeometry: mapToV4MeshGeometry
  }[entity.type] || identity)(entity);
}

/**
 * Map a v3 meshGeometry entity to a v4 meshGeometry entity and a buffer entity.
 * @function mapToV4MeshGeometry
 * @param {Object} entity The v3 meshGeometry entity to map.
 * @returns {Array} An array containing a v4 meshGeometry entity and a buffer
 * entity.
 */
function mapToV4MeshGeometry(entity) {
  var buffer = {
    type: 'buffer',
    id: uuid.v4(),
    sid: entity.sid + '-buffer',
    properties: {
      name: entity.sid + '-buffer',
      src: 'geometry.bin',
      accessors: {}
    }
  };

  // Add an accessor to the buffer for each attribute.
  each(entity.properties.attributes, function(attribute, name) {
    buffer.properties.accessors[name] = {
      type: attribute.type,
      componentType: attribute.componentType,
      byteOffset: attribute.byteOffset,
      byteStride: 0,
      count: attribute.count
    };

    attribute.accessorId = buffer.id + '#' + name;

    delete attribute.type;
    delete attribute.componentType;
    delete attribute.byteOffset;
    delete attribute.byteStride;
    delete attribute.count;
  });

  // Add an accessor to the buffer for "indices".
  buffer.properties.accessors.indices = {
    type: entity.properties.indices.type,
    componentType: entity.properties.indices.componentType,
    byteOffset: entity.properties.indices.byteOffset,
    byteStride: 0,
    count: entity.properties.indices.count
  };

  entity.properties.indices = buffer.id + '#indices';

  return [entity, buffer];
}

module.exports = {
  mapToV4Entity: mapToV4Entity
};



/***/ }),
/* 234 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var identity = __webpack_require__(13).identity;

/**
 * Map a v4 entity to v5.
 * @function mapToV5Entity
 * @param {Object} entity The v4 entity to map.
 * @param {Object} version The incoming entity version.
 * @param {Number} version.major The major version.
 * @param {Number} version.minor The minor version.
 * @returns {Object|Array} The v5 entity (or entities).
 */
function mapToV5Entity(entity, version) {
  return ({
    image: mapToV5Image
  }[entity.type] || identity)(entity, version);
}

/**
 * Map a v4 image entity to a v5 image entity.
 * @function mapToV5Image
 * @param {Object} entity The v4 image entity to map.
 * @param {Object} version The incoming entity version.
 * @param {Number} version.major The major version.
 * @param {Number} version.minor The minor version.
 * @returns {Object} The mapped image entity.
 */
function mapToV5Image(entity, version) {
  if (version.minor < 3 && entity.hasOwnProperty('representations')) {
    entity.representations = entity.representations.filter(function(representation) {
      return representation.width <= 4096 && representation.height <= 4096;
    });
  }

  return entity;
}

module.exports = {
  mapToV5Entity: mapToV5Entity
};


/***/ }),
/* 235 */
/***/ (function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ }),
/* 236 */
/***/ (function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(189)('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(74)(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ }),
/* 237 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(48);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ }),
/* 238 */
/***/ (function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = __webpack_require__(186)
  , IObject  = __webpack_require__(245)
  , toObject = __webpack_require__(253)
  , toLength = __webpack_require__(252)
  , asc      = __webpack_require__(240);
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ }),
/* 239 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(48)
  , isArray  = __webpack_require__(246)
  , SPECIES  = __webpack_require__(189)('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};

/***/ }),
/* 240 */
/***/ (function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(239);

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};

/***/ }),
/* 241 */
/***/ (function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ }),
/* 242 */
/***/ (function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(48)
  , document = __webpack_require__(33).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ }),
/* 243 */
/***/ (function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ }),
/* 244 */
/***/ (function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(72) && !__webpack_require__(187)(function(){
  return Object.defineProperty(__webpack_require__(242)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ }),
/* 245 */
/***/ (function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(185);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ }),
/* 246 */
/***/ (function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(185);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ }),
/* 247 */
/***/ (function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(237)
  , IE8_DOM_DEFINE = __webpack_require__(244)
  , toPrimitive    = __webpack_require__(254)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(72) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ }),
/* 248 */
/***/ (function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ }),
/* 249 */
/***/ (function(module, exports, __webpack_require__) {

var global    = __webpack_require__(33)
  , hide      = __webpack_require__(74)
  , has       = __webpack_require__(243)
  , SRC       = __webpack_require__(188)('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

__webpack_require__(32).inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ }),
/* 250 */
/***/ (function(module, exports, __webpack_require__) {

var global = __webpack_require__(33)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ }),
/* 251 */
/***/ (function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ }),
/* 252 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(251)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ }),
/* 253 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(241);
module.exports = function(it){
  return Object(defined(it));
};

/***/ }),
/* 254 */
/***/ (function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(48);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ }),
/* 255 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(73)
  , $find   = __webpack_require__(238)(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(236)(KEY);

/***/ }),
/* 256 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(73);

$export($export.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});

/***/ }),
/* 257 */
/***/ (function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(73);

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});

/***/ }),
/* 258 */
/***/ (function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // these private functions always need `this` to be set properly

    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }
    }

    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public API
       *
       */

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Package-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    return defaultLogger;
}));


/***/ }),
/* 259 */
/***/ (function(module, exports, __webpack_require__) {

// stats.js - http://github.com/mrdoob/stats.js
(function(f,e){ true?module.exports=e():"function"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
u(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/
1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});


/***/ }),
/* 260 */
/***/ (function(module, exports, __webpack_require__) {

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var rng = __webpack_require__(191);
var bytesToUuid = __webpack_require__(190);

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ }),
/* 261 */
/***/ (function(module, exports, __webpack_require__) {

var rng = __webpack_require__(191);
var bytesToUuid = __webpack_require__(190);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ }),
/* 262 */
/***/ (function(module, exports, __webpack_require__) {

"use strict";

function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
__webpack_require__(194);
__webpack_require__(196);
__webpack_require__(195);
__export(__webpack_require__(193));


/***/ })
/******/ ]);
});
//# sourceMappingURL=box3d-runtime.js.map