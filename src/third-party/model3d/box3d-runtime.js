(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define("Box3D", [], factory);
	else if(typeof exports === 'object')
		exports["Box3D"] = factory();
	else
		root["Box3D"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId])
/******/ 			return installedModules[moduleId].exports;
/******/
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// identity function for calling harmony imports with the correct context
/******/ 	__webpack_require__.i = function(value) { return value; };
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 249);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* harmony export (immutable) */ exports["__extends"] = __extends;
/* harmony export (binding) */ __webpack_require__.d(exports, "__assign", function() { return __assign; });
/* harmony export (immutable) */ exports["__rest"] = __rest;
/* harmony export (immutable) */ exports["__decorate"] = __decorate;
/* harmony export (immutable) */ exports["__param"] = __param;
/* harmony export (immutable) */ exports["__metadata"] = __metadata;
/* harmony export (immutable) */ exports["__awaiter"] = __awaiter;
/* harmony export (immutable) */ exports["__generator"] = __generator;
/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved.
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0

THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE,
MERCHANTABLITY OR NON-INFRINGEMENT.

See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */
/* global Reflect, Promise */

var extendStatics = Object.setPrototypeOf ||
    ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||
    function (d, b) { for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p]; };

function __extends(d, b) {
    extendStatics(d, b);
    function __() { this.constructor = d; }
    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());
}

var __assign = Object.assign || function __assign(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
        s = arguments[i];
        for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];
    }
    return t;
};

function __rest(s, e) {
    var t = {};
    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)
        t[p] = s[p];
    if (s != null && typeof Object.getOwnPropertySymbols === "function")
        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) if (e.indexOf(p[i]) < 0)
            t[p[i]] = s[p[i]];
    return t;
};

function __decorate(decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};

function __param(paramIndex, decorator) {
    return function (target, key) { decorator(target, key, paramIndex); }
};

function __metadata(metadataKey, metadataValue) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(metadataKey, metadataValue);
};

function __awaiter(thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator.throw(value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};

function __generator(thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t;
    return { next: verb(0), "throw": verb(1), "return": verb(2) };
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};

/***/ },
/* 1 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* harmony export (binding) */ __webpack_require__.d(exports, "CylinderBufferGeometry", function() { return CylinderBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "WebGLRenderTargetCube", function() { return WebGLRenderTargetCube; });
/* harmony export (binding) */ __webpack_require__.d(exports, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
/* harmony export (binding) */ __webpack_require__.d(exports, "WebGLRenderer", function() { return WebGLRenderer; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ShaderLib", function() { return ShaderLib; });
/* harmony export (binding) */ __webpack_require__.d(exports, "UniformsLib", function() { return UniformsLib; });
/* harmony export (binding) */ __webpack_require__.d(exports, "UniformsUtils", function() { return UniformsUtils; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ShaderChunk", function() { return ShaderChunk; });
/* harmony export (binding) */ __webpack_require__.d(exports, "FogExp2", function() { return FogExp2; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Fog", function() { return Fog; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Scene", function() { return Scene; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LensFlare", function() { return LensFlare; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Sprite", function() { return Sprite; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LOD", function() { return LOD; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SkinnedMesh", function() { return SkinnedMesh; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Skeleton", function() { return Skeleton; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Bone", function() { return Bone; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Mesh", function() { return Mesh; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LineSegments", function() { return LineSegments; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Line", function() { return Line; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Points", function() { return Points; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Group", function() { return Group; });
/* harmony export (binding) */ __webpack_require__.d(exports, "VideoTexture", function() { return VideoTexture; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DataTexture", function() { return DataTexture; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CompressedTexture", function() { return CompressedTexture; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubeTexture", function() { return CubeTexture; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CanvasTexture", function() { return CanvasTexture; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DepthTexture", function() { return DepthTexture; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Texture", function() { return Texture; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BinaryTextureLoader", function() { return BinaryTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DataTextureLoader", function() { return DataTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubeTextureLoader", function() { return CubeTextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TextureLoader", function() { return TextureLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ObjectLoader", function() { return ObjectLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MaterialLoader", function() { return MaterialLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LoadingManager", function() { return LoadingManager; });
/* harmony export (binding) */ __webpack_require__.d(exports, "JSONLoader", function() { return JSONLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ImageLoader", function() { return ImageLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "FontLoader", function() { return FontLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "FileLoader", function() { return FileLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Loader", function() { return Loader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Cache", function() { return Cache; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AudioLoader", function() { return AudioLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SpotLightShadow", function() { return SpotLightShadow; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SpotLight", function() { return SpotLight; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PointLight", function() { return PointLight; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RectAreaLight", function() { return RectAreaLight; });
/* harmony export (binding) */ __webpack_require__.d(exports, "HemisphereLight", function() { return HemisphereLight; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DirectionalLightShadow", function() { return DirectionalLightShadow; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DirectionalLight", function() { return DirectionalLight; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AmbientLight", function() { return AmbientLight; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LightShadow", function() { return LightShadow; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Light", function() { return Light; });
/* harmony export (binding) */ __webpack_require__.d(exports, "StereoCamera", function() { return StereoCamera; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PerspectiveCamera", function() { return PerspectiveCamera; });
/* harmony export (binding) */ __webpack_require__.d(exports, "OrthographicCamera", function() { return OrthographicCamera; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubeCamera", function() { return CubeCamera; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Camera", function() { return Camera; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AudioListener", function() { return AudioListener; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PositionalAudio", function() { return PositionalAudio; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AudioContext", function() { return AudioContext; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AudioAnalyser", function() { return AudioAnalyser; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Audio", function() { return Audio; });
/* harmony export (binding) */ __webpack_require__.d(exports, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(exports, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(exports, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(exports, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PropertyMixer", function() { return PropertyMixer; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PropertyBinding", function() { return PropertyBinding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "KeyframeTrack", function() { return KeyframeTrack; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AnimationUtils", function() { return AnimationUtils; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AnimationMixer", function() { return AnimationMixer; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AnimationClip", function() { return AnimationClip; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Uniform", function() { return Uniform; });
/* harmony export (binding) */ __webpack_require__.d(exports, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BufferGeometry", function() { return BufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "GeometryIdCount", function() { return GeometryIdCount; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Geometry", function() { return Geometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(exports, "InterleavedBuffer", function() { return InterleavedBuffer; });
/* harmony export (binding) */ __webpack_require__.d(exports, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Face3", function() { return Face3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Object3D", function() { return Object3D; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Raycaster", function() { return Raycaster; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Layers", function() { return Layers; });
/* harmony export (binding) */ __webpack_require__.d(exports, "EventDispatcher", function() { return EventDispatcher; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Clock", function() { return Clock; });
/* harmony export (binding) */ __webpack_require__.d(exports, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LinearInterpolant", function() { return LinearInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubicInterpolant", function() { return CubicInterpolant; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Interpolant", function() { return Interpolant; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Triangle", function() { return Triangle; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Spline", function() { return Spline; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Math", function() { return _Math; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Spherical", function() { return Spherical; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Cylindrical", function() { return Cylindrical; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Plane", function() { return Plane; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Frustum", function() { return Frustum; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Sphere", function() { return Sphere; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Ray", function() { return Ray; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Matrix4", function() { return Matrix4; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Matrix3", function() { return Matrix3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Box3", function() { return Box3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Box2", function() { return Box2; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Line3", function() { return Line3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Euler", function() { return Euler; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Vector4", function() { return Vector4; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Vector3", function() { return Vector3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Vector2", function() { return Vector2; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Quaternion", function() { return Quaternion; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Color", function() { return Color; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MorphBlendMesh", function() { return MorphBlendMesh; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ImmediateRenderObject", function() { return ImmediateRenderObject; });
/* harmony export (binding) */ __webpack_require__.d(exports, "VertexNormalsHelper", function() { return VertexNormalsHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SpotLightHelper", function() { return SpotLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SkeletonHelper", function() { return SkeletonHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PointLightHelper", function() { return PointLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RectAreaLightHelper", function() { return RectAreaLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "GridHelper", function() { return GridHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PolarGridHelper", function() { return PolarGridHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "FaceNormalsHelper", function() { return FaceNormalsHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CameraHelper", function() { return CameraHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BoxHelper", function() { return BoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ArrowHelper", function() { return ArrowHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AxisHelper", function() { return AxisHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SplineCurve3", function() { return SplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LineCurve3", function() { return LineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ArcCurve", function() { return ArcCurve; });
/* harmony export (binding) */ __webpack_require__.d(exports, "EllipseCurve", function() { return EllipseCurve; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SplineCurve", function() { return SplineCurve; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubicBezierCurve", function() { return CubicBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(exports, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LineCurve", function() { return LineCurve; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Shape", function() { return Shape; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ShapePath", function() { return ShapePath; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Path", function() { return Path; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Font", function() { return Font; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CurvePath", function() { return CurvePath; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Curve", function() { return Curve; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ShapeUtils", function() { return ShapeUtils; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SceneUtils", function() { return SceneUtils; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CurveUtils", function() { return CurveUtils; });
/* harmony export (binding) */ __webpack_require__.d(exports, "WireframeGeometry", function() { return WireframeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ParametricGeometry", function() { return ParametricGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ParametricBufferGeometry", function() { return ParametricBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TetrahedronBufferGeometry", function() { return TetrahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "OctahedronGeometry", function() { return OctahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "OctahedronBufferGeometry", function() { return OctahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "IcosahedronBufferGeometry", function() { return IcosahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DodecahedronBufferGeometry", function() { return DodecahedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PolyhedronBufferGeometry", function() { return PolyhedronBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TubeGeometry", function() { return TubeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TubeBufferGeometry", function() { return TubeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TorusKnotBufferGeometry", function() { return TorusKnotBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TorusGeometry", function() { return TorusGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TorusBufferGeometry", function() { return TorusBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TextGeometry", function() { return TextGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SphereBufferGeometry", function() { return SphereBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SphereGeometry", function() { return SphereGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RingGeometry", function() { return RingGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RingBufferGeometry", function() { return RingBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PlaneBufferGeometry", function() { return PlaneBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PlaneGeometry", function() { return PlaneGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LatheGeometry", function() { return LatheGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LatheBufferGeometry", function() { return LatheBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ShapeGeometry", function() { return ShapeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ShapeBufferGeometry", function() { return ShapeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "EdgesGeometry", function() { return EdgesGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ConeGeometry", function() { return ConeGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ConeBufferGeometry", function() { return ConeBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CylinderGeometry", function() { return CylinderGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CircleBufferGeometry", function() { return CircleBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CircleGeometry", function() { return CircleGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BoxBufferGeometry", function() { return BoxBufferGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BoxGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ShadowMaterial", function() { return ShadowMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SpriteMaterial", function() { return SpriteMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RawShaderMaterial", function() { return RawShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ShaderMaterial", function() { return ShaderMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PointsMaterial", function() { return PointsMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MultiMaterial", function() { return MultiMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MeshToonMaterial", function() { return MeshToonMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LineDashedMaterial", function() { return LineDashedMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LineBasicMaterial", function() { return LineBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Material", function() { return Material; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Float64BufferAttribute", function() { return Float64BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BufferAttribute", function() { return BufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "REVISION", function() { return REVISION; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MOUSE", function() { return MOUSE; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CullFaceNone", function() { return CullFaceNone; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CullFaceBack", function() { return CullFaceBack; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CullFaceFront", function() { return CullFaceFront; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
/* harmony export (binding) */ __webpack_require__.d(exports, "FrontFaceDirectionCW", function() { return FrontFaceDirectionCW; });
/* harmony export (binding) */ __webpack_require__.d(exports, "FrontFaceDirectionCCW", function() { return FrontFaceDirectionCCW; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BasicShadowMap", function() { return BasicShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PCFShadowMap", function() { return PCFShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
/* harmony export (binding) */ __webpack_require__.d(exports, "FrontSide", function() { return FrontSide; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BackSide", function() { return BackSide; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DoubleSide", function() { return DoubleSide; });
/* harmony export (binding) */ __webpack_require__.d(exports, "FlatShading", function() { return FlatShading; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SmoothShading", function() { return SmoothShading; });
/* harmony export (binding) */ __webpack_require__.d(exports, "NoColors", function() { return NoColors; });
/* harmony export (binding) */ __webpack_require__.d(exports, "FaceColors", function() { return FaceColors; });
/* harmony export (binding) */ __webpack_require__.d(exports, "VertexColors", function() { return VertexColors; });
/* harmony export (binding) */ __webpack_require__.d(exports, "NoBlending", function() { return NoBlending; });
/* harmony export (binding) */ __webpack_require__.d(exports, "NormalBlending", function() { return NormalBlending; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AdditiveBlending", function() { return AdditiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SubtractiveBlending", function() { return SubtractiveBlending; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MultiplyBlending", function() { return MultiplyBlending; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CustomBlending", function() { return CustomBlending; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BlendingMode", function() { return BlendingMode; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AddEquation", function() { return AddEquation; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SubtractEquation", function() { return SubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MinEquation", function() { return MinEquation; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MaxEquation", function() { return MaxEquation; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ZeroFactor", function() { return ZeroFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "OneFactor", function() { return OneFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SrcColorFactor", function() { return SrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DstAlphaFactor", function() { return DstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DstColorFactor", function() { return DstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
/* harmony export (binding) */ __webpack_require__.d(exports, "NeverDepth", function() { return NeverDepth; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AlwaysDepth", function() { return AlwaysDepth; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LessDepth", function() { return LessDepth; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LessEqualDepth", function() { return LessEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(exports, "EqualDepth", function() { return EqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(exports, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(exports, "GreaterDepth", function() { return GreaterDepth; });
/* harmony export (binding) */ __webpack_require__.d(exports, "NotEqualDepth", function() { return NotEqualDepth; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MultiplyOperation", function() { return MultiplyOperation; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MixOperation", function() { return MixOperation; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AddOperation", function() { return AddOperation; });
/* harmony export (binding) */ __webpack_require__.d(exports, "NoToneMapping", function() { return NoToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LinearToneMapping", function() { return LinearToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Uncharted2ToneMapping", function() { return Uncharted2ToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CineonToneMapping", function() { return CineonToneMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "UVMapping", function() { return UVMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "SphericalReflectionMapping", function() { return SphericalReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TextureMapping", function() { return TextureMapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RepeatWrapping", function() { return RepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TextureWrapping", function() { return TextureWrapping; });
/* harmony export (binding) */ __webpack_require__.d(exports, "NearestFilter", function() { return NearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(exports, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(exports, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LinearFilter", function() { return LinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TextureFilter", function() { return TextureFilter; });
/* harmony export (binding) */ __webpack_require__.d(exports, "UnsignedByteType", function() { return UnsignedByteType; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ByteType", function() { return ByteType; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ShortType", function() { return ShortType; });
/* harmony export (binding) */ __webpack_require__.d(exports, "UnsignedShortType", function() { return UnsignedShortType; });
/* harmony export (binding) */ __webpack_require__.d(exports, "IntType", function() { return IntType; });
/* harmony export (binding) */ __webpack_require__.d(exports, "UnsignedIntType", function() { return UnsignedIntType; });
/* harmony export (binding) */ __webpack_require__.d(exports, "FloatType", function() { return FloatType; });
/* harmony export (binding) */ __webpack_require__.d(exports, "HalfFloatType", function() { return HalfFloatType; });
/* harmony export (binding) */ __webpack_require__.d(exports, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
/* harmony export (binding) */ __webpack_require__.d(exports, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
/* harmony export (binding) */ __webpack_require__.d(exports, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
/* harmony export (binding) */ __webpack_require__.d(exports, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
/* harmony export (binding) */ __webpack_require__.d(exports, "AlphaFormat", function() { return AlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBFormat", function() { return RGBFormat; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBAFormat", function() { return RGBAFormat; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LuminanceFormat", function() { return LuminanceFormat; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBEFormat", function() { return RGBEFormat; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DepthFormat", function() { return DepthFormat; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DepthStencilFormat", function() { return DepthStencilFormat; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LoopOnce", function() { return LoopOnce; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LoopRepeat", function() { return LoopRepeat; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LoopPingPong", function() { return LoopPingPong; });
/* harmony export (binding) */ __webpack_require__.d(exports, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
/* harmony export (binding) */ __webpack_require__.d(exports, "InterpolateLinear", function() { return InterpolateLinear; });
/* harmony export (binding) */ __webpack_require__.d(exports, "InterpolateSmooth", function() { return InterpolateSmooth; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "WrapAroundEnding", function() { return WrapAroundEnding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(exports, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LinearEncoding", function() { return LinearEncoding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "sRGBEncoding", function() { return sRGBEncoding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "GammaEncoding", function() { return GammaEncoding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBEEncoding", function() { return RGBEEncoding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LogLuvEncoding", function() { return LogLuvEncoding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBM7Encoding", function() { return RGBM7Encoding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBM16Encoding", function() { return RGBM16Encoding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBDEncoding", function() { return RGBDEncoding; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BasicDepthPacking", function() { return BasicDepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(exports, "RGBADepthPacking", function() { return RGBADepthPacking; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CubeGeometry", function() { return BoxGeometry; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Face4", function() { return Face4; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LineStrip", function() { return LineStrip; });
/* harmony export (binding) */ __webpack_require__.d(exports, "LinePieces", function() { return LinePieces; });
/* harmony export (binding) */ __webpack_require__.d(exports, "MeshFaceMaterial", function() { return MeshFaceMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PointCloud", function() { return PointCloud; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Particle", function() { return Particle; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ParticleSystem", function() { return ParticleSystem; });
/* harmony export (binding) */ __webpack_require__.d(exports, "PointCloudMaterial", function() { return PointCloudMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ParticleBasicMaterial", function() { return ParticleBasicMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ParticleSystemMaterial", function() { return ParticleSystemMaterial; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Vertex", function() { return Vertex; });
/* harmony export (binding) */ __webpack_require__.d(exports, "DynamicBufferAttribute", function() { return DynamicBufferAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Int8Attribute", function() { return Int8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Uint8Attribute", function() { return Uint8Attribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Uint8ClampedAttribute", function() { return Uint8ClampedAttribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Int16Attribute", function() { return Int16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Uint16Attribute", function() { return Uint16Attribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Int32Attribute", function() { return Int32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Uint32Attribute", function() { return Uint32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Float32Attribute", function() { return Float32Attribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Float64Attribute", function() { return Float64Attribute; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ClosedSplineCurve3", function() { return ClosedSplineCurve3; });
/* harmony export (binding) */ __webpack_require__.d(exports, "BoundingBoxHelper", function() { return BoundingBoxHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "EdgesHelper", function() { return EdgesHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "WireframeHelper", function() { return WireframeHelper; });
/* harmony export (binding) */ __webpack_require__.d(exports, "XHRLoader", function() { return XHRLoader; });
/* harmony export (binding) */ __webpack_require__.d(exports, "GeometryUtils", function() { return GeometryUtils; });
/* harmony export (binding) */ __webpack_require__.d(exports, "ImageUtils", function() { return ImageUtils; });
/* harmony export (binding) */ __webpack_require__.d(exports, "Projector", function() { return Projector; });
/* harmony export (binding) */ __webpack_require__.d(exports, "CanvasRenderer", function() { return CanvasRenderer; });
// Polyfills

if ( Number.EPSILON === undefined ) {

	Number.EPSILON = Math.pow( 2, - 52 );

}

//

if ( Math.sign === undefined ) {

	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign

	Math.sign = function ( x ) {

		return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;

	};

}

if ( Function.prototype.name === undefined ) {

	// Missing in IE9-11.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name

	Object.defineProperty( Function.prototype, 'name', {

		get: function () {

			return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];

		}

	} );

}

if ( Object.assign === undefined ) {

	// Missing in IE.
	// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign

	( function () {

		Object.assign = function ( target ) {

			'use strict';

			if ( target === undefined || target === null ) {

				throw new TypeError( 'Cannot convert undefined or null to object' );

			}

			var output = Object( target );

			for ( var index = 1; index < arguments.length; index ++ ) {

				var source = arguments[ index ];

				if ( source !== undefined && source !== null ) {

					for ( var nextKey in source ) {

						if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {

							output[ nextKey ] = source[ nextKey ];

						}

					}

				}

			}

			return output;

		};

	} )();

}

/**
 * https://github.com/mrdoob/eventdispatcher.js/
 */

function EventDispatcher() {}

Object.assign( EventDispatcher.prototype, {

	addEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) this._listeners = {};

		var listeners = this._listeners;

		if ( listeners[ type ] === undefined ) {

			listeners[ type ] = [];

		}

		if ( listeners[ type ].indexOf( listener ) === - 1 ) {

			listeners[ type ].push( listener );

		}

	},

	hasEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return false;

		var listeners = this._listeners;

		return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;

	},

	removeEventListener: function ( type, listener ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ type ];

		if ( listenerArray !== undefined ) {

			var index = listenerArray.indexOf( listener );

			if ( index !== - 1 ) {

				listenerArray.splice( index, 1 );

			}

		}

	},

	dispatchEvent: function ( event ) {

		if ( this._listeners === undefined ) return;

		var listeners = this._listeners;
		var listenerArray = listeners[ event.type ];

		if ( listenerArray !== undefined ) {

			event.target = this;

			var array = [], i = 0;
			var length = listenerArray.length;

			for ( i = 0; i < length; i ++ ) {

				array[ i ] = listenerArray[ i ];

			}

			for ( i = 0; i < length; i ++ ) {

				array[ i ].call( this, event );

			}

		}

	}

} );

var REVISION = '83';
var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
var CullFaceNone = 0;
var CullFaceBack = 1;
var CullFaceFront = 2;
var CullFaceFrontBack = 3;
var FrontFaceDirectionCW = 0;
var FrontFaceDirectionCCW = 1;
var BasicShadowMap = 0;
var PCFShadowMap = 1;
var PCFSoftShadowMap = 2;
var FrontSide = 0;
var BackSide = 1;
var DoubleSide = 2;
var FlatShading = 1;
var SmoothShading = 2;
var NoColors = 0;
var FaceColors = 1;
var VertexColors = 2;
var NoBlending = 0;
var NormalBlending = 1;
var AdditiveBlending = 2;
var SubtractiveBlending = 3;
var MultiplyBlending = 4;
var CustomBlending = 5;
var BlendingMode = {
	NoBlending: NoBlending,
	NormalBlending: NormalBlending,
	AdditiveBlending: AdditiveBlending,
	SubtractiveBlending: SubtractiveBlending,
	MultiplyBlending: MultiplyBlending,
	CustomBlending: CustomBlending
};
var AddEquation = 100;
var SubtractEquation = 101;
var ReverseSubtractEquation = 102;
var MinEquation = 103;
var MaxEquation = 104;
var ZeroFactor = 200;
var OneFactor = 201;
var SrcColorFactor = 202;
var OneMinusSrcColorFactor = 203;
var SrcAlphaFactor = 204;
var OneMinusSrcAlphaFactor = 205;
var DstAlphaFactor = 206;
var OneMinusDstAlphaFactor = 207;
var DstColorFactor = 208;
var OneMinusDstColorFactor = 209;
var SrcAlphaSaturateFactor = 210;
var NeverDepth = 0;
var AlwaysDepth = 1;
var LessDepth = 2;
var LessEqualDepth = 3;
var EqualDepth = 4;
var GreaterEqualDepth = 5;
var GreaterDepth = 6;
var NotEqualDepth = 7;
var MultiplyOperation = 0;
var MixOperation = 1;
var AddOperation = 2;
var NoToneMapping = 0;
var LinearToneMapping = 1;
var ReinhardToneMapping = 2;
var Uncharted2ToneMapping = 3;
var CineonToneMapping = 4;
var UVMapping = 300;
var CubeReflectionMapping = 301;
var CubeRefractionMapping = 302;
var EquirectangularReflectionMapping = 303;
var EquirectangularRefractionMapping = 304;
var SphericalReflectionMapping = 305;
var CubeUVReflectionMapping = 306;
var CubeUVRefractionMapping = 307;
var TextureMapping = {
	UVMapping: UVMapping,
	CubeReflectionMapping: CubeReflectionMapping,
	CubeRefractionMapping: CubeRefractionMapping,
	EquirectangularReflectionMapping: EquirectangularReflectionMapping,
	EquirectangularRefractionMapping: EquirectangularRefractionMapping,
	SphericalReflectionMapping: SphericalReflectionMapping,
	CubeUVReflectionMapping: CubeUVReflectionMapping,
	CubeUVRefractionMapping: CubeUVRefractionMapping
};
var RepeatWrapping = 1000;
var ClampToEdgeWrapping = 1001;
var MirroredRepeatWrapping = 1002;
var TextureWrapping = {
	RepeatWrapping: RepeatWrapping,
	ClampToEdgeWrapping: ClampToEdgeWrapping,
	MirroredRepeatWrapping: MirroredRepeatWrapping
};
var NearestFilter = 1003;
var NearestMipMapNearestFilter = 1004;
var NearestMipMapLinearFilter = 1005;
var LinearFilter = 1006;
var LinearMipMapNearestFilter = 1007;
var LinearMipMapLinearFilter = 1008;
var TextureFilter = {
	NearestFilter: NearestFilter,
	NearestMipMapNearestFilter: NearestMipMapNearestFilter,
	NearestMipMapLinearFilter: NearestMipMapLinearFilter,
	LinearFilter: LinearFilter,
	LinearMipMapNearestFilter: LinearMipMapNearestFilter,
	LinearMipMapLinearFilter: LinearMipMapLinearFilter
};
var UnsignedByteType = 1009;
var ByteType = 1010;
var ShortType = 1011;
var UnsignedShortType = 1012;
var IntType = 1013;
var UnsignedIntType = 1014;
var FloatType = 1015;
var HalfFloatType = 1016;
var UnsignedShort4444Type = 1017;
var UnsignedShort5551Type = 1018;
var UnsignedShort565Type = 1019;
var UnsignedInt248Type = 1020;
var AlphaFormat = 1021;
var RGBFormat = 1022;
var RGBAFormat = 1023;
var LuminanceFormat = 1024;
var LuminanceAlphaFormat = 1025;
var RGBEFormat = RGBAFormat;
var DepthFormat = 1026;
var DepthStencilFormat = 1027;
var RGB_S3TC_DXT1_Format = 2001;
var RGBA_S3TC_DXT1_Format = 2002;
var RGBA_S3TC_DXT3_Format = 2003;
var RGBA_S3TC_DXT5_Format = 2004;
var RGB_PVRTC_4BPPV1_Format = 2100;
var RGB_PVRTC_2BPPV1_Format = 2101;
var RGBA_PVRTC_4BPPV1_Format = 2102;
var RGBA_PVRTC_2BPPV1_Format = 2103;
var RGB_ETC1_Format = 2151;
var LoopOnce = 2200;
var LoopRepeat = 2201;
var LoopPingPong = 2202;
var InterpolateDiscrete = 2300;
var InterpolateLinear = 2301;
var InterpolateSmooth = 2302;
var ZeroCurvatureEnding = 2400;
var ZeroSlopeEnding = 2401;
var WrapAroundEnding = 2402;
var TrianglesDrawMode = 0;
var TriangleStripDrawMode = 1;
var TriangleFanDrawMode = 2;
var LinearEncoding = 3000;
var sRGBEncoding = 3001;
var GammaEncoding = 3007;
var RGBEEncoding = 3002;
var LogLuvEncoding = 3003;
var RGBM7Encoding = 3004;
var RGBM16Encoding = 3005;
var RGBDEncoding = 3006;
var BasicDepthPacking = 3200;
var RGBADepthPacking = 3201;

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

var _Math = {

	DEG2RAD: Math.PI / 180,
	RAD2DEG: 180 / Math.PI,

	generateUUID: function () {

		// http://www.broofa.com/Tools/Math.uuid.htm

		var chars = '0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz'.split( '' );
		var uuid = new Array( 36 );
		var rnd = 0, r;

		return function generateUUID() {

			for ( var i = 0; i < 36; i ++ ) {

				if ( i === 8 || i === 13 || i === 18 || i === 23 ) {

					uuid[ i ] = '-';

				} else if ( i === 14 ) {

					uuid[ i ] = '4';

				} else {

					if ( rnd <= 0x02 ) rnd = 0x2000000 + ( Math.random() * 0x1000000 ) | 0;
					r = rnd & 0xf;
					rnd = rnd >> 4;
					uuid[ i ] = chars[ ( i === 19 ) ? ( r & 0x3 ) | 0x8 : r ];

				}

			}

			return uuid.join( '' );

		};

	}(),

	clamp: function ( value, min, max ) {

		return Math.max( min, Math.min( max, value ) );

	},

	// compute euclidian modulo of m % n
	// https://en.wikipedia.org/wiki/Modulo_operation

	euclideanModulo: function ( n, m ) {

		return ( ( n % m ) + m ) % m;

	},

	// Linear mapping from range <a1, a2> to range <b1, b2>

	mapLinear: function ( x, a1, a2, b1, b2 ) {

		return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );

	},

	// https://en.wikipedia.org/wiki/Linear_interpolation

	lerp: function ( x, y, t ) {

		return ( 1 - t ) * x + t * y;

	},

	// http://en.wikipedia.org/wiki/Smoothstep

	smoothstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * ( 3 - 2 * x );

	},

	smootherstep: function ( x, min, max ) {

		if ( x <= min ) return 0;
		if ( x >= max ) return 1;

		x = ( x - min ) / ( max - min );

		return x * x * x * ( x * ( x * 6 - 15 ) + 10 );

	},

	// Random integer from <low, high> interval

	randInt: function ( low, high ) {

		return low + Math.floor( Math.random() * ( high - low + 1 ) );

	},

	// Random float from <low, high> interval

	randFloat: function ( low, high ) {

		return low + Math.random() * ( high - low );

	},

	// Random float from <-range/2, range/2> interval

	randFloatSpread: function ( range ) {

		return range * ( 0.5 - Math.random() );

	},

	degToRad: function ( degrees ) {

		return degrees * _Math.DEG2RAD;

	},

	radToDeg: function ( radians ) {

		return radians * _Math.RAD2DEG;

	},

	isPowerOfTwo: function ( value ) {

		return ( value & ( value - 1 ) ) === 0 && value !== 0;

	},

	nearestPowerOfTwo: function ( value ) {

		return Math.pow( 2, Math.round( Math.log( value ) / Math.LN2 ) );

	},

	nextPowerOfTwo: function ( value ) {

		value --;
		value |= value >> 1;
		value |= value >> 2;
		value |= value >> 4;
		value |= value >> 8;
		value |= value >> 16;
		value ++;

		return value;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author philogb / http://blog.thejit.org/
 * @author egraether / http://egraether.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

function Vector2( x, y ) {

	this.x = x || 0;
	this.y = y || 0;

}

Vector2.prototype = {

	constructor: Vector2,

	isVector2: true,

	get width() {

		return this.x;

	},

	set width( value ) {

		this.x = value;

	},

	get height() {

		return this.y;

	},

	set height( value ) {

		this.y = value;

	},

	//

	set: function ( x, y ) {

		this.x = x;
		this.y = y;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;

		return this;

	},

	multiply: function ( v ) {

		this.x *= v.x;
		this.y *= v.y;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;

		} else {

			this.x = 0;
			this.y = 0;

		}

		return this;

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new Vector2();
				max = new Vector2();

			}

			min.set( minVal, minVal );
			max.set( maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y );

	},

	lengthManhattan: function() {

		return Math.abs( this.x ) + Math.abs( this.y );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	angle: function () {

		// computes the angle in radians with respect to the positive x-axis

		var angle = Math.atan2( this.y, this.x );

		if ( angle < 0 ) angle += 2 * Math.PI;

		return angle;

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y;
		return dx * dx + dy * dy;

	},

	distanceToManhattan: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector2: offset has been removed from .fromAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );

		return this;

	},

	rotateAround: function ( center, angle ) {

		var c = Math.cos( angle ), s = Math.sin( angle );

		var x = this.x - center.x;
		var y = this.y - center.y;

		this.x = x * c - y * s + center.x;
		this.y = x * s + y * c + center.y;

		return this;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 */

var textureId = 0;

function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	Object.defineProperty( this, 'id', { value: textureId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';

	this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
	this.mipmaps = [];

	this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;

	this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
	this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;

	this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
	this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;

	this.anisotropy = anisotropy !== undefined ? anisotropy : 1;

	this.format = format !== undefined ? format : RGBAFormat;
	this.type = type !== undefined ? type : UnsignedByteType;

	this.offset = new Vector2( 0, 0 );
	this.repeat = new Vector2( 1, 1 );

	this.generateMipmaps = true;
	this.premultiplyAlpha = false;
	this.flipY = true;
	this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)


	// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
	//
	// Also changing the encoding after already used by a Material will not automatically make the Material
	// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
	this.encoding = encoding !== undefined ? encoding : LinearEncoding;

	this.version = 0;
	this.onUpdate = null;

}

Texture.DEFAULT_IMAGE = undefined;
Texture.DEFAULT_MAPPING = UVMapping;

Texture.prototype = {

	constructor: Texture,

	isTexture: true,

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.image = source.image;
		this.mipmaps = source.mipmaps.slice( 0 );

		this.mapping = source.mapping;

		this.wrapS = source.wrapS;
		this.wrapT = source.wrapT;

		this.magFilter = source.magFilter;
		this.minFilter = source.minFilter;

		this.anisotropy = source.anisotropy;

		this.format = source.format;
		this.type = source.type;

		this.offset.copy( source.offset );
		this.repeat.copy( source.repeat );

		this.generateMipmaps = source.generateMipmaps;
		this.premultiplyAlpha = source.premultiplyAlpha;
		this.flipY = source.flipY;
		this.unpackAlignment = source.unpackAlignment;
		this.encoding = source.encoding;

		return this;

	},

	toJSON: function ( meta ) {

		if ( meta.textures[ this.uuid ] !== undefined ) {

			return meta.textures[ this.uuid ];

		}

		function getDataURL( image ) {

			var canvas;

			if ( image.toDataURL !== undefined ) {

				canvas = image;

			} else {

				canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
				canvas.width = image.width;
				canvas.height = image.height;

				canvas.getContext( '2d' ).drawImage( image, 0, 0, image.width, image.height );

			}

			if ( canvas.width > 2048 || canvas.height > 2048 ) {

				return canvas.toDataURL( 'image/jpeg', 0.6 );

			} else {

				return canvas.toDataURL( 'image/png' );

			}

		}

		var output = {
			metadata: {
				version: 4.4,
				type: 'Texture',
				generator: 'Texture.toJSON'
			},

			uuid: this.uuid,
			name: this.name,

			mapping: this.mapping,

			repeat: [ this.repeat.x, this.repeat.y ],
			offset: [ this.offset.x, this.offset.y ],
			wrap: [ this.wrapS, this.wrapT ],

			minFilter: this.minFilter,
			magFilter: this.magFilter,
			anisotropy: this.anisotropy,

			flipY: this.flipY
		};

		if ( this.image !== undefined ) {

			// TODO: Move to THREE.Image

			var image = this.image;

			if ( image.uuid === undefined ) {

				image.uuid = _Math.generateUUID(); // UGH

			}

			if ( meta.images[ image.uuid ] === undefined ) {

				meta.images[ image.uuid ] = {
					uuid: image.uuid,
					url: getDataURL( image )
				};

			}

			output.image = image.uuid;

		}

		meta.textures[ this.uuid ] = output;

		return output;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	},

	transformUv: function ( uv ) {

		if ( this.mapping !== UVMapping ) return;

		uv.multiply( this.repeat );
		uv.add( this.offset );

		if ( uv.x < 0 || uv.x > 1 ) {

			switch ( this.wrapS ) {

				case RepeatWrapping:

					uv.x = uv.x - Math.floor( uv.x );
					break;

				case ClampToEdgeWrapping:

					uv.x = uv.x < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {

						uv.x = Math.ceil( uv.x ) - uv.x;

					} else {

						uv.x = uv.x - Math.floor( uv.x );

					}
					break;

			}

		}

		if ( uv.y < 0 || uv.y > 1 ) {

			switch ( this.wrapT ) {

				case RepeatWrapping:

					uv.y = uv.y - Math.floor( uv.y );
					break;

				case ClampToEdgeWrapping:

					uv.y = uv.y < 0 ? 0 : 1;
					break;

				case MirroredRepeatWrapping:

					if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {

						uv.y = Math.ceil( uv.y ) - uv.y;

					} else {

						uv.y = uv.y - Math.floor( uv.y );

					}
					break;

			}

		}

		if ( this.flipY ) {

			uv.y = 1 - uv.y;

		}

	}

};

Object.assign( Texture.prototype, EventDispatcher.prototype );

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector4( x, y, z, w ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;
	this.w = ( w !== undefined ) ? w : 1;

}

Vector4.prototype = {

	constructor: Vector4,

	isVector4: true,

	set: function ( x, y, z, w ) {

		this.x = x;
		this.y = y;
		this.z = z;
		this.w = w;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;
		this.w = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setW: function ( w ) {

		this.w = w;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			case 3: this.w = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			case 3: return this.w;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z, this.w );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;
		this.w = ( v.w !== undefined ) ? v.w : 1;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;
		this.w += v.w;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;
		this.w += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;
		this.w = a.w + b.w;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;
		this.w += v.w * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;
		this.w -= v.w;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;
		this.w -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;
		this.w = a.w - b.w;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;
			this.w = 0;

		}

		return this;

	},

	applyMatrix4: function ( m ) {

		var x = this.x, y = this.y, z = this.z, w = this.w;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
		this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	setAxisAngleFromQuaternion: function ( q ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm

		// q is assumed to be normalized

		this.w = 2 * Math.acos( q.w );

		var s = Math.sqrt( 1 - q.w * q.w );

		if ( s < 0.0001 ) {

			 this.x = 1;
			 this.y = 0;
			 this.z = 0;

		} else {

			 this.x = q.x / s;
			 this.y = q.y / s;
			 this.z = q.z / s;

		}

		return this;

	},

	setAxisAngleFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var angle, x, y, z,		// variables for result
			epsilon = 0.01,		// margin to allow for rounding errors
			epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees

			te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
		     ( Math.abs( m13 - m31 ) < epsilon ) &&
		     ( Math.abs( m23 - m32 ) < epsilon ) ) {

			// singularity found
			// first check for identity matrix which must have +1 for all terms
			// in leading diagonal and zero in other terms

			if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
			     ( Math.abs( m13 + m31 ) < epsilon2 ) &&
			     ( Math.abs( m23 + m32 ) < epsilon2 ) &&
			     ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {

				// this singularity is identity matrix so angle = 0

				this.set( 1, 0, 0, 0 );

				return this; // zero angle, arbitrary axis

			}

			// otherwise this singularity is angle = 180

			angle = Math.PI;

			var xx = ( m11 + 1 ) / 2;
			var yy = ( m22 + 1 ) / 2;
			var zz = ( m33 + 1 ) / 2;
			var xy = ( m12 + m21 ) / 4;
			var xz = ( m13 + m31 ) / 4;
			var yz = ( m23 + m32 ) / 4;

			if ( ( xx > yy ) && ( xx > zz ) ) {

				// m11 is the largest diagonal term

				if ( xx < epsilon ) {

					x = 0;
					y = 0.707106781;
					z = 0.707106781;

				} else {

					x = Math.sqrt( xx );
					y = xy / x;
					z = xz / x;

				}

			} else if ( yy > zz ) {

				// m22 is the largest diagonal term

				if ( yy < epsilon ) {

					x = 0.707106781;
					y = 0;
					z = 0.707106781;

				} else {

					y = Math.sqrt( yy );
					x = xy / y;
					z = yz / y;

				}

			} else {

				// m33 is the largest diagonal term so base result on this

				if ( zz < epsilon ) {

					x = 0.707106781;
					y = 0.707106781;
					z = 0;

				} else {

					z = Math.sqrt( zz );
					x = xz / z;
					y = yz / z;

				}

			}

			this.set( x, y, z, angle );

			return this; // return 180 deg rotation

		}

		// as we have reached here there are no singularities so we can handle normally

		var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
		                   ( m13 - m31 ) * ( m13 - m31 ) +
		                   ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize

		if ( Math.abs( s ) < 0.001 ) s = 1;

		// prevent divide by zero, should not happen if matrix is orthogonal and should be
		// caught by singularity test above, but I've left it in just in case

		this.x = ( m32 - m23 ) / s;
		this.y = ( m13 - m31 ) / s;
		this.z = ( m21 - m12 ) / s;
		this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );

		return this;

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );
		this.w = Math.min( this.w, v.w );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );
		this.w = Math.max( this.w, v.w );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );
		this.w = Math.max( min.w, Math.min( max.w, this.w ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new Vector4();
				max = new Vector4();

			}

			min.set( minVal, minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );
		this.w = Math.floor( this.w );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );
		this.w = Math.ceil( this.w );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );
		this.w = Math.round( this.w );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
		this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;
		this.w = - this.w;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;
		this.w += ( v.w - this.w ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];
		this.w = array[ offset + 3 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;
		array[ offset + 3 ] = this.w;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector4: offset has been removed from .fromAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );
		this.w = attribute.getW( index );

		return this;

	}

};

/**
 * @author szimek / https://github.com/szimek/
 * @author alteredq / http://alteredqualia.com/
 * @author Marius Kintel / https://github.com/kintel
 */

/*
 In options, we can specify:
 * Texture parameters for an auto-generated target texture
 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
*/
function WebGLRenderTarget( width, height, options ) {

	this.uuid = _Math.generateUUID();

	this.width = width;
	this.height = height;

	this.scissor = new Vector4( 0, 0, width, height );
	this.scissorTest = false;

	this.viewport = new Vector4( 0, 0, width, height );

	options = options || {};

	if ( options.minFilter === undefined ) options.minFilter = LinearFilter;

	this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );

	this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
	this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
	this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;

}

Object.assign( WebGLRenderTarget.prototype, EventDispatcher.prototype, {

	isWebGLRenderTarget: true,

	setSize: function ( width, height ) {

		if ( this.width !== width || this.height !== height ) {

			this.width = width;
			this.height = height;

			this.dispose();

		}

		this.viewport.set( 0, 0, width, height );
		this.scissor.set( 0, 0, width, height );

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.width = source.width;
		this.height = source.height;

		this.viewport.copy( source.viewport );

		this.texture = source.texture.clone();

		this.depthBuffer = source.depthBuffer;
		this.stencilBuffer = source.stencilBuffer;
		this.depthTexture = source.depthTexture;

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

/**
 * @author alteredq / http://alteredqualia.com
 */

function WebGLRenderTargetCube( width, height, options ) {

	WebGLRenderTarget.call( this, width, height, options );

	this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
	this.activeMipMapLevel = 0;

}

WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;

WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Quaternion( x, y, z, w ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._w = ( w !== undefined ) ? w : 1;

}

Quaternion.prototype = {

	constructor: Quaternion,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get w () {

		return this._w;

	},

	set w ( value ) {

		this._w = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, w ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._w = w;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._w );

	},

	copy: function ( quaternion ) {

		this._x = quaternion.x;
		this._y = quaternion.y;
		this._z = quaternion.z;
		this._w = quaternion.w;

		this.onChangeCallback();

		return this;

	},

	setFromEuler: function ( euler, update ) {

		if ( (euler && euler.isEuler) === false ) {

			throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );

		}

		// http://www.mathworks.com/matlabcentral/fileexchange/
		// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
		//	content/SpinCalc.m

		var c1 = Math.cos( euler._x / 2 );
		var c2 = Math.cos( euler._y / 2 );
		var c3 = Math.cos( euler._z / 2 );
		var s1 = Math.sin( euler._x / 2 );
		var s2 = Math.sin( euler._y / 2 );
		var s3 = Math.sin( euler._z / 2 );

		var order = euler.order;

		if ( order === 'XYZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'YXZ' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'ZXY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'ZYX' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		} else if ( order === 'YZX' ) {

			this._x = s1 * c2 * c3 + c1 * s2 * s3;
			this._y = c1 * s2 * c3 + s1 * c2 * s3;
			this._z = c1 * c2 * s3 - s1 * s2 * c3;
			this._w = c1 * c2 * c3 - s1 * s2 * s3;

		} else if ( order === 'XZY' ) {

			this._x = s1 * c2 * c3 - c1 * s2 * s3;
			this._y = c1 * s2 * c3 - s1 * c2 * s3;
			this._z = c1 * c2 * s3 + s1 * s2 * c3;
			this._w = c1 * c2 * c3 + s1 * s2 * s3;

		}

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromAxisAngle: function ( axis, angle ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm

		// assumes axis is normalized

		var halfAngle = angle / 2, s = Math.sin( halfAngle );

		this._x = axis.x * s;
		this._y = axis.y * s;
		this._z = axis.z * s;
		this._w = Math.cos( halfAngle );

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m ) {

		// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements,

			m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
			m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
			m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],

			trace = m11 + m22 + m33,
			s;

		if ( trace > 0 ) {

			s = 0.5 / Math.sqrt( trace + 1.0 );

			this._w = 0.25 / s;
			this._x = ( m32 - m23 ) * s;
			this._y = ( m13 - m31 ) * s;
			this._z = ( m21 - m12 ) * s;

		} else if ( m11 > m22 && m11 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );

			this._w = ( m32 - m23 ) / s;
			this._x = 0.25 * s;
			this._y = ( m12 + m21 ) / s;
			this._z = ( m13 + m31 ) / s;

		} else if ( m22 > m33 ) {

			s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );

			this._w = ( m13 - m31 ) / s;
			this._x = ( m12 + m21 ) / s;
			this._y = 0.25 * s;
			this._z = ( m23 + m32 ) / s;

		} else {

			s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );

			this._w = ( m21 - m12 ) / s;
			this._x = ( m13 + m31 ) / s;
			this._y = ( m23 + m32 ) / s;
			this._z = 0.25 * s;

		}

		this.onChangeCallback();

		return this;

	},

	setFromUnitVectors: function () {

		// http://lolengine.net/blog/2014/02/24/quaternion-from-two-vectors-final

		// assumes direction vectors vFrom and vTo are normalized

		var v1, r;

		var EPS = 0.000001;

		return function setFromUnitVectors( vFrom, vTo ) {

			if ( v1 === undefined ) v1 = new Vector3();

			r = vFrom.dot( vTo ) + 1;

			if ( r < EPS ) {

				r = 0;

				if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {

					v1.set( - vFrom.y, vFrom.x, 0 );

				} else {

					v1.set( 0, - vFrom.z, vFrom.y );

				}

			} else {

				v1.crossVectors( vFrom, vTo );

			}

			this._x = v1.x;
			this._y = v1.y;
			this._z = v1.z;
			this._w = r;

			return this.normalize();

		};

	}(),

	inverse: function () {

		return this.conjugate().normalize();

	},

	conjugate: function () {

		this._x *= - 1;
		this._y *= - 1;
		this._z *= - 1;

		this.onChangeCallback();

		return this;

	},

	dot: function ( v ) {

		return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;

	},

	lengthSq: function () {

		return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;

	},

	length: function () {

		return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );

	},

	normalize: function () {

		var l = this.length();

		if ( l === 0 ) {

			this._x = 0;
			this._y = 0;
			this._z = 0;
			this._w = 1;

		} else {

			l = 1 / l;

			this._x = this._x * l;
			this._y = this._y * l;
			this._z = this._z * l;
			this._w = this._w * l;

		}

		this.onChangeCallback();

		return this;

	},

	multiply: function ( q, p ) {

		if ( p !== undefined ) {

			console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
			return this.multiplyQuaternions( q, p );

		}

		return this.multiplyQuaternions( this, q );

	},

	premultiply: function ( q ) {

		return this.multiplyQuaternions( q, this );

	},

	multiplyQuaternions: function ( a, b ) {

		// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm

		var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
		var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;

		this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
		this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
		this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
		this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;

		this.onChangeCallback();

		return this;

	},

	slerp: function ( qb, t ) {

		if ( t === 0 ) return this;
		if ( t === 1 ) return this.copy( qb );

		var x = this._x, y = this._y, z = this._z, w = this._w;

		// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/

		var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;

		if ( cosHalfTheta < 0 ) {

			this._w = - qb._w;
			this._x = - qb._x;
			this._y = - qb._y;
			this._z = - qb._z;

			cosHalfTheta = - cosHalfTheta;

		} else {

			this.copy( qb );

		}

		if ( cosHalfTheta >= 1.0 ) {

			this._w = w;
			this._x = x;
			this._y = y;
			this._z = z;

			return this;

		}

		var sinHalfTheta = Math.sqrt( 1.0 - cosHalfTheta * cosHalfTheta );

		if ( Math.abs( sinHalfTheta ) < 0.001 ) {

			this._w = 0.5 * ( w + this._w );
			this._x = 0.5 * ( x + this._x );
			this._y = 0.5 * ( y + this._y );
			this._z = 0.5 * ( z + this._z );

			return this;

		}

		var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
		var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
		ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;

		this._w = ( w * ratioA + this._w * ratioB );
		this._x = ( x * ratioA + this._x * ratioB );
		this._y = ( y * ratioA + this._y * ratioB );
		this._z = ( z * ratioA + this._z * ratioB );

		this.onChangeCallback();

		return this;

	},

	equals: function ( quaternion ) {

		return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this._x = array[ offset ];
		this._y = array[ offset + 1 ];
		this._z = array[ offset + 2 ];
		this._w = array[ offset + 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._w;

		return array;

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

Object.assign( Quaternion, {

	slerp: function( qa, qb, qm, t ) {

		return qm.copy( qa ).slerp( qb, t );

	},

	slerpFlat: function(
			dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {

		// fuzz-free, array-based Quaternion SLERP operation

		var x0 = src0[ srcOffset0 + 0 ],
			y0 = src0[ srcOffset0 + 1 ],
			z0 = src0[ srcOffset0 + 2 ],
			w0 = src0[ srcOffset0 + 3 ],

			x1 = src1[ srcOffset1 + 0 ],
			y1 = src1[ srcOffset1 + 1 ],
			z1 = src1[ srcOffset1 + 2 ],
			w1 = src1[ srcOffset1 + 3 ];

		if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {

			var s = 1 - t,

				cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,

				dir = ( cos >= 0 ? 1 : - 1 ),
				sqrSin = 1 - cos * cos;

			// Skip the Slerp for tiny steps to avoid numeric problems:
			if ( sqrSin > Number.EPSILON ) {

				var sin = Math.sqrt( sqrSin ),
					len = Math.atan2( sin, cos * dir );

				s = Math.sin( s * len ) / sin;
				t = Math.sin( t * len ) / sin;

			}

			var tDir = t * dir;

			x0 = x0 * s + x1 * tDir;
			y0 = y0 * s + y1 * tDir;
			z0 = z0 * s + z1 * tDir;
			w0 = w0 * s + w1 * tDir;

			// Normalize in case we just did a lerp:
			if ( s === 1 - t ) {

				var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );

				x0 *= f;
				y0 *= f;
				z0 *= f;
				w0 *= f;

			}

		}

		dst[ dstOffset ] = x0;
		dst[ dstOffset + 1 ] = y0;
		dst[ dstOffset + 2 ] = z0;
		dst[ dstOffset + 3 ] = w0;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author *kile / http://kile.stravaganza.org/
 * @author philogb / http://blog.thejit.org/
 * @author mikael emtinger / http://gomo.se/
 * @author egraether / http://egraether.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function Vector3( x, y, z ) {

	this.x = x || 0;
	this.y = y || 0;
	this.z = z || 0;

}

Vector3.prototype = {

	constructor: Vector3,

	isVector3: true,

	set: function ( x, y, z ) {

		this.x = x;
		this.y = y;
		this.z = z;

		return this;

	},

	setScalar: function ( scalar ) {

		this.x = scalar;
		this.y = scalar;
		this.z = scalar;

		return this;

	},

	setX: function ( x ) {

		this.x = x;

		return this;

	},

	setY: function ( y ) {

		this.y = y;

		return this;

	},

	setZ: function ( z ) {

		this.z = z;

		return this;

	},

	setComponent: function ( index, value ) {

		switch ( index ) {

			case 0: this.x = value; break;
			case 1: this.y = value; break;
			case 2: this.z = value; break;
			default: throw new Error( 'index is out of range: ' + index );

		}

		return this;

	},

	getComponent: function ( index ) {

		switch ( index ) {

			case 0: return this.x;
			case 1: return this.y;
			case 2: return this.z;
			default: throw new Error( 'index is out of range: ' + index );

		}

	},

	clone: function () {

		return new this.constructor( this.x, this.y, this.z );

	},

	copy: function ( v ) {

		this.x = v.x;
		this.y = v.y;
		this.z = v.z;

		return this;

	},

	add: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
			return this.addVectors( v, w );

		}

		this.x += v.x;
		this.y += v.y;
		this.z += v.z;

		return this;

	},

	addScalar: function ( s ) {

		this.x += s;
		this.y += s;
		this.z += s;

		return this;

	},

	addVectors: function ( a, b ) {

		this.x = a.x + b.x;
		this.y = a.y + b.y;
		this.z = a.z + b.z;

		return this;

	},

	addScaledVector: function ( v, s ) {

		this.x += v.x * s;
		this.y += v.y * s;
		this.z += v.z * s;

		return this;

	},

	sub: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
			return this.subVectors( v, w );

		}

		this.x -= v.x;
		this.y -= v.y;
		this.z -= v.z;

		return this;

	},

	subScalar: function ( s ) {

		this.x -= s;
		this.y -= s;
		this.z -= s;

		return this;

	},

	subVectors: function ( a, b ) {

		this.x = a.x - b.x;
		this.y = a.y - b.y;
		this.z = a.z - b.z;

		return this;

	},

	multiply: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
			return this.multiplyVectors( v, w );

		}

		this.x *= v.x;
		this.y *= v.y;
		this.z *= v.z;

		return this;

	},

	multiplyScalar: function ( scalar ) {

		if ( isFinite( scalar ) ) {

			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;

		} else {

			this.x = 0;
			this.y = 0;
			this.z = 0;

		}

		return this;

	},

	multiplyVectors: function ( a, b ) {

		this.x = a.x * b.x;
		this.y = a.y * b.y;
		this.z = a.z * b.z;

		return this;

	},

	applyEuler: function () {

		var quaternion;

		return function applyEuler( euler ) {

			if ( (euler && euler.isEuler) === false ) {

				console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );

			}

			if ( quaternion === undefined ) quaternion = new Quaternion();

			return this.applyQuaternion( quaternion.setFromEuler( euler ) );

		};

	}(),

	applyAxisAngle: function () {

		var quaternion;

		return function applyAxisAngle( axis, angle ) {

			if ( quaternion === undefined ) quaternion = new Quaternion();

			return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );

		};

	}(),

	applyMatrix3: function ( m ) {

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
		this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
		this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;

		return this;

	},

	applyMatrix4: function ( m ) {

		// input: THREE.Matrix4 affine matrix

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ];
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ];
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ];

		return this;

	},

	applyProjection: function ( m ) {

		// input: THREE.Matrix4 projection matrix

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;
		var d = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] ); // perspective divide

		this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z + e[ 12 ] ) * d;
		this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z + e[ 13 ] ) * d;
		this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * d;

		return this;

	},

	applyQuaternion: function ( q ) {

		var x = this.x, y = this.y, z = this.z;
		var qx = q.x, qy = q.y, qz = q.z, qw = q.w;

		// calculate quat * vector

		var ix =  qw * x + qy * z - qz * y;
		var iy =  qw * y + qz * x - qx * z;
		var iz =  qw * z + qx * y - qy * x;
		var iw = - qx * x - qy * y - qz * z;

		// calculate result * inverse quat

		this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
		this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
		this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;

		return this;

	},

	project: function () {

		var matrix;

		return function project( camera ) {

			if ( matrix === undefined ) matrix = new Matrix4();

			matrix.multiplyMatrices( camera.projectionMatrix, matrix.getInverse( camera.matrixWorld ) );
			return this.applyProjection( matrix );

		};

	}(),

	unproject: function () {

		var matrix;

		return function unproject( camera ) {

			if ( matrix === undefined ) matrix = new Matrix4();

			matrix.multiplyMatrices( camera.matrixWorld, matrix.getInverse( camera.projectionMatrix ) );
			return this.applyProjection( matrix );

		};

	}(),

	transformDirection: function ( m ) {

		// input: THREE.Matrix4 affine matrix
		// vector interpreted as a direction

		var x = this.x, y = this.y, z = this.z;
		var e = m.elements;

		this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ]  * z;
		this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ]  * z;
		this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;

		return this.normalize();

	},

	divide: function ( v ) {

		this.x /= v.x;
		this.y /= v.y;
		this.z /= v.z;

		return this;

	},

	divideScalar: function ( scalar ) {

		return this.multiplyScalar( 1 / scalar );

	},

	min: function ( v ) {

		this.x = Math.min( this.x, v.x );
		this.y = Math.min( this.y, v.y );
		this.z = Math.min( this.z, v.z );

		return this;

	},

	max: function ( v ) {

		this.x = Math.max( this.x, v.x );
		this.y = Math.max( this.y, v.y );
		this.z = Math.max( this.z, v.z );

		return this;

	},

	clamp: function ( min, max ) {

		// This function assumes min < max, if this assumption isn't true it will not operate correctly

		this.x = Math.max( min.x, Math.min( max.x, this.x ) );
		this.y = Math.max( min.y, Math.min( max.y, this.y ) );
		this.z = Math.max( min.z, Math.min( max.z, this.z ) );

		return this;

	},

	clampScalar: function () {

		var min, max;

		return function clampScalar( minVal, maxVal ) {

			if ( min === undefined ) {

				min = new Vector3();
				max = new Vector3();

			}

			min.set( minVal, minVal, minVal );
			max.set( maxVal, maxVal, maxVal );

			return this.clamp( min, max );

		};

	}(),

	clampLength: function ( min, max ) {

		var length = this.length();

		return this.multiplyScalar( Math.max( min, Math.min( max, length ) ) / length );

	},

	floor: function () {

		this.x = Math.floor( this.x );
		this.y = Math.floor( this.y );
		this.z = Math.floor( this.z );

		return this;

	},

	ceil: function () {

		this.x = Math.ceil( this.x );
		this.y = Math.ceil( this.y );
		this.z = Math.ceil( this.z );

		return this;

	},

	round: function () {

		this.x = Math.round( this.x );
		this.y = Math.round( this.y );
		this.z = Math.round( this.z );

		return this;

	},

	roundToZero: function () {

		this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
		this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
		this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );

		return this;

	},

	negate: function () {

		this.x = - this.x;
		this.y = - this.y;
		this.z = - this.z;

		return this;

	},

	dot: function ( v ) {

		return this.x * v.x + this.y * v.y + this.z * v.z;

	},

	lengthSq: function () {

		return this.x * this.x + this.y * this.y + this.z * this.z;

	},

	length: function () {

		return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );

	},

	lengthManhattan: function () {

		return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );

	},

	normalize: function () {

		return this.divideScalar( this.length() );

	},

	setLength: function ( length ) {

		return this.multiplyScalar( length / this.length() );

	},

	lerp: function ( v, alpha ) {

		this.x += ( v.x - this.x ) * alpha;
		this.y += ( v.y - this.y ) * alpha;
		this.z += ( v.z - this.z ) * alpha;

		return this;

	},

	lerpVectors: function ( v1, v2, alpha ) {

		return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );

	},

	cross: function ( v, w ) {

		if ( w !== undefined ) {

			console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
			return this.crossVectors( v, w );

		}

		var x = this.x, y = this.y, z = this.z;

		this.x = y * v.z - z * v.y;
		this.y = z * v.x - x * v.z;
		this.z = x * v.y - y * v.x;

		return this;

	},

	crossVectors: function ( a, b ) {

		var ax = a.x, ay = a.y, az = a.z;
		var bx = b.x, by = b.y, bz = b.z;

		this.x = ay * bz - az * by;
		this.y = az * bx - ax * bz;
		this.z = ax * by - ay * bx;

		return this;

	},

	projectOnVector: function ( vector ) {

		var scalar = vector.dot( this ) / vector.lengthSq();

		return this.copy( vector ).multiplyScalar( scalar );

	},

	projectOnPlane: function () {

		var v1;

		return function projectOnPlane( planeNormal ) {

			if ( v1 === undefined ) v1 = new Vector3();

			v1.copy( this ).projectOnVector( planeNormal );

			return this.sub( v1 );

		};

	}(),

	reflect: function () {

		// reflect incident vector off plane orthogonal to normal
		// normal is assumed to have unit length

		var v1;

		return function reflect( normal ) {

			if ( v1 === undefined ) v1 = new Vector3();

			return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );

		};

	}(),

	angleTo: function ( v ) {

		var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );

		// clamp, to handle numerical problems

		return Math.acos( _Math.clamp( theta, - 1, 1 ) );

	},

	distanceTo: function ( v ) {

		return Math.sqrt( this.distanceToSquared( v ) );

	},

	distanceToSquared: function ( v ) {

		var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;

		return dx * dx + dy * dy + dz * dz;

	},

	distanceToManhattan: function ( v ) {

		return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );

	},

	setFromSpherical: function( s ) {

		var sinPhiRadius = Math.sin( s.phi ) * s.radius;

		this.x = sinPhiRadius * Math.sin( s.theta );
		this.y = Math.cos( s.phi ) * s.radius;
		this.z = sinPhiRadius * Math.cos( s.theta );

		return this;

	},

	setFromCylindrical: function( c ) {

		this.x = c.radius * Math.sin( c.theta );
		this.y = c.y;
		this.z = c.radius * Math.cos( c.theta );

		return this;

	},

	setFromMatrixPosition: function ( m ) {

		return this.setFromMatrixColumn( m, 3 );

	},

	setFromMatrixScale: function ( m ) {

		var sx = this.setFromMatrixColumn( m, 0 ).length();
		var sy = this.setFromMatrixColumn( m, 1 ).length();
		var sz = this.setFromMatrixColumn( m, 2 ).length();

		this.x = sx;
		this.y = sy;
		this.z = sz;

		return this;

	},

	setFromMatrixColumn: function ( m, index ) {

		if ( typeof m === 'number' ) {

			console.warn( 'THREE.Vector3: setFromMatrixColumn now expects ( matrix, index ).' );
			var temp = m;
			m = index;
			index = temp;

		}

		return this.fromArray( m.elements, index * 4 );

	},

	equals: function ( v ) {

		return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.x = array[ offset ];
		this.y = array[ offset + 1 ];
		this.z = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.x;
		array[ offset + 1 ] = this.y;
		array[ offset + 2 ] = this.z;

		return array;

	},

	fromAttribute: function ( attribute, index, offset ) {

		if ( offset !== undefined ) {

			console.warn( 'THREE.Vector3: offset has been removed from .fromAttribute().' );

		}

		this.x = attribute.getX( index );
		this.y = attribute.getY( index );
		this.z = attribute.getZ( index );

		return this;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author philogb / http://blog.thejit.org/
 * @author jordi_ros / http://plattsoft.com
 * @author D1plo1d / http://github.com/D1plo1d
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author timknip / http://www.floorplanner.com/
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Matrix4() {

	this.elements = new Float32Array( [

		1, 0, 0, 0,
		0, 1, 0, 0,
		0, 0, 1, 0,
		0, 0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Matrix4.prototype = {

	constructor: Matrix4,

	isMatrix4: true,

	set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
		te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
		te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
		te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new Matrix4().fromArray( this.elements );

	},

	copy: function ( m ) {

		this.elements.set( m.elements );

		return this;

	},

	copyPosition: function ( m ) {

		var te = this.elements;
		var me = m.elements;

		te[ 12 ] = me[ 12 ];
		te[ 13 ] = me[ 13 ];
		te[ 14 ] = me[ 14 ];

		return this;

	},

	extractBasis: function ( xAxis, yAxis, zAxis ) {

		xAxis.setFromMatrixColumn( this, 0 );
		yAxis.setFromMatrixColumn( this, 1 );
		zAxis.setFromMatrixColumn( this, 2 );

		return this;

	},

	makeBasis: function ( xAxis, yAxis, zAxis ) {

		this.set(
			xAxis.x, yAxis.x, zAxis.x, 0,
			xAxis.y, yAxis.y, zAxis.y, 0,
			xAxis.z, yAxis.z, zAxis.z, 0,
			0,       0,       0,       1
		);

		return this;

	},

	extractRotation: function () {

		var v1;

		return function extractRotation( m ) {

			if ( v1 === undefined ) v1 = new Vector3();

			var te = this.elements;
			var me = m.elements;

			var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
			var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
			var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();

			te[ 0 ] = me[ 0 ] * scaleX;
			te[ 1 ] = me[ 1 ] * scaleX;
			te[ 2 ] = me[ 2 ] * scaleX;

			te[ 4 ] = me[ 4 ] * scaleY;
			te[ 5 ] = me[ 5 ] * scaleY;
			te[ 6 ] = me[ 6 ] * scaleY;

			te[ 8 ] = me[ 8 ] * scaleZ;
			te[ 9 ] = me[ 9 ] * scaleZ;
			te[ 10 ] = me[ 10 ] * scaleZ;

			return this;

		};

	}(),

	makeRotationFromEuler: function ( euler ) {

		if ( (euler && euler.isEuler) === false ) {

			console.error( 'THREE.Matrix: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );

		}

		var te = this.elements;

		var x = euler.x, y = euler.y, z = euler.z;
		var a = Math.cos( x ), b = Math.sin( x );
		var c = Math.cos( y ), d = Math.sin( y );
		var e = Math.cos( z ), f = Math.sin( z );

		if ( euler.order === 'XYZ' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = - c * f;
			te[ 8 ] = d;

			te[ 1 ] = af + be * d;
			te[ 5 ] = ae - bf * d;
			te[ 9 ] = - b * c;

			te[ 2 ] = bf - ae * d;
			te[ 6 ] = be + af * d;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YXZ' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce + df * b;
			te[ 4 ] = de * b - cf;
			te[ 8 ] = a * d;

			te[ 1 ] = a * f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b;

			te[ 2 ] = cf * b - de;
			te[ 6 ] = df + ce * b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZXY' ) {

			var ce = c * e, cf = c * f, de = d * e, df = d * f;

			te[ 0 ] = ce - df * b;
			te[ 4 ] = - a * f;
			te[ 8 ] = de + cf * b;

			te[ 1 ] = cf + de * b;
			te[ 5 ] = a * e;
			te[ 9 ] = df - ce * b;

			te[ 2 ] = - a * d;
			te[ 6 ] = b;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'ZYX' ) {

			var ae = a * e, af = a * f, be = b * e, bf = b * f;

			te[ 0 ] = c * e;
			te[ 4 ] = be * d - af;
			te[ 8 ] = ae * d + bf;

			te[ 1 ] = c * f;
			te[ 5 ] = bf * d + ae;
			te[ 9 ] = af * d - be;

			te[ 2 ] = - d;
			te[ 6 ] = b * c;
			te[ 10 ] = a * c;

		} else if ( euler.order === 'YZX' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = bd - ac * f;
			te[ 8 ] = bc * f + ad;

			te[ 1 ] = f;
			te[ 5 ] = a * e;
			te[ 9 ] = - b * e;

			te[ 2 ] = - d * e;
			te[ 6 ] = ad * f + bc;
			te[ 10 ] = ac - bd * f;

		} else if ( euler.order === 'XZY' ) {

			var ac = a * c, ad = a * d, bc = b * c, bd = b * d;

			te[ 0 ] = c * e;
			te[ 4 ] = - f;
			te[ 8 ] = d * e;

			te[ 1 ] = ac * f + bd;
			te[ 5 ] = a * e;
			te[ 9 ] = ad * f - bc;

			te[ 2 ] = bc * f - ad;
			te[ 6 ] = b * e;
			te[ 10 ] = bd * f + ac;

		}

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	makeRotationFromQuaternion: function ( q ) {

		var te = this.elements;

		var x = q.x, y = q.y, z = q.z, w = q.w;
		var x2 = x + x, y2 = y + y, z2 = z + z;
		var xx = x * x2, xy = x * y2, xz = x * z2;
		var yy = y * y2, yz = y * z2, zz = z * z2;
		var wx = w * x2, wy = w * y2, wz = w * z2;

		te[ 0 ] = 1 - ( yy + zz );
		te[ 4 ] = xy - wz;
		te[ 8 ] = xz + wy;

		te[ 1 ] = xy + wz;
		te[ 5 ] = 1 - ( xx + zz );
		te[ 9 ] = yz - wx;

		te[ 2 ] = xz - wy;
		te[ 6 ] = yz + wx;
		te[ 10 ] = 1 - ( xx + yy );

		// last column
		te[ 3 ] = 0;
		te[ 7 ] = 0;
		te[ 11 ] = 0;

		// bottom row
		te[ 12 ] = 0;
		te[ 13 ] = 0;
		te[ 14 ] = 0;
		te[ 15 ] = 1;

		return this;

	},

	lookAt: function () {

		var x, y, z;

		return function lookAt( eye, target, up ) {

			if ( x === undefined ) {

				x = new Vector3();
				y = new Vector3();
				z = new Vector3();

			}

			var te = this.elements;

			z.subVectors( eye, target ).normalize();

			if ( z.lengthSq() === 0 ) {

				z.z = 1;

			}

			x.crossVectors( up, z ).normalize();

			if ( x.lengthSq() === 0 ) {

				z.z += 0.0001;
				x.crossVectors( up, z ).normalize();

			}

			y.crossVectors( z, x );


			te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
			te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
			te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;

			return this;

		};

	}(),

	multiply: function ( m, n ) {

		if ( n !== undefined ) {

			console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
			return this.multiplyMatrices( m, n );

		}

		return this.multiplyMatrices( this, m );

	},

	premultiply: function ( m ) {

		return this.multiplyMatrices( m, this );

	},

	multiplyMatrices: function ( a, b ) {

		var ae = a.elements;
		var be = b.elements;
		var te = this.elements;

		var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
		var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
		var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
		var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];

		var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
		var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
		var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
		var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];

		te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
		te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
		te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
		te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;

		te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
		te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
		te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
		te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;

		te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
		te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
		te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
		te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;

		te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
		te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
		te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
		te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;

		return this;

	},

	multiplyToArray: function ( a, b, r ) {

		var te = this.elements;

		this.multiplyMatrices( a, b );

		r[ 0 ] = te[ 0 ]; r[ 1 ] = te[ 1 ]; r[ 2 ] = te[ 2 ]; r[ 3 ] = te[ 3 ];
		r[ 4 ] = te[ 4 ]; r[ 5 ] = te[ 5 ]; r[ 6 ] = te[ 6 ]; r[ 7 ] = te[ 7 ];
		r[ 8 ]  = te[ 8 ]; r[ 9 ]  = te[ 9 ]; r[ 10 ] = te[ 10 ]; r[ 11 ] = te[ 11 ];
		r[ 12 ] = te[ 12 ]; r[ 13 ] = te[ 13 ]; r[ 14 ] = te[ 14 ]; r[ 15 ] = te[ 15 ];

		return this;

	},

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
		te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
		te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
		te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;

		return this;

	},

	applyToVector3Array: function () {

		var v1;

		return function applyToVector3Array( array, offset, length ) {

			if ( v1 === undefined ) v1 = new Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix4( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBufferAttribute: function () {

		var v1;

		return function applyToBufferAttribute( attribute ) {

			if ( v1 === undefined ) v1 = new Vector3();

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				v1.x = attribute.getX( i );
				v1.y = attribute.getY( i );
				v1.z = attribute.getZ( i );

				v1.applyMatrix4( this );

				attribute.setXYZ( i, v1.x, v1.y, v1.z );

			}

			return attribute;

		};

	}(),

	determinant: function () {

		var te = this.elements;

		var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
		var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
		var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
		var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];

		//TODO: make this more efficient
		//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )

		return (
			n41 * (
				+ n14 * n23 * n32
				 - n13 * n24 * n32
				 - n14 * n22 * n33
				 + n12 * n24 * n33
				 + n13 * n22 * n34
				 - n12 * n23 * n34
			) +
			n42 * (
				+ n11 * n23 * n34
				 - n11 * n24 * n33
				 + n14 * n21 * n33
				 - n13 * n21 * n34
				 + n13 * n24 * n31
				 - n14 * n23 * n31
			) +
			n43 * (
				+ n11 * n24 * n32
				 - n11 * n22 * n34
				 - n14 * n21 * n32
				 + n12 * n21 * n34
				 + n14 * n22 * n31
				 - n12 * n24 * n31
			) +
			n44 * (
				- n13 * n22 * n31
				 - n11 * n23 * n32
				 + n11 * n22 * n33
				 + n13 * n21 * n32
				 - n12 * n21 * n33
				 + n12 * n23 * n31
			)

		);

	},

	transpose: function () {

		var te = this.elements;
		var tmp;

		tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
		tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
		tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;

		tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
		tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
		tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;

		return this;

	},

	setPosition: function ( v ) {

		var te = this.elements;

		te[ 12 ] = v.x;
		te[ 13 ] = v.y;
		te[ 14 ] = v.z;

		return this;

	},

	getInverse: function ( m, throwOnDegenerate ) {

		// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
		var te = this.elements,
			me = m.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
			n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
			n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
			n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],

			t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
			t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
			t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
			t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;

		var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;

		if ( det === 0 ) {

			var msg = "THREE.Matrix4.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();

		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
		te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
		te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;

		te[ 4 ] = t12 * detInv;
		te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
		te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
		te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;

		te[ 8 ] = t13 * detInv;
		te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
		te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
		te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;

		te[ 12 ] = t14 * detInv;
		te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
		te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
		te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;

		return this;

	},

	scale: function ( v ) {

		var te = this.elements;
		var x = v.x, y = v.y, z = v.z;

		te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
		te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
		te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
		te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;

		return this;

	},

	getMaxScaleOnAxis: function () {

		var te = this.elements;

		var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
		var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
		var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];

		return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );

	},

	makeTranslation: function ( x, y, z ) {

		this.set(

			1, 0, 0, x,
			0, 1, 0, y,
			0, 0, 1, z,
			0, 0, 0, 1

		);

		return this;

	},

	makeRotationX: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			1, 0,  0, 0,
			0, c, - s, 0,
			0, s,  c, 0,
			0, 0,  0, 1

		);

		return this;

	},

	makeRotationY: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			 c, 0, s, 0,
			 0, 1, 0, 0,
			- s, 0, c, 0,
			 0, 0, 0, 1

		);

		return this;

	},

	makeRotationZ: function ( theta ) {

		var c = Math.cos( theta ), s = Math.sin( theta );

		this.set(

			c, - s, 0, 0,
			s,  c, 0, 0,
			0,  0, 1, 0,
			0,  0, 0, 1

		);

		return this;

	},

	makeRotationAxis: function ( axis, angle ) {

		// Based on http://www.gamedev.net/reference/articles/article1199.asp

		var c = Math.cos( angle );
		var s = Math.sin( angle );
		var t = 1 - c;
		var x = axis.x, y = axis.y, z = axis.z;
		var tx = t * x, ty = t * y;

		this.set(

			tx * x + c, tx * y - s * z, tx * z + s * y, 0,
			tx * y + s * z, ty * y + c, ty * z - s * x, 0,
			tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
			0, 0, 0, 1

		);

		 return this;

	},

	makeScale: function ( x, y, z ) {

		this.set(

			x, 0, 0, 0,
			0, y, 0, 0,
			0, 0, z, 0,
			0, 0, 0, 1

		);

		return this;

	},

	makeShear: function ( x, y, z ) {

		this.set(

			1, y, z, 0,
			x, 1, z, 0,
			x, y, 1, 0,
			0, 0, 0, 1

		);

		return this;

	},

	compose: function ( position, quaternion, scale ) {

		this.makeRotationFromQuaternion( quaternion );
		this.scale( scale );
		this.setPosition( position );

		return this;

	},

	decompose: function () {

		var vector, matrix;

		return function decompose( position, quaternion, scale ) {

			if ( vector === undefined ) {

				vector = new Vector3();
				matrix = new Matrix4();

			}

			var te = this.elements;

			var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
			var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
			var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();

			// if determine is negative, we need to invert one scale
			var det = this.determinant();
			if ( det < 0 ) {

				sx = - sx;

			}

			position.x = te[ 12 ];
			position.y = te[ 13 ];
			position.z = te[ 14 ];

			// scale the rotation part

			matrix.elements.set( this.elements ); // at this point matrix is incomplete so we can't use .copy()

			var invSX = 1 / sx;
			var invSY = 1 / sy;
			var invSZ = 1 / sz;

			matrix.elements[ 0 ] *= invSX;
			matrix.elements[ 1 ] *= invSX;
			matrix.elements[ 2 ] *= invSX;

			matrix.elements[ 4 ] *= invSY;
			matrix.elements[ 5 ] *= invSY;
			matrix.elements[ 6 ] *= invSY;

			matrix.elements[ 8 ] *= invSZ;
			matrix.elements[ 9 ] *= invSZ;
			matrix.elements[ 10 ] *= invSZ;

			quaternion.setFromRotationMatrix( matrix );

			scale.x = sx;
			scale.y = sy;
			scale.z = sz;

			return this;

		};

	}(),

	makeFrustum: function ( left, right, bottom, top, near, far ) {

		var te = this.elements;
		var x = 2 * near / ( right - left );
		var y = 2 * near / ( top - bottom );

		var a = ( right + left ) / ( right - left );
		var b = ( top + bottom ) / ( top - bottom );
		var c = - ( far + near ) / ( far - near );
		var d = - 2 * far * near / ( far - near );

		te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
		te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;

		return this;

	},

	makePerspective: function ( fov, aspect, near, far ) {

		var ymax = near * Math.tan( _Math.DEG2RAD * fov * 0.5 );
		var ymin = - ymax;
		var xmin = ymin * aspect;
		var xmax = ymax * aspect;

		return this.makeFrustum( xmin, xmax, ymin, ymax, near, far );

	},

	makeOrthographic: function ( left, right, top, bottom, near, far ) {

		var te = this.elements;
		var w = 1.0 / ( right - left );
		var h = 1.0 / ( top - bottom );
		var p = 1.0 / ( far - near );

		var x = ( right + left ) * w;
		var y = ( top + bottom ) * h;
		var z = ( far + near ) * p;

		te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
		te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
		te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
		te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;

		return this;

	},

	equals: function ( matrix ) {

		var te = this.elements;
		var me = matrix.elements;

		for ( var i = 0; i < 16; i ++ ) {

			if ( te[ i ] !== me[ i ] ) return false;

		}

		return true;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for( var i = 0; i < 16; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];
		array[ offset + 3 ] = te[ 3 ];

		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];
		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];

		array[ offset + 8 ]  = te[ 8 ];
		array[ offset + 9 ]  = te[ 9 ];
		array[ offset + 10 ] = te[ 10 ];
		array[ offset + 11 ] = te[ 11 ];

		array[ offset + 12 ] = te[ 12 ];
		array[ offset + 13 ] = te[ 13 ];
		array[ offset + 14 ] = te[ 14 ];
		array[ offset + 15 ] = te[ 15 ];

		return array;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {

	images = images !== undefined ? images : [];
	mapping = mapping !== undefined ? mapping : CubeReflectionMapping;

	Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.flipY = false;

}

CubeTexture.prototype = Object.create( Texture.prototype );
CubeTexture.prototype.constructor = CubeTexture;

CubeTexture.prototype.isCubeTexture = true;

Object.defineProperty( CubeTexture.prototype, 'images', {

	get: function () {

		return this.image;

	},

	set: function ( value ) {

		this.image = value;

	}

} );

/**
 * @author tschw
 *
 * Uniforms of a program.
 * Those form a tree structure with a special top-level container for the root,
 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
 *
 *
 * Properties of inner nodes including the top-level container:
 *
 * .seq - array of nested uniforms
 * .map - nested uniforms by name
 *
 *
 * Methods of all nodes except the top-level container:
 *
 * .setValue( gl, value, [renderer] )
 *
 * 		uploads a uniform value(s)
 *  	the 'renderer' parameter is needed for sampler uniforms
 *
 *
 * Static methods of the top-level container (renderer factorizations):
 *
 * .upload( gl, seq, values, renderer )
 *
 * 		sets uniforms in 'seq' to 'values[id].value'
 *
 * .seqWithValue( seq, values ) : filteredSeq
 *
 * 		filters 'seq' entries with corresponding entry in values
 *
 *
 * Methods of the top-level container (renderer factorizations):
 *
 * .setValue( gl, name, value )
 *
 * 		sets uniform with  name 'name' to 'value'
 *
 * .set( gl, obj, prop )
 *
 * 		sets uniform from object and property with same name than uniform
 *
 * .setOptional( gl, obj, prop )
 *
 * 		like .set for an optional property of the object
 *
 */

var emptyTexture = new Texture();
var emptyCubeTexture = new CubeTexture();

// --- Base for inner nodes (including the root) ---

function UniformContainer() {

	this.seq = [];
	this.map = {};

}

// --- Utilities ---

// Array Caches (provide typed arrays for temporary by size)

var arrayCacheF32 = [];
var arrayCacheI32 = [];

// Flattening for arrays of vectors and matrices

function flatten( array, nBlocks, blockSize ) {

	var firstElem = array[ 0 ];

	if ( firstElem <= 0 || firstElem > 0 ) return array;
	// unoptimized: ! isNaN( firstElem )
	// see http://jacksondunstan.com/articles/983

	var n = nBlocks * blockSize,
		r = arrayCacheF32[ n ];

	if ( r === undefined ) {

		r = new Float32Array( n );
		arrayCacheF32[ n ] = r;

	}

	if ( nBlocks !== 0 ) {

		firstElem.toArray( r, 0 );

		for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {

			offset += blockSize;
			array[ i ].toArray( r, offset );

		}

	}

	return r;

}

// Texture unit allocation

function allocTexUnits( renderer, n ) {

	var r = arrayCacheI32[ n ];

	if ( r === undefined ) {

		r = new Int32Array( n );
		arrayCacheI32[ n ] = r;

	}

	for ( var i = 0; i !== n; ++ i )
		r[ i ] = renderer.allocTextureUnit();

	return r;

}

// --- Setters ---

// Note: Defining these methods externally, because they come in a bunch
// and this way their names minify.

// Single scalar

function setValue1f( gl, v ) { gl.uniform1f( this.addr, v ); }
function setValue1i( gl, v ) { gl.uniform1i( this.addr, v ); }

// Single float vector (from flat array or THREE.VectorN)

function setValue2fv( gl, v ) {

	if ( v.x === undefined ) gl.uniform2fv( this.addr, v );
	else gl.uniform2f( this.addr, v.x, v.y );

}

function setValue3fv( gl, v ) {

	if ( v.x !== undefined )
		gl.uniform3f( this.addr, v.x, v.y, v.z );
	else if ( v.r !== undefined )
		gl.uniform3f( this.addr, v.r, v.g, v.b );
	else
		gl.uniform3fv( this.addr, v );

}

function setValue4fv( gl, v ) {

	if ( v.x === undefined ) gl.uniform4fv( this.addr, v );
	else gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );

}

// Single matrix (from flat array or MatrixN)

function setValue2fm( gl, v ) {

	gl.uniformMatrix2fv( this.addr, false, v.elements || v );

}

function setValue3fm( gl, v ) {

	gl.uniformMatrix3fv( this.addr, false, v.elements || v );

}

function setValue4fm( gl, v ) {

	gl.uniformMatrix4fv( this.addr, false, v.elements || v );

}

// Single texture (2D / Cube)

function setValueT1( gl, v, renderer ) {

	var unit = renderer.allocTextureUnit();
	gl.uniform1i( this.addr, unit );
	renderer.setTexture2D( v || emptyTexture, unit );

}

function setValueT6( gl, v, renderer ) {

	var unit = renderer.allocTextureUnit();
	gl.uniform1i( this.addr, unit );
	renderer.setTextureCube( v || emptyCubeTexture, unit );

}

// Integer / Boolean vectors or arrays thereof (always flat arrays)

function setValue2iv( gl, v ) { gl.uniform2iv( this.addr, v ); }
function setValue3iv( gl, v ) { gl.uniform3iv( this.addr, v ); }
function setValue4iv( gl, v ) { gl.uniform4iv( this.addr, v ); }

// Helper to pick the right setter for the singular case

function getSingularSetter( type ) {

	switch ( type ) {

		case 0x1406: return setValue1f; // FLOAT
		case 0x8b50: return setValue2fv; // _VEC2
		case 0x8b51: return setValue3fv; // _VEC3
		case 0x8b52: return setValue4fv; // _VEC4

		case 0x8b5a: return setValue2fm; // _MAT2
		case 0x8b5b: return setValue3fm; // _MAT3
		case 0x8b5c: return setValue4fm; // _MAT4

		case 0x8b5e: return setValueT1; // SAMPLER_2D
		case 0x8b60: return setValueT6; // SAMPLER_CUBE

		case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

	}

}

// Array of scalars

function setValue1fv( gl, v ) { gl.uniform1fv( this.addr, v ); }
function setValue1iv( gl, v ) { gl.uniform1iv( this.addr, v ); }

// Array of vectors (flat or from THREE classes)

function setValueV2a( gl, v ) {

	gl.uniform2fv( this.addr, flatten( v, this.size, 2 ) );

}

function setValueV3a( gl, v ) {

	gl.uniform3fv( this.addr, flatten( v, this.size, 3 ) );

}

function setValueV4a( gl, v ) {

	gl.uniform4fv( this.addr, flatten( v, this.size, 4 ) );

}

// Array of matrices (flat or from THREE clases)

function setValueM2a( gl, v ) {

	gl.uniformMatrix2fv( this.addr, false, flatten( v, this.size, 4 ) );

}

function setValueM3a( gl, v ) {

	gl.uniformMatrix3fv( this.addr, false, flatten( v, this.size, 9 ) );

}

function setValueM4a( gl, v ) {

	gl.uniformMatrix4fv( this.addr, false, flatten( v, this.size, 16 ) );

}

// Array of textures (2D / Cube)

function setValueT1a( gl, v, renderer ) {

	var n = v.length,
		units = allocTexUnits( renderer, n );

	gl.uniform1iv( this.addr, units );

	for ( var i = 0; i !== n; ++ i ) {

		renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );

	}

}

function setValueT6a( gl, v, renderer ) {

	var n = v.length,
		units = allocTexUnits( renderer, n );

	gl.uniform1iv( this.addr, units );

	for ( var i = 0; i !== n; ++ i ) {

		renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );

	}

}

// Helper to pick the right setter for a pure (bottom-level) array

function getPureArraySetter( type ) {

	switch ( type ) {

		case 0x1406: return setValue1fv; // FLOAT
		case 0x8b50: return setValueV2a; // _VEC2
		case 0x8b51: return setValueV3a; // _VEC3
		case 0x8b52: return setValueV4a; // _VEC4

		case 0x8b5a: return setValueM2a; // _MAT2
		case 0x8b5b: return setValueM3a; // _MAT3
		case 0x8b5c: return setValueM4a; // _MAT4

		case 0x8b5e: return setValueT1a; // SAMPLER_2D
		case 0x8b60: return setValueT6a; // SAMPLER_CUBE

		case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
		case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
		case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
		case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4

	}

}

// --- Uniform Classes ---

function SingleUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.setValue = getSingularSetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function PureArrayUniform( id, activeInfo, addr ) {

	this.id = id;
	this.addr = addr;
	this.size = activeInfo.size;
	this.setValue = getPureArraySetter( activeInfo.type );

	// this.path = activeInfo.name; // DEBUG

}

function StructuredUniform( id ) {

	this.id = id;

	UniformContainer.call( this ); // mix-in

}

StructuredUniform.prototype.setValue = function( gl, value ) {

	// Note: Don't need an extra 'renderer' parameter, since samplers
	// are not allowed in structured uniforms.

	var seq = this.seq;

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		u.setValue( gl, value[ u.id ] );

	}

};

// --- Top-level ---

// Parser - builds up the property tree from the path strings

var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;

// extracts
// 	- the identifier (member name or array index)
//  - followed by an optional right bracket (found when array index)
//  - followed by an optional left bracket or dot (type of subscript)
//
// Note: These portions can be read in a non-overlapping fashion and
// allow straightforward parsing of the hierarchy that WebGL encodes
// in the uniform names.

function addUniform( container, uniformObject ) {

	container.seq.push( uniformObject );
	container.map[ uniformObject.id ] = uniformObject;

}

function parseUniform( activeInfo, addr, container ) {

	var path = activeInfo.name,
		pathLength = path.length;

	// reset RegExp object, because of the early exit of a previous run
	RePathPart.lastIndex = 0;

	for (; ;) {

		var match = RePathPart.exec( path ),
			matchEnd = RePathPart.lastIndex,

			id = match[ 1 ],
			idIsIndex = match[ 2 ] === ']',
			subscript = match[ 3 ];

		if ( idIsIndex ) id = id | 0; // convert to integer

		if ( subscript === undefined ||
				subscript === '[' && matchEnd + 2 === pathLength ) {
			// bare name or "pure" bottom-level array "[0]" suffix

			addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );

			break;

		} else {
			// step into inner node / create it in case it doesn't exist

			var map = container.map,
				next = map[ id ];

			if ( next === undefined ) {

				next = new StructuredUniform( id );
				addUniform( container, next );

			}

			container = next;

		}

	}

}

// Root Container

function WebGLUniforms( gl, program, renderer ) {

	UniformContainer.call( this );

	this.renderer = renderer;

	var n = gl.getProgramParameter( program, gl.ACTIVE_UNIFORMS );

	for ( var i = 0; i !== n; ++ i ) {

		var info = gl.getActiveUniform( program, i ),
			path = info.name,
			addr = gl.getUniformLocation( program, path );

		parseUniform( info, addr, this );

	}

}

WebGLUniforms.prototype.setValue = function( gl, name, value ) {

	var u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, value, this.renderer );

};

WebGLUniforms.prototype.set = function( gl, object, name ) {

	var u = this.map[ name ];

	if ( u !== undefined ) u.setValue( gl, object[ name ], this.renderer );

};

WebGLUniforms.prototype.setOptional = function( gl, object, name ) {

	var v = object[ name ];

	if ( v !== undefined ) this.setValue( gl, name, v );

};


// Static interface

WebGLUniforms.upload = function( gl, seq, values, renderer ) {

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ],
			v = values[ u.id ];

		if ( v.needsUpdate !== false ) {
			// note: always updating when .needsUpdate is undefined

			u.setValue( gl, v.value, renderer );

		}

	}

};

WebGLUniforms.seqWithValue = function( seq, values ) {

	var r = [];

	for ( var i = 0, n = seq.length; i !== n; ++ i ) {

		var u = seq[ i ];
		if ( u.id in values ) r.push( u );

	}

	return r;

};

/**
 * Uniform Utilities
 */

var UniformsUtils = {

	merge: function ( uniforms ) {

		var merged = {};

		for ( var u = 0; u < uniforms.length; u ++ ) {

			var tmp = this.clone( uniforms[ u ] );

			for ( var p in tmp ) {

				merged[ p ] = tmp[ p ];

			}

		}

		return merged;

	},

	clone: function ( uniforms_src ) {

		var uniforms_dst = {};

		for ( var u in uniforms_src ) {

			uniforms_dst[ u ] = {};

			for ( var p in uniforms_src[ u ] ) {

				var parameter_src = uniforms_src[ u ][ p ];

				if ( parameter_src && ( parameter_src.isColor ||
					parameter_src.isMatrix3 || parameter_src.isMatrix4 ||
					parameter_src.isVector2 || parameter_src.isVector3 || parameter_src.isVector4 ||
					parameter_src.isTexture ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.clone();

				} else if ( Array.isArray( parameter_src ) ) {

					uniforms_dst[ u ][ p ] = parameter_src.slice();

				} else {

					uniforms_dst[ u ][ p ] = parameter_src;

				}

			}

		}

		return uniforms_dst;

	}

};

var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif\n";

var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif\n";

var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif\n";

var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif\n";

var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";

var begin_vertex = "\nvec3 transformed = vec3( position );\n";

var beginnormal_vertex = "\nvec3 objectNormal = vec3( normal );\n";

var bsdfs = "float punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n\t\tif( decayExponent > 0.0 ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\t\t\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\t\t\tfloat maxDistanceCutoffFactor = pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t\t\treturn distanceFalloff * maxDistanceCutoffFactor;\n#else\n\t\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n#endif\n\t\t}\n\t\treturn 1.0;\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 ltcTextureCoords( const in GeometricContext geometry, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = (LUT_SIZE - 1.0)/LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5/LUT_SIZE;\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tfloat theta = acos( dot( N, V ) );\n\tvec2 uv = vec2(\n\t\tsqrt( saturate( roughness ) ),\n\t\tsaturate( theta / ( 0.5 * PI ) ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nvoid clipQuadToHorizon( inout vec3 L[5], out int n ) {\n\tint config = 0;\n\tif ( L[0].z > 0.0 ) config += 1;\n\tif ( L[1].z > 0.0 ) config += 2;\n\tif ( L[2].z > 0.0 ) config += 4;\n\tif ( L[3].z > 0.0 ) config += 8;\n\tn = 0;\n\tif ( config == 0 ) {\n\t} else if ( config == 1 ) {\n\t\tn = 3;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 2 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 3 ) {\n\t\tn = 4;\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t\tL[3] = -L[3].z * L[0] + L[0].z * L[3];\n\t} else if ( config == 4 ) {\n\t\tn = 3;\n\t\tL[0] = -L[3].z * L[2] + L[2].z * L[3];\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t} else if ( config == 5 ) {\n\t\tn = 0;\n\t} else if ( config == 6 ) {\n\t\tn = 4;\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 7 ) {\n\t\tn = 5;\n\t\tL[4] = -L[3].z * L[0] + L[0].z * L[3];\n\t\tL[3] = -L[3].z * L[2] + L[2].z * L[3];\n\t} else if ( config == 8 ) {\n\t\tn = 3;\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[1] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] =  L[3];\n\t} else if ( config == 9 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t\tL[2] = -L[2].z * L[3] + L[3].z * L[2];\n\t} else if ( config == 10 ) {\n\t\tn = 0;\n\t} else if ( config == 11 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = -L[2].z * L[3] + L[3].z * L[2];\n\t\tL[2] = -L[2].z * L[1] + L[1].z * L[2];\n\t} else if ( config == 12 ) {\n\t\tn = 4;\n\t\tL[1] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[0] = -L[0].z * L[3] + L[3].z * L[0];\n\t} else if ( config == 13 ) {\n\t\tn = 5;\n\t\tL[4] = L[3];\n\t\tL[3] = L[2];\n\t\tL[2] = -L[1].z * L[2] + L[2].z * L[1];\n\t\tL[1] = -L[1].z * L[0] + L[0].z * L[1];\n\t} else if ( config == 14 ) {\n\t\tn = 5;\n\t\tL[4] = -L[0].z * L[3] + L[3].z * L[0];\n\t\tL[0] = -L[0].z * L[1] + L[1].z * L[0];\n\t} else if ( config == 15 ) {\n\t\tn = 4;\n\t}\n\tif ( n == 3 )\n\t\tL[3] = L[0];\n\tif ( n == 4 )\n\t\tL[4] = L[0];\n}\nfloat integrateLtcBrdfOverRectEdge( vec3 v1, vec3 v2 ) {\n\tfloat cosTheta = dot( v1, v2 );\n\tfloat theta = acos( cosTheta );\n\tfloat res = cross( v1, v2 ).z * ( ( theta > 0.001 ) ? theta / sin( theta ) : 1.0 );\n\treturn res;\n}\nvoid initRectPoints( const in vec3 pos, const in vec3 halfWidth, const in vec3 halfHeight, out vec3 rectPoints[4] ) {\n\trectPoints[0] = pos - halfWidth - halfHeight;\n\trectPoints[1] = pos + halfWidth - halfHeight;\n\trectPoints[2] = pos + halfWidth + halfHeight;\n\trectPoints[3] = pos - halfWidth + halfHeight;\n}\nvec3 integrateLtcBrdfOverRect( const in GeometricContext geometry, const in mat3 brdfMat, const in vec3 rectPoints[4] ) {\n\tvec3 N = geometry.normal;\n\tvec3 V = geometry.viewDir;\n\tvec3 P = geometry.position;\n\tvec3 T1, T2;\n\tT1 = normalize(V - N * dot( V, N ));\n\tT2 = - cross( N, T1 );\n\tmat3 brdfWrtSurface = brdfMat * transpose( mat3( T1, T2, N ) );\n\tvec3 clippedRect[5];\n\tclippedRect[0] = brdfWrtSurface * ( rectPoints[0] - P );\n\tclippedRect[1] = brdfWrtSurface * ( rectPoints[1] - P );\n\tclippedRect[2] = brdfWrtSurface * ( rectPoints[2] - P );\n\tclippedRect[3] = brdfWrtSurface * ( rectPoints[3] - P );\n\tint n;\n\tclipQuadToHorizon(clippedRect, n);\n\tif ( n == 0 )\n\t\treturn vec3( 0, 0, 0 );\n\tclippedRect[0] = normalize( clippedRect[0] );\n\tclippedRect[1] = normalize( clippedRect[1] );\n\tclippedRect[2] = normalize( clippedRect[2] );\n\tclippedRect[3] = normalize( clippedRect[3] );\n\tclippedRect[4] = normalize( clippedRect[4] );\n\tfloat sum = 0.0;\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[0], clippedRect[1] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[1], clippedRect[2] );\n\tsum += integrateLtcBrdfOverRectEdge( clippedRect[2], clippedRect[3] );\n\tif (n >= 4)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[3], clippedRect[4] );\n\tif (n == 5)\n\t\tsum += integrateLtcBrdfOverRectEdge( clippedRect[4], clippedRect[0] );\n\tsum = max( 0.0, sum );\n\tvec3 Lo_i = vec3( sum, sum, sum );\n\treturn Lo_i;\n}\nvec3 Rect_Area_Light_Specular_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight,\n\t\tconst in float roughness,\n\t\tconst in sampler2D ltcMat, const in sampler2D ltcMag ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tvec2 uv = ltcTextureCoords( geometry, roughness );\n\tvec4 brdfLtcApproxParams, t;\n\tbrdfLtcApproxParams = texture2D( ltcMat, uv );\n\tt = texture2D( ltcMat, uv );\n\tfloat brdfLtcScalar = texture2D( ltcMag, uv ).a;\n\tmat3 brdfLtcApproxMat = mat3(\n\t\tvec3(   1,   0, t.y ),\n\t\tvec3(   0, t.z,   0 ),\n\t\tvec3( t.w,   0, t.x )\n\t);\n\tvec3 specularReflectance = integrateLtcBrdfOverRect( geometry, brdfLtcApproxMat, rectPoints );\n\tspecularReflectance *= brdfLtcScalar;\n\treturn specularReflectance;\n}\nvec3 Rect_Area_Light_Diffuse_Reflectance(\n\t\tconst in GeometricContext geometry,\n\t\tconst in vec3 lightPos, const in vec3 lightHalfWidth, const in vec3 lightHalfHeight ) {\n\tvec3 rectPoints[4];\n\tinitRectPoints( lightPos, lightHalfWidth, lightHalfHeight, rectPoints );\n\tmat3 diffuseBrdfMat = mat3(1);\n\tvec3 diffuseReflectance = integrateLtcBrdfOverRect( geometry, diffuseBrdfMat, rectPoints );\n\treturn diffuseReflectance;\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\tvec2 AB = vec2( -1.04, 1.04 ) * a004 + r.zw;\n\treturn specularColor * AB.x + AB.y;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}\n";

var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = dFdx( surf_pos );\n\t\tvec3 vSigmaY = dFdy( surf_pos );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif\n";

var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; ++ i ) {\n\t\tvec4 plane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t\t\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; ++ i ) {\n\t\t\tvec4 plane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t\n\t#endif\n#endif\n";

var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif\n";

var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvarying vec3 vViewPosition;\n#endif\n";

var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n";

var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";

var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif\n";

var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";

var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";

var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transpose( const in mat3 v ) {\n\tmat3 tmp;\n\ttmp[0] = vec3(v[0].x, v[1].x, v[2].x);\n\ttmp[1] = vec3(v[0].y, v[1].y, v[2].y);\n\ttmp[2] = vec3(v[0].z, v[1].z, v[2].z);\n\treturn tmp;\n}\n";

var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ?  0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV(vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif\n";

var defaultnormal_vertex = "#ifdef FLIP_SIDED\n\tobjectNormal = -objectNormal;\n#endif\nvec3 transformedNormal = normalMatrix * objectNormal;\n";

var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif\n";

var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normal * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif\n";

var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif\n";

var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif\n";

var encodings_fragment = "  gl_FragColor = linearToOutputTexel( gl_FragColor );\n";

var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n  return value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( gammaFactor ) ), value.w );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n  return vec4( pow( value.xyz, vec3( 1.0 / gammaFactor ) ), value.w );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n  return vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.w );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n  return vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.w );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n  return vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n  float maxComponent = max( max( value.r, value.g ), value.b );\n  float fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n  return vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n  return vec4( value.xyz * value.w * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n  float maxRGB = max( value.x, max( value.g, value.b ) );\n  float M      = clamp( maxRGB / maxRange, 0.0, 1.0 );\n  M            = ceil( M * 255.0 ) / 255.0;\n  return vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n    return vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n    float maxRGB = max( value.x, max( value.g, value.b ) );\n    float D      = max( maxRange / maxRGB, 1.0 );\n    D            = min( floor( D ) / 255.0, 1.0 );\n    return vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n  vec3 Xp_Y_XYZp = value.rgb * cLogLuvM;\n  Xp_Y_XYZp = max(Xp_Y_XYZp, vec3(1e-6, 1e-6, 1e-6));\n  vec4 vResult;\n  vResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n  float Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n  vResult.w = fract(Le);\n  vResult.z = (Le - (floor(vResult.w*255.0))/255.0)/255.0;\n  return vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n  float Le = value.z * 255.0 + value.w;\n  vec3 Xp_Y_XYZp;\n  Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);\n  Xp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n  Xp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n  vec3 vRGB = Xp_Y_XYZp.rgb * cLogLuvInverseM;\n  return vec4( max(vRGB, 0.0), 1.0 );\n}\n";

var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, flipNormal * vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\tsampleUV.y = saturate( flipNormal * reflectVec.y * 0.5 + 0.5 );\n\t\tsampleUV.x = atan( flipNormal * reflectVec.z, flipNormal * reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\tvec3 reflectView = flipNormal * normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif\n";

var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif\n";

var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif\n";

var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif\n";

var fog_fragment = "#ifdef USE_FOG\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tfloat depth = gl_FragDepthEXT / gl_FragCoord.w;\n\t#else\n\t\tfloat depth = gl_FragCoord.z / gl_FragCoord.w;\n\t#endif\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * depth * depth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, depth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif\n";

var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";

var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif\n";

var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif\n";

var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";

var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvLightFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif\n";

var lights_pars = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltcMat;\tuniform sampler2D ltcMag;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif\n#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar - 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV(queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = saturate( reflectVec.y * 0.5 + 0.5 );\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif\n";

var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;\n";

var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\n#if NUM_RECT_AREA_LIGHTS > 0\n    void RE_Direct_RectArea_BlinnPhong( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n        vec3 matDiffColor = material.diffuseColor;\n        vec3 matSpecColor = material.specularColor;\n        vec3 lightColor   = rectAreaLight.color;\n        float roughness = BlinnExponentToGGXRoughness( material.specularShininess );\n        vec3 spec = Rect_Area_Light_Specular_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n                roughness,\n                ltcMat, ltcMag );\n        vec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n        reflectedLight.directSpecular += lightColor * matSpecColor * spec / PI2;\n        reflectedLight.directDiffuse  += lightColor * matDiffColor * diff / PI2;\n    }\n#endif\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)\n";

var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif\n";

var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n    void RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n        vec3 matDiffColor = material.diffuseColor;\n        vec3 matSpecColor = material.specularColor;\n        vec3 lightColor   = rectAreaLight.color;\n        float roughness = material.specularRoughness;\n        vec3 spec = Rect_Area_Light_Specular_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight,\n                roughness,\n                ltcMat, ltcMag );\n        vec3 diff = Rect_Area_Light_Diffuse_Reflectance(\n                geometry,\n                rectAreaLight.position, rectAreaLight.halfWidth, rectAreaLight.halfHeight );\n        reflectedLight.directSpecular += lightColor * matSpecColor * spec;\n        reflectedLight.directDiffuse  += lightColor * matDiffColor * diff;\n    }\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}\n";

var lights_template = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t \tirradiance += getLightProbeIndirectIrradiance( geometry, 8 );\n\t#endif\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tvec3 radiance = getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), 8 );\n\t#ifndef STANDARD\n\t\tvec3 clearCoatRadiance = getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), 8 );\n\t#else\n\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t#endif\n\t\t\n\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif\n";

var logdepthbuf_fragment = "#if defined(USE_LOGDEPTHBUF) && defined(USE_LOGDEPTHBUF_EXT)\n\tgl_FragDepthEXT = log2(vFragDepth) * logDepthBufFC * 0.5;\n#endif";

var logdepthbuf_pars_fragment = "#ifdef USE_LOGDEPTHBUF\n\tuniform float logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n#endif\n";

var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#endif\n\tuniform float logDepthBufFC;\n#endif";

var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\tgl_Position.z = log2(max( EPSILON, gl_Position.w + 1.0 )) * logDepthBufFC;\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = (gl_Position.z - 1.0) * gl_Position.w;\n\t#endif\n#endif\n";

var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif\n";

var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif\n";

var map_particle_fragment = "#ifdef USE_MAP\n\tvec4 mapTexel = texture2D( map, vec2( gl_PointCoord.x, 1.0 - gl_PointCoord.y ) * offsetRepeat.zw + offsetRepeat.xy );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif\n";

var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform vec4 offsetRepeat;\n\tuniform sampler2D map;\n#endif\n";

var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.r;\n#endif\n";

var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";

var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif\n";

var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";

var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif\n";

var normal_flip = "#ifdef DOUBLE_SIDED\n\tfloat flipNormal = ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n#else\n\tfloat flipNormal = 1.0;\n#endif\n";

var normal_fragment = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal ) * flipNormal;\n#endif\n#ifdef USE_NORMALMAP\n\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif\n";

var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\tvec3 q0 = dFdx( eye_pos.xyz );\n\t\tvec3 q1 = dFdy( eye_pos.xyz );\n\t\tvec2 st0 = dFdx( vUv.st );\n\t\tvec2 st1 = dFdy( vUv.st );\n\t\tvec3 S = normalize( q0 * st1.t - q1 * st0.t );\n\t\tvec3 T = normalize( -q0 * st1.s + q1 * st0.s );\n\t\tvec3 N = normalize( surf_norm );\n\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\tmapN.xy = normalScale * mapN.xy;\n\t\tmat3 tsn = mat3( S, T, N );\n\t\treturn normalize( tsn * mapN );\n\t}\n#endif\n";

var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n  return normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n  return 1.0 - 2.0 * rgb.xyz;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n  return ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n  return linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n  return (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n  return ( near * far ) / ( ( far - near ) * invClipZ - far );\n}\n";

var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif\n";

var project_vertex = "#ifdef USE_SKINNING\n\tvec4 mvPosition = modelViewMatrix * skinned;\n#else\n\tvec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\n#endif\ngl_Position = projectionMatrix * mvPosition;\n";

var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.r;\n#endif\n";

var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";

var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\treturn (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn 1.0;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\tfloat dp = ( length( lightToPosition ) - shadowBias ) / 1000.0;\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif\n";

var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n#endif\n";

var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n    #if NUM_RECT_AREA_LIGHTS > 0\n    #endif\n#endif\n";

var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_RECT_AREA_LIGHTS > 0\n\t#endif\n\t#endif\n\treturn shadow;\n}\n";

var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";

var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureWidth;\n\t\tuniform int boneTextureHeight;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureWidth ) );\n\t\t\tfloat y = floor( j / float( boneTextureWidth ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureWidth );\n\t\t\tfloat dy = 1.0 / float( boneTextureHeight );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif\n";

var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\tskinned  = bindMatrixInverse * skinned;\n#endif\n";

var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif\n";

var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";

var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";

var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif\n";

var tonemapping_pars_fragment = "#define saturate(a) clamp( a, 0.0, 1.0 )\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n  return toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  return saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n  color *= toneMappingExposure;\n  color = max( vec3( 0.0 ), color - 0.004 );\n  return pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\n";

var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";

var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n";

var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = uv * offsetRepeat.zw + offsetRepeat.xy;\n#endif";

var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";

var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";

var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";

var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( PHONG ) || defined( PHYSICAL ) || defined( LAMBERT ) || defined ( USE_SHADOWMAP )\n\t#ifdef USE_SKINNING\n\t\tvec4 worldPosition = modelMatrix * skinned;\n\t#else\n\t\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n\t#endif\n#endif\n";

var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tgl_FragColor = textureCube( tCube, vec3( tFlip * vWorldPosition.x, vWorldPosition.yz ) );\n\tgl_FragColor.a *= opacity;\n}\n";

var cube_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}\n";

var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

var distanceRGBA_frag = "uniform vec3 lightPos;\nvarying vec4 vWorldPosition;\n#include <common>\n#include <packing>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tgl_FragColor = packDepthToRGBA( length( vWorldPosition.xyz - lightPos.xyz ) / 1000.0 );\n}\n";

var distanceRGBA_vert = "varying vec4 vWorldPosition;\n#include <common>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <skinbase_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition;\n}\n";

var equirect_frag = "uniform sampler2D tEquirect;\nuniform float tFlip;\nvarying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldPosition );\n\tvec2 sampleUV;\n\tsampleUV.y = saturate( tFlip * direction.y * -0.5 + 0.5 );\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tgl_FragColor = texture2D( tEquirect, sampleUV );\n}\n";

var equirect_vert = "varying vec3 vWorldPosition;\n#include <common>\nvoid main() {\n\tvWorldPosition = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}\n";

var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}\n";

var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n}\n";

var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <normal_flip>\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n}\n";

var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n}\n";

var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_template>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_flip>\n\t#include <normal_fragment>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n\t#include <premultiplied_alpha_fragment>\n\t#include <encodings_fragment>\n}\n";

var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED  ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}\n";

var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}\n";

var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#ifdef USE_SIZEATTENUATION\n\t\tgl_PointSize = size * ( scale / - mvPosition.z );\n\t#else\n\t\tgl_PointSize = size;\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

var shadow_frag = "uniform float opacity;\n#include <common>\n#include <packing>\n#include <bsdfs>\n#include <lights_pars>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( 0.0, 0.0, 0.0, opacity * ( 1.0  - getShadowMask() ) );\n}\n";

var shadow_vert = "#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n}\n";

var ShaderChunk = {
	alphamap_fragment: alphamap_fragment,
	alphamap_pars_fragment: alphamap_pars_fragment,
	alphatest_fragment: alphatest_fragment,
	aomap_fragment: aomap_fragment,
	aomap_pars_fragment: aomap_pars_fragment,
	begin_vertex: begin_vertex,
	beginnormal_vertex: beginnormal_vertex,
	bsdfs: bsdfs,
	bumpmap_pars_fragment: bumpmap_pars_fragment,
	clipping_planes_fragment: clipping_planes_fragment,
	clipping_planes_pars_fragment: clipping_planes_pars_fragment,
	clipping_planes_pars_vertex: clipping_planes_pars_vertex,
	clipping_planes_vertex: clipping_planes_vertex,
	color_fragment: color_fragment,
	color_pars_fragment: color_pars_fragment,
	color_pars_vertex: color_pars_vertex,
	color_vertex: color_vertex,
	common: common,
	cube_uv_reflection_fragment: cube_uv_reflection_fragment,
	defaultnormal_vertex: defaultnormal_vertex,
	displacementmap_pars_vertex: displacementmap_pars_vertex,
	displacementmap_vertex: displacementmap_vertex,
	emissivemap_fragment: emissivemap_fragment,
	emissivemap_pars_fragment: emissivemap_pars_fragment,
	encodings_fragment: encodings_fragment,
	encodings_pars_fragment: encodings_pars_fragment,
	envmap_fragment: envmap_fragment,
	envmap_pars_fragment: envmap_pars_fragment,
	envmap_pars_vertex: envmap_pars_vertex,
	envmap_vertex: envmap_vertex,
	fog_fragment: fog_fragment,
	fog_pars_fragment: fog_pars_fragment,
	gradientmap_pars_fragment: gradientmap_pars_fragment,
	lightmap_fragment: lightmap_fragment,
	lightmap_pars_fragment: lightmap_pars_fragment,
	lights_lambert_vertex: lights_lambert_vertex,
	lights_pars: lights_pars,
	lights_phong_fragment: lights_phong_fragment,
	lights_phong_pars_fragment: lights_phong_pars_fragment,
	lights_physical_fragment: lights_physical_fragment,
	lights_physical_pars_fragment: lights_physical_pars_fragment,
	lights_template: lights_template,
	logdepthbuf_fragment: logdepthbuf_fragment,
	logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
	logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
	logdepthbuf_vertex: logdepthbuf_vertex,
	map_fragment: map_fragment,
	map_pars_fragment: map_pars_fragment,
	map_particle_fragment: map_particle_fragment,
	map_particle_pars_fragment: map_particle_pars_fragment,
	metalnessmap_fragment: metalnessmap_fragment,
	metalnessmap_pars_fragment: metalnessmap_pars_fragment,
	morphnormal_vertex: morphnormal_vertex,
	morphtarget_pars_vertex: morphtarget_pars_vertex,
	morphtarget_vertex: morphtarget_vertex,
	normal_flip: normal_flip,
	normal_fragment: normal_fragment,
	normalmap_pars_fragment: normalmap_pars_fragment,
	packing: packing,
	premultiplied_alpha_fragment: premultiplied_alpha_fragment,
	project_vertex: project_vertex,
	roughnessmap_fragment: roughnessmap_fragment,
	roughnessmap_pars_fragment: roughnessmap_pars_fragment,
	shadowmap_pars_fragment: shadowmap_pars_fragment,
	shadowmap_pars_vertex: shadowmap_pars_vertex,
	shadowmap_vertex: shadowmap_vertex,
	shadowmask_pars_fragment: shadowmask_pars_fragment,
	skinbase_vertex: skinbase_vertex,
	skinning_pars_vertex: skinning_pars_vertex,
	skinning_vertex: skinning_vertex,
	skinnormal_vertex: skinnormal_vertex,
	specularmap_fragment: specularmap_fragment,
	specularmap_pars_fragment: specularmap_pars_fragment,
	tonemapping_fragment: tonemapping_fragment,
	tonemapping_pars_fragment: tonemapping_pars_fragment,
	uv_pars_fragment: uv_pars_fragment,
	uv_pars_vertex: uv_pars_vertex,
	uv_vertex: uv_vertex,
	uv2_pars_fragment: uv2_pars_fragment,
	uv2_pars_vertex: uv2_pars_vertex,
	uv2_vertex: uv2_vertex,
	worldpos_vertex: worldpos_vertex,

	cube_frag: cube_frag,
	cube_vert: cube_vert,
	depth_frag: depth_frag,
	depth_vert: depth_vert,
	distanceRGBA_frag: distanceRGBA_frag,
	distanceRGBA_vert: distanceRGBA_vert,
	equirect_frag: equirect_frag,
	equirect_vert: equirect_vert,
	linedashed_frag: linedashed_frag,
	linedashed_vert: linedashed_vert,
	meshbasic_frag: meshbasic_frag,
	meshbasic_vert: meshbasic_vert,
	meshlambert_frag: meshlambert_frag,
	meshlambert_vert: meshlambert_vert,
	meshphong_frag: meshphong_frag,
	meshphong_vert: meshphong_vert,
	meshphysical_frag: meshphysical_frag,
	meshphysical_vert: meshphysical_vert,
	normal_frag: normal_frag,
	normal_vert: normal_vert,
	points_frag: points_frag,
	points_vert: points_vert,
	shadow_frag: shadow_frag,
	shadow_vert: shadow_vert
};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Color( r, g, b ) {

	if ( g === undefined && b === undefined ) {

		// r is THREE.Color, hex or string
		return this.set( r );

	}

	return this.setRGB( r, g, b );

}

Color.prototype = {

	constructor: Color,

	isColor: true,

	r: 1, g: 1, b: 1,

	set: function ( value ) {

		if ( value && value.isColor ) {

			this.copy( value );

		} else if ( typeof value === 'number' ) {

			this.setHex( value );

		} else if ( typeof value === 'string' ) {

			this.setStyle( value );

		}

		return this;

	},

	setScalar: function ( scalar ) {

		this.r = scalar;
		this.g = scalar;
		this.b = scalar;

		return this;

	},

	setHex: function ( hex ) {

		hex = Math.floor( hex );

		this.r = ( hex >> 16 & 255 ) / 255;
		this.g = ( hex >> 8 & 255 ) / 255;
		this.b = ( hex & 255 ) / 255;

		return this;

	},

	setRGB: function ( r, g, b ) {

		this.r = r;
		this.g = g;
		this.b = b;

		return this;

	},

	setHSL: function () {

		function hue2rgb( p, q, t ) {

			if ( t < 0 ) t += 1;
			if ( t > 1 ) t -= 1;
			if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
			if ( t < 1 / 2 ) return q;
			if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
			return p;

		}

		return function setHSL( h, s, l ) {

			// h,s,l ranges are in 0.0 - 1.0
			h = _Math.euclideanModulo( h, 1 );
			s = _Math.clamp( s, 0, 1 );
			l = _Math.clamp( l, 0, 1 );

			if ( s === 0 ) {

				this.r = this.g = this.b = l;

			} else {

				var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
				var q = ( 2 * l ) - p;

				this.r = hue2rgb( q, p, h + 1 / 3 );
				this.g = hue2rgb( q, p, h );
				this.b = hue2rgb( q, p, h - 1 / 3 );

			}

			return this;

		};

	}(),

	setStyle: function ( style ) {

		function handleAlpha( string ) {

			if ( string === undefined ) return;

			if ( parseFloat( string ) < 1 ) {

				console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );

			}

		}


		var m;

		if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {

			// rgb / hsl

			var color;
			var name = m[ 1 ];
			var components = m[ 2 ];

			switch ( name ) {

				case 'rgb':
				case 'rgba':

					if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(255,0,0) rgba(255,0,0,0.5)
						this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
						this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
						this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;

						handleAlpha( color[ 5 ] );

						return this;

					}

					if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
						this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
						this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
						this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;

						handleAlpha( color[ 5 ] );

						return this;

					}

					break;

				case 'hsl':
				case 'hsla':

					if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {

						// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
						var h = parseFloat( color[ 1 ] ) / 360;
						var s = parseInt( color[ 2 ], 10 ) / 100;
						var l = parseInt( color[ 3 ], 10 ) / 100;

						handleAlpha( color[ 5 ] );

						return this.setHSL( h, s, l );

					}

					break;

			}

		} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {

			// hex color

			var hex = m[ 1 ];
			var size = hex.length;

			if ( size === 3 ) {

				// #ff0
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;

				return this;

			} else if ( size === 6 ) {

				// #ff0000
				this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
				this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
				this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;

				return this;

			}

		}

		if ( style && style.length > 0 ) {

			// color keywords
			var hex = ColorKeywords[ style ];

			if ( hex !== undefined ) {

				// red
				this.setHex( hex );

			} else {

				// unknown color
				console.warn( 'THREE.Color: Unknown color ' + style );

			}

		}

		return this;

	},

	clone: function () {

		return new this.constructor( this.r, this.g, this.b );

	},

	copy: function ( color ) {

		this.r = color.r;
		this.g = color.g;
		this.b = color.b;

		return this;

	},

	copyGammaToLinear: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		this.r = Math.pow( color.r, gammaFactor );
		this.g = Math.pow( color.g, gammaFactor );
		this.b = Math.pow( color.b, gammaFactor );

		return this;

	},

	copyLinearToGamma: function ( color, gammaFactor ) {

		if ( gammaFactor === undefined ) gammaFactor = 2.0;

		var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;

		this.r = Math.pow( color.r, safeInverse );
		this.g = Math.pow( color.g, safeInverse );
		this.b = Math.pow( color.b, safeInverse );

		return this;

	},

	convertGammaToLinear: function () {

		var r = this.r, g = this.g, b = this.b;

		this.r = r * r;
		this.g = g * g;
		this.b = b * b;

		return this;

	},

	convertLinearToGamma: function () {

		this.r = Math.sqrt( this.r );
		this.g = Math.sqrt( this.g );
		this.b = Math.sqrt( this.b );

		return this;

	},

	getHex: function () {

		return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;

	},

	getHexString: function () {

		return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );

	},

	getHSL: function ( optionalTarget ) {

		// h,s,l ranges are in 0.0 - 1.0

		var hsl = optionalTarget || { h: 0, s: 0, l: 0 };

		var r = this.r, g = this.g, b = this.b;

		var max = Math.max( r, g, b );
		var min = Math.min( r, g, b );

		var hue, saturation;
		var lightness = ( min + max ) / 2.0;

		if ( min === max ) {

			hue = 0;
			saturation = 0;

		} else {

			var delta = max - min;

			saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );

			switch ( max ) {

				case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
				case g: hue = ( b - r ) / delta + 2; break;
				case b: hue = ( r - g ) / delta + 4; break;

			}

			hue /= 6;

		}

		hsl.h = hue;
		hsl.s = saturation;
		hsl.l = lightness;

		return hsl;

	},

	getStyle: function () {

		return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';

	},

	offsetHSL: function ( h, s, l ) {

		var hsl = this.getHSL();

		hsl.h += h; hsl.s += s; hsl.l += l;

		this.setHSL( hsl.h, hsl.s, hsl.l );

		return this;

	},

	add: function ( color ) {

		this.r += color.r;
		this.g += color.g;
		this.b += color.b;

		return this;

	},

	addColors: function ( color1, color2 ) {

		this.r = color1.r + color2.r;
		this.g = color1.g + color2.g;
		this.b = color1.b + color2.b;

		return this;

	},

	addScalar: function ( s ) {

		this.r += s;
		this.g += s;
		this.b += s;

		return this;

	},

	sub: function( color ) {

		this.r = Math.max( 0, this.r - color.r );
		this.g = Math.max( 0, this.g - color.g );
		this.b = Math.max( 0, this.b - color.b );

		return this;

	},

	multiply: function ( color ) {

		this.r *= color.r;
		this.g *= color.g;
		this.b *= color.b;

		return this;

	},

	multiplyScalar: function ( s ) {

		this.r *= s;
		this.g *= s;
		this.b *= s;

		return this;

	},

	lerp: function ( color, alpha ) {

		this.r += ( color.r - this.r ) * alpha;
		this.g += ( color.g - this.g ) * alpha;
		this.b += ( color.b - this.b ) * alpha;

		return this;

	},

	equals: function ( c ) {

		return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		this.r = array[ offset ];
		this.g = array[ offset + 1 ];
		this.b = array[ offset + 2 ];

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this.r;
		array[ offset + 1 ] = this.g;
		array[ offset + 2 ] = this.b;

		return array;

	},

	toJSON: function () {

		return this.getHex();

	}

};

var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };

/**
 * @author alteredq / http://alteredqualia.com/
 */

function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { data: data, width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.generateMipmaps  = false;
	this.flipY = false;
	this.unpackAlignment = 1;

}

DataTexture.prototype = Object.create( Texture.prototype );
DataTexture.prototype.constructor = DataTexture;

DataTexture.prototype.isDataTexture = true;

/**
 * Uniforms library for shared webgl shaders
 */

var UniformsLib = {

	common: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },

		map: { value: null },
		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) },

		specularMap: { value: null },
		alphaMap: { value: null },

		envMap: { value: null },
		flipEnvMap: { value: - 1 },
		reflectivity: { value: 1.0 },
		refractionRatio: { value: 0.98 }

	},

	aomap: {

		aoMap: { value: null },
		aoMapIntensity: { value: 1 }

	},

	lightmap: {

		lightMap: { value: null },
		lightMapIntensity: { value: 1 }

	},

	emissivemap: {

		emissiveMap: { value: null }

	},

	bumpmap: {

		bumpMap: { value: null },
		bumpScale: { value: 1 }

	},

	normalmap: {

		normalMap: { value: null },
		normalScale: { value: new Vector2( 1, 1 ) }

	},

	displacementmap: {

		displacementMap: { value: null },
		displacementScale: { value: 1 },
		displacementBias: { value: 0 }

	},

	roughnessmap: {

		roughnessMap: { value: null }

	},

	metalnessmap: {

		metalnessMap: { value: null }

	},

	gradientmap: {

		gradientMap: { value: null }

	},

	fog: {

		fogDensity: { value: 0.00025 },
		fogNear: { value: 1 },
		fogFar: { value: 2000 },
		fogColor: { value: new Color( 0xffffff ) }

	},

	lights: {

		ambientLightColor: { value: [] },

		directionalLights: { value: [], properties: {
			direction: {},
			color: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		directionalShadowMap: { value: [] },
		directionalShadowMatrix: { value: [] },

		spotLights: { value: [], properties: {
			color: {},
			position: {},
			direction: {},
			distance: {},
			coneCos: {},
			penumbraCos: {},
			decay: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		spotShadowMap: { value: [] },
		spotShadowMatrix: { value: [] },

		pointLights: { value: [], properties: {
			color: {},
			position: {},
			decay: {},
			distance: {},

			shadow: {},
			shadowBias: {},
			shadowRadius: {},
			shadowMapSize: {}
		} },

		pointShadowMap: { value: [] },
		pointShadowMatrix: { value: [] },

		hemisphereLights: { value: [], properties: {
			direction: {},
			skyColor: {},
			groundColor: {}
		} },

        // TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
        rectAreaLights: { value: [], properties: {
            color: {},
            position: {},
            width: {},
            height: {},
        } }

	},

	points: {

		diffuse: { value: new Color( 0xeeeeee ) },
		opacity: { value: 1.0 },
		size: { value: 1.0 },
		scale: { value: 1.0 },
		map: { value: null },
		offsetRepeat: { value: new Vector4( 0, 0, 1, 1 ) }

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 */

var ShaderLib = {

	basic: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.meshbasic_vert,
		fragmentShader: ShaderChunk.meshbasic_frag

	},

	lambert: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) }
			}
		] ),

		vertexShader: ShaderChunk.meshlambert_vert,
		fragmentShader: ShaderChunk.meshlambert_frag

	},

	phong: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.gradientmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				specular: { value: new Color( 0x111111 ) },
				shininess: { value: 30 }
			}
		] ),

		vertexShader: ShaderChunk.meshphong_vert,
		fragmentShader: ShaderChunk.meshphong_frag

	},

	standard: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.aomap,
			UniformsLib.lightmap,
			UniformsLib.emissivemap,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			UniformsLib.roughnessmap,
			UniformsLib.metalnessmap,
			UniformsLib.fog,
			UniformsLib.lights,
			{
				emissive: { value: new Color( 0x000000 ) },
				roughness: { value: 0.5 },
				metalness: { value: 0 },
				envMapIntensity: { value: 1 } // temporary
			}
		] ),

		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag

	},

	points: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.points,
			UniformsLib.fog
		] ),

		vertexShader: ShaderChunk.points_vert,
		fragmentShader: ShaderChunk.points_frag

	},

	dashed: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.fog,
			{
				scale: { value: 1 },
				dashSize: { value: 1 },
				totalSize: { value: 2 }
			}
		] ),

		vertexShader: ShaderChunk.linedashed_vert,
		fragmentShader: ShaderChunk.linedashed_frag

	},

	depth: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.displacementmap
		] ),

		vertexShader: ShaderChunk.depth_vert,
		fragmentShader: ShaderChunk.depth_frag

	},

	normal: {

		uniforms: UniformsUtils.merge( [
			UniformsLib.common,
			UniformsLib.bumpmap,
			UniformsLib.normalmap,
			UniformsLib.displacementmap,
			{
				opacity: { value: 1.0 }
			}
		] ),

		vertexShader: ShaderChunk.normal_vert,
		fragmentShader: ShaderChunk.normal_frag

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	cube: {

		uniforms: {
			tCube: { value: null },
			tFlip: { value: - 1 },
			opacity: { value: 1.0 }
		},

		vertexShader: ShaderChunk.cube_vert,
		fragmentShader: ShaderChunk.cube_frag

	},

	/* -------------------------------------------------------------------------
	//	Cube map shader
	 ------------------------------------------------------------------------- */

	equirect: {

		uniforms: {
			tEquirect: { value: null },
			tFlip: { value: - 1 }
		},

		vertexShader: ShaderChunk.equirect_vert,
		fragmentShader: ShaderChunk.equirect_frag

	},

	distanceRGBA: {

		uniforms: {
			lightPos: { value: new Vector3() }
		},

		vertexShader: ShaderChunk.distanceRGBA_vert,
		fragmentShader: ShaderChunk.distanceRGBA_frag

	}

};

ShaderLib.physical = {

	uniforms: UniformsUtils.merge( [
		ShaderLib.standard.uniforms,
		{
			clearCoat: { value: 0 },
			clearCoatRoughness: { value: 0 }
		}
	] ),

	vertexShader: ShaderChunk.meshphysical_vert,
	fragmentShader: ShaderChunk.meshphysical_frag

};

/**
 * @author bhouston / http://clara.io
 */

function Box2( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );

}

Box2.prototype = {

	constructor: Box2,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new Vector2();

		return function setFromCenterAndSize( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = + Infinity;
		this.max.x = this.max.y = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );

	},

	getCenter: function ( optionalTarget ) {

		var result = optionalTarget || new Vector2();
		return this.isEmpty() ? result.set( 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( optionalTarget ) {

		var result = optionalTarget || new Vector2();
		return this.isEmpty() ? result.set( 0, 0 ) : result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new Vector2();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ? false : true;

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new Vector2();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new Vector2();

		return function distanceToPoint( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function LensFlarePlugin( renderer, flares ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var shader, program, attributes, uniforms;

	var tempTexture, occlusionTexture;

	function init() {

		var vertices = new Float32Array( [
			- 1, - 1,  0, 0,
			 1, - 1,  1, 0,
			 1,  1,  1, 1,
			- 1,  1,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		// buffers

		vertexBuffer     = gl.createBuffer();
		elementBuffer    = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		// textures

		tempTexture      = gl.createTexture();
		occlusionTexture = gl.createTexture();

		state.bindTexture( gl.TEXTURE_2D, tempTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGB, 16, 16, 0, gl.RGB, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
		gl.texImage2D( gl.TEXTURE_2D, 0, gl.RGBA, 16, 16, 0, gl.RGBA, gl.UNSIGNED_BYTE, null );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST );
		gl.texParameteri( gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST );

		shader = {

			vertexShader: [

				"uniform lowp int renderType;",

				"uniform vec3 screenPosition;",
				"uniform vec2 scale;",
				"uniform float rotation;",

				"uniform sampler2D occlusionMap;",

				"attribute vec2 position;",
				"attribute vec2 uv;",

				"varying vec2 vUV;",
				"varying float vVisibility;",

				"void main() {",

					"vUV = uv;",

					"vec2 pos = position;",

					"if ( renderType == 2 ) {",

						"vec4 visibility = texture2D( occlusionMap, vec2( 0.1, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.1 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.9, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.9 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.1, 0.5 ) );",
						"visibility += texture2D( occlusionMap, vec2( 0.5, 0.5 ) );",

						"vVisibility =        visibility.r / 9.0;",
						"vVisibility *= 1.0 - visibility.g / 9.0;",
						"vVisibility *=       visibility.b / 9.0;",
						"vVisibility *= 1.0 - visibility.a / 9.0;",

						"pos.x = cos( rotation ) * position.x - sin( rotation ) * position.y;",
						"pos.y = sin( rotation ) * position.x + cos( rotation ) * position.y;",

					"}",

					"gl_Position = vec4( ( pos * scale + screenPosition.xy ).xy, screenPosition.z, 1.0 );",

				"}"

			].join( "\n" ),

			fragmentShader: [

				"uniform lowp int renderType;",

				"uniform sampler2D map;",
				"uniform float opacity;",
				"uniform vec3 color;",

				"varying vec2 vUV;",
				"varying float vVisibility;",

				"void main() {",

					// pink square

					"if ( renderType == 0 ) {",

						"gl_FragColor = vec4( 1.0, 0.0, 1.0, 0.0 );",

					// restore

					"} else if ( renderType == 1 ) {",

						"gl_FragColor = texture2D( map, vUV );",

					// flare

					"} else {",

						"vec4 texture = texture2D( map, vUV );",
						"texture.a *= opacity * vVisibility;",
						"gl_FragColor = texture;",
						"gl_FragColor.rgb *= color;",

					"}",

				"}"

			].join( "\n" )

		};

		program = createProgram( shader );

		attributes = {
			vertex: gl.getAttribLocation ( program, "position" ),
			uv:     gl.getAttribLocation ( program, "uv" )
		};

		uniforms = {
			renderType:     gl.getUniformLocation( program, "renderType" ),
			map:            gl.getUniformLocation( program, "map" ),
			occlusionMap:   gl.getUniformLocation( program, "occlusionMap" ),
			opacity:        gl.getUniformLocation( program, "opacity" ),
			color:          gl.getUniformLocation( program, "color" ),
			scale:          gl.getUniformLocation( program, "scale" ),
			rotation:       gl.getUniformLocation( program, "rotation" ),
			screenPosition: gl.getUniformLocation( program, "screenPosition" )
		};

	}

	/*
	 * Render lens flares
	 * Method: renders 16x16 0xff00ff-colored points scattered over the light source area,
	 *         reads these back and calculates occlusion.
	 */

	this.render = function ( scene, camera, viewport ) {

		if ( flares.length === 0 ) return;

		var tempPosition = new Vector3();

		var invAspect = viewport.w / viewport.z,
			halfViewportWidth = viewport.z * 0.5,
			halfViewportHeight = viewport.w * 0.5;

		var size = 16 / viewport.w,
			scale = new Vector2( size * invAspect, size );

		var screenPosition = new Vector3( 1, 1, 0 ),
			screenPositionPixels = new Vector2( 1, 1 );

		var validArea = new Box2();

		validArea.min.set( viewport.x, viewport.y );
		validArea.max.set( viewport.x + ( viewport.z - 16 ), viewport.y + ( viewport.w - 16 ) );

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.vertex );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		// loop through all lens flares to update their occlusion and positions
		// setup gl and common used attribs/uniforms

		gl.uniform1i( uniforms.occlusionMap, 0 );
		gl.uniform1i( uniforms.map, 1 );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.vertex, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		state.disable( gl.CULL_FACE );
		state.setDepthWrite( false );

		for ( var i = 0, l = flares.length; i < l; i ++ ) {

			size = 16 / viewport.w;
			scale.set( size * invAspect, size );

			// calc object screen position

			var flare = flares[ i ];

			tempPosition.set( flare.matrixWorld.elements[ 12 ], flare.matrixWorld.elements[ 13 ], flare.matrixWorld.elements[ 14 ] );

			tempPosition.applyMatrix4( camera.matrixWorldInverse );
			tempPosition.applyProjection( camera.projectionMatrix );

			// setup arrays for gl programs

			screenPosition.copy( tempPosition );

			// horizontal and vertical coordinate of the lower left corner of the pixels to copy

			screenPositionPixels.x = viewport.x + ( screenPosition.x * halfViewportWidth ) + halfViewportWidth - 8;
			screenPositionPixels.y = viewport.y + ( screenPosition.y * halfViewportHeight ) + halfViewportHeight - 8;

			// screen cull

			if ( validArea.containsPoint( screenPositionPixels ) === true ) {

				// save current RGB to temp texture

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, null );
				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGB, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


				// render pink quad

				gl.uniform1i( uniforms.renderType, 0 );
				gl.uniform2f( uniforms.scale, scale.x, scale.y );
				gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );

				state.disable( gl.BLEND );
				state.enable( gl.DEPTH_TEST );

				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// copy result to occlusionMap

				state.activeTexture( gl.TEXTURE0 );
				state.bindTexture( gl.TEXTURE_2D, occlusionTexture );
				gl.copyTexImage2D( gl.TEXTURE_2D, 0, gl.RGBA, screenPositionPixels.x, screenPositionPixels.y, 16, 16, 0 );


				// restore graphics

				gl.uniform1i( uniforms.renderType, 1 );
				state.disable( gl.DEPTH_TEST );

				state.activeTexture( gl.TEXTURE1 );
				state.bindTexture( gl.TEXTURE_2D, tempTexture );
				gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );


				// update object positions

				flare.positionScreen.copy( screenPosition );

				if ( flare.customUpdateCallback ) {

					flare.customUpdateCallback( flare );

				} else {

					flare.updateLensFlares();

				}

				// render flares

				gl.uniform1i( uniforms.renderType, 2 );
				state.enable( gl.BLEND );

				for ( var j = 0, jl = flare.lensFlares.length; j < jl; j ++ ) {

					var sprite = flare.lensFlares[ j ];

					if ( sprite.opacity > 0.001 && sprite.scale > 0.001 ) {

						screenPosition.x = sprite.x;
						screenPosition.y = sprite.y;
						screenPosition.z = sprite.z;

						size = sprite.size * sprite.scale / viewport.w;

						scale.x = size * invAspect;
						scale.y = size;

						gl.uniform3f( uniforms.screenPosition, screenPosition.x, screenPosition.y, screenPosition.z );
						gl.uniform2f( uniforms.scale, scale.x, scale.y );
						gl.uniform1f( uniforms.rotation, sprite.rotation );

						gl.uniform1f( uniforms.opacity, sprite.opacity );
						gl.uniform3f( uniforms.color, sprite.color.r, sprite.color.g, sprite.color.b );

						state.setBlending( sprite.blending, sprite.blendEquation, sprite.blendSrc, sprite.blendDst );
						renderer.setTexture2D( sprite.texture, 1 );

						gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

					}

				}

			}

		}

		// restore gl

		state.enable( gl.CULL_FACE );
		state.enable( gl.DEPTH_TEST );
		state.setDepthWrite( true );

		renderer.resetGLState();

	};

	function createProgram( shader ) {

		var program = gl.createProgram();

		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );
		var vertexShader = gl.createShader( gl.VERTEX_SHADER );

		var prefix = "precision " + renderer.getPrecision() + " float;\n";

		gl.shaderSource( fragmentShader, prefix + shader.fragmentShader );
		gl.shaderSource( vertexShader, prefix + shader.vertexShader );

		gl.compileShader( fragmentShader );
		gl.compileShader( vertexShader );

		gl.attachShader( program, fragmentShader );
		gl.attachShader( program, vertexShader );

		gl.linkProgram( program );

		return program;

	}

}

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function SpritePlugin( renderer, sprites ) {

	var gl = renderer.context;
	var state = renderer.state;

	var vertexBuffer, elementBuffer;
	var program, attributes, uniforms;

	var texture;

	// decompose matrixWorld

	var spritePosition = new Vector3();
	var spriteRotation = new Quaternion();
	var spriteScale = new Vector3();

	function init() {

		var vertices = new Float32Array( [
			- 0.5, - 0.5,  0, 0,
			  0.5, - 0.5,  1, 0,
			  0.5,   0.5,  1, 1,
			- 0.5,   0.5,  0, 1
		] );

		var faces = new Uint16Array( [
			0, 1, 2,
			0, 2, 3
		] );

		vertexBuffer  = gl.createBuffer();
		elementBuffer = gl.createBuffer();

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.bufferData( gl.ARRAY_BUFFER, vertices, gl.STATIC_DRAW );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );
		gl.bufferData( gl.ELEMENT_ARRAY_BUFFER, faces, gl.STATIC_DRAW );

		program = createProgram();

		attributes = {
			position:			gl.getAttribLocation ( program, 'position' ),
			uv:					gl.getAttribLocation ( program, 'uv' )
		};

		uniforms = {
			uvOffset:			gl.getUniformLocation( program, 'uvOffset' ),
			uvScale:			gl.getUniformLocation( program, 'uvScale' ),

			rotation:			gl.getUniformLocation( program, 'rotation' ),
			scale:				gl.getUniformLocation( program, 'scale' ),

			color:				gl.getUniformLocation( program, 'color' ),
			map:				gl.getUniformLocation( program, 'map' ),
			opacity:			gl.getUniformLocation( program, 'opacity' ),

			modelViewMatrix: 	gl.getUniformLocation( program, 'modelViewMatrix' ),
			projectionMatrix:	gl.getUniformLocation( program, 'projectionMatrix' ),

			fogType:			gl.getUniformLocation( program, 'fogType' ),
			fogDensity:			gl.getUniformLocation( program, 'fogDensity' ),
			fogNear:			gl.getUniformLocation( program, 'fogNear' ),
			fogFar:				gl.getUniformLocation( program, 'fogFar' ),
			fogColor:			gl.getUniformLocation( program, 'fogColor' ),

			alphaTest:			gl.getUniformLocation( program, 'alphaTest' )
		};

		var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
		canvas.width = 8;
		canvas.height = 8;

		var context = canvas.getContext( '2d' );
		context.fillStyle = 'white';
		context.fillRect( 0, 0, 8, 8 );

		texture = new Texture( canvas );
		texture.needsUpdate = true;

	}

	this.render = function ( scene, camera ) {

		if ( sprites.length === 0 ) return;

		// setup gl

		if ( program === undefined ) {

			init();

		}

		gl.useProgram( program );

		state.initAttributes();
		state.enableAttribute( attributes.position );
		state.enableAttribute( attributes.uv );
		state.disableUnusedAttributes();

		state.disable( gl.CULL_FACE );
		state.enable( gl.BLEND );

		gl.bindBuffer( gl.ARRAY_BUFFER, vertexBuffer );
		gl.vertexAttribPointer( attributes.position, 2, gl.FLOAT, false, 2 * 8, 0 );
		gl.vertexAttribPointer( attributes.uv, 2, gl.FLOAT, false, 2 * 8, 8 );

		gl.bindBuffer( gl.ELEMENT_ARRAY_BUFFER, elementBuffer );

		gl.uniformMatrix4fv( uniforms.projectionMatrix, false, camera.projectionMatrix.elements );

		state.activeTexture( gl.TEXTURE0 );
		gl.uniform1i( uniforms.map, 0 );

		var oldFogType = 0;
		var sceneFogType = 0;
		var fog = scene.fog;

		if ( fog ) {

			gl.uniform3f( uniforms.fogColor, fog.color.r, fog.color.g, fog.color.b );

			if ( fog.isFog ) {

				gl.uniform1f( uniforms.fogNear, fog.near );
				gl.uniform1f( uniforms.fogFar, fog.far );

				gl.uniform1i( uniforms.fogType, 1 );
				oldFogType = 1;
				sceneFogType = 1;

			} else if ( fog.isFogExp2 ) {

				gl.uniform1f( uniforms.fogDensity, fog.density );

				gl.uniform1i( uniforms.fogType, 2 );
				oldFogType = 2;
				sceneFogType = 2;

			}

		} else {

			gl.uniform1i( uniforms.fogType, 0 );
			oldFogType = 0;
			sceneFogType = 0;

		}


		// update positions and sort

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];

			sprite.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, sprite.matrixWorld );
			sprite.z = - sprite.modelViewMatrix.elements[ 14 ];

		}

		sprites.sort( painterSortStable );

		// render all sprites

		var scale = [];

		for ( var i = 0, l = sprites.length; i < l; i ++ ) {

			var sprite = sprites[ i ];
			var material = sprite.material;

			if ( material.visible === false ) continue;

			gl.uniform1f( uniforms.alphaTest, material.alphaTest );
			gl.uniformMatrix4fv( uniforms.modelViewMatrix, false, sprite.modelViewMatrix.elements );

			sprite.matrixWorld.decompose( spritePosition, spriteRotation, spriteScale );

			scale[ 0 ] = spriteScale.x;
			scale[ 1 ] = spriteScale.y;

			var fogType = 0;

			if ( scene.fog && material.fog ) {

				fogType = sceneFogType;

			}

			if ( oldFogType !== fogType ) {

				gl.uniform1i( uniforms.fogType, fogType );
				oldFogType = fogType;

			}

			if ( material.map !== null ) {

				gl.uniform2f( uniforms.uvOffset, material.map.offset.x, material.map.offset.y );
				gl.uniform2f( uniforms.uvScale, material.map.repeat.x, material.map.repeat.y );

			} else {

				gl.uniform2f( uniforms.uvOffset, 0, 0 );
				gl.uniform2f( uniforms.uvScale, 1, 1 );

			}

			gl.uniform1f( uniforms.opacity, material.opacity );
			gl.uniform3f( uniforms.color, material.color.r, material.color.g, material.color.b );

			gl.uniform1f( uniforms.rotation, material.rotation );
			gl.uniform2fv( uniforms.scale, scale );

			state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst );
			state.setDepthTest( material.depthTest );
			state.setDepthWrite( material.depthWrite );

			if ( material.map ) {

				renderer.setTexture2D( material.map, 0 );

			} else {

				renderer.setTexture2D( texture, 0 );

			}

			gl.drawElements( gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0 );

		}

		// restore gl

		state.enable( gl.CULL_FACE );

		renderer.resetGLState();

	};

	function createProgram() {

		var program = gl.createProgram();

		var vertexShader = gl.createShader( gl.VERTEX_SHADER );
		var fragmentShader = gl.createShader( gl.FRAGMENT_SHADER );

		gl.shaderSource( vertexShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform float rotation;',
			'uniform vec2 scale;',
			'uniform vec2 uvOffset;',
			'uniform vec2 uvScale;',

			'attribute vec2 position;',
			'attribute vec2 uv;',

			'varying vec2 vUV;',

			'void main() {',

				'vUV = uvOffset + uv * uvScale;',

				'vec2 alignedPosition = position * scale;',

				'vec2 rotatedPosition;',
				'rotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;',
				'rotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;',

				'vec4 finalPosition;',

				'finalPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );',
				'finalPosition.xy += rotatedPosition;',
				'finalPosition = projectionMatrix * finalPosition;',

				'gl_Position = finalPosition;',

			'}'

		].join( '\n' ) );

		gl.shaderSource( fragmentShader, [

			'precision ' + renderer.getPrecision() + ' float;',

			'uniform vec3 color;',
			'uniform sampler2D map;',
			'uniform float opacity;',

			'uniform int fogType;',
			'uniform vec3 fogColor;',
			'uniform float fogDensity;',
			'uniform float fogNear;',
			'uniform float fogFar;',
			'uniform float alphaTest;',

			'varying vec2 vUV;',

			'void main() {',

				'vec4 texture = texture2D( map, vUV );',

				'if ( texture.a < alphaTest ) discard;',

				'gl_FragColor = vec4( color * texture.xyz, texture.a * opacity );',

				'if ( fogType > 0 ) {',

					'float depth = gl_FragCoord.z / gl_FragCoord.w;',
					'float fogFactor = 0.0;',

					'if ( fogType == 1 ) {',

						'fogFactor = smoothstep( fogNear, fogFar, depth );',

					'} else {',

						'const float LOG2 = 1.442695;',
						'fogFactor = exp2( - fogDensity * fogDensity * depth * depth * LOG2 );',
						'fogFactor = 1.0 - clamp( fogFactor, 0.0, 1.0 );',

					'}',

					'gl_FragColor = mix( gl_FragColor, vec4( fogColor, gl_FragColor.w ), fogFactor );',

				'}',

			'}'

		].join( '\n' ) );

		gl.compileShader( vertexShader );
		gl.compileShader( fragmentShader );

		gl.attachShader( program, vertexShader );
		gl.attachShader( program, fragmentShader );

		gl.linkProgram( program );

		return program;

	}

	function painterSortStable( a, b ) {

		if ( a.renderOrder !== b.renderOrder ) {

			return a.renderOrder - b.renderOrder;

		} else if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return b.id - a.id;

		}

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

var materialId = 0;

function Material() {

	Object.defineProperty( this, 'id', { value: materialId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Material';

	this.fog = true;
	this.lights = true;

	this.blending = NormalBlending;
	this.side = FrontSide;
	this.shading = SmoothShading; // THREE.FlatShading, THREE.SmoothShading
	this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors

	this.opacity = 1;
	this.transparent = false;

	this.blendSrc = SrcAlphaFactor;
	this.blendDst = OneMinusSrcAlphaFactor;
	this.blendEquation = AddEquation;
	this.blendSrcAlpha = null;
	this.blendDstAlpha = null;
	this.blendEquationAlpha = null;

	this.depthFunc = LessEqualDepth;
	this.depthTest = true;
	this.depthWrite = true;

	this.clippingPlanes = null;
	this.clipIntersection = false;
	this.clipShadows = false;

	this.colorWrite = true;

	this.precision = null; // override the renderer's default precision for this material

	this.polygonOffset = false;
	this.polygonOffsetFactor = 0;
	this.polygonOffsetUnits = 0;

	this.alphaTest = 0;
	this.premultipliedAlpha = false;

	this.overdraw = 0; // Overdrawn pixels (typically between 0 and 1) for fixing antialiasing gaps in CanvasRenderer

	this.visible = true;

	this._needsUpdate = true;

}

Material.prototype = {

	constructor: Material,

	isMaterial: true,

	get needsUpdate() {

		return this._needsUpdate;

	},

	set needsUpdate( value ) {

		if ( value === true ) this.update();
		this._needsUpdate = value;

	},

	setValues: function ( values ) {

		if ( values === undefined ) return;

		for ( var key in values ) {

			var newValue = values[ key ];

			if ( newValue === undefined ) {

				console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
				continue;

			}

			var currentValue = this[ key ];

			if ( currentValue === undefined ) {

				console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
				continue;

			}

			if ( currentValue && currentValue.isColor ) {

				currentValue.set( newValue );

			} else if ( (currentValue && currentValue.isVector3) && (newValue && newValue.isVector3) ) {

				currentValue.copy( newValue );

			} else if ( key === 'overdraw' ) {

				// ensure overdraw is backwards-compatible with legacy boolean type
				this[ key ] = Number( newValue );

			} else {

				this[ key ] = newValue;

			}

		}

	},

	toJSON: function ( meta ) {

		var isRoot = meta === undefined;

		if ( isRoot ) {

			meta = {
				textures: {},
				images: {}
			};

		}

		var data = {
			metadata: {
				version: 4.4,
				type: 'Material',
				generator: 'Material.toJSON'
			}
		};

		// standard Material serialization
		data.uuid = this.uuid;
		data.type = this.type;

		if ( this.name !== '' ) data.name = this.name;

		if ( this.color && this.color.isColor ) data.color = this.color.getHex();

		if ( this.roughness !== undefined ) data.roughness = this.roughness;
		if ( this.metalness !== undefined ) data.metalness = this.metalness;

		if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
		if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
		if ( this.shininess !== undefined ) data.shininess = this.shininess;
		if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
		if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;

		if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
		if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
		if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
		if ( this.bumpMap && this.bumpMap.isTexture ) {

			data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
			data.bumpScale = this.bumpScale;

		}
		if ( this.normalMap && this.normalMap.isTexture ) {

			data.normalMap = this.normalMap.toJSON( meta ).uuid;
			data.normalScale = this.normalScale.toArray();

		}
		if ( this.displacementMap && this.displacementMap.isTexture ) {

			data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
			data.displacementScale = this.displacementScale;
			data.displacementBias = this.displacementBias;

		}
		if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
		if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;

		if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
		if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;

		if ( this.envMap && this.envMap.isTexture ) {

			data.envMap = this.envMap.toJSON( meta ).uuid;
			data.reflectivity = this.reflectivity; // Scale behind envMap

		}

		if ( this.gradientMap && this.gradientMap.isTexture ) {

			data.gradientMap = this.gradientMap.toJSON( meta ).uuid;

		}

		if ( this.size !== undefined ) data.size = this.size;
		if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;

		if ( this.blending !== NormalBlending ) data.blending = this.blending;
		if ( this.shading !== SmoothShading ) data.shading = this.shading;
		if ( this.side !== FrontSide ) data.side = this.side;
		if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;

		if ( this.opacity < 1 ) data.opacity = this.opacity;
		if ( this.transparent === true ) data.transparent = this.transparent;

		data.depthFunc = this.depthFunc;
		data.depthTest = this.depthTest;
		data.depthWrite = this.depthWrite;

		if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
		if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
		if ( this.wireframe === true ) data.wireframe = this.wireframe;
		if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
		if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
		if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;

		data.skinning = this.skinning;
		data.morphTargets = this.morphTargets;

		// TODO: Copied from Object3D.toJSON

		function extractFromCache( cache ) {

			var values = [];

			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}

			return values;

		}

		if ( isRoot ) {

			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( textures.length > 0 ) data.textures = textures;
			if ( images.length > 0 ) data.images = images;

		}

		return data;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.name = source.name;

		this.fog = source.fog;
		this.lights = source.lights;

		this.blending = source.blending;
		this.side = source.side;
		this.shading = source.shading;
		this.vertexColors = source.vertexColors;

		this.opacity = source.opacity;
		this.transparent = source.transparent;

		this.blendSrc = source.blendSrc;
		this.blendDst = source.blendDst;
		this.blendEquation = source.blendEquation;
		this.blendSrcAlpha = source.blendSrcAlpha;
		this.blendDstAlpha = source.blendDstAlpha;
		this.blendEquationAlpha = source.blendEquationAlpha;

		this.depthFunc = source.depthFunc;
		this.depthTest = source.depthTest;
		this.depthWrite = source.depthWrite;

		this.colorWrite = source.colorWrite;

		this.precision = source.precision;

		this.polygonOffset = source.polygonOffset;
		this.polygonOffsetFactor = source.polygonOffsetFactor;
		this.polygonOffsetUnits = source.polygonOffsetUnits;

		this.alphaTest = source.alphaTest;

		this.premultipliedAlpha = source.premultipliedAlpha;

		this.overdraw = source.overdraw;

		this.visible = source.visible;
		this.clipShadows = source.clipShadows;
		this.clipIntersection = source.clipIntersection;

		var srcPlanes = source.clippingPlanes,
			dstPlanes = null;

		if ( srcPlanes !== null ) {

			var n = srcPlanes.length;
			dstPlanes = new Array( n );

			for ( var i = 0; i !== n; ++ i )
				dstPlanes[ i ] = srcPlanes[ i ].clone();

		}

		this.clippingPlanes = dstPlanes;

		return this;

	},

	update: function () {

		this.dispatchEvent( { type: 'update' } );

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

};

Object.assign( Material.prototype, EventDispatcher.prototype );

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  defines: { "label" : "value" },
 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
 *
 *  fragmentShader: <string>,
 *  vertexShader: <string>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  lights: <bool>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function ShaderMaterial( parameters ) {

	Material.call( this );

	this.type = 'ShaderMaterial';

	this.defines = {};
	this.uniforms = {};

	this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
	this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';

	this.linewidth = 1;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false; // set to use scene fog
	this.lights = false; // set to use scene lights
	this.clipping = false; // set to use user-defined clipping planes

	this.skinning = false; // set to use skinning attribute streams
	this.morphTargets = false; // set to use morph targets
	this.morphNormals = false; // set to use morph normals

	this.extensions = {
		derivatives: false, // set to use derivatives
		fragDepth: false, // set to use fragment depth values
		drawBuffers: false, // set to use draw buffers
		shaderTextureLOD: false // set to use shader texture LOD
	};

	// When rendered geometry doesn't include these attributes but the material does,
	// use these default values in WebGL. This avoids errors when buffer data is missing.
	this.defaultAttributeValues = {
		'color': [ 1, 1, 1 ],
		'uv': [ 0, 0 ],
		'uv2': [ 0, 0 ]
	};

	this.index0AttributeName = undefined;

	if ( parameters !== undefined ) {

		if ( parameters.attributes !== undefined ) {

			console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );

		}

		this.setValues( parameters );

	}

}

ShaderMaterial.prototype = Object.create( Material.prototype );
ShaderMaterial.prototype.constructor = ShaderMaterial;

ShaderMaterial.prototype.isShaderMaterial = true;

ShaderMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.fragmentShader = source.fragmentShader;
	this.vertexShader = source.vertexShader;

	this.uniforms = UniformsUtils.clone( source.uniforms );

	this.defines = source.defines;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.lights = source.lights;
	this.clipping = source.clipping;

	this.skinning = source.skinning;

	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	this.extensions = source.extensions;

	return this;

};

ShaderMaterial.prototype.toJSON = function ( meta ) {

	var data = Material.prototype.toJSON.call( this, meta );

	data.uniforms = this.uniforms;
	data.vertexShader = this.vertexShader;
	data.fragmentShader = this.fragmentShader;

	return data;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / https://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 * }
 */

function MeshDepthMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshDepthMaterial';

	this.depthPacking = BasicDepthPacking;

	this.skinning = false;
	this.morphTargets = false;

	this.map = null;

	this.alphaMap = null;

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;

	this.setValues( parameters );

}

MeshDepthMaterial.prototype = Object.create( Material.prototype );
MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;

MeshDepthMaterial.prototype.isMeshDepthMaterial = true;

MeshDepthMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.depthPacking = source.depthPacking;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	this.map = source.map;

	this.alphaMap = source.alphaMap;

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	return this;

};

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 */

function Box3( min, max ) {

	this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
	this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );

}

Box3.prototype = {

	constructor: Box3,

	isBox3: true,

	set: function ( min, max ) {

		this.min.copy( min );
		this.max.copy( max );

		return this;

	},

	setFromArray: function ( array ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = array.length; i < l; i += 3 ) {

			var x = array[ i ];
			var y = array[ i + 1 ];
			var z = array[ i + 2 ];

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

	},

	setFromBufferAttribute: function ( attribute ) {

		var minX = + Infinity;
		var minY = + Infinity;
		var minZ = + Infinity;

		var maxX = - Infinity;
		var maxY = - Infinity;
		var maxZ = - Infinity;

		for ( var i = 0, l = attribute.count; i < l; i ++ ) {

			var x = attribute.getX( i );
			var y = attribute.getY( i );
			var z = attribute.getZ( i );

			if ( x < minX ) minX = x;
			if ( y < minY ) minY = y;
			if ( z < minZ ) minZ = z;

			if ( x > maxX ) maxX = x;
			if ( y > maxY ) maxY = y;
			if ( z > maxZ ) maxZ = z;

		}

		this.min.set( minX, minY, minZ );
		this.max.set( maxX, maxY, maxZ );

	},

	setFromPoints: function ( points ) {

		this.makeEmpty();

		for ( var i = 0, il = points.length; i < il; i ++ ) {

			this.expandByPoint( points[ i ] );

		}

		return this;

	},

	setFromCenterAndSize: function () {

		var v1 = new Vector3();

		return function setFromCenterAndSize( center, size ) {

			var halfSize = v1.copy( size ).multiplyScalar( 0.5 );

			this.min.copy( center ).sub( halfSize );
			this.max.copy( center ).add( halfSize );

			return this;

		};

	}(),

	setFromObject: function () {

		// Computes the world-axis-aligned bounding box of an object (including its children),
		// accounting for both the object's, and children's, world transforms

		var v1 = new Vector3();

		return function setFromObject( object ) {

			var scope = this;

			object.updateMatrixWorld( true );

			this.makeEmpty();

			object.traverse( function ( node ) {

				var i, l;

				var geometry = node.geometry;

				if ( geometry !== undefined ) {

					if ( geometry.isGeometry ) {

						var vertices = geometry.vertices;

						for ( i = 0, l = vertices.length; i < l; i ++ ) {

							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );

							scope.expandByPoint( v1 );

						}

					} else if ( geometry.isBufferGeometry ) {

						var attribute = geometry.attributes.position;

						if ( attribute !== undefined ) {

							for ( i = 0, l = attribute.count; i < l; i ++ ) {

								v1.fromAttribute( attribute, i ).applyMatrix4( node.matrixWorld );

								scope.expandByPoint( v1 );

							}

						}

					}

				}

			} );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( box ) {

		this.min.copy( box.min );
		this.max.copy( box.max );

		return this;

	},

	makeEmpty: function () {

		this.min.x = this.min.y = this.min.z = + Infinity;
		this.max.x = this.max.y = this.max.z = - Infinity;

		return this;

	},

	isEmpty: function () {

		// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes

		return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );

	},

	getCenter: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.addVectors( this.min, this.max ).multiplyScalar( 0.5 );

	},

	getSize: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return this.isEmpty() ? result.set( 0, 0, 0 ) : result.subVectors( this.max, this.min );

	},

	expandByPoint: function ( point ) {

		this.min.min( point );
		this.max.max( point );

		return this;

	},

	expandByVector: function ( vector ) {

		this.min.sub( vector );
		this.max.add( vector );

		return this;

	},

	expandByScalar: function ( scalar ) {

		this.min.addScalar( - scalar );
		this.max.addScalar( scalar );

		return this;

	},

	containsPoint: function ( point ) {

		return point.x < this.min.x || point.x > this.max.x ||
			point.y < this.min.y || point.y > this.max.y ||
			point.z < this.min.z || point.z > this.max.z ? false : true;

	},

	containsBox: function ( box ) {

		return this.min.x <= box.min.x && box.max.x <= this.max.x &&
			this.min.y <= box.min.y && box.max.y <= this.max.y &&
			this.min.z <= box.min.z && box.max.z <= this.max.z;

	},

	getParameter: function ( point, optionalTarget ) {

		// This can potentially have a divide by zero if the box
		// has a size dimension of 0.

		var result = optionalTarget || new Vector3();

		return result.set(
			( point.x - this.min.x ) / ( this.max.x - this.min.x ),
			( point.y - this.min.y ) / ( this.max.y - this.min.y ),
			( point.z - this.min.z ) / ( this.max.z - this.min.z )
		);

	},

	intersectsBox: function ( box ) {

		// using 6 splitting planes to rule out intersections.
		return box.max.x < this.min.x || box.min.x > this.max.x ||
			box.max.y < this.min.y || box.min.y > this.max.y ||
			box.max.z < this.min.z || box.min.z > this.max.z ? false : true;

	},

	intersectsSphere: ( function () {

		var closestPoint;

		return function intersectsSphere( sphere ) {

			if ( closestPoint === undefined ) closestPoint = new Vector3();

			// Find the point on the AABB closest to the sphere center.
			this.clampPoint( sphere.center, closestPoint );

			// If that point is inside the sphere, the AABB and sphere intersect.
			return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );

		};

	} )(),

	intersectsPlane: function ( plane ) {

		// We compute the minimum and maximum dot product values. If those values
		// are on the same side (back or front) of the plane, then there is no intersection.

		var min, max;

		if ( plane.normal.x > 0 ) {

			min = plane.normal.x * this.min.x;
			max = plane.normal.x * this.max.x;

		} else {

			min = plane.normal.x * this.max.x;
			max = plane.normal.x * this.min.x;

		}

		if ( plane.normal.y > 0 ) {

			min += plane.normal.y * this.min.y;
			max += plane.normal.y * this.max.y;

		} else {

			min += plane.normal.y * this.max.y;
			max += plane.normal.y * this.min.y;

		}

		if ( plane.normal.z > 0 ) {

			min += plane.normal.z * this.min.z;
			max += plane.normal.z * this.max.z;

		} else {

			min += plane.normal.z * this.max.z;
			max += plane.normal.z * this.min.z;

		}

		return ( min <= plane.constant && max >= plane.constant );

	},

	clampPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.copy( point ).clamp( this.min, this.max );

	},

	distanceToPoint: function () {

		var v1 = new Vector3();

		return function distanceToPoint( point ) {

			var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
			return clampedPoint.sub( point ).length();

		};

	}(),

	getBoundingSphere: function () {

		var v1 = new Vector3();

		return function getBoundingSphere( optionalTarget ) {

			var result = optionalTarget || new Sphere();

			this.getCenter( result.center );

			result.radius = this.getSize( v1 ).length() * 0.5;

			return result;

		};

	}(),

	intersect: function ( box ) {

		this.min.max( box.min );
		this.max.min( box.max );

		// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
		if( this.isEmpty() ) this.makeEmpty();

		return this;

	},

	union: function ( box ) {

		this.min.min( box.min );
		this.max.max( box.max );

		return this;

	},

	applyMatrix4: function () {

		var points = [
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3(),
			new Vector3()
		];

		return function applyMatrix4( matrix ) {

			// transform of empty box is an empty box.
			if( this.isEmpty() ) return this;

			// NOTE: I am using a binary pattern to specify all 2^3 combinations below
			points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
			points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
			points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
			points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
			points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
			points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
			points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
			points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix );	// 111

			this.setFromPoints( points );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.min.add( offset );
		this.max.add( offset );

		return this;

	},

	equals: function ( box ) {

		return box.min.equals( this.min ) && box.max.equals( this.max );

	}

};

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Sphere( center, radius ) {

	this.center = ( center !== undefined ) ? center : new Vector3();
	this.radius = ( radius !== undefined ) ? radius : 0;

}

Sphere.prototype = {

	constructor: Sphere,

	set: function ( center, radius ) {

		this.center.copy( center );
		this.radius = radius;

		return this;

	},

	setFromPoints: function () {

		var box = new Box3();

		return function setFromPoints( points, optionalCenter ) {

			var center = this.center;

			if ( optionalCenter !== undefined ) {

				center.copy( optionalCenter );

			} else {

				box.setFromPoints( points ).getCenter( center );

			}

			var maxRadiusSq = 0;

			for ( var i = 0, il = points.length; i < il; i ++ ) {

				maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );

			}

			this.radius = Math.sqrt( maxRadiusSq );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( sphere ) {

		this.center.copy( sphere.center );
		this.radius = sphere.radius;

		return this;

	},

	empty: function () {

		return ( this.radius <= 0 );

	},

	containsPoint: function ( point ) {

		return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );

	},

	distanceToPoint: function ( point ) {

		return ( point.distanceTo( this.center ) - this.radius );

	},

	intersectsSphere: function ( sphere ) {

		var radiusSum = this.radius + sphere.radius;

		return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );

	},

	intersectsBox: function ( box ) {

		return box.intersectsSphere( this );

	},

	intersectsPlane: function ( plane ) {

		// We use the following equation to compute the signed distance from
		// the center of the sphere to the plane.
		//
		// distance = q * n - d
		//
		// If this distance is greater than the radius of the sphere,
		// then there is no intersection.

		return Math.abs( this.center.dot( plane.normal ) - plane.constant ) <= this.radius;

	},

	clampPoint: function ( point, optionalTarget ) {

		var deltaLengthSq = this.center.distanceToSquared( point );

		var result = optionalTarget || new Vector3();

		result.copy( point );

		if ( deltaLengthSq > ( this.radius * this.radius ) ) {

			result.sub( this.center ).normalize();
			result.multiplyScalar( this.radius ).add( this.center );

		}

		return result;

	},

	getBoundingBox: function ( optionalTarget ) {

		var box = optionalTarget || new Box3();

		box.set( this.center, this.center );
		box.expandByScalar( this.radius );

		return box;

	},

	applyMatrix4: function ( matrix ) {

		this.center.applyMatrix4( matrix );
		this.radius = this.radius * matrix.getMaxScaleOnAxis();

		return this;

	},

	translate: function ( offset ) {

		this.center.add( offset );

		return this;

	},

	equals: function ( sphere ) {

		return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 * @author tschw
 */

function Matrix3() {

	this.elements = new Float32Array( [

		1, 0, 0,
		0, 1, 0,
		0, 0, 1

	] );

	if ( arguments.length > 0 ) {

		console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );

	}

}

Matrix3.prototype = {

	constructor: Matrix3,

	isMatrix3: true,

	set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {

		var te = this.elements;

		te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
		te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
		te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;

		return this;

	},

	identity: function () {

		this.set(

			1, 0, 0,
			0, 1, 0,
			0, 0, 1

		);

		return this;

	},

	clone: function () {

		return new this.constructor().fromArray( this.elements );

	},

	copy: function ( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 3 ], me[ 6 ],
			me[ 1 ], me[ 4 ], me[ 7 ],
			me[ 2 ], me[ 5 ], me[ 8 ]

		);

		return this;

	},

	setFromMatrix4: function( m ) {

		var me = m.elements;

		this.set(

			me[ 0 ], me[ 4 ], me[  8 ],
			me[ 1 ], me[ 5 ], me[  9 ],
			me[ 2 ], me[ 6 ], me[ 10 ]

		);

		return this;

	},

	applyToVector3Array: function () {

		var v1;

		return function applyToVector3Array( array, offset, length ) {

			if ( v1 === undefined ) v1 = new Vector3();
			if ( offset === undefined ) offset = 0;
			if ( length === undefined ) length = array.length;

			for ( var i = 0, j = offset; i < length; i += 3, j += 3 ) {

				v1.fromArray( array, j );
				v1.applyMatrix3( this );
				v1.toArray( array, j );

			}

			return array;

		};

	}(),

	applyToBufferAttribute: function () {

		var v1;

		return function applyToBufferAttribute( attribute ) {

			if ( v1 === undefined ) v1 = new Vector3();

			for ( var i = 0, l = attribute.count; i < l; i ++ ) {

				v1.x = attribute.getX( i );
				v1.y = attribute.getY( i );
				v1.z = attribute.getZ( i );

				v1.applyMatrix3( this );

				attribute.setXYZ( i, v1.x, v1.y, v1.z );

			}

			return attribute;

		};

	}(),

	multiplyScalar: function ( s ) {

		var te = this.elements;

		te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
		te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
		te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;

		return this;

	},

	determinant: function () {

		var te = this.elements;

		var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
			d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
			g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];

		return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;

	},

	getInverse: function ( matrix, throwOnDegenerate ) {

		if ( matrix && matrix.isMatrix4 ) {

			console.error( "THREE.Matrix3.getInverse no longer takes a Matrix4 argument." );

		}

		var me = matrix.elements,
			te = this.elements,

			n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
			n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
			n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],

			t11 = n33 * n22 - n32 * n23,
			t12 = n32 * n13 - n33 * n12,
			t13 = n23 * n12 - n22 * n13,

			det = n11 * t11 + n21 * t12 + n31 * t13;

		if ( det === 0 ) {

			var msg = "THREE.Matrix3.getInverse(): can't invert matrix, determinant is 0";

			if ( throwOnDegenerate === true ) {

				throw new Error( msg );

			} else {

				console.warn( msg );

			}

			return this.identity();
		}

		var detInv = 1 / det;

		te[ 0 ] = t11 * detInv;
		te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
		te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;

		te[ 3 ] = t12 * detInv;
		te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
		te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;

		te[ 6 ] = t13 * detInv;
		te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
		te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;

		return this;

	},

	transpose: function () {

		var tmp, m = this.elements;

		tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
		tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
		tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;

		return this;

	},

	getNormalMatrix: function ( matrix4 ) {

		return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();

	},

	transposeIntoArray: function ( r ) {

		var m = this.elements;

		r[ 0 ] = m[ 0 ];
		r[ 1 ] = m[ 3 ];
		r[ 2 ] = m[ 6 ];
		r[ 3 ] = m[ 1 ];
		r[ 4 ] = m[ 4 ];
		r[ 5 ] = m[ 7 ];
		r[ 6 ] = m[ 2 ];
		r[ 7 ] = m[ 5 ];
		r[ 8 ] = m[ 8 ];

		return this;

	},

	fromArray: function ( array, offset ) {

		if ( offset === undefined ) offset = 0;

		for( var i = 0; i < 9; i ++ ) {

			this.elements[ i ] = array[ i + offset ];

		}

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		var te = this.elements;

		array[ offset ] = te[ 0 ];
		array[ offset + 1 ] = te[ 1 ];
		array[ offset + 2 ] = te[ 2 ];

		array[ offset + 3 ] = te[ 3 ];
		array[ offset + 4 ] = te[ 4 ];
		array[ offset + 5 ] = te[ 5 ];

		array[ offset + 6 ] = te[ 6 ];
		array[ offset + 7 ] = te[ 7 ];
		array[ offset + 8 ]  = te[ 8 ];

		return array;

	}

};

/**
 * @author bhouston / http://clara.io
 */

function Plane( normal, constant ) {

	this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
	this.constant = ( constant !== undefined ) ? constant : 0;

}

Plane.prototype = {

	constructor: Plane,

	set: function ( normal, constant ) {

		this.normal.copy( normal );
		this.constant = constant;

		return this;

	},

	setComponents: function ( x, y, z, w ) {

		this.normal.set( x, y, z );
		this.constant = w;

		return this;

	},

	setFromNormalAndCoplanarPoint: function ( normal, point ) {

		this.normal.copy( normal );
		this.constant = - point.dot( this.normal );	// must be this.normal, not normal, as this.normal is normalized

		return this;

	},

	setFromCoplanarPoints: function () {

		var v1 = new Vector3();
		var v2 = new Vector3();

		return function setFromCoplanarPoints( a, b, c ) {

			var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();

			// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?

			this.setFromNormalAndCoplanarPoint( normal, a );

			return this;

		};

	}(),

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( plane ) {

		this.normal.copy( plane.normal );
		this.constant = plane.constant;

		return this;

	},

	normalize: function () {

		// Note: will lead to a divide by zero if the plane is invalid.

		var inverseNormalLength = 1.0 / this.normal.length();
		this.normal.multiplyScalar( inverseNormalLength );
		this.constant *= inverseNormalLength;

		return this;

	},

	negate: function () {

		this.constant *= - 1;
		this.normal.negate();

		return this;

	},

	distanceToPoint: function ( point ) {

		return this.normal.dot( point ) + this.constant;

	},

	distanceToSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) - sphere.radius;

	},

	projectPoint: function ( point, optionalTarget ) {

		return this.orthoPoint( point, optionalTarget ).sub( point ).negate();

	},

	orthoPoint: function ( point, optionalTarget ) {

		var perpendicularMagnitude = this.distanceToPoint( point );

		var result = optionalTarget || new Vector3();
		return result.copy( this.normal ).multiplyScalar( perpendicularMagnitude );

	},

	intersectLine: function () {

		var v1 = new Vector3();

		return function intersectLine( line, optionalTarget ) {

			var result = optionalTarget || new Vector3();

			var direction = line.delta( v1 );

			var denominator = this.normal.dot( direction );

			if ( denominator === 0 ) {

				// line is coplanar, return origin
				if ( this.distanceToPoint( line.start ) === 0 ) {

					return result.copy( line.start );

				}

				// Unsure if this is the correct method to handle this case.
				return undefined;

			}

			var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;

			if ( t < 0 || t > 1 ) {

				return undefined;

			}

			return result.copy( direction ).multiplyScalar( t ).add( line.start );

		};

	}(),

	intersectsLine: function ( line ) {

		// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.

		var startSign = this.distanceToPoint( line.start );
		var endSign = this.distanceToPoint( line.end );

		return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );

	},

	intersectsBox: function ( box ) {

		return box.intersectsPlane( this );

	},

	intersectsSphere: function ( sphere ) {

		return sphere.intersectsPlane( this );

	},

	coplanarPoint: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.copy( this.normal ).multiplyScalar( - this.constant );

	},

	applyMatrix4: function () {

		var v1 = new Vector3();
		var m1 = new Matrix3();

		return function applyMatrix4( matrix, optionalNormalMatrix ) {

			var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );

			// transform normal based on theory here:
			// http://www.songho.ca/opengl/gl_normaltransform.html
			var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
			var normal = this.normal.applyMatrix3( normalMatrix ).normalize();

			// recalculate constant (like in setFromNormalAndCoplanarPoint)
			this.constant = - referencePoint.dot( normal );

			return this;

		};

	}(),

	translate: function ( offset ) {

		this.constant = this.constant - offset.dot( this.normal );

		return this;

	},

	equals: function ( plane ) {

		return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author bhouston / http://clara.io
 */

function Frustum( p0, p1, p2, p3, p4, p5 ) {

	this.planes = [

		( p0 !== undefined ) ? p0 : new Plane(),
		( p1 !== undefined ) ? p1 : new Plane(),
		( p2 !== undefined ) ? p2 : new Plane(),
		( p3 !== undefined ) ? p3 : new Plane(),
		( p4 !== undefined ) ? p4 : new Plane(),
		( p5 !== undefined ) ? p5 : new Plane()

	];

}

Frustum.prototype = {

	constructor: Frustum,

	set: function ( p0, p1, p2, p3, p4, p5 ) {

		var planes = this.planes;

		planes[ 0 ].copy( p0 );
		planes[ 1 ].copy( p1 );
		planes[ 2 ].copy( p2 );
		planes[ 3 ].copy( p3 );
		planes[ 4 ].copy( p4 );
		planes[ 5 ].copy( p5 );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( frustum ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			planes[ i ].copy( frustum.planes[ i ] );

		}

		return this;

	},

	setFromMatrix: function ( m ) {

		var planes = this.planes;
		var me = m.elements;
		var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
		var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
		var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
		var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];

		planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
		planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
		planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
		planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
		planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
		planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();

		return this;

	},

	intersectsObject: function () {

		var sphere = new Sphere();

		return function intersectsObject( object ) {

			var geometry = object.geometry;

			if ( geometry.boundingSphere === null )
				geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere )
				.applyMatrix4( object.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSprite: function () {

		var sphere = new Sphere();

		return function intersectsSprite( sprite ) {

			sphere.center.set( 0, 0, 0 );
			sphere.radius = 0.7071067811865476;
			sphere.applyMatrix4( sprite.matrixWorld );

			return this.intersectsSphere( sphere );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		var planes = this.planes;
		var center = sphere.center;
		var negRadius = - sphere.radius;

		for ( var i = 0; i < 6; i ++ ) {

			var distance = planes[ i ].distanceToPoint( center );

			if ( distance < negRadius ) {

				return false;

			}

		}

		return true;

	},

	intersectsBox: function () {

		var p1 = new Vector3(),
			p2 = new Vector3();

		return function intersectsBox( box ) {

			var planes = this.planes;

			for ( var i = 0; i < 6 ; i ++ ) {

				var plane = planes[ i ];

				p1.x = plane.normal.x > 0 ? box.min.x : box.max.x;
				p2.x = plane.normal.x > 0 ? box.max.x : box.min.x;
				p1.y = plane.normal.y > 0 ? box.min.y : box.max.y;
				p2.y = plane.normal.y > 0 ? box.max.y : box.min.y;
				p1.z = plane.normal.z > 0 ? box.min.z : box.max.z;
				p2.z = plane.normal.z > 0 ? box.max.z : box.min.z;

				var d1 = plane.distanceToPoint( p1 );
				var d2 = plane.distanceToPoint( p2 );

				// if both outside plane, no intersection

				if ( d1 < 0 && d2 < 0 ) {

					return false;

				}

			}

			return true;

		};

	}(),


	containsPoint: function ( point ) {

		var planes = this.planes;

		for ( var i = 0; i < 6; i ++ ) {

			if ( planes[ i ].distanceToPoint( point ) < 0 ) {

				return false;

			}

		}

		return true;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLShadowMap( _renderer, _lights, _objects, capabilities ) {

	var _gl = _renderer.context,
	_state = _renderer.state,
	_frustum = new Frustum(),
	_projScreenMatrix = new Matrix4(),

	_lightShadows = _lights.shadows,

	_shadowMapSize = new Vector2(),
	_maxShadowMapSize = new Vector2( capabilities.maxTextureSize, capabilities.maxTextureSize ),

	_lookTarget = new Vector3(),
	_lightPositionWorld = new Vector3(),

	_renderList = [],

	_MorphingFlag = 1,
	_SkinningFlag = 2,

	_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,

	_depthMaterials = new Array( _NumberOfMaterialVariants ),
	_distanceMaterials = new Array( _NumberOfMaterialVariants ),

	_materialCache = {};

	var cubeDirections = [
		new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
		new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
	];

	var cubeUps = [
		new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
		new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
	];

	var cube2DViewPorts = [
		new Vector4(), new Vector4(), new Vector4(),
		new Vector4(), new Vector4(), new Vector4()
	];

	// init

	var depthMaterialTemplate = new MeshDepthMaterial();
	depthMaterialTemplate.depthPacking = RGBADepthPacking;
	depthMaterialTemplate.clipping = true;

	var distanceShader = ShaderLib[ "distanceRGBA" ];
	var distanceUniforms = UniformsUtils.clone( distanceShader.uniforms );

	for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {

		var useMorphing = ( i & _MorphingFlag ) !== 0;
		var useSkinning = ( i & _SkinningFlag ) !== 0;

		var depthMaterial = depthMaterialTemplate.clone();
		depthMaterial.morphTargets = useMorphing;
		depthMaterial.skinning = useSkinning;

		_depthMaterials[ i ] = depthMaterial;

		var distanceMaterial = new ShaderMaterial( {
			defines: {
				'USE_SHADOWMAP': ''
			},
			uniforms: distanceUniforms,
			vertexShader: distanceShader.vertexShader,
			fragmentShader: distanceShader.fragmentShader,
			morphTargets: useMorphing,
			skinning: useSkinning,
			clipping: true
		} );

		_distanceMaterials[ i ] = distanceMaterial;

	}

	//

	var scope = this;

	this.enabled = false;

	this.autoUpdate = true;
	this.needsUpdate = false;

	this.type = PCFShadowMap;

	this.renderReverseSided = true;
	this.renderSingleSided = true;

	this.render = function ( scene, camera ) {

		if ( scope.enabled === false ) return;
		if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;

		if ( _lightShadows.length === 0 ) return;

		// Set GL state for depth map.
		_state.buffers.color.setClear( 1, 1, 1, 1 );
		_state.disable( _gl.BLEND );
		_state.setDepthTest( true );
		_state.setScissorTest( false );

		// render depth map

		var faceCount, isPointLight;

		for ( var i = 0, il = _lightShadows.length; i < il; i ++ ) {

			var light = _lightShadows[ i ];
			var shadow = light.shadow;

			if ( shadow === undefined ) {

				console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
				continue;

			}

			var shadowCamera = shadow.camera;

			_shadowMapSize.copy( shadow.mapSize );
			_shadowMapSize.min( _maxShadowMapSize );

			if ( light && light.isPointLight ) {

				faceCount = 6;
				isPointLight = true;

				var vpWidth = _shadowMapSize.x;
				var vpHeight = _shadowMapSize.y;

				// These viewports map a cube-map onto a 2D texture with the
				// following orientation:
				//
				//  xzXZ
				//   y Y
				//
				// X - Positive x direction
				// x - Negative x direction
				// Y - Positive y direction
				// y - Negative y direction
				// Z - Positive z direction
				// z - Negative z direction

				// positive X
				cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
				// negative X
				cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
				// positive Z
				cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
				// negative Z
				cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
				// positive Y
				cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
				// negative Y
				cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );

				_shadowMapSize.x *= 4.0;
				_shadowMapSize.y *= 2.0;

			} else {

				faceCount = 1;
				isPointLight = false;

			}

			if ( shadow.map === null ) {

				var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };

				shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );

				shadowCamera.updateProjectionMatrix();

			}

			if ( shadow.isSpotLightShadow ) {

				shadow.update( light );

			}

			// TODO (abelnation / sam-g-steel): is this needed?
			if (shadow && shadow.isRectAreaLightShadow ) {

				shadow.update( light );

			}

			var shadowMap = shadow.map;
			var shadowMatrix = shadow.matrix;

			_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
			shadowCamera.position.copy( _lightPositionWorld );

			_renderer.setRenderTarget( shadowMap );
			_renderer.clear();

			// render shadow map for each cube face (if omni-directional) or
			// run a single pass if not

			for ( var face = 0; face < faceCount; face ++ ) {

				if ( isPointLight ) {

					_lookTarget.copy( shadowCamera.position );
					_lookTarget.add( cubeDirections[ face ] );
					shadowCamera.up.copy( cubeUps[ face ] );
					shadowCamera.lookAt( _lookTarget );

					var vpDimensions = cube2DViewPorts[ face ];
					_state.viewport( vpDimensions );

				} else {

					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );

				}

				shadowCamera.updateMatrixWorld();
				shadowCamera.matrixWorldInverse.getInverse( shadowCamera.matrixWorld );

				// compute shadow matrix

				shadowMatrix.set(
					0.5, 0.0, 0.0, 0.5,
					0.0, 0.5, 0.0, 0.5,
					0.0, 0.0, 0.5, 0.5,
					0.0, 0.0, 0.0, 1.0
				);

				shadowMatrix.multiply( shadowCamera.projectionMatrix );
				shadowMatrix.multiply( shadowCamera.matrixWorldInverse );

				// update camera matrices and frustum

				_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
				_frustum.setFromMatrix( _projScreenMatrix );

				// set object matrices & frustum culling

				_renderList.length = 0;

				projectObject( scene, camera, shadowCamera );

				// render shadow map
				// render regular objects

				for ( var j = 0, jl = _renderList.length; j < jl; j ++ ) {

					var object = _renderList[ j ];
					var geometry = _objects.update( object );
					var material = object.material;

					if ( material && material.isMultiMaterial ) {

						var groups = geometry.groups;
						var materials = material.materials;

						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {

							var group = groups[ k ];
							var groupMaterial = materials[ group.materialIndex ];

							if ( groupMaterial.visible === true ) {

								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );

							}

						}

					} else {

						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );

					}

				}

			}

		}

		// Restore GL state.
		var clearColor = _renderer.getClearColor(),
		clearAlpha = _renderer.getClearAlpha();
		_renderer.setClearColor( clearColor, clearAlpha );

		scope.needsUpdate = false;

	};

	function getDepthMaterial( object, material, isPointLight, lightPositionWorld ) {

		var geometry = object.geometry;

		var result = null;

		var materialVariants = _depthMaterials;
		var customMaterial = object.customDepthMaterial;

		if ( isPointLight ) {

			materialVariants = _distanceMaterials;
			customMaterial = object.customDistanceMaterial;

		}

		if ( ! customMaterial ) {

			var useMorphing = false;

			if ( material.morphTargets ) {

				if ( geometry && geometry.isBufferGeometry ) {

					useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;

				} else if ( geometry && geometry.isGeometry ) {

					useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;

				}

			}

			var useSkinning = object.isSkinnedMesh && material.skinning;

			var variantIndex = 0;

			if ( useMorphing ) variantIndex |= _MorphingFlag;
			if ( useSkinning ) variantIndex |= _SkinningFlag;

			result = materialVariants[ variantIndex ];

		} else {

			result = customMaterial;

		}

		if ( _renderer.localClippingEnabled &&
			 material.clipShadows === true &&
				material.clippingPlanes.length !== 0 ) {

			// in this case we need a unique material instance reflecting the
			// appropriate state

			var keyA = result.uuid, keyB = material.uuid;

			var materialsForVariant = _materialCache[ keyA ];

			if ( materialsForVariant === undefined ) {

				materialsForVariant = {};
				_materialCache[ keyA ] = materialsForVariant;

			}

			var cachedMaterial = materialsForVariant[ keyB ];

			if ( cachedMaterial === undefined ) {

				cachedMaterial = result.clone();
				materialsForVariant[ keyB ] = cachedMaterial;

			}

			result = cachedMaterial;

		}

		result.visible = material.visible;
		result.wireframe = material.wireframe;

		var side = material.side;

		if ( scope.renderSingleSided && side == DoubleSide ) {

			side = FrontSide;

		}

		if ( scope.renderReverseSided ) {

			if ( side === FrontSide ) side = BackSide;
			else if ( side === BackSide ) side = FrontSide;

		}

		result.side = side;

		result.clipShadows = material.clipShadows;
		result.clippingPlanes = material.clippingPlanes;

		result.wireframeLinewidth = material.wireframeLinewidth;
		result.linewidth = material.linewidth;

		if ( isPointLight && result.uniforms.lightPos !== undefined ) {

			result.uniforms.lightPos.value.copy( lightPositionWorld );

		}

		return result;

	}

	function projectObject( object, camera, shadowCamera ) {

		if ( object.visible === false ) return;

		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

		if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {

			if ( object.castShadow && ( object.frustumCulled === false || _frustum.intersectsObject( object ) === true ) ) {

				var material = object.material;

				if ( material.visible === true ) {

					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
					_renderList.push( object );

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera, shadowCamera );

		}

	}

}

/**
 * @author bhouston / http://clara.io
 */

function Ray( origin, direction ) {

	this.origin = ( origin !== undefined ) ? origin : new Vector3();
	this.direction = ( direction !== undefined ) ? direction : new Vector3();

}

Ray.prototype = {

	constructor: Ray,

	set: function ( origin, direction ) {

		this.origin.copy( origin );
		this.direction.copy( direction );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( ray ) {

		this.origin.copy( ray.origin );
		this.direction.copy( ray.direction );

		return this;

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new Vector3();

		return result.copy( this.direction ).multiplyScalar( t ).add( this.origin );

	},

	lookAt: function ( v ) {

		this.direction.copy( v ).sub( this.origin ).normalize();

		return this;

	},

	recast: function () {

		var v1 = new Vector3();

		return function recast( t ) {

			this.origin.copy( this.at( t, v1 ) );

			return this;

		};

	}(),

	closestPointToPoint: function ( point, optionalTarget ) {

		var result = optionalTarget || new Vector3();
		result.subVectors( point, this.origin );
		var directionDistance = result.dot( this.direction );

		if ( directionDistance < 0 ) {

			return result.copy( this.origin );

		}

		return result.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

	},

	distanceToPoint: function ( point ) {

		return Math.sqrt( this.distanceSqToPoint( point ) );

	},

	distanceSqToPoint: function () {

		var v1 = new Vector3();

		return function distanceSqToPoint( point ) {

			var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );

			// point behind the ray

			if ( directionDistance < 0 ) {

				return this.origin.distanceToSquared( point );

			}

			v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );

			return v1.distanceToSquared( point );

		};

	}(),

	distanceSqToSegment: function () {

		var segCenter = new Vector3();
		var segDir = new Vector3();
		var diff = new Vector3();

		return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
			// It returns the min distance between the ray and the segment
			// defined by v0 and v1
			// It can also set two optional targets :
			// - The closest point on the ray
			// - The closest point on the segment

			segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
			segDir.copy( v1 ).sub( v0 ).normalize();
			diff.copy( this.origin ).sub( segCenter );

			var segExtent = v0.distanceTo( v1 ) * 0.5;
			var a01 = - this.direction.dot( segDir );
			var b0 = diff.dot( this.direction );
			var b1 = - diff.dot( segDir );
			var c = diff.lengthSq();
			var det = Math.abs( 1 - a01 * a01 );
			var s0, s1, sqrDist, extDet;

			if ( det > 0 ) {

				// The ray and segment are not parallel.

				s0 = a01 * b1 - b0;
				s1 = a01 * b0 - b1;
				extDet = segExtent * det;

				if ( s0 >= 0 ) {

					if ( s1 >= - extDet ) {

						if ( s1 <= extDet ) {

							// region 0
							// Minimum at interior points of ray and segment.

							var invDet = 1 / det;
							s0 *= invDet;
							s1 *= invDet;
							sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;

						} else {

							// region 1

							s1 = segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

						}

					} else {

						// region 5

						s1 = - segExtent;
						s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				} else {

					if ( s1 <= - extDet ) {

						// region 4

						s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					} else if ( s1 <= extDet ) {

						// region 3

						s0 = 0;
						s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = s1 * ( s1 + 2 * b1 ) + c;

					} else {

						// region 2

						s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
						s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
						sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

					}

				}

			} else {

				// Ray and segment are parallel.

				s1 = ( a01 > 0 ) ? - segExtent : segExtent;
				s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
				sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;

			}

			if ( optionalPointOnRay ) {

				optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );

			}

			if ( optionalPointOnSegment ) {

				optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );

			}

			return sqrDist;

		};

	}(),

	intersectSphere: function () {

		var v1 = new Vector3();

		return function intersectSphere( sphere, optionalTarget ) {

			v1.subVectors( sphere.center, this.origin );
			var tca = v1.dot( this.direction );
			var d2 = v1.dot( v1 ) - tca * tca;
			var radius2 = sphere.radius * sphere.radius;

			if ( d2 > radius2 ) return null;

			var thc = Math.sqrt( radius2 - d2 );

			// t0 = first intersect point - entrance on front of sphere
			var t0 = tca - thc;

			// t1 = second intersect point - exit point on back of sphere
			var t1 = tca + thc;

			// test to see if both t0 and t1 are behind the ray - if so, return null
			if ( t0 < 0 && t1 < 0 ) return null;

			// test to see if t0 is behind the ray:
			// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
			// in order to always return an intersect point that is in front of the ray.
			if ( t0 < 0 ) return this.at( t1, optionalTarget );

			// else t0 is in front of the ray, so return the first collision point scaled by t0
			return this.at( t0, optionalTarget );

		};

	}(),

	intersectsSphere: function ( sphere ) {

		return this.distanceToPoint( sphere.center ) <= sphere.radius;

	},

	distanceToPlane: function ( plane ) {

		var denominator = plane.normal.dot( this.direction );

		if ( denominator === 0 ) {

			// line is coplanar, return origin
			if ( plane.distanceToPoint( this.origin ) === 0 ) {

				return 0;

			}

			// Null is preferable to undefined since undefined means.... it is undefined

			return null;

		}

		var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;

		// Return if the ray never intersects the plane

		return t >= 0 ? t :  null;

	},

	intersectPlane: function ( plane, optionalTarget ) {

		var t = this.distanceToPlane( plane );

		if ( t === null ) {

			return null;

		}

		return this.at( t, optionalTarget );

	},



	intersectsPlane: function ( plane ) {

		// check if the ray lies on the plane first

		var distToPoint = plane.distanceToPoint( this.origin );

		if ( distToPoint === 0 ) {

			return true;

		}

		var denominator = plane.normal.dot( this.direction );

		if ( denominator * distToPoint < 0 ) {

			return true;

		}

		// ray origin is behind the plane (and is pointing behind it)

		return false;

	},

	intersectBox: function ( box, optionalTarget ) {

		var tmin, tmax, tymin, tymax, tzmin, tzmax;

		var invdirx = 1 / this.direction.x,
			invdiry = 1 / this.direction.y,
			invdirz = 1 / this.direction.z;

		var origin = this.origin;

		if ( invdirx >= 0 ) {

			tmin = ( box.min.x - origin.x ) * invdirx;
			tmax = ( box.max.x - origin.x ) * invdirx;

		} else {

			tmin = ( box.max.x - origin.x ) * invdirx;
			tmax = ( box.min.x - origin.x ) * invdirx;

		}

		if ( invdiry >= 0 ) {

			tymin = ( box.min.y - origin.y ) * invdiry;
			tymax = ( box.max.y - origin.y ) * invdiry;

		} else {

			tymin = ( box.max.y - origin.y ) * invdiry;
			tymax = ( box.min.y - origin.y ) * invdiry;

		}

		if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;

		// These lines also handle the case where tmin or tmax is NaN
		// (result of 0 * Infinity). x !== x returns true if x is NaN

		if ( tymin > tmin || tmin !== tmin ) tmin = tymin;

		if ( tymax < tmax || tmax !== tmax ) tmax = tymax;

		if ( invdirz >= 0 ) {

			tzmin = ( box.min.z - origin.z ) * invdirz;
			tzmax = ( box.max.z - origin.z ) * invdirz;

		} else {

			tzmin = ( box.max.z - origin.z ) * invdirz;
			tzmax = ( box.min.z - origin.z ) * invdirz;

		}

		if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;

		if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;

		if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;

		//return point closest to the ray (positive side)

		if ( tmax < 0 ) return null;

		return this.at( tmin >= 0 ? tmin : tmax, optionalTarget );

	},

	intersectsBox: ( function () {

		var v = new Vector3();

		return function intersectsBox( box ) {

			return this.intersectBox( box, v ) !== null;

		};

	} )(),

	intersectTriangle: function () {

		// Compute the offset origin, edges, and normal.
		var diff = new Vector3();
		var edge1 = new Vector3();
		var edge2 = new Vector3();
		var normal = new Vector3();

		return function intersectTriangle( a, b, c, backfaceCulling, optionalTarget ) {

			// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h

			edge1.subVectors( b, a );
			edge2.subVectors( c, a );
			normal.crossVectors( edge1, edge2 );

			// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
			// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
			//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
			//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
			//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
			var DdN = this.direction.dot( normal );
			var sign;

			if ( DdN > 0 ) {

				if ( backfaceCulling ) return null;
				sign = 1;

			} else if ( DdN < 0 ) {

				sign = - 1;
				DdN = - DdN;

			} else {

				return null;

			}

			diff.subVectors( this.origin, a );
			var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );

			// b1 < 0, no intersection
			if ( DdQxE2 < 0 ) {

				return null;

			}

			var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );

			// b2 < 0, no intersection
			if ( DdE1xQ < 0 ) {

				return null;

			}

			// b1+b2 > 1, no intersection
			if ( DdQxE2 + DdE1xQ > DdN ) {

				return null;

			}

			// Line intersects triangle, check if ray does.
			var QdN = - sign * diff.dot( normal );

			// t < 0, no intersection
			if ( QdN < 0 ) {

				return null;

			}

			// Ray intersects triangle.
			return this.at( QdN / DdN, optionalTarget );

		};

	}(),

	applyMatrix4: function ( matrix4 ) {

		this.direction.add( this.origin ).applyMatrix4( matrix4 );
		this.origin.applyMatrix4( matrix4 );
		this.direction.sub( this.origin );
		this.direction.normalize();

		return this;

	},

	equals: function ( ray ) {

		return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author bhouston / http://clara.io
 */

function Euler( x, y, z, order ) {

	this._x = x || 0;
	this._y = y || 0;
	this._z = z || 0;
	this._order = order || Euler.DefaultOrder;

}

Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];

Euler.DefaultOrder = 'XYZ';

Euler.prototype = {

	constructor: Euler,

	isEuler: true,

	get x () {

		return this._x;

	},

	set x ( value ) {

		this._x = value;
		this.onChangeCallback();

	},

	get y () {

		return this._y;

	},

	set y ( value ) {

		this._y = value;
		this.onChangeCallback();

	},

	get z () {

		return this._z;

	},

	set z ( value ) {

		this._z = value;
		this.onChangeCallback();

	},

	get order () {

		return this._order;

	},

	set order ( value ) {

		this._order = value;
		this.onChangeCallback();

	},

	set: function ( x, y, z, order ) {

		this._x = x;
		this._y = y;
		this._z = z;
		this._order = order || this._order;

		this.onChangeCallback();

		return this;

	},

	clone: function () {

		return new this.constructor( this._x, this._y, this._z, this._order );

	},

	copy: function ( euler ) {

		this._x = euler._x;
		this._y = euler._y;
		this._z = euler._z;
		this._order = euler._order;

		this.onChangeCallback();

		return this;

	},

	setFromRotationMatrix: function ( m, order, update ) {

		var clamp = _Math.clamp;

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		var te = m.elements;
		var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
		var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
		var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];

		order = order || this._order;

		if ( order === 'XYZ' ) {

			this._y = Math.asin( clamp( m13, - 1, 1 ) );

			if ( Math.abs( m13 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m33 );
				this._z = Math.atan2( - m12, m11 );

			} else {

				this._x = Math.atan2( m32, m22 );
				this._z = 0;

			}

		} else if ( order === 'YXZ' ) {

			this._x = Math.asin( - clamp( m23, - 1, 1 ) );

			if ( Math.abs( m23 ) < 0.99999 ) {

				this._y = Math.atan2( m13, m33 );
				this._z = Math.atan2( m21, m22 );

			} else {

				this._y = Math.atan2( - m31, m11 );
				this._z = 0;

			}

		} else if ( order === 'ZXY' ) {

			this._x = Math.asin( clamp( m32, - 1, 1 ) );

			if ( Math.abs( m32 ) < 0.99999 ) {

				this._y = Math.atan2( - m31, m33 );
				this._z = Math.atan2( - m12, m22 );

			} else {

				this._y = 0;
				this._z = Math.atan2( m21, m11 );

			}

		} else if ( order === 'ZYX' ) {

			this._y = Math.asin( - clamp( m31, - 1, 1 ) );

			if ( Math.abs( m31 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m33 );
				this._z = Math.atan2( m21, m11 );

			} else {

				this._x = 0;
				this._z = Math.atan2( - m12, m22 );

			}

		} else if ( order === 'YZX' ) {

			this._z = Math.asin( clamp( m21, - 1, 1 ) );

			if ( Math.abs( m21 ) < 0.99999 ) {

				this._x = Math.atan2( - m23, m22 );
				this._y = Math.atan2( - m31, m11 );

			} else {

				this._x = 0;
				this._y = Math.atan2( m13, m33 );

			}

		} else if ( order === 'XZY' ) {

			this._z = Math.asin( - clamp( m12, - 1, 1 ) );

			if ( Math.abs( m12 ) < 0.99999 ) {

				this._x = Math.atan2( m32, m22 );
				this._y = Math.atan2( m13, m11 );

			} else {

				this._x = Math.atan2( - m23, m33 );
				this._y = 0;

			}

		} else {

			console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );

		}

		this._order = order;

		if ( update !== false ) this.onChangeCallback();

		return this;

	},

	setFromQuaternion: function () {

		var matrix;

		return function setFromQuaternion( q, order, update ) {

			if ( matrix === undefined ) matrix = new Matrix4();

			matrix.makeRotationFromQuaternion( q );

			return this.setFromRotationMatrix( matrix, order, update );

		};

	}(),

	setFromVector3: function ( v, order ) {

		return this.set( v.x, v.y, v.z, order || this._order );

	},

	reorder: function () {

		// WARNING: this discards revolution information -bhouston

		var q = new Quaternion();

		return function reorder( newOrder ) {

			q.setFromEuler( this );

			return this.setFromQuaternion( q, newOrder );

		};

	}(),

	equals: function ( euler ) {

		return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );

	},

	fromArray: function ( array ) {

		this._x = array[ 0 ];
		this._y = array[ 1 ];
		this._z = array[ 2 ];
		if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];

		this.onChangeCallback();

		return this;

	},

	toArray: function ( array, offset ) {

		if ( array === undefined ) array = [];
		if ( offset === undefined ) offset = 0;

		array[ offset ] = this._x;
		array[ offset + 1 ] = this._y;
		array[ offset + 2 ] = this._z;
		array[ offset + 3 ] = this._order;

		return array;

	},

	toVector3: function ( optionalResult ) {

		if ( optionalResult ) {

			return optionalResult.set( this._x, this._y, this._z );

		} else {

			return new Vector3( this._x, this._y, this._z );

		}

	},

	onChange: function ( callback ) {

		this.onChangeCallback = callback;

		return this;

	},

	onChangeCallback: function () {}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Layers() {

	this.mask = 1;

}

Layers.prototype = {

	constructor: Layers,

	set: function ( channel ) {

		this.mask = 1 << channel;

	},

	enable: function ( channel ) {

		this.mask |= 1 << channel;

	},

	toggle: function ( channel ) {

		this.mask ^= 1 << channel;

	},

	disable: function ( channel ) {

		this.mask &= ~ ( 1 << channel );

	},

	test: function ( layers ) {

		return ( this.mask & layers.mask ) !== 0;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author WestLangley / http://github.com/WestLangley
 * @author elephantatwork / www.elephantatwork.ch
 */

var object3DId = 0;

function Object3D() {

	Object.defineProperty( this, 'id', { value: object3DId ++ } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Object3D';

	this.parent = null;
	this.children = [];

	this.up = Object3D.DefaultUp.clone();

	var position = new Vector3();
	var rotation = new Euler();
	var quaternion = new Quaternion();
	var scale = new Vector3( 1, 1, 1 );

	function onRotationChange() {

		quaternion.setFromEuler( rotation, false );

	}

	function onQuaternionChange() {

		rotation.setFromQuaternion( quaternion, undefined, false );

	}

	rotation.onChange( onRotationChange );
	quaternion.onChange( onQuaternionChange );

	Object.defineProperties( this, {
		position: {
			enumerable: true,
			value: position
		},
		rotation: {
			enumerable: true,
			value: rotation
		},
		quaternion: {
			enumerable: true,
			value: quaternion
		},
		scale: {
			enumerable: true,
			value: scale
		},
		modelViewMatrix: {
			value: new Matrix4()
		},
		normalMatrix: {
			value: new Matrix3()
		}
	} );

	this.matrix = new Matrix4();
	this.matrixWorld = new Matrix4();

	this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
	this.matrixWorldNeedsUpdate = false;

	this.layers = new Layers();
	this.visible = true;

	this.castShadow = false;
	this.receiveShadow = false;

	this.frustumCulled = true;
	this.renderOrder = 0;

	this.userData = {};

	this.onBeforeRender = function () {};
	this.onAfterRender = function () {};

}

Object3D.DefaultUp = new Vector3( 0, 1, 0 );
Object3D.DefaultMatrixAutoUpdate = true;

Object.assign( Object3D.prototype, EventDispatcher.prototype, {

	isObject3D: true,

	applyMatrix: function ( matrix ) {

		this.matrix.multiplyMatrices( matrix, this.matrix );

		this.matrix.decompose( this.position, this.quaternion, this.scale );

	},

	setRotationFromAxisAngle: function ( axis, angle ) {

		// assumes axis is normalized

		this.quaternion.setFromAxisAngle( axis, angle );

	},

	setRotationFromEuler: function ( euler ) {

		this.quaternion.setFromEuler( euler, true );

	},

	setRotationFromMatrix: function ( m ) {

		// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)

		this.quaternion.setFromRotationMatrix( m );

	},

	setRotationFromQuaternion: function ( q ) {

		// assumes q is normalized

		this.quaternion.copy( q );

	},

	rotateOnAxis: function () {

		// rotate object on axis in object space
		// axis is assumed to be normalized

		var q1 = new Quaternion();

		return function rotateOnAxis( axis, angle ) {

			q1.setFromAxisAngle( axis, angle );

			this.quaternion.multiply( q1 );

			return this;

		};

	}(),

	rotateX: function () {

		var v1 = new Vector3( 1, 0, 0 );

		return function rotateX( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateY: function () {

		var v1 = new Vector3( 0, 1, 0 );

		return function rotateY( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	rotateZ: function () {

		var v1 = new Vector3( 0, 0, 1 );

		return function rotateZ( angle ) {

			return this.rotateOnAxis( v1, angle );

		};

	}(),

	translateOnAxis: function () {

		// translate object by distance along axis in object space
		// axis is assumed to be normalized

		var v1 = new Vector3();

		return function translateOnAxis( axis, distance ) {

			v1.copy( axis ).applyQuaternion( this.quaternion );

			this.position.add( v1.multiplyScalar( distance ) );

			return this;

		};

	}(),

	translateX: function () {

		var v1 = new Vector3( 1, 0, 0 );

		return function translateX( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateY: function () {

		var v1 = new Vector3( 0, 1, 0 );

		return function translateY( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	translateZ: function () {

		var v1 = new Vector3( 0, 0, 1 );

		return function translateZ( distance ) {

			return this.translateOnAxis( v1, distance );

		};

	}(),

	localToWorld: function ( vector ) {

		return vector.applyMatrix4( this.matrixWorld );

	},

	worldToLocal: function () {

		var m1 = new Matrix4();

		return function worldToLocal( vector ) {

			return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );

		};

	}(),

	lookAt: function () {

		// This routine does not support objects with rotated and/or translated parent(s)

		var m1 = new Matrix4();

		return function lookAt( vector ) {

			m1.lookAt( vector, this.position, this.up );

			this.quaternion.setFromRotationMatrix( m1 );

		};

	}(),

	add: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.add( arguments[ i ] );

			}

			return this;

		}

		if ( object === this ) {

			console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
			return this;

		}

		if ( ( object && object.isObject3D ) ) {

			if ( object.parent !== null ) {

				object.parent.remove( object );

			}

			object.parent = this;
			object.dispatchEvent( { type: 'added' } );

			this.children.push( object );

		} else {

			console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );

		}

		return this;

	},

	remove: function ( object ) {

		if ( arguments.length > 1 ) {

			for ( var i = 0; i < arguments.length; i ++ ) {

				this.remove( arguments[ i ] );

			}

		}

		var index = this.children.indexOf( object );

		if ( index !== - 1 ) {

			object.parent = null;

			object.dispatchEvent( { type: 'removed' } );

			this.children.splice( index, 1 );

		}

	},

	getObjectById: function ( id ) {

		return this.getObjectByProperty( 'id', id );

	},

	getObjectByName: function ( name ) {

		return this.getObjectByProperty( 'name', name );

	},

	getObjectByProperty: function ( name, value ) {

		if ( this[ name ] === value ) return this;

		for ( var i = 0, l = this.children.length; i < l; i ++ ) {

			var child = this.children[ i ];
			var object = child.getObjectByProperty( name, value );

			if ( object !== undefined ) {

				return object;

			}

		}

		return undefined;

	},

	getWorldPosition: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();

		this.updateMatrixWorld( true );

		return result.setFromMatrixPosition( this.matrixWorld );

	},

	getWorldQuaternion: function () {

		var position = new Vector3();
		var scale = new Vector3();

		return function getWorldQuaternion( optionalTarget ) {

			var result = optionalTarget || new Quaternion();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, result, scale );

			return result;

		};

	}(),

	getWorldRotation: function () {

		var quaternion = new Quaternion();

		return function getWorldRotation( optionalTarget ) {

			var result = optionalTarget || new Euler();

			this.getWorldQuaternion( quaternion );

			return result.setFromQuaternion( quaternion, this.rotation.order, false );

		};

	}(),

	getWorldScale: function () {

		var position = new Vector3();
		var quaternion = new Quaternion();

		return function getWorldScale( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			this.updateMatrixWorld( true );

			this.matrixWorld.decompose( position, quaternion, result );

			return result;

		};

	}(),

	getWorldDirection: function () {

		var quaternion = new Quaternion();

		return function getWorldDirection( optionalTarget ) {

			var result = optionalTarget || new Vector3();

			this.getWorldQuaternion( quaternion );

			return result.set( 0, 0, 1 ).applyQuaternion( quaternion );

		};

	}(),

	raycast: function () {},

	traverse: function ( callback ) {

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverse( callback );

		}

	},

	traverseVisible: function ( callback ) {

		if ( this.visible === false ) return;

		callback( this );

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].traverseVisible( callback );

		}

	},

	traverseAncestors: function ( callback ) {

		var parent = this.parent;

		if ( parent !== null ) {

			callback( parent );

			parent.traverseAncestors( callback );

		}

	},

	updateMatrix: function () {

		this.matrix.compose( this.position, this.quaternion, this.scale );

		this.matrixWorldNeedsUpdate = true;

	},

	updateMatrixWorld: function ( force ) {

		if ( this.matrixAutoUpdate === true ) this.updateMatrix();

		if ( this.matrixWorldNeedsUpdate === true || force === true ) {

			if ( this.parent === null ) {

				this.matrixWorld.copy( this.matrix );

			} else {

				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );

			}

			this.matrixWorldNeedsUpdate = false;

			force = true;

		}

		// update children

		var children = this.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			children[ i ].updateMatrixWorld( force );

		}

	},

	toJSON: function ( meta ) {

		// meta is '' when called from JSON.stringify
		var isRootObject = ( meta === undefined || meta === '' );

		var output = {};

		// meta is a hash used to collect geometries, materials.
		// not providing it implies that this is the root object
		// being serialized.
		if ( isRootObject ) {

			// initialize meta obj
			meta = {
				geometries: {},
				materials: {},
				textures: {},
				images: {}
			};

			output.metadata = {
				version: 4.4,
				type: 'Object',
				generator: 'Object3D.toJSON'
			};

		}

		// standard Object3D serialization

		var object = {};

		object.uuid = this.uuid;
		object.type = this.type;

		if ( this.name !== '' ) object.name = this.name;
		if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
		if ( this.castShadow === true ) object.castShadow = true;
		if ( this.receiveShadow === true ) object.receiveShadow = true;
		if ( this.visible === false ) object.visible = false;

		object.matrix = this.matrix.toArray();

		//

		if ( this.geometry !== undefined ) {

			if ( meta.geometries[ this.geometry.uuid ] === undefined ) {

				meta.geometries[ this.geometry.uuid ] = this.geometry.toJSON( meta );

			}

			object.geometry = this.geometry.uuid;

		}

		if ( this.material !== undefined ) {

			if ( meta.materials[ this.material.uuid ] === undefined ) {

				meta.materials[ this.material.uuid ] = this.material.toJSON( meta );

			}

			object.material = this.material.uuid;

		}

		//

		if ( this.children.length > 0 ) {

			object.children = [];

			for ( var i = 0; i < this.children.length; i ++ ) {

				object.children.push( this.children[ i ].toJSON( meta ).object );

			}

		}

		if ( isRootObject ) {

			var geometries = extractFromCache( meta.geometries );
			var materials = extractFromCache( meta.materials );
			var textures = extractFromCache( meta.textures );
			var images = extractFromCache( meta.images );

			if ( geometries.length > 0 ) output.geometries = geometries;
			if ( materials.length > 0 ) output.materials = materials;
			if ( textures.length > 0 ) output.textures = textures;
			if ( images.length > 0 ) output.images = images;

		}

		output.object = object;

		return output;

		// extract data from the cache hash
		// remove metadata on each item
		// and return as array
		function extractFromCache( cache ) {

			var values = [];
			for ( var key in cache ) {

				var data = cache[ key ];
				delete data.metadata;
				values.push( data );

			}
			return values;

		}

	},

	clone: function ( recursive ) {

		return new this.constructor().copy( this, recursive );

	},

	copy: function ( source, recursive ) {

		if ( recursive === undefined ) recursive = true;

		this.name = source.name;

		this.up.copy( source.up );

		this.position.copy( source.position );
		this.quaternion.copy( source.quaternion );
		this.scale.copy( source.scale );

		this.matrix.copy( source.matrix );
		this.matrixWorld.copy( source.matrixWorld );

		this.matrixAutoUpdate = source.matrixAutoUpdate;
		this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;

		this.layers.mask = source.layers.mask;
		this.visible = source.visible;

		this.castShadow = source.castShadow;
		this.receiveShadow = source.receiveShadow;

		this.frustumCulled = source.frustumCulled;
		this.renderOrder = source.renderOrder;

		this.userData = JSON.parse( JSON.stringify( source.userData ) );

		if ( recursive === true ) {

			for ( var i = 0; i < source.children.length; i ++ ) {

				var child = source.children[ i ];
				this.add( child.clone() );

			}

		}

		return this;

	}

} );

/**
 * @author bhouston / http://clara.io
 */

function Line3( start, end ) {

	this.start = ( start !== undefined ) ? start : new Vector3();
	this.end = ( end !== undefined ) ? end : new Vector3();

}

Line3.prototype = {

	constructor: Line3,

	set: function ( start, end ) {

		this.start.copy( start );
		this.end.copy( end );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( line ) {

		this.start.copy( line.start );
		this.end.copy( line.end );

		return this;

	},

	getCenter: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.addVectors( this.start, this.end ).multiplyScalar( 0.5 );

	},

	delta: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.subVectors( this.end, this.start );

	},

	distanceSq: function () {

		return this.start.distanceToSquared( this.end );

	},

	distance: function () {

		return this.start.distanceTo( this.end );

	},

	at: function ( t, optionalTarget ) {

		var result = optionalTarget || new Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	closestPointToPointParameter: function () {

		var startP = new Vector3();
		var startEnd = new Vector3();

		return function closestPointToPointParameter( point, clampToLine ) {

			startP.subVectors( point, this.start );
			startEnd.subVectors( this.end, this.start );

			var startEnd2 = startEnd.dot( startEnd );
			var startEnd_startP = startEnd.dot( startP );

			var t = startEnd_startP / startEnd2;

			if ( clampToLine ) {

				t = _Math.clamp( t, 0, 1 );

			}

			return t;

		};

	}(),

	closestPointToPoint: function ( point, clampToLine, optionalTarget ) {

		var t = this.closestPointToPointParameter( point, clampToLine );

		var result = optionalTarget || new Vector3();

		return this.delta( result ).multiplyScalar( t ).add( this.start );

	},

	applyMatrix4: function ( matrix ) {

		this.start.applyMatrix4( matrix );
		this.end.applyMatrix4( matrix );

		return this;

	},

	equals: function ( line ) {

		return line.start.equals( this.start ) && line.end.equals( this.end );

	}

};

/**
 * @author bhouston / http://clara.io
 * @author mrdoob / http://mrdoob.com/
 */

function Triangle( a, b, c ) {

	this.a = ( a !== undefined ) ? a : new Vector3();
	this.b = ( b !== undefined ) ? b : new Vector3();
	this.c = ( c !== undefined ) ? c : new Vector3();

}

Triangle.normal = function () {

	var v0 = new Vector3();

	return function normal( a, b, c, optionalTarget ) {

		var result = optionalTarget || new Vector3();

		result.subVectors( c, b );
		v0.subVectors( a, b );
		result.cross( v0 );

		var resultLengthSq = result.lengthSq();
		if ( resultLengthSq > 0 ) {

			return result.multiplyScalar( 1 / Math.sqrt( resultLengthSq ) );

		}

		return result.set( 0, 0, 0 );

	};

}();

// static/instance method to calculate barycentric coordinates
// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
Triangle.barycoordFromPoint = function () {

	var v0 = new Vector3();
	var v1 = new Vector3();
	var v2 = new Vector3();

	return function barycoordFromPoint( point, a, b, c, optionalTarget ) {

		v0.subVectors( c, a );
		v1.subVectors( b, a );
		v2.subVectors( point, a );

		var dot00 = v0.dot( v0 );
		var dot01 = v0.dot( v1 );
		var dot02 = v0.dot( v2 );
		var dot11 = v1.dot( v1 );
		var dot12 = v1.dot( v2 );

		var denom = ( dot00 * dot11 - dot01 * dot01 );

		var result = optionalTarget || new Vector3();

		// collinear or singular triangle
		if ( denom === 0 ) {

			// arbitrary location outside of triangle?
			// not sure if this is the best idea, maybe should be returning undefined
			return result.set( - 2, - 1, - 1 );

		}

		var invDenom = 1 / denom;
		var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
		var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;

		// barycentric coordinates must always sum to 1
		return result.set( 1 - u - v, v, u );

	};

}();

Triangle.containsPoint = function () {

	var v1 = new Vector3();

	return function containsPoint( point, a, b, c ) {

		var result = Triangle.barycoordFromPoint( point, a, b, c, v1 );

		return ( result.x >= 0 ) && ( result.y >= 0 ) && ( ( result.x + result.y ) <= 1 );

	};

}();

Triangle.prototype = {

	constructor: Triangle,

	set: function ( a, b, c ) {

		this.a.copy( a );
		this.b.copy( b );
		this.c.copy( c );

		return this;

	},

	setFromPointsAndIndices: function ( points, i0, i1, i2 ) {

		this.a.copy( points[ i0 ] );
		this.b.copy( points[ i1 ] );
		this.c.copy( points[ i2 ] );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( triangle ) {

		this.a.copy( triangle.a );
		this.b.copy( triangle.b );
		this.c.copy( triangle.c );

		return this;

	},

	area: function () {

		var v0 = new Vector3();
		var v1 = new Vector3();

		return function area() {

			v0.subVectors( this.c, this.b );
			v1.subVectors( this.a, this.b );

			return v0.cross( v1 ).length() * 0.5;

		};

	}(),

	midpoint: function ( optionalTarget ) {

		var result = optionalTarget || new Vector3();
		return result.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );

	},

	normal: function ( optionalTarget ) {

		return Triangle.normal( this.a, this.b, this.c, optionalTarget );

	},

	plane: function ( optionalTarget ) {

		var result = optionalTarget || new Plane();

		return result.setFromCoplanarPoints( this.a, this.b, this.c );

	},

	barycoordFromPoint: function ( point, optionalTarget ) {

		return Triangle.barycoordFromPoint( point, this.a, this.b, this.c, optionalTarget );

	},

	containsPoint: function ( point ) {

		return Triangle.containsPoint( point, this.a, this.b, this.c );

	},

	closestPointToPoint: function () {

		var plane, edgeList, projectedPoint, closestPoint;

		return function closestPointToPoint( point, optionalTarget ) {

			if ( plane === undefined ) {

				plane = new Plane();
				edgeList = [ new Line3(), new Line3(), new Line3() ];
				projectedPoint = new Vector3();
				closestPoint = new Vector3();

			}

			var result = optionalTarget || new Vector3();
			var minDistance = Infinity;

			// project the point onto the plane of the triangle

			plane.setFromCoplanarPoints( this.a, this.b, this.c );
			plane.projectPoint( point, projectedPoint );

			// check if the projection lies within the triangle

			if( this.containsPoint( projectedPoint ) === true ) {

				// if so, this is the closest point

				result.copy( projectedPoint );

			} else {

				// if not, the point falls outside the triangle. the result is the closest point to the triangle's edges or vertices

				edgeList[ 0 ].set( this.a, this.b );
				edgeList[ 1 ].set( this.b, this.c );
				edgeList[ 2 ].set( this.c, this.a );

				for( var i = 0; i < edgeList.length; i ++ ) {

					edgeList[ i ].closestPointToPoint( projectedPoint, true, closestPoint );

					var distance = projectedPoint.distanceToSquared( closestPoint );

					if( distance < minDistance ) {

						minDistance = distance;

						result.copy( closestPoint );

					}

				}

			}

			return result;

		};

	}(),

	equals: function ( triangle ) {

		return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Face3( a, b, c, normal, color, materialIndex ) {

	this.a = a;
	this.b = b;
	this.c = c;

	this.normal = (normal && normal.isVector3) ? normal : new Vector3();
	this.vertexNormals = Array.isArray( normal ) ? normal : [];

	this.color = (color && color.isColor) ? color : new Color();
	this.vertexColors = Array.isArray( color ) ? color : [];

	this.materialIndex = materialIndex !== undefined ? materialIndex : 0;

}

Face3.prototype = {

	constructor: Face3,

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( source ) {

		this.a = source.a;
		this.b = source.b;
		this.c = source.c;

		this.normal.copy( source.normal );
		this.color.copy( source.color );

		this.materialIndex = source.materialIndex;

		for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {

			this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();

		}

		for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {

			this.vertexColors[ i ] = source.vertexColors[ i ].clone();

		}

		return this;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  shading: THREE.SmoothShading,
 *  depthTest: <bool>,
 *  depthWrite: <bool>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>
 * }
 */

function MeshBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshBasicMaterial';

	this.color = new Color( 0xffffff ); // emissive

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;

	this.lights = false;

	this.setValues( parameters );

}

MeshBasicMaterial.prototype = Object.create( Material.prototype );
MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;

MeshBasicMaterial.prototype.isMeshBasicMaterial = true;

MeshBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferAttribute( array, itemSize, normalized ) {

	if ( Array.isArray( array ) ) {

		throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

	}

	this.uuid = _Math.generateUUID();

	this.array = array;
	this.itemSize = itemSize;
	this.count = array !== undefined ? array.length / itemSize : 0;
	this.normalized = normalized === true;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.onUploadCallback = function () {};

	this.version = 0;

}

BufferAttribute.prototype = {

	constructor: BufferAttribute,

	isBufferAttribute: true,

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setArray: function ( array ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.count = array !== undefined ? array.length / this.itemSize : 0;
		this.array = array;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.itemSize = source.itemSize;
		this.count = source.count;
		this.normalized = source.normalized;

		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.itemSize;
		index2 *= attribute.itemSize;

		for ( var i = 0, l = this.itemSize; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	copyArray: function ( array ) {

		this.array.set( array );

		return this;

	},

	copyColorsArray: function ( colors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = colors.length; i < l; i ++ ) {

			var color = colors[ i ];

			if ( color === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
				color = new Color();

			}

			array[ offset ++ ] = color.r;
			array[ offset ++ ] = color.g;
			array[ offset ++ ] = color.b;

		}

		return this;

	},

	copyIndicesArray: function ( indices ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = indices.length; i < l; i ++ ) {

			var index = indices[ i ];

			array[ offset ++ ] = index.a;
			array[ offset ++ ] = index.b;
			array[ offset ++ ] = index.c;

		}

		return this;

	},

	copyVector2sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
				vector = new Vector2();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;

		}

		return this;

	},

	copyVector3sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
				vector = new Vector3();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;

		}

		return this;

	},

	copyVector4sArray: function ( vectors ) {

		var array = this.array, offset = 0;

		for ( var i = 0, l = vectors.length; i < l; i ++ ) {

			var vector = vectors[ i ];

			if ( vector === undefined ) {

				console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
				vector = new Vector4();

			}

			array[ offset ++ ] = vector.x;
			array[ offset ++ ] = vector.y;
			array[ offset ++ ] = vector.z;
			array[ offset ++ ] = vector.w;

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	getX: function ( index ) {

		return this.array[ index * this.itemSize ];

	},

	setX: function ( index, x ) {

		this.array[ index * this.itemSize ] = x;

		return this;

	},

	getY: function ( index ) {

		return this.array[ index * this.itemSize + 1 ];

	},

	setY: function ( index, y ) {

		this.array[ index * this.itemSize + 1 ] = y;

		return this;

	},

	getZ: function ( index ) {

		return this.array[ index * this.itemSize + 2 ];

	},

	setZ: function ( index, z ) {

		this.array[ index * this.itemSize + 2 ] = z;

		return this;

	},

	getW: function ( index ) {

		return this.array[ index * this.itemSize + 3 ];

	},

	setW: function ( index, w ) {

		this.array[ index * this.itemSize + 3 ] = w;

		return this;

	},

	setXY: function ( index, x, y ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index *= this.itemSize;

		this.array[ index + 0 ] = x;
		this.array[ index + 1 ] = y;
		this.array[ index + 2 ] = z;
		this.array[ index + 3 ] = w;

		return this;

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	}

};

//

function Int8BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Int8Array( array ), itemSize );

}

Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;


function Uint8BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint8Array( array ), itemSize );

}

Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;


function Uint8ClampedBufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize );

}

Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;


function Int16BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Int16Array( array ), itemSize );

}

Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;


function Uint16BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint16Array( array ), itemSize );

}

Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;


function Int32BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Int32Array( array ), itemSize );

}

Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;


function Uint32BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Uint32Array( array ), itemSize );

}

Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;


function Float32BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Float32Array( array ), itemSize );

}

Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;


function Float64BufferAttribute( array, itemSize ) {

	BufferAttribute.call( this, new Float64Array( array ), itemSize );

}

Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectGeometry() {

	this.indices = [];
	this.vertices = [];
	this.normals = [];
	this.colors = [];
	this.uvs = [];
	this.uvs2 = [];

	this.groups = [];

	this.morphTargets = {};

	this.skinWeights = [];
	this.skinIndices = [];

	// this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.verticesNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Object.assign( DirectGeometry.prototype, {

	computeGroups: function ( geometry ) {

		var group;
		var groups = [];
		var materialIndex = undefined;

		var faces = geometry.faces;

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			// materials

			if ( face.materialIndex !== materialIndex ) {

				materialIndex = face.materialIndex;

				if ( group !== undefined ) {

					group.count = ( i * 3 ) - group.start;
					groups.push( group );

				}

				group = {
					start: i * 3,
					materialIndex: materialIndex
				};

			}

		}

		if ( group !== undefined ) {

			group.count = ( i * 3 ) - group.start;
			groups.push( group );

		}

		this.groups = groups;

	},

	fromGeometry: function ( geometry ) {

		var faces = geometry.faces;
		var vertices = geometry.vertices;
		var faceVertexUvs = geometry.faceVertexUvs;

		var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
		var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;

		// morphs

		var morphTargets = geometry.morphTargets;
		var morphTargetsLength = morphTargets.length;

		var morphTargetsPosition;

		if ( morphTargetsLength > 0 ) {

			morphTargetsPosition = [];

			for ( var i = 0; i < morphTargetsLength; i ++ ) {

				morphTargetsPosition[ i ] = [];

			}

			this.morphTargets.position = morphTargetsPosition;

		}

		var morphNormals = geometry.morphNormals;
		var morphNormalsLength = morphNormals.length;

		var morphTargetsNormal;

		if ( morphNormalsLength > 0 ) {

			morphTargetsNormal = [];

			for ( var i = 0; i < morphNormalsLength; i ++ ) {

				morphTargetsNormal[ i ] = [];

			}

			this.morphTargets.normal = morphTargetsNormal;

		}

		// skins

		var skinIndices = geometry.skinIndices;
		var skinWeights = geometry.skinWeights;

		var hasSkinIndices = skinIndices.length === vertices.length;
		var hasSkinWeights = skinWeights.length === vertices.length;

		//

		for ( var i = 0; i < faces.length; i ++ ) {

			var face = faces[ i ];

			this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );

			} else {

				var normal = face.normal;

				this.normals.push( normal, normal, normal );

			}

			var vertexColors = face.vertexColors;

			if ( vertexColors.length === 3 ) {

				this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );

			} else {

				var color = face.color;

				this.colors.push( color, color, color );

			}

			if ( hasFaceVertexUv === true ) {

				var vertexUvs = faceVertexUvs[ 0 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );

					this.uvs.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			if ( hasFaceVertexUv2 === true ) {

				var vertexUvs = faceVertexUvs[ 1 ][ i ];

				if ( vertexUvs !== undefined ) {

					this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );

				} else {

					console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );

					this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );

				}

			}

			// morphs

			for ( var j = 0; j < morphTargetsLength; j ++ ) {

				var morphTarget = morphTargets[ j ].vertices;

				morphTargetsPosition[ j ].push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );

			}

			for ( var j = 0; j < morphNormalsLength; j ++ ) {

				var morphNormal = morphNormals[ j ].vertexNormals[ i ];

				morphTargetsNormal[ j ].push( morphNormal.a, morphNormal.b, morphNormal.c );

			}

			// skins

			if ( hasSkinIndices ) {

				this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );

			}

			if ( hasSkinWeights ) {

				this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );

			}

		}

		this.computeGroups( geometry );

		this.verticesNeedUpdate = geometry.verticesNeedUpdate;
		this.normalsNeedUpdate = geometry.normalsNeedUpdate;
		this.colorsNeedUpdate = geometry.colorsNeedUpdate;
		this.uvsNeedUpdate = geometry.uvsNeedUpdate;
		this.groupsNeedUpdate = geometry.groupsNeedUpdate;

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author kile / http://kile.stravaganza.org/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author bhouston / http://clara.io
 */

function Geometry() {

	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'Geometry';

	this.vertices = [];
	this.colors = [];
	this.faces = [];
	this.faceVertexUvs = [ [] ];

	this.morphTargets = [];
	this.morphNormals = [];

	this.skinWeights = [];
	this.skinIndices = [];

	this.lineDistances = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	// update flags

	this.elementsNeedUpdate = false;
	this.verticesNeedUpdate = false;
	this.uvsNeedUpdate = false;
	this.normalsNeedUpdate = false;
	this.colorsNeedUpdate = false;
	this.lineDistancesNeedUpdate = false;
	this.groupsNeedUpdate = false;

}

Object.assign( Geometry.prototype, EventDispatcher.prototype, {

	isGeometry: true,

	applyMatrix: function ( matrix ) {

		var normalMatrix = new Matrix3().getNormalMatrix( matrix );

		for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {

			var vertex = this.vertices[ i ];
			vertex.applyMatrix4( matrix );

		}

		for ( var i = 0, il = this.faces.length; i < il; i ++ ) {

			var face = this.faces[ i ];
			face.normal.applyMatrix3( normalMatrix ).normalize();

			for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

				face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();

			}

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		this.verticesNeedUpdate = true;
		this.normalsNeedUpdate = true;

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	fromBufferGeometry: function ( geometry ) {

		var scope = this;

		var indices = geometry.index !== null ? geometry.index.array : undefined;
		var attributes = geometry.attributes;

		var positions = attributes.position.array;
		var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
		var colors = attributes.color !== undefined ? attributes.color.array : undefined;
		var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
		var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;

		if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];

		var tempNormals = [];
		var tempUVs = [];
		var tempUVs2 = [];

		for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {

			scope.vertices.push( new Vector3( positions[ i ], positions[ i + 1 ], positions[ i + 2 ] ) );

			if ( normals !== undefined ) {

				tempNormals.push( new Vector3( normals[ i ], normals[ i + 1 ], normals[ i + 2 ] ) );

			}

			if ( colors !== undefined ) {

				scope.colors.push( new Color( colors[ i ], colors[ i + 1 ], colors[ i + 2 ] ) );

			}

			if ( uvs !== undefined ) {

				tempUVs.push( new Vector2( uvs[ j ], uvs[ j + 1 ] ) );

			}

			if ( uvs2 !== undefined ) {

				tempUVs2.push( new Vector2( uvs2[ j ], uvs2[ j + 1 ] ) );

			}

		}

		function addFace( a, b, c, materialIndex ) {

			var vertexNormals = normals !== undefined ? [ tempNormals[ a ].clone(), tempNormals[ b ].clone(), tempNormals[ c ].clone() ] : [];
			var vertexColors = colors !== undefined ? [ scope.colors[ a ].clone(), scope.colors[ b ].clone(), scope.colors[ c ].clone() ] : [];

			var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );

			scope.faces.push( face );

			if ( uvs !== undefined ) {

				scope.faceVertexUvs[ 0 ].push( [ tempUVs[ a ].clone(), tempUVs[ b ].clone(), tempUVs[ c ].clone() ] );

			}

			if ( uvs2 !== undefined ) {

				scope.faceVertexUvs[ 1 ].push( [ tempUVs2[ a ].clone(), tempUVs2[ b ].clone(), tempUVs2[ c ].clone() ] );

			}

		}

		if ( indices !== undefined ) {

			var groups = geometry.groups;

			if ( groups.length > 0 ) {

				for ( var i = 0; i < groups.length; i ++ ) {

					var group = groups[ i ];

					var start = group.start;
					var count = group.count;

					for ( var j = start, jl = start + count; j < jl; j += 3 ) {

						addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex  );

					}

				}

			} else {

				for ( var i = 0; i < indices.length; i += 3 ) {

					addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );

				}

			}

		} else {

			for ( var i = 0; i < positions.length / 3; i += 3 ) {

				addFace( i, i + 1, i + 2 );

			}

		}

		this.computeFaceNormals();

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		return this;

	},

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.getCenter().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	normalize: function () {

		this.computeBoundingSphere();

		var center = this.boundingSphere.center;
		var radius = this.boundingSphere.radius;

		var s = radius === 0 ? 1 : 1.0 / radius;

		var matrix = new Matrix4();
		matrix.set(
			s, 0, 0, - s * center.x,
			0, s, 0, - s * center.y,
			0, 0, s, - s * center.z,
			0, 0, 0, 1
		);

		this.applyMatrix( matrix );

		return this;

	},

	computeFaceNormals: function () {

		var cb = new Vector3(), ab = new Vector3();

		for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {

			var face = this.faces[ f ];

			var vA = this.vertices[ face.a ];
			var vB = this.vertices[ face.b ];
			var vC = this.vertices[ face.c ];

			cb.subVectors( vC, vB );
			ab.subVectors( vA, vB );
			cb.cross( ab );

			cb.normalize();

			face.normal.copy( cb );

		}

	},

	computeVertexNormals: function ( areaWeighted ) {

		if ( areaWeighted === undefined ) areaWeighted = true;

		var v, vl, f, fl, face, vertices;

		vertices = new Array( this.vertices.length );

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ] = new Vector3();

		}

		if ( areaWeighted ) {

			// vertex normals weighted by triangle areas
			// http://www.iquilezles.org/www/articles/normals/normals.htm

			var vA, vB, vC;
			var cb = new Vector3(), ab = new Vector3();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vA = this.vertices[ face.a ];
				vB = this.vertices[ face.b ];
				vC = this.vertices[ face.c ];

				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );

				vertices[ face.a ].add( cb );
				vertices[ face.b ].add( cb );
				vertices[ face.c ].add( cb );

			}

		} else {

			this.computeFaceNormals();

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				vertices[ face.a ].add( face.normal );
				vertices[ face.b ].add( face.normal );
				vertices[ face.c ].add( face.normal );

			}

		}

		for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {

			vertices[ v ].normalize();

		}

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( vertices[ face.a ] );
				vertexNormals[ 1 ].copy( vertices[ face.b ] );
				vertexNormals[ 2 ].copy( vertices[ face.c ] );

			} else {

				vertexNormals[ 0 ] = vertices[ face.a ].clone();
				vertexNormals[ 1 ] = vertices[ face.b ].clone();
				vertexNormals[ 2 ] = vertices[ face.c ].clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeFlatVertexNormals: function () {

		var f, fl, face;

		this.computeFaceNormals();

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			var vertexNormals = face.vertexNormals;

			if ( vertexNormals.length === 3 ) {

				vertexNormals[ 0 ].copy( face.normal );
				vertexNormals[ 1 ].copy( face.normal );
				vertexNormals[ 2 ].copy( face.normal );

			} else {

				vertexNormals[ 0 ] = face.normal.clone();
				vertexNormals[ 1 ] = face.normal.clone();
				vertexNormals[ 2 ] = face.normal.clone();

			}

		}

		if ( this.faces.length > 0 ) {

			this.normalsNeedUpdate = true;

		}

	},

	computeMorphNormals: function () {

		var i, il, f, fl, face;

		// save original normals
		// - create temp variables on first access
		//   otherwise just copy (for faster repeated calls)

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			if ( ! face.__originalFaceNormal ) {

				face.__originalFaceNormal = face.normal.clone();

			} else {

				face.__originalFaceNormal.copy( face.normal );

			}

			if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];

			for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {

				if ( ! face.__originalVertexNormals[ i ] ) {

					face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();

				} else {

					face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );

				}

			}

		}

		// use temp geometry to compute face and vertex normals for each morph

		var tmpGeo = new Geometry();
		tmpGeo.faces = this.faces;

		for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {

			// create on first access

			if ( ! this.morphNormals[ i ] ) {

				this.morphNormals[ i ] = {};
				this.morphNormals[ i ].faceNormals = [];
				this.morphNormals[ i ].vertexNormals = [];

				var dstNormalsFace = this.morphNormals[ i ].faceNormals;
				var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;

				var faceNormal, vertexNormals;

				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

					faceNormal = new Vector3();
					vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };

					dstNormalsFace.push( faceNormal );
					dstNormalsVertex.push( vertexNormals );

				}

			}

			var morphNormals = this.morphNormals[ i ];

			// set vertices to morph target

			tmpGeo.vertices = this.morphTargets[ i ].vertices;

			// compute morph normals

			tmpGeo.computeFaceNormals();
			tmpGeo.computeVertexNormals();

			// store morph normals

			var faceNormal, vertexNormals;

			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

				face = this.faces[ f ];

				faceNormal = morphNormals.faceNormals[ f ];
				vertexNormals = morphNormals.vertexNormals[ f ];

				faceNormal.copy( face.normal );

				vertexNormals.a.copy( face.vertexNormals[ 0 ] );
				vertexNormals.b.copy( face.vertexNormals[ 1 ] );
				vertexNormals.c.copy( face.vertexNormals[ 2 ] );

			}

		}

		// restore original normals

		for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {

			face = this.faces[ f ];

			face.normal = face.__originalFaceNormal;
			face.vertexNormals = face.__originalVertexNormals;

		}

	},

	computeLineDistances: function () {

		var d = 0;
		var vertices = this.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			if ( i > 0 ) {

				d += vertices[ i ].distanceTo( vertices[ i - 1 ] );

			}

			this.lineDistances[ i ] = d;

		}

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		this.boundingBox.setFromPoints( this.vertices );

	},

	computeBoundingSphere: function () {

		if ( this.boundingSphere === null ) {

			this.boundingSphere = new Sphere();

		}

		this.boundingSphere.setFromPoints( this.vertices );

	},

	merge: function ( geometry, matrix, materialIndexOffset ) {

		if ( (geometry && geometry.isGeometry) === false ) {

			console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
			return;

		}

		var normalMatrix,
		vertexOffset = this.vertices.length,
		vertices1 = this.vertices,
		vertices2 = geometry.vertices,
		faces1 = this.faces,
		faces2 = geometry.faces,
		uvs1 = this.faceVertexUvs[ 0 ],
		uvs2 = geometry.faceVertexUvs[ 0 ],
		colors1 = this.colors,
		colors2 = geometry.colors;

		if ( materialIndexOffset === undefined ) materialIndexOffset = 0;

		if ( matrix !== undefined ) {

			normalMatrix = new Matrix3().getNormalMatrix( matrix );

		}

		// vertices

		for ( var i = 0, il = vertices2.length; i < il; i ++ ) {

			var vertex = vertices2[ i ];

			var vertexCopy = vertex.clone();

			if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );

			vertices1.push( vertexCopy );

		}

		// colors

		for ( var i = 0, il = colors2.length; i < il; i ++ ) {

			colors1.push( colors2[ i ].clone() );

		}

		// faces

		for ( i = 0, il = faces2.length; i < il; i ++ ) {

			var face = faces2[ i ], faceCopy, normal, color,
			faceVertexNormals = face.vertexNormals,
			faceVertexColors = face.vertexColors;

			faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
			faceCopy.normal.copy( face.normal );

			if ( normalMatrix !== undefined ) {

				faceCopy.normal.applyMatrix3( normalMatrix ).normalize();

			}

			for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {

				normal = faceVertexNormals[ j ].clone();

				if ( normalMatrix !== undefined ) {

					normal.applyMatrix3( normalMatrix ).normalize();

				}

				faceCopy.vertexNormals.push( normal );

			}

			faceCopy.color.copy( face.color );

			for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {

				color = faceVertexColors[ j ];
				faceCopy.vertexColors.push( color.clone() );

			}

			faceCopy.materialIndex = face.materialIndex + materialIndexOffset;

			faces1.push( faceCopy );

		}

		// uvs

		for ( i = 0, il = uvs2.length; i < il; i ++ ) {

			var uv = uvs2[ i ], uvCopy = [];

			if ( uv === undefined ) {

				continue;

			}

			for ( var j = 0, jl = uv.length; j < jl; j ++ ) {

				uvCopy.push( uv[ j ].clone() );

			}

			uvs1.push( uvCopy );

		}

	},

	mergeMesh: function ( mesh ) {

		if ( (mesh && mesh.isMesh) === false ) {

			console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
			return;

		}

		mesh.matrixAutoUpdate && mesh.updateMatrix();

		this.merge( mesh.geometry, mesh.matrix );

	},

	/*
	 * Checks for duplicate vertices with hashmap.
	 * Duplicated vertices are removed
	 * and faces' vertices are updated.
	 */

	mergeVertices: function () {

		var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
		var unique = [], changes = [];

		var v, key;
		var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
		var precision = Math.pow( 10, precisionPoints );
		var i, il, face;
		var indices, j, jl;

		for ( i = 0, il = this.vertices.length; i < il; i ++ ) {

			v = this.vertices[ i ];
			key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );

			if ( verticesMap[ key ] === undefined ) {

				verticesMap[ key ] = i;
				unique.push( this.vertices[ i ] );
				changes[ i ] = unique.length - 1;

			} else {

				//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
				changes[ i ] = changes[ verticesMap[ key ] ];

			}

		}


		// if faces are completely degenerate after merging vertices, we
		// have to remove them from the geometry.
		var faceIndicesToRemove = [];

		for ( i = 0, il = this.faces.length; i < il; i ++ ) {

			face = this.faces[ i ];

			face.a = changes[ face.a ];
			face.b = changes[ face.b ];
			face.c = changes[ face.c ];

			indices = [ face.a, face.b, face.c ];

			var dupIndex = - 1;

			// if any duplicate vertices are found in a Face3
			// we have to remove the face as nothing can be saved
			for ( var n = 0; n < 3; n ++ ) {

				if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {

					dupIndex = n;
					faceIndicesToRemove.push( i );
					break;

				}

			}

		}

		for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {

			var idx = faceIndicesToRemove[ i ];

			this.faces.splice( idx, 1 );

			for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {

				this.faceVertexUvs[ j ].splice( idx, 1 );

			}

		}

		// Use unique set of vertices

		var diff = this.vertices.length - unique.length;
		this.vertices = unique;
		return diff;

	},

	sortFacesByMaterialIndex: function () {

		var faces = this.faces;
		var length = faces.length;

		// tag faces

		for ( var i = 0; i < length; i ++ ) {

			faces[ i ]._id = i;

		}

		// sort faces

		function materialIndexSort( a, b ) {

			return a.materialIndex - b.materialIndex;

		}

		faces.sort( materialIndexSort );

		// sort uvs

		var uvs1 = this.faceVertexUvs[ 0 ];
		var uvs2 = this.faceVertexUvs[ 1 ];

		var newUvs1, newUvs2;

		if ( uvs1 && uvs1.length === length ) newUvs1 = [];
		if ( uvs2 && uvs2.length === length ) newUvs2 = [];

		for ( var i = 0; i < length; i ++ ) {

			var id = faces[ i ]._id;

			if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
			if ( newUvs2 ) newUvs2.push( uvs2[ id ] );

		}

		if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
		if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'Geometry',
				generator: 'Geometry.toJSON'
			}
		};

		// standard Geometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		var vertices = [];

		for ( var i = 0; i < this.vertices.length; i ++ ) {

			var vertex = this.vertices[ i ];
			vertices.push( vertex.x, vertex.y, vertex.z );

		}

		var faces = [];
		var normals = [];
		var normalsHash = {};
		var colors = [];
		var colorsHash = {};
		var uvs = [];
		var uvsHash = {};

		for ( var i = 0; i < this.faces.length; i ++ ) {

			var face = this.faces[ i ];

			var hasMaterial = true;
			var hasFaceUv = false; // deprecated
			var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
			var hasFaceNormal = face.normal.length() > 0;
			var hasFaceVertexNormal = face.vertexNormals.length > 0;
			var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
			var hasFaceVertexColor = face.vertexColors.length > 0;

			var faceType = 0;

			faceType = setBit( faceType, 0, 0 ); // isQuad
			faceType = setBit( faceType, 1, hasMaterial );
			faceType = setBit( faceType, 2, hasFaceUv );
			faceType = setBit( faceType, 3, hasFaceVertexUv );
			faceType = setBit( faceType, 4, hasFaceNormal );
			faceType = setBit( faceType, 5, hasFaceVertexNormal );
			faceType = setBit( faceType, 6, hasFaceColor );
			faceType = setBit( faceType, 7, hasFaceVertexColor );

			faces.push( faceType );
			faces.push( face.a, face.b, face.c );
			faces.push( face.materialIndex );

			if ( hasFaceVertexUv ) {

				var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];

				faces.push(
					getUvIndex( faceVertexUvs[ 0 ] ),
					getUvIndex( faceVertexUvs[ 1 ] ),
					getUvIndex( faceVertexUvs[ 2 ] )
				);

			}

			if ( hasFaceNormal ) {

				faces.push( getNormalIndex( face.normal ) );

			}

			if ( hasFaceVertexNormal ) {

				var vertexNormals = face.vertexNormals;

				faces.push(
					getNormalIndex( vertexNormals[ 0 ] ),
					getNormalIndex( vertexNormals[ 1 ] ),
					getNormalIndex( vertexNormals[ 2 ] )
				);

			}

			if ( hasFaceColor ) {

				faces.push( getColorIndex( face.color ) );

			}

			if ( hasFaceVertexColor ) {

				var vertexColors = face.vertexColors;

				faces.push(
					getColorIndex( vertexColors[ 0 ] ),
					getColorIndex( vertexColors[ 1 ] ),
					getColorIndex( vertexColors[ 2 ] )
				);

			}

		}

		function setBit( value, position, enabled ) {

			return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );

		}

		function getNormalIndex( normal ) {

			var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();

			if ( normalsHash[ hash ] !== undefined ) {

				return normalsHash[ hash ];

			}

			normalsHash[ hash ] = normals.length / 3;
			normals.push( normal.x, normal.y, normal.z );

			return normalsHash[ hash ];

		}

		function getColorIndex( color ) {

			var hash = color.r.toString() + color.g.toString() + color.b.toString();

			if ( colorsHash[ hash ] !== undefined ) {

				return colorsHash[ hash ];

			}

			colorsHash[ hash ] = colors.length;
			colors.push( color.getHex() );

			return colorsHash[ hash ];

		}

		function getUvIndex( uv ) {

			var hash = uv.x.toString() + uv.y.toString();

			if ( uvsHash[ hash ] !== undefined ) {

				return uvsHash[ hash ];

			}

			uvsHash[ hash ] = uvs.length / 2;
			uvs.push( uv.x, uv.y );

			return uvsHash[ hash ];

		}

		data.data = {};

		data.data.vertices = vertices;
		data.data.normals = normals;
		if ( colors.length > 0 ) data.data.colors = colors;
		if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
		data.data.faces = faces;

		return data;

	},

	clone: function () {

		/*
		// Handle primitives

		var parameters = this.parameters;

		if ( parameters !== undefined ) {

			var values = [];

			for ( var key in parameters ) {

				values.push( parameters[ key ] );

			}

			var geometry = Object.create( this.constructor.prototype );
			this.constructor.apply( geometry, values );
			return geometry;

		}

		return new this.constructor().copy( this );
		*/

		return new Geometry().copy( this );

	},

	copy: function ( source ) {

		this.vertices = [];
		this.faces = [];
		this.faceVertexUvs = [ [] ];
		this.colors = [];

		var vertices = source.vertices;

		for ( var i = 0, il = vertices.length; i < il; i ++ ) {

			this.vertices.push( vertices[ i ].clone() );

		}

		var colors = source.colors;

		for ( var i = 0, il = colors.length; i < il; i ++ ) {

			this.colors.push( colors[ i ].clone() );

		}

		var faces = source.faces;

		for ( var i = 0, il = faces.length; i < il; i ++ ) {

			this.faces.push( faces[ i ].clone() );

		}

		for ( var i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {

			var faceVertexUvs = source.faceVertexUvs[ i ];

			if ( this.faceVertexUvs[ i ] === undefined ) {

				this.faceVertexUvs[ i ] = [];

			}

			for ( var j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {

				var uvs = faceVertexUvs[ j ], uvsCopy = [];

				for ( var k = 0, kl = uvs.length; k < kl; k ++ ) {

					var uv = uvs[ k ];

					uvsCopy.push( uv.clone() );

				}

				this.faceVertexUvs[ i ].push( uvsCopy );

			}

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

var count = 0;
function GeometryIdCount() { return count++; }

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometry() {

	Object.defineProperty( this, 'id', { value: GeometryIdCount() } );

	this.uuid = _Math.generateUUID();

	this.name = '';
	this.type = 'BufferGeometry';

	this.index = null;
	this.attributes = {};

	this.morphAttributes = {};

	this.groups = [];

	this.boundingBox = null;
	this.boundingSphere = null;

	this.drawRange = { start: 0, count: Infinity };

}

Object.assign( BufferGeometry.prototype, EventDispatcher.prototype, {

	isBufferGeometry: true,

	getIndex: function () {

		return this.index;

	},

	setIndex: function ( index ) {

		this.index = index;

	},

	addAttribute: function ( name, attribute ) {

		if ( ( attribute && attribute.isBufferAttribute ) === false && ( attribute && attribute.isInterleavedBufferAttribute ) === false ) {

			console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );

			this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );

			return;

		}

		if ( name === 'index' ) {

			console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
			this.setIndex( attribute );

			return;

		}

		this.attributes[ name ] = attribute;

		return this;

	},

	getAttribute: function ( name ) {

		return this.attributes[ name ];

	},

	removeAttribute: function ( name ) {

		delete this.attributes[ name ];

		return this;

	},

	addGroup: function ( start, count, materialIndex ) {

		this.groups.push( {

			start: start,
			count: count,
			materialIndex: materialIndex !== undefined ? materialIndex : 0

		} );

	},

	clearGroups: function () {

		this.groups = [];

	},

	setDrawRange: function ( start, count ) {

		this.drawRange.start = start;
		this.drawRange.count = count;

	},

	applyMatrix: function ( matrix ) {

		var position = this.attributes.position;

		if ( position !== undefined ) {

			matrix.applyToVector3Array( position.array );
			position.needsUpdate = true;

		}

		var normal = this.attributes.normal;

		if ( normal !== undefined ) {

			var normalMatrix = new Matrix3().getNormalMatrix( matrix );

			normalMatrix.applyToVector3Array( normal.array );
			normal.needsUpdate = true;

		}

		if ( this.boundingBox !== null ) {

			this.computeBoundingBox();

		}

		if ( this.boundingSphere !== null ) {

			this.computeBoundingSphere();

		}

		return this;

	},

	rotateX: function () {

		// rotate geometry around world x-axis

		var m1;

		return function rotateX( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationX( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateY: function () {

		// rotate geometry around world y-axis

		var m1;

		return function rotateY( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationY( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	rotateZ: function () {

		// rotate geometry around world z-axis

		var m1;

		return function rotateZ( angle ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeRotationZ( angle );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	translate: function () {

		// translate geometry

		var m1;

		return function translate( x, y, z ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeTranslation( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	scale: function () {

		// scale geometry

		var m1;

		return function scale( x, y, z ) {

			if ( m1 === undefined ) m1 = new Matrix4();

			m1.makeScale( x, y, z );

			this.applyMatrix( m1 );

			return this;

		};

	}(),

	lookAt: function () {

		var obj;

		return function lookAt( vector ) {

			if ( obj === undefined ) obj = new Object3D();

			obj.lookAt( vector );

			obj.updateMatrix();

			this.applyMatrix( obj.matrix );

		};

	}(),

	center: function () {

		this.computeBoundingBox();

		var offset = this.boundingBox.getCenter().negate();

		this.translate( offset.x, offset.y, offset.z );

		return offset;

	},

	setFromObject: function ( object ) {

		// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );

		var geometry = object.geometry;

		if ( object.isPoints || object.isLine ) {

			var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
			var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );

			this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
			this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );

			if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {

				var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );

				this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );

			}

			if ( geometry.boundingSphere !== null ) {

				this.boundingSphere = geometry.boundingSphere.clone();

			}

			if ( geometry.boundingBox !== null ) {

				this.boundingBox = geometry.boundingBox.clone();

			}

		} else if ( object.isMesh ) {

			if ( geometry && geometry.isGeometry ) {

				this.fromGeometry( geometry );

			}

		}

		return this;

	},

	updateFromObject: function ( object ) {

		var geometry = object.geometry;

		if ( object.isMesh ) {

			var direct = geometry.__directGeometry;

			if ( geometry.elementsNeedUpdate === true ) {

				direct = undefined;
				geometry.elementsNeedUpdate = false;

			}

			if ( direct === undefined ) {

				return this.fromGeometry( geometry );

			}

			direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
			direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
			direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
			direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
			direct.groupsNeedUpdate = geometry.groupsNeedUpdate;

			geometry.verticesNeedUpdate = false;
			geometry.normalsNeedUpdate = false;
			geometry.colorsNeedUpdate = false;
			geometry.uvsNeedUpdate = false;
			geometry.groupsNeedUpdate = false;

			geometry = direct;

		}

		var attribute;

		if ( geometry.verticesNeedUpdate === true ) {

			attribute = this.attributes.position;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.vertices );
				attribute.needsUpdate = true;

			}

			geometry.verticesNeedUpdate = false;

		}

		if ( geometry.normalsNeedUpdate === true ) {

			attribute = this.attributes.normal;

			if ( attribute !== undefined ) {

				attribute.copyVector3sArray( geometry.normals );
				attribute.needsUpdate = true;

			}

			geometry.normalsNeedUpdate = false;

		}

		if ( geometry.colorsNeedUpdate === true ) {

			attribute = this.attributes.color;

			if ( attribute !== undefined ) {

				attribute.copyColorsArray( geometry.colors );
				attribute.needsUpdate = true;

			}

			geometry.colorsNeedUpdate = false;

		}

		if ( geometry.uvsNeedUpdate ) {

			attribute = this.attributes.uv;

			if ( attribute !== undefined ) {

				attribute.copyVector2sArray( geometry.uvs );
				attribute.needsUpdate = true;

			}

			geometry.uvsNeedUpdate = false;

		}

		if ( geometry.lineDistancesNeedUpdate ) {

			attribute = this.attributes.lineDistance;

			if ( attribute !== undefined ) {

				attribute.copyArray( geometry.lineDistances );
				attribute.needsUpdate = true;

			}

			geometry.lineDistancesNeedUpdate = false;

		}

		if ( geometry.groupsNeedUpdate ) {

			geometry.computeGroups( object.geometry );
			this.groups = geometry.groups;

			geometry.groupsNeedUpdate = false;

		}

		return this;

	},

	fromGeometry: function ( geometry ) {

		geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );

		return this.fromDirectGeometry( geometry.__directGeometry );

	},

	fromDirectGeometry: function ( geometry ) {

		var positions = new Float32Array( geometry.vertices.length * 3 );
		this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );

		if ( geometry.normals.length > 0 ) {

			var normals = new Float32Array( geometry.normals.length * 3 );
			this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );

		}

		if ( geometry.colors.length > 0 ) {

			var colors = new Float32Array( geometry.colors.length * 3 );
			this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );

		}

		if ( geometry.uvs.length > 0 ) {

			var uvs = new Float32Array( geometry.uvs.length * 2 );
			this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );

		}

		if ( geometry.uvs2.length > 0 ) {

			var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
			this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );

		}

		if ( geometry.indices.length > 0 ) {

			var TypeArray = geometry.vertices.length > 65535 ? Uint32Array : Uint16Array;
			var indices = new TypeArray( geometry.indices.length * 3 );
			this.setIndex( new BufferAttribute( indices, 1 ).copyIndicesArray( geometry.indices ) );

		}

		// groups

		this.groups = geometry.groups;

		// morphs

		for ( var name in geometry.morphTargets ) {

			var array = [];
			var morphTargets = geometry.morphTargets[ name ];

			for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {

				var morphTarget = morphTargets[ i ];

				var attribute = new Float32BufferAttribute( morphTarget.length * 3, 3 );

				array.push( attribute.copyVector3sArray( morphTarget ) );

			}

			this.morphAttributes[ name ] = array;

		}

		// skinning

		if ( geometry.skinIndices.length > 0 ) {

			var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
			this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );

		}

		if ( geometry.skinWeights.length > 0 ) {

			var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
			this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );

		}

		//

		if ( geometry.boundingSphere !== null ) {

			this.boundingSphere = geometry.boundingSphere.clone();

		}

		if ( geometry.boundingBox !== null ) {

			this.boundingBox = geometry.boundingBox.clone();

		}

		return this;

	},

	computeBoundingBox: function () {

		if ( this.boundingBox === null ) {

			this.boundingBox = new Box3();

		}

		var position = this.attributes.position;

		if ( position !== undefined ) {

			this.boundingBox.setFromBufferAttribute( position );

		} else {

			this.boundingBox.makeEmpty();

		}

		if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {

			console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );

		}

	},

	computeBoundingSphere: function () {

		var box = new Box3();
		var vector = new Vector3();

		return function computeBoundingSphere() {

			if ( this.boundingSphere === null ) {

				this.boundingSphere = new Sphere();

			}

			var position = this.attributes.position;

			if ( position ) {

				var center = this.boundingSphere.center;

				box.setFromBufferAttribute( position );
				box.getCenter( center );

				// hoping to find a boundingSphere with a radius smaller than the
				// boundingSphere of the boundingBox: sqrt(3) smaller in the best case

				var maxRadiusSq = 0;

				for ( var i = 0, il = position.count; i < il; i ++ ) {

					vector.x = position.getX( i );
					vector.y = position.getY( i );
					vector.z = position.getZ( i );
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );

				}

				this.boundingSphere.radius = Math.sqrt( maxRadiusSq );

				if ( isNaN( this.boundingSphere.radius ) ) {

					console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );

				}

			}

		};

	}(),

	computeFaceNormals: function () {

		// backwards compatibility

	},

	computeVertexNormals: function () {

		var index = this.index;
		var attributes = this.attributes;
		var groups = this.groups;

		if ( attributes.position ) {

			var positions = attributes.position.array;

			if ( attributes.normal === undefined ) {

				this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );

			} else {

				// reset existing normals to zero

				var array = attributes.normal.array;

				for ( var i = 0, il = array.length; i < il; i ++ ) {

					array[ i ] = 0;

				}

			}

			var normals = attributes.normal.array;

			var vA, vB, vC;
			var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
			var cb = new Vector3(), ab = new Vector3();

			// indexed elements

			if ( index ) {

				var indices = index.array;

				if ( groups.length === 0 ) {

					this.addGroup( 0, indices.length );

				}

				for ( var j = 0, jl = groups.length; j < jl; ++ j ) {

					var group = groups[ j ];

					var start = group.start;
					var count = group.count;

					for ( var i = start, il = start + count; i < il; i += 3 ) {

						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;

						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );

						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );

						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;

						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;

						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;

					}

				}

			} else {

				// non-indexed elements (unconnected triangle soup)

				for ( var i = 0, il = positions.length; i < il; i += 9 ) {

					pA.fromArray( positions, i );
					pB.fromArray( positions, i + 3 );
					pC.fromArray( positions, i + 6 );

					cb.subVectors( pC, pB );
					ab.subVectors( pA, pB );
					cb.cross( ab );

					normals[ i ] = cb.x;
					normals[ i + 1 ] = cb.y;
					normals[ i + 2 ] = cb.z;

					normals[ i + 3 ] = cb.x;
					normals[ i + 4 ] = cb.y;
					normals[ i + 5 ] = cb.z;

					normals[ i + 6 ] = cb.x;
					normals[ i + 7 ] = cb.y;
					normals[ i + 8 ] = cb.z;

				}

			}

			this.normalizeNormals();

			attributes.normal.needsUpdate = true;

		}

	},

	merge: function ( geometry, offset ) {

		if ( ( geometry && geometry.isBufferGeometry ) === false ) {

			console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
			return;

		}

		if ( offset === undefined ) offset = 0;

		var attributes = this.attributes;

		for ( var key in attributes ) {

			if ( geometry.attributes[ key ] === undefined ) continue;

			var attribute1 = attributes[ key ];
			var attributeArray1 = attribute1.array;

			var attribute2 = geometry.attributes[ key ];
			var attributeArray2 = attribute2.array;

			var attributeSize = attribute2.itemSize;

			for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {

				attributeArray1[ j ] = attributeArray2[ i ];

			}

		}

		return this;

	},

	normalizeNormals: function () {

		var normals = this.attributes.normal.array;

		var x, y, z, n;

		for ( var i = 0, il = normals.length; i < il; i += 3 ) {

			x = normals[ i ];
			y = normals[ i + 1 ];
			z = normals[ i + 2 ];

			n = 1.0 / Math.sqrt( x * x + y * y + z * z );

			normals[ i ] *= n;
			normals[ i + 1 ] *= n;
			normals[ i + 2 ] *= n;

		}

	},

	toNonIndexed: function () {

		if ( this.index === null ) {

			console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
			return this;

		}

		var geometry2 = new BufferGeometry();

		var indices = this.index.array;
		var attributes = this.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];

			var array = attribute.array;
			var itemSize = attribute.itemSize;

			var array2 = new array.constructor( indices.length * itemSize );

			var index = 0, index2 = 0;

			for ( var i = 0, l = indices.length; i < l; i ++ ) {

				index = indices[ i ] * itemSize;

				for ( var j = 0; j < itemSize; j ++ ) {

					array2[ index2 ++ ] = array[ index ++ ];

				}

			}

			geometry2.addAttribute( name, new BufferAttribute( array2, itemSize ) );

		}

		return geometry2;

	},

	toJSON: function () {

		var data = {
			metadata: {
				version: 4.4,
				type: 'BufferGeometry',
				generator: 'BufferGeometry.toJSON'
			}
		};

		// standard BufferGeometry serialization

		data.uuid = this.uuid;
		data.type = this.type;
		if ( this.name !== '' ) data.name = this.name;

		if ( this.parameters !== undefined ) {

			var parameters = this.parameters;

			for ( var key in parameters ) {

				if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];

			}

			return data;

		}

		data.data = { attributes: {} };

		var index = this.index;

		if ( index !== null ) {

			var array = Array.prototype.slice.call( index.array );

			data.data.index = {
				type: index.array.constructor.name,
				array: array
			};

		}

		var attributes = this.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];

			var array = Array.prototype.slice.call( attribute.array );

			data.data.attributes[ key ] = {
				itemSize: attribute.itemSize,
				type: attribute.array.constructor.name,
				array: array,
				normalized: attribute.normalized
			};

		}

		var groups = this.groups;

		if ( groups.length > 0 ) {

			data.data.groups = JSON.parse( JSON.stringify( groups ) );

		}

		var boundingSphere = this.boundingSphere;

		if ( boundingSphere !== null ) {

			data.data.boundingSphere = {
				center: boundingSphere.center.toArray(),
				radius: boundingSphere.radius
			};

		}

		return data;

	},

	clone: function () {

		/*
		// Handle primitives

		var parameters = this.parameters;

		if ( parameters !== undefined ) {

			var values = [];

			for ( var key in parameters ) {

				values.push( parameters[ key ] );

			}

			var geometry = Object.create( this.constructor.prototype );
			this.constructor.apply( geometry, values );
			return geometry;

		}

		return new this.constructor().copy( this );
		*/

		return new BufferGeometry().copy( this );

	},

	copy: function ( source ) {

		var index = source.index;

		if ( index !== null ) {

			this.setIndex( index.clone() );

		}

		var attributes = source.attributes;

		for ( var name in attributes ) {

			var attribute = attributes[ name ];
			this.addAttribute( name, attribute.clone() );

		}

		var groups = source.groups;

		for ( var i = 0, l = groups.length; i < l; i ++ ) {

			var group = groups[ i ];
			this.addGroup( group.start, group.count, group.materialIndex );

		}

		return this;

	},

	dispose: function () {

		this.dispatchEvent( { type: 'dispose' } );

	}

} );

BufferGeometry.MaxIndex = 65535;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author mikael emtinger / http://gomo.se/
 * @author jonobr1 / http://jonobr1.com/
 */

function Mesh( geometry, material ) {

	Object3D.call( this );

	this.type = 'Mesh';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );

	this.drawMode = TrianglesDrawMode;

	this.updateMorphTargets();

}

Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Mesh,

	isMesh: true,

	setDrawMode: function ( value ) {

		this.drawMode = value;

	},

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.drawMode = source.drawMode;

		return this;

	},

	updateMorphTargets: function () {

		var morphTargets = this.geometry.morphTargets;

		if ( morphTargets !== undefined && morphTargets.length > 0 ) {

			this.morphTargetInfluences = [];
			this.morphTargetDictionary = {};

			for ( var m = 0, ml = morphTargets.length; m < ml; m ++ ) {

				this.morphTargetInfluences.push( 0 );
				this.morphTargetDictionary[ morphTargets[ m ].name ] = m;

			}

		}

	},

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		var vA = new Vector3();
		var vB = new Vector3();
		var vC = new Vector3();

		var tempA = new Vector3();
		var tempB = new Vector3();
		var tempC = new Vector3();

		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();

		var barycoord = new Vector3();

		var intersectionPoint = new Vector3();
		var intersectionPointWorld = new Vector3();

		function uvIntersection( point, p1, p2, p3, uv1, uv2, uv3 ) {

			Triangle.barycoordFromPoint( point, p1, p2, p3, barycoord );

			uv1.multiplyScalar( barycoord.x );
			uv2.multiplyScalar( barycoord.y );
			uv3.multiplyScalar( barycoord.z );

			uv1.add( uv2 ).add( uv3 );

			return uv1.clone();

		}

		function checkIntersection( object, raycaster, ray, pA, pB, pC, point ) {

			var intersect;
			var material = object.material;

			if ( material.side === BackSide ) {

				intersect = ray.intersectTriangle( pC, pB, pA, true, point );

			} else {

				intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );

			}

			if ( intersect === null ) return null;

			intersectionPointWorld.copy( point );
			intersectionPointWorld.applyMatrix4( object.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );

			if ( distance < raycaster.near || distance > raycaster.far ) return null;

			return {
				distance: distance,
				point: intersectionPointWorld.clone(),
				object: object
			};

		}

		function checkBufferGeometryIntersection( object, raycaster, ray, positions, uvs, a, b, c ) {

			vA.fromArray( positions, a * 3 );
			vB.fromArray( positions, b * 3 );
			vC.fromArray( positions, c * 3 );

			var intersection = checkIntersection( object, raycaster, ray, vA, vB, vC, intersectionPoint );

			if ( intersection ) {

				if ( uvs ) {

					uvA.fromArray( uvs, a * 2 );
					uvB.fromArray( uvs, b * 2 );
					uvC.fromArray( uvs, c * 2 );

					intersection.uv = uvIntersection( intersectionPoint,  vA, vB, vC,  uvA, uvB, uvC );

				}

				intersection.face = new Face3( a, b, c, Triangle.normal( vA, vB, vC ) );
				intersection.faceIndex = a;

			}

			return intersection;

		}

		return function raycast( raycaster, intersects ) {

			var geometry = this.geometry;
			var material = this.material;
			var matrixWorld = this.matrixWorld;

			if ( material === undefined ) return;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			// Check boundingBox before continuing

			if ( geometry.boundingBox !== null ) {

				if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;

			}

			var uvs, intersection;

			if ( geometry.isBufferGeometry ) {

				var a, b, c;
				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( attributes.uv !== undefined ) {

					uvs = attributes.uv.array;

				}

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, l = indices.length; i < l; i += 3 ) {

						a = indices[ i ];
						b = indices[ i + 1 ];
						c = indices[ i + 2 ];

						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

						if ( intersection ) {

							intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indices buffer semantics
							intersects.push( intersection );

						}

					}

				} else {


					for ( var i = 0, l = positions.length; i < l; i += 9 ) {

						a = i / 3;
						b = a + 1;
						c = a + 2;

						intersection = checkBufferGeometryIntersection( this, raycaster, ray, positions, uvs, a, b, c );

						if ( intersection ) {

							intersection.index = a; // triangle number in positions buffer semantics
							intersects.push( intersection );

						}

					}

				}

			} else if ( geometry.isGeometry ) {

				var fvA, fvB, fvC;
				var isFaceMaterial = (material && material.isMultiMaterial);
				var materials = isFaceMaterial === true ? material.materials : null;

				var vertices = geometry.vertices;
				var faces = geometry.faces;
				var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
				if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;

				for ( var f = 0, fl = faces.length; f < fl; f ++ ) {

					var face = faces[ f ];
					var faceMaterial = isFaceMaterial === true ? materials[ face.materialIndex ] : material;

					if ( faceMaterial === undefined ) continue;

					fvA = vertices[ face.a ];
					fvB = vertices[ face.b ];
					fvC = vertices[ face.c ];

					if ( faceMaterial.morphTargets === true ) {

						var morphTargets = geometry.morphTargets;
						var morphInfluences = this.morphTargetInfluences;

						vA.set( 0, 0, 0 );
						vB.set( 0, 0, 0 );
						vC.set( 0, 0, 0 );

						for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {

							var influence = morphInfluences[ t ];

							if ( influence === 0 ) continue;

							var targets = morphTargets[ t ].vertices;

							vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
							vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
							vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );

						}

						vA.add( fvA );
						vB.add( fvB );
						vC.add( fvC );

						fvA = vA;
						fvB = vB;
						fvC = vC;

					}

					intersection = checkIntersection( this, raycaster, ray, fvA, fvB, fvC, intersectionPoint );

					if ( intersection ) {

						if ( uvs ) {

							var uvs_f = uvs[ f ];
							uvA.copy( uvs_f[ 0 ] );
							uvB.copy( uvs_f[ 1 ] );
							uvC.copy( uvs_f[ 2 ] );

							intersection.uv = uvIntersection( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC );

						}

						intersection.face = face;
						intersection.faceIndex = f;
						intersects.push( intersection );

					}

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	BufferGeometry.call( this );

	this.type = 'BoxBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	var scope = this;

	// segments
	widthSegments = Math.floor( widthSegments ) || 1;
	heightSegments = Math.floor( heightSegments ) || 1;
	depthSegments = Math.floor( depthSegments ) || 1;

	// these are used to calculate buffer length
	var vertexCount = calculateVertexCount( widthSegments, heightSegments, depthSegments );
	var indexCount = calculateIndexCount( widthSegments, heightSegments, depthSegments );

	// buffers
	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
	var vertices = new Float32Array( vertexCount * 3 );
	var normals = new Float32Array( vertexCount * 3 );
	var uvs = new Float32Array( vertexCount * 2 );

	// offset variables
	var vertexBufferOffset = 0;
	var uvBufferOffset = 0;
	var indexBufferOffset = 0;
	var numberOfVertices = 0;

	// group variables
	var groupStart = 0;

	// build each side of the box geometry
	buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height,   width,  depthSegments, heightSegments, 0 ); // px
	buildPlane( 'z', 'y', 'x',   1, - 1, depth, height, - width,  depthSegments, heightSegments, 1 ); // nx
	buildPlane( 'x', 'z', 'y',   1,   1, width, depth,    height, widthSegments, depthSegments,  2 ); // py
	buildPlane( 'x', 'z', 'y',   1, - 1, width, depth,  - height, widthSegments, depthSegments,  3 ); // ny
	buildPlane( 'x', 'y', 'z',   1, - 1, width, height,   depth,  widthSegments, heightSegments, 4 ); // pz
	buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth,  widthSegments, heightSegments, 5 ); // nz

	// build geometry
	this.setIndex( new BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

	// helper functions

	function calculateVertexCount( w, h, d ) {

		var vertices = 0;

		// calculate the amount of vertices for each side (plane)
		vertices += (w + 1) * (h + 1) * 2; // xy
		vertices += (w + 1) * (d + 1) * 2; // xz
		vertices += (d + 1) * (h + 1) * 2; // zy

		return vertices;

	}

	function calculateIndexCount( w, h, d ) {

		var index = 0;

		// calculate the amount of squares for each side
		index += w * h * 2; // xy
		index += w * d * 2; // xz
		index += d * h * 2; // zy

		return index * 6; // two triangles per square => six vertices per square

	}

	function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {

		var segmentWidth	= width / gridX;
		var segmentHeight = height / gridY;

		var widthHalf = width / 2;
		var heightHalf = height / 2;
		var depthHalf = depth / 2;

		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;

		var vertexCounter = 0;
		var groupCount = 0;

		var vector = new Vector3();

		// generate vertices, normals and uvs

		for ( var iy = 0; iy < gridY1; iy ++ ) {

			var y = iy * segmentHeight - heightHalf;

			for ( var ix = 0; ix < gridX1; ix ++ ) {

				var x = ix * segmentWidth - widthHalf;

				// set values to correct vector component
				vector[ u ] = x * udir;
				vector[ v ] = y * vdir;
				vector[ w ] = depthHalf;

				// now apply vector to vertex buffer
				vertices[ vertexBufferOffset ] = vector.x;
				vertices[ vertexBufferOffset + 1 ] = vector.y;
				vertices[ vertexBufferOffset + 2 ] = vector.z;

				// set values to correct vector component
				vector[ u ] = 0;
				vector[ v ] = 0;
				vector[ w ] = depth > 0 ? 1 : - 1;

				// now apply vector to normal buffer
				normals[ vertexBufferOffset ] = vector.x;
				normals[ vertexBufferOffset + 1 ] = vector.y;
				normals[ vertexBufferOffset + 2 ] = vector.z;

				// uvs
				uvs[ uvBufferOffset ] = ix / gridX;
				uvs[ uvBufferOffset + 1 ] = 1 - ( iy / gridY );

				// update offsets and counters
				vertexBufferOffset += 3;
				uvBufferOffset += 2;
				vertexCounter += 1;

			}

		}

		// 1. you need three indices to draw a single face
		// 2. a single segment consists of two faces
		// 3. so we need to generate six (2*3) indices per segment

		for ( iy = 0; iy < gridY; iy ++ ) {

			for ( ix = 0; ix < gridX; ix ++ ) {

				// indices
				var a = numberOfVertices + ix + gridX1 * iy;
				var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
				var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;

				// face one
				indices[ indexBufferOffset ] = a;
				indices[ indexBufferOffset + 1 ] = b;
				indices[ indexBufferOffset + 2 ] = d;

				// face two
				indices[ indexBufferOffset + 3 ] = b;
				indices[ indexBufferOffset + 4 ] = c;
				indices[ indexBufferOffset + 5 ] = d;

				// update offsets and counters
				indexBufferOffset += 6;
				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support
		scope.addGroup( groupStart, groupCount, materialIndex );

		// calculate new start value for groups
		groupStart += groupCount;

		// update total number of vertices
		numberOfVertices += vertexCounter;

	}

}

BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {

	BufferGeometry.call( this );

	this.type = 'PlaneBufferGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	var width_half = width / 2;
	var height_half = height / 2;

	var gridX = Math.floor( widthSegments ) || 1;
	var gridY = Math.floor( heightSegments ) || 1;

	var gridX1 = gridX + 1;
	var gridY1 = gridY + 1;

	var segment_width = width / gridX;
	var segment_height = height / gridY;

	var vertices = new Float32Array( gridX1 * gridY1 * 3 );
	var normals = new Float32Array( gridX1 * gridY1 * 3 );
	var uvs = new Float32Array( gridX1 * gridY1 * 2 );

	var offset = 0;
	var offset2 = 0;

	for ( var iy = 0; iy < gridY1; iy ++ ) {

		var y = iy * segment_height - height_half;

		for ( var ix = 0; ix < gridX1; ix ++ ) {

			var x = ix * segment_width - width_half;

			vertices[ offset ] = x;
			vertices[ offset + 1 ] = - y;

			normals[ offset + 2 ] = 1;

			uvs[ offset2 ] = ix / gridX;
			uvs[ offset2 + 1 ] = 1 - ( iy / gridY );

			offset += 3;
			offset2 += 2;

		}

	}

	offset = 0;

	var indices = new ( ( vertices.length / 3 ) > 65535 ? Uint32Array : Uint16Array )( gridX * gridY * 6 );

	for ( var iy = 0; iy < gridY; iy ++ ) {

		for ( var ix = 0; ix < gridX; ix ++ ) {

			var a = ix + gridX1 * iy;
			var b = ix + gridX1 * ( iy + 1 );
			var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
			var d = ( ix + 1 ) + gridX1 * iy;

			indices[ offset ] = a;
			indices[ offset + 1 ] = b;
			indices[ offset + 2 ] = d;

			indices[ offset + 3 ] = b;
			indices[ offset + 4 ] = c;
			indices[ offset + 5 ] = d;

			offset += 6;

		}

	}

	this.setIndex( new BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

}

PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author mikael emtinger / http://gomo.se/
 * @author WestLangley / http://github.com/WestLangley
*/

function Camera() {

	Object3D.call( this );

	this.type = 'Camera';

	this.matrixWorldInverse = new Matrix4();
	this.projectionMatrix = new Matrix4();

}

Camera.prototype = Object.create( Object3D.prototype );
Camera.prototype.constructor = Camera;

Camera.prototype.isCamera = true;

Camera.prototype.getWorldDirection = function () {

	var quaternion = new Quaternion();

	return function getWorldDirection( optionalTarget ) {

		var result = optionalTarget || new Vector3();

		this.getWorldQuaternion( quaternion );

		return result.set( 0, 0, - 1 ).applyQuaternion( quaternion );

	};

}();

Camera.prototype.lookAt = function () {

	// This routine does not support cameras with rotated and/or translated parent(s)

	var m1 = new Matrix4();

	return function lookAt( vector ) {

		m1.lookAt( this.position, vector, this.up );

		this.quaternion.setFromRotationMatrix( m1 );

	};

}();

Camera.prototype.clone = function () {

	return new this.constructor().copy( this );

};

Camera.prototype.copy = function ( source ) {

	Object3D.prototype.copy.call( this, source );

	this.matrixWorldInverse.copy( source.matrixWorldInverse );
	this.projectionMatrix.copy( source.projectionMatrix );

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author greggman / http://games.greggman.com/
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author tschw
 */

function PerspectiveCamera( fov, aspect, near, far ) {

	Camera.call( this );

	this.type = 'PerspectiveCamera';

	this.fov = fov !== undefined ? fov : 50;
	this.zoom = 1;

	this.near = near !== undefined ? near : 0.1;
	this.far = far !== undefined ? far : 2000;
	this.focus = 10;

	this.aspect = aspect !== undefined ? aspect : 1;
	this.view = null;

	this.filmGauge = 35;	// width of the film (default in millimeters)
	this.filmOffset = 0;	// horizontal film offset (same unit as gauge)

	this.updateProjectionMatrix();

}

PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: PerspectiveCamera,

	isPerspectiveCamera: true,

	copy: function ( source ) {

		Camera.prototype.copy.call( this, source );

		this.fov = source.fov;
		this.zoom = source.zoom;

		this.near = source.near;
		this.far = source.far;
		this.focus = source.focus;

		this.aspect = source.aspect;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		this.filmGauge = source.filmGauge;
		this.filmOffset = source.filmOffset;

		return this;

	},

	/**
	 * Sets the FOV by focal length in respect to the current .filmGauge.
	 *
	 * The default film gauge is 35, so that the focal length can be specified for
	 * a 35mm (full frame) camera.
	 *
	 * Values for focal length and film gauge must have the same unit.
	 */
	setFocalLength: function ( focalLength ) {

		// see http://www.bobatkins.com/photography/technical/field_of_view.html
		var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;

		this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
		this.updateProjectionMatrix();

	},

	/**
	 * Calculates the focal length from the current .fov and .filmGauge.
	 */
	getFocalLength: function () {

		var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );

		return 0.5 * this.getFilmHeight() / vExtentSlope;

	},

	getEffectiveFOV: function () {

		return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );

	},

	getFilmWidth: function () {

		// film not completely covered in portrait format (aspect < 1)
		return this.filmGauge * Math.min( this.aspect, 1 );

	},

	getFilmHeight: function () {

		// film not completely covered in landscape format (aspect > 1)
		return this.filmGauge / Math.max( this.aspect, 1 );

	},

	/**
	 * Sets an offset in a larger frustum. This is useful for multi-window or
	 * multi-monitor/multi-machine setups.
	 *
	 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
	 * the monitors are in grid like this
	 *
	 *   +---+---+---+
	 *   | A | B | C |
	 *   +---+---+---+
	 *   | D | E | F |
	 *   +---+---+---+
	 *
	 * then for each monitor you would call it like this
	 *
	 *   var w = 1920;
	 *   var h = 1080;
	 *   var fullWidth = w * 3;
	 *   var fullHeight = h * 2;
	 *
	 *   --A--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
	 *   --B--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
	 *   --C--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
	 *   --D--
	 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
	 *   --E--
	 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
	 *   --F--
	 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
	 *
	 *   Note there is no reason monitors have to be the same size or in a grid.
	 */
	setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {

		this.aspect = fullWidth / fullHeight;

		this.view = {
			fullWidth: fullWidth,
			fullHeight: fullHeight,
			offsetX: x,
			offsetY: y,
			width: width,
			height: height
		};

		this.updateProjectionMatrix();

	},

	clearViewOffset: function() {

		this.view = null;
		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var near = this.near,
			top = near * Math.tan(
					_Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
			height = 2 * top,
			width = this.aspect * height,
			left = - 0.5 * width,
			view = this.view;

		if ( view !== null ) {

			var fullWidth = view.fullWidth,
				fullHeight = view.fullHeight;

			left += view.offsetX * width / fullWidth;
			top -= view.offsetY * height / fullHeight;
			width *= view.width / fullWidth;
			height *= view.height / fullHeight;

		}

		var skew = this.filmOffset;
		if ( skew !== 0 ) left += near * skew / this.getFilmWidth();

		this.projectionMatrix.makeFrustum(
				left, left + width, top - height, top, near, this.far );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.fov = this.fov;
		data.object.zoom = this.zoom;

		data.object.near = this.near;
		data.object.far = this.far;
		data.object.focus = this.focus;

		data.object.aspect = this.aspect;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		data.object.filmGauge = this.filmGauge;
		data.object.filmOffset = this.filmOffset;

		return data;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author arose / http://github.com/arose
 */

function OrthographicCamera( left, right, top, bottom, near, far ) {

	Camera.call( this );

	this.type = 'OrthographicCamera';

	this.zoom = 1;
	this.view = null;

	this.left = left;
	this.right = right;
	this.top = top;
	this.bottom = bottom;

	this.near = ( near !== undefined ) ? near : 0.1;
	this.far = ( far !== undefined ) ? far : 2000;

	this.updateProjectionMatrix();

}

OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {

	constructor: OrthographicCamera,

	isOrthographicCamera: true,

	copy: function ( source ) {

		Camera.prototype.copy.call( this, source );

		this.left = source.left;
		this.right = source.right;
		this.top = source.top;
		this.bottom = source.bottom;
		this.near = source.near;
		this.far = source.far;

		this.zoom = source.zoom;
		this.view = source.view === null ? null : Object.assign( {}, source.view );

		return this;

	},

	setViewOffset: function( fullWidth, fullHeight, x, y, width, height ) {

		this.view = {
			fullWidth: fullWidth,
			fullHeight: fullHeight,
			offsetX: x,
			offsetY: y,
			width: width,
			height: height
		};

		this.updateProjectionMatrix();

	},

	clearViewOffset: function() {

		this.view = null;
		this.updateProjectionMatrix();

	},

	updateProjectionMatrix: function () {

		var dx = ( this.right - this.left ) / ( 2 * this.zoom );
		var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
		var cx = ( this.right + this.left ) / 2;
		var cy = ( this.top + this.bottom ) / 2;

		var left = cx - dx;
		var right = cx + dx;
		var top = cy + dy;
		var bottom = cy - dy;

		if ( this.view !== null ) {

			var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
			var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
			var scaleW = ( this.right - this.left ) / this.view.width;
			var scaleH = ( this.top - this.bottom ) / this.view.height;

			left += scaleW * ( this.view.offsetX / zoomW );
			right = left + scaleW * ( this.view.width / zoomW );
			top -= scaleH * ( this.view.offsetY / zoomH );
			bottom = top - scaleH * ( this.view.height / zoomH );

		}

		this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.zoom = this.zoom;
		data.object.left = this.left;
		data.object.right = this.right;
		data.object.top = this.top;
		data.object.bottom = this.bottom;
		data.object.near = this.near;
		data.object.far = this.far;

		if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );

		return data;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLIndexedBufferRenderer( gl, extensions, infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	var type, size;

	function setIndex( index ) {

		if ( index.array instanceof Uint32Array && extensions.get( 'OES_element_index_uint' ) ) {

			type = gl.UNSIGNED_INT;
			size = 4;

		} else if ( index.array instanceof Uint16Array ) {

			type = gl.UNSIGNED_SHORT;
			size = 2;

		} else {
			
			type = gl.UNSIGNED_BYTE;
			size = 1;
		}

	}

	function render( start, count ) {

		gl.drawElements( mode, count, type, start * size );

		infoRender.calls ++;
		infoRender.vertices += count;

		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

	}

	function renderInstances( geometry, start, count ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		extension.drawElementsInstancedANGLE( mode, count, type, start * size, geometry.maxInstancedCount );

		infoRender.calls ++;
		infoRender.vertices += count * geometry.maxInstancedCount;

		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

	}

	return {

		setMode: setMode,
		setIndex: setIndex,
		render: render,
		renderInstances: renderInstances

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLBufferRenderer( gl, extensions, infoRender ) {

	var mode;

	function setMode( value ) {

		mode = value;

	}

	function render( start, count ) {

		gl.drawArrays( mode, start, count );

		infoRender.calls ++;
		infoRender.vertices += count;

		if ( mode === gl.TRIANGLES ) infoRender.faces += count / 3;

	}

	function renderInstances( geometry ) {

		var extension = extensions.get( 'ANGLE_instanced_arrays' );

		if ( extension === null ) {

			console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
			return;

		}

		var position = geometry.attributes.position;

		var count = 0;

		if ( position.isInterleavedBufferAttribute ) {

			count = position.data.count;

			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

		} else {

			count = position.count;

			extension.drawArraysInstancedANGLE( mode, 0, count, geometry.maxInstancedCount );

		}

		infoRender.calls ++;
		infoRender.vertices += count * geometry.maxInstancedCount;

		if ( mode === gl.TRIANGLES ) infoRender.faces += geometry.maxInstancedCount * count / 3;

	}

	return {
		setMode: setMode,
		render: render,
		renderInstances: renderInstances
	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLLights() {

	var lights = {};

	return {

		get: function ( light ) {

			if ( lights[ light.id ] !== undefined ) {

				return lights[ light.id ];

			}

			var uniforms;

			switch ( light.type ) {

				case 'DirectionalLight':
					uniforms = {
						direction: new Vector3(),
						color: new Color(),

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'SpotLight':
					uniforms = {
						position: new Vector3(),
						direction: new Vector3(),
						color: new Color(),
						distance: 0,
						coneCos: 0,
						penumbraCos: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'PointLight':
					uniforms = {
						position: new Vector3(),
						color: new Color(),
						distance: 0,
						decay: 0,

						shadow: false,
						shadowBias: 0,
						shadowRadius: 1,
						shadowMapSize: new Vector2()
					};
					break;

				case 'HemisphereLight':
					uniforms = {
						direction: new Vector3(),
						skyColor: new Color(),
						groundColor: new Color()
					};
					break;

				case 'RectAreaLight':
					uniforms = {
						color: new Color(),
						position: new Vector3(),
						halfWidth: new Vector3(),
						halfHeight: new Vector3()
						// TODO (abelnation): set RectAreaLight shadow uniforms
					};
					break;

			}

			lights[ light.id ] = uniforms;

			return uniforms;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function addLineNumbers( string ) {

	var lines = string.split( '\n' );

	for ( var i = 0; i < lines.length; i ++ ) {

		lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];

	}

	return lines.join( '\n' );

}

function WebGLShader( gl, type, string ) {

	var shader = gl.createShader( type );

	gl.shaderSource( shader, string );
	gl.compileShader( shader );

	if ( gl.getShaderParameter( shader, gl.COMPILE_STATUS ) === false ) {

		console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );

	}

	if ( gl.getShaderInfoLog( shader ) !== '' ) {

		console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === gl.VERTEX_SHADER ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );

	}

	// --enable-privileged-webgl-extension
	// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );

	return shader;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

var programIdCount = 0;

function getEncodingComponents( encoding ) {

	switch ( encoding ) {

		case LinearEncoding:
			return [ 'Linear','( value )' ];
		case sRGBEncoding:
			return [ 'sRGB','( value )' ];
		case RGBEEncoding:
			return [ 'RGBE','( value )' ];
		case RGBM7Encoding:
			return [ 'RGBM','( value, 7.0 )' ];
		case RGBM16Encoding:
			return [ 'RGBM','( value, 16.0 )' ];
		case RGBDEncoding:
			return [ 'RGBD','( value, 256.0 )' ];
		case GammaEncoding:
			return [ 'Gamma','( value, float( GAMMA_FACTOR ) )' ];
		default:
			throw new Error( 'unsupported encoding: ' + encoding );

	}

}

function getTexelDecodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return "vec4 " + functionName + "( vec4 value ) { return " + components[ 0 ] + "ToLinear" + components[ 1 ] + "; }";

}

function getTexelEncodingFunction( functionName, encoding ) {

	var components = getEncodingComponents( encoding );
	return "vec4 " + functionName + "( vec4 value ) { return LinearTo" + components[ 0 ] + components[ 1 ] + "; }";

}

function getToneMappingFunction( functionName, toneMapping ) {

	var toneMappingName;

	switch ( toneMapping ) {

		case LinearToneMapping:
			toneMappingName = "Linear";
			break;

		case ReinhardToneMapping:
			toneMappingName = "Reinhard";
			break;

		case Uncharted2ToneMapping:
			toneMappingName = "Uncharted2";
			break;

		case CineonToneMapping:
			toneMappingName = "OptimizedCineon";
			break;

		default:
			throw new Error( 'unsupported toneMapping: ' + toneMapping );

	}

	return "vec3 " + functionName + "( vec3 color ) { return " + toneMappingName + "ToneMapping( color ); }";

}

function generateExtensions( extensions, parameters, rendererExtensions ) {

	extensions = extensions || {};

	var chunks = [
		( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || parameters.normalMap || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
		( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
		( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
		( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
	];

	return chunks.filter( filterEmptyLine ).join( '\n' );

}

function generateDefines( defines ) {

	var chunks = [];

	for ( var name in defines ) {

		var value = defines[ name ];

		if ( value === false ) continue;

		chunks.push( '#define ' + name + ' ' + value );

	}

	return chunks.join( '\n' );

}

function fetchAttributeLocations( gl, program, identifiers ) {

	var attributes = {};

	var n = gl.getProgramParameter( program, gl.ACTIVE_ATTRIBUTES );

	for ( var i = 0; i < n; i ++ ) {

		var info = gl.getActiveAttrib( program, i );
		var name = info.name;

		// console.log("THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:", name, i );

		attributes[ name ] = gl.getAttribLocation( program, name );

	}

	return attributes;

}

function filterEmptyLine( string ) {

	return string !== '';

}

function replaceLightNums( string, parameters ) {

	return string
		.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
		.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
		.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
		.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
		.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );

}

function parseIncludes( string ) {

	var pattern = /#include +<([\w\d.]+)>/g;

	function replace( match, include ) {

		var replace = ShaderChunk[ include ];

		if ( replace === undefined ) {

			throw new Error( 'Can not resolve #include <' + include + '>' );

		}

		return parseIncludes( replace );

	}

	return string.replace( pattern, replace );

}

function unrollLoops( string ) {

	var pattern = /for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;

	function replace( match, start, end, snippet ) {

		var unroll = '';

		for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {

			unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );

		}

		return unroll;

	}

	return string.replace( pattern, replace );

}

function WebGLProgram( renderer, code, material, parameters ) {

	var gl = renderer.context;

	var extensions = material.extensions;
	var defines = material.defines;

	var vertexShader = material.__webglShader.vertexShader;
	var fragmentShader = material.__webglShader.fragmentShader;

	var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';

	if ( parameters.shadowMapType === PCFShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';

	} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {

		shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';

	}

	var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
	var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
	var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';

	if ( parameters.envMap ) {

		switch ( material.envMap.mapping ) {

			case CubeReflectionMapping:
			case CubeRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
				break;

			case CubeUVReflectionMapping:
			case CubeUVRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
				break;

			case EquirectangularReflectionMapping:
			case EquirectangularRefractionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
				break;

			case SphericalReflectionMapping:
				envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
				break;

		}

		switch ( material.envMap.mapping ) {

			case CubeRefractionMapping:
			case EquirectangularRefractionMapping:
				envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
				break;

		}

		switch ( material.combine ) {

			case MultiplyOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
				break;

			case MixOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
				break;

			case AddOperation:
				envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
				break;

		}

	}

	var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;

	// console.log( 'building new program ' );

	//

	var customExtensions = generateExtensions( extensions, parameters, renderer.extensions );

	var customDefines = generateDefines( defines );

	//

	var program = gl.createProgram();

	var prefixVertex, prefixFragment;

	if ( material.isRawShaderMaterial ) {

		prefixVertex = [

			customDefines,

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,
			customDefines,

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	} else {

		prefixVertex = [

			'precision ' + parameters.precision + ' float;',
			'precision ' + parameters.precision + ' int;',

			'#define SHADER_NAME ' + material.__webglShader.name,

			customDefines,

			parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			'#define MAX_BONES ' + parameters.maxBones,

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.skinning ? '#define USE_SKINNING' : '',
			parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',

			parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
			parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			'uniform mat4 modelMatrix;',
			'uniform mat4 modelViewMatrix;',
			'uniform mat4 projectionMatrix;',
			'uniform mat4 viewMatrix;',
			'uniform mat3 normalMatrix;',
			'uniform vec3 cameraPosition;',

			'attribute vec3 position;',
			'attribute vec3 normal;',
			'attribute vec2 uv;',

			'#ifdef USE_COLOR',

			'	attribute vec3 color;',

			'#endif',

			'#ifdef USE_MORPHTARGETS',

			'	attribute vec3 morphTarget0;',
			'	attribute vec3 morphTarget1;',
			'	attribute vec3 morphTarget2;',
			'	attribute vec3 morphTarget3;',

			'	#ifdef USE_MORPHNORMALS',

			'		attribute vec3 morphNormal0;',
			'		attribute vec3 morphNormal1;',
			'		attribute vec3 morphNormal2;',
			'		attribute vec3 morphNormal3;',

			'	#else',

			'		attribute vec3 morphTarget4;',
			'		attribute vec3 morphTarget5;',
			'		attribute vec3 morphTarget6;',
			'		attribute vec3 morphTarget7;',

			'	#endif',

			'#endif',

			'#ifdef USE_SKINNING',

			'	attribute vec4 skinIndex;',
			'	attribute vec4 skinWeight;',

			'#endif',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

		prefixFragment = [

			customExtensions,

			'precision ' + parameters.precision + ' float;',
			'precision ' + parameters.precision + ' int;',

			'#define SHADER_NAME ' + material.__webglShader.name,

			customDefines,

			parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest : '',

			'#define GAMMA_FACTOR ' + gammaFactorDefine,

			( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
			( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',

			parameters.map ? '#define USE_MAP' : '',
			parameters.envMap ? '#define USE_ENVMAP' : '',
			parameters.envMap ? '#define ' + envMapTypeDefine : '',
			parameters.envMap ? '#define ' + envMapModeDefine : '',
			parameters.envMap ? '#define ' + envMapBlendingDefine : '',
			parameters.lightMap ? '#define USE_LIGHTMAP' : '',
			parameters.aoMap ? '#define USE_AOMAP' : '',
			parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
			parameters.bumpMap ? '#define USE_BUMPMAP' : '',
			parameters.normalMap ? '#define USE_NORMALMAP' : '',
			parameters.specularMap ? '#define USE_SPECULARMAP' : '',
			parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
			parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
			parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
			parameters.vertexColors ? '#define USE_COLOR' : '',

			parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',

			parameters.flatShading ? '#define FLAT_SHADED' : '',

			parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
			parameters.flipSided ? '#define FLIP_SIDED' : '',

			'#define NUM_CLIPPING_PLANES ' + parameters.numClippingPlanes,
			'#define UNION_CLIPPING_PLANES ' + (parameters.numClippingPlanes - parameters.numClipIntersection),

			parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
			parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',

			parameters.premultipliedAlpha ? "#define PREMULTIPLIED_ALPHA" : '',

			parameters.physicallyCorrectLights ? "#define PHYSICALLY_CORRECT_LIGHTS" : '',

			parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
			parameters.logarithmicDepthBuffer && renderer.extensions.get( 'EXT_frag_depth' ) ? '#define USE_LOGDEPTHBUF_EXT' : '',

			parameters.envMap && renderer.extensions.get( 'EXT_shader_texture_lod' ) ? '#define TEXTURE_LOD_EXT' : '',

			'uniform mat4 viewMatrix;',
			'uniform vec3 cameraPosition;',

			( parameters.toneMapping !== NoToneMapping ) ? "#define TONE_MAPPING" : '',
			( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '',  // this code is required here because it is used by the toneMapping() function defined below
			( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( "toneMapping", parameters.toneMapping ) : '',

			( parameters.outputEncoding || parameters.mapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ? ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
			parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
			parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
			parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
			parameters.outputEncoding ? getTexelEncodingFunction( "linearToOutputTexel", parameters.outputEncoding ) : '',

			parameters.depthPacking ? "#define DEPTH_PACKING " + material.depthPacking : '',

			'\n'

		].filter( filterEmptyLine ).join( '\n' );

	}

	vertexShader = parseIncludes( vertexShader, parameters );
	vertexShader = replaceLightNums( vertexShader, parameters );

	fragmentShader = parseIncludes( fragmentShader, parameters );
	fragmentShader = replaceLightNums( fragmentShader, parameters );

	if ( ! material.isShaderMaterial ) {

		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );

	}

	var vertexGlsl = prefixVertex + vertexShader;
	var fragmentGlsl = prefixFragment + fragmentShader;

	// console.log( '*VERTEX*', vertexGlsl );
	// console.log( '*FRAGMENT*', fragmentGlsl );

	var glVertexShader = WebGLShader( gl, gl.VERTEX_SHADER, vertexGlsl );
	var glFragmentShader = WebGLShader( gl, gl.FRAGMENT_SHADER, fragmentGlsl );

	gl.attachShader( program, glVertexShader );
	gl.attachShader( program, glFragmentShader );

	// Force a particular attribute to index 0.

	if ( material.index0AttributeName !== undefined ) {

		gl.bindAttribLocation( program, 0, material.index0AttributeName );

	} else if ( parameters.morphTargets === true ) {

		// programs with morphTargets displace position out of attribute 0
		gl.bindAttribLocation( program, 0, 'position' );

	}

	gl.linkProgram( program );

	var programLog = gl.getProgramInfoLog( program );
	var vertexLog = gl.getShaderInfoLog( glVertexShader );
	var fragmentLog = gl.getShaderInfoLog( glFragmentShader );

	var runnable = true;
	var haveDiagnostics = true;

	// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
	// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );

	if ( gl.getProgramParameter( program, gl.LINK_STATUS ) === false ) {

		runnable = false;

		console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), 'gl.VALIDATE_STATUS', gl.getProgramParameter( program, gl.VALIDATE_STATUS ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );

	} else if ( programLog !== '' ) {

		console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );

	} else if ( vertexLog === '' || fragmentLog === '' ) {

		haveDiagnostics = false;

	}

	if ( haveDiagnostics ) {

		this.diagnostics = {

			runnable: runnable,
			material: material,

			programLog: programLog,

			vertexShader: {

				log: vertexLog,
				prefix: prefixVertex

			},

			fragmentShader: {

				log: fragmentLog,
				prefix: prefixFragment

			}

		};

	}

	// clean up

	gl.deleteShader( glVertexShader );
	gl.deleteShader( glFragmentShader );

	// set up caching for uniform locations

	var cachedUniforms;

	this.getUniforms = function() {

		if ( cachedUniforms === undefined ) {

			cachedUniforms =
				new WebGLUniforms( gl, program, renderer );

		}

		return cachedUniforms;

	};

	// set up caching for attribute locations

	var cachedAttributes;

	this.getAttributes = function() {

		if ( cachedAttributes === undefined ) {

			cachedAttributes = fetchAttributeLocations( gl, program );

		}

		return cachedAttributes;

	};

	// free resource

	this.destroy = function() {

		gl.deleteProgram( program );
		this.program = undefined;

	};

	// DEPRECATED

	Object.defineProperties( this, {

		uniforms: {
			get: function() {

				console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
				return this.getUniforms();

			}
		},

		attributes: {
			get: function() {

				console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
				return this.getAttributes();

			}
		}

	} );


	//

	this.id = programIdCount ++;
	this.code = code;
	this.usedTimes = 1;
	this.program = program;
	this.vertexShader = glVertexShader;
	this.fragmentShader = glFragmentShader;

	return this;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLPrograms( renderer, capabilities ) {

	var programs = [];

	var shaderIDs = {
		MeshDepthMaterial: 'depth',
		MeshNormalMaterial: 'normal',
		MeshBasicMaterial: 'basic',
		MeshLambertMaterial: 'lambert',
		MeshPhongMaterial: 'phong',
		MeshToonMaterial: 'phong',
		MeshStandardMaterial: 'physical',
		MeshPhysicalMaterial: 'physical',
		LineBasicMaterial: 'basic',
		LineDashedMaterial: 'dashed',
		PointsMaterial: 'points'
	};

	var parameterNames = [
		"precision", "supportsVertexTextures", "map", "mapEncoding", "envMap", "envMapMode", "envMapEncoding",
		"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "displacementMap", "specularMap",
		"roughnessMap", "metalnessMap", "gradientMap",
		"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
		"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
		"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
		"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
		"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
		"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
		"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking"
	];


	function allocateBones( object ) {

		if ( capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture ) {

			return 1024;

		} else {

			// default for when object is not specified
			// ( for example when prebuilding shader to be used with multiple objects )
			//
			//  - leave some extra space for other uniforms
			//  - limit here is ANGLE's 254 max uniform vectors
			//    (up to 54 should be safe)

			var nVertexUniforms = capabilities.maxVertexUniforms;
			var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );

			var maxBones = nVertexMatrices;

			if ( object !== undefined && (object && object.isSkinnedMesh) ) {

				maxBones = Math.min( object.skeleton.bones.length, maxBones );

				if ( maxBones < object.skeleton.bones.length ) {

					console.warn( 'WebGLRenderer: too many bones - ' + object.skeleton.bones.length + ', this GPU supports just ' + maxBones + ' (try OpenGL instead of ANGLE)' );

				}

			}

			return maxBones;

		}

	}

	function getTextureEncodingFromMap( map, gammaOverrideLinear ) {

		var encoding;

		if ( ! map ) {

			encoding = LinearEncoding;

		} else if ( map.isTexture ) {

			encoding = map.encoding;

		} else if ( map.isWebGLRenderTarget ) {

			console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
			encoding = map.texture.encoding;

		}

		// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
		if ( encoding === LinearEncoding && gammaOverrideLinear ) {

			encoding = GammaEncoding;

		}

		return encoding;

	}

	this.getParameters = function ( material, lights, fog, nClipPlanes, nClipIntersection, object ) {

		var shaderID = shaderIDs[ material.type ];

		// heuristics to create shader parameters according to lights in the scene
		// (not to blow over maxLights budget)

		var maxBones = allocateBones( object );
		var precision = renderer.getPrecision();

		if ( material.precision !== null ) {

			precision = capabilities.getMaxPrecision( material.precision );

			if ( precision !== material.precision ) {

				console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );

			}

		}

		var currentRenderTarget = renderer.getCurrentRenderTarget();

		var parameters = {

			shaderID: shaderID,

			precision: precision,
			supportsVertexTextures: capabilities.vertexTextures,
			outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
			map: !! material.map,
			mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
			envMap: !! material.envMap,
			envMapMode: material.envMap && material.envMap.mapping,
			envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
			envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
			lightMap: !! material.lightMap,
			aoMap: !! material.aoMap,
			emissiveMap: !! material.emissiveMap,
			emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
			bumpMap: !! material.bumpMap,
			normalMap: !! material.normalMap,
			displacementMap: !! material.displacementMap,
			roughnessMap: !! material.roughnessMap,
			metalnessMap: !! material.metalnessMap,
			specularMap: !! material.specularMap,
			alphaMap: !! material.alphaMap,

			gradientMap: !! material.gradientMap,

			combine: material.combine,

			vertexColors: material.vertexColors,

			fog: !! fog,
			useFog: material.fog,
			fogExp: (fog && fog.isFogExp2),

			flatShading: material.shading === FlatShading,

			sizeAttenuation: material.sizeAttenuation,
			logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,

			skinning: material.skinning,
			maxBones: maxBones,
			useVertexTexture: capabilities.floatVertexTextures && object && object.skeleton && object.skeleton.useVertexTexture,

			morphTargets: material.morphTargets,
			morphNormals: material.morphNormals,
			maxMorphTargets: renderer.maxMorphTargets,
			maxMorphNormals: renderer.maxMorphNormals,

			numDirLights: lights.directional.length,
			numPointLights: lights.point.length,
			numSpotLights: lights.spot.length,
			numRectAreaLights: lights.rectArea.length,
			numHemiLights: lights.hemi.length,

			numClippingPlanes: nClipPlanes,
			numClipIntersection: nClipIntersection,

			shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && lights.shadows.length > 0,
			shadowMapType: renderer.shadowMap.type,

			toneMapping: renderer.toneMapping,
			physicallyCorrectLights: renderer.physicallyCorrectLights,

			premultipliedAlpha: material.premultipliedAlpha,

			alphaTest: material.alphaTest,
			doubleSided: material.side === DoubleSide,
			flipSided: material.side === BackSide,

			depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false

		};

		return parameters;

	};

	this.getProgramCode = function ( material, parameters ) {

		var array = [];

		if ( parameters.shaderID ) {

			array.push( parameters.shaderID );

		} else {

			array.push( material.fragmentShader );
			array.push( material.vertexShader );

		}

		if ( material.defines !== undefined ) {

			for ( var name in material.defines ) {

				array.push( name );
				array.push( material.defines[ name ] );

			}

		}

		for ( var i = 0; i < parameterNames.length; i ++ ) {

			array.push( parameters[ parameterNames[ i ] ] );

		}

		return array.join();

	};

	this.acquireProgram = function ( material, parameters, code ) {

		var program;

		// Check if code has been already compiled
		for ( var p = 0, pl = programs.length; p < pl; p ++ ) {

			var programInfo = programs[ p ];

			if ( programInfo.code === code ) {

				program = programInfo;
				++ program.usedTimes;

				break;

			}

		}

		if ( program === undefined ) {

			program = new WebGLProgram( renderer, code, material, parameters );
			programs.push( program );

		}

		return program;

	};

	this.releaseProgram = function( program ) {

		if ( -- program.usedTimes === 0 ) {

			// Remove from unordered set
			var i = programs.indexOf( program );
			programs[ i ] = programs[ programs.length - 1 ];
			programs.pop();

			// Free WebGL resources
			program.destroy();

		}

	};

	// Exposed for resource monitoring & error feedback via renderer.info:
	this.programs = programs;

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLGeometries( gl, properties, info ) {

	var geometries = {};

	function onGeometryDispose( event ) {

		var geometry = event.target;
		var buffergeometry = geometries[ geometry.id ];

		if ( buffergeometry.index !== null ) {

			deleteAttribute( buffergeometry.index );

		}

		deleteAttributes( buffergeometry.attributes );

		geometry.removeEventListener( 'dispose', onGeometryDispose );

		delete geometries[ geometry.id ];

		// TODO

		var property = properties.get( geometry );

		if ( property.wireframe ) {

			deleteAttribute( property.wireframe );

		}

		properties.delete( geometry );

		var bufferproperty = properties.get( buffergeometry );

		if ( bufferproperty.wireframe ) {

			deleteAttribute( bufferproperty.wireframe );

		}

		properties.delete( buffergeometry );

		//

		info.memory.geometries --;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function deleteAttribute( attribute ) {

		var buffer = getAttributeBuffer( attribute );

		if ( buffer !== undefined ) {

			gl.deleteBuffer( buffer );
			removeAttributeBuffer( attribute );

		}

	}

	function deleteAttributes( attributes ) {

		for ( var name in attributes ) {

			deleteAttribute( attributes[ name ] );

		}

	}

	function removeAttributeBuffer( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) {

			properties.delete( attribute.data );

		} else {

			properties.delete( attribute );

		}

	}

	return {

		get: function ( object ) {

			var geometry = object.geometry;

			if ( geometries[ geometry.id ] !== undefined ) {

				return geometries[ geometry.id ];

			}

			geometry.addEventListener( 'dispose', onGeometryDispose );

			var buffergeometry;

			if ( geometry.isBufferGeometry ) {

				buffergeometry = geometry;

			} else if ( geometry.isGeometry ) {

				if ( geometry._bufferGeometry === undefined ) {

					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );

				}

				buffergeometry = geometry._bufferGeometry;

			}

			geometries[ geometry.id ] = buffergeometry;

			info.memory.geometries ++;

			return buffergeometry;

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLObjects( gl, properties, info ) {

	var geometries = new WebGLGeometries( gl, properties, info );

	//

	function update( object ) {

		// TODO: Avoid updating twice (when using shadowMap). Maybe add frame counter.

		var geometry = geometries.get( object );

		if ( object.geometry.isGeometry ) {

			geometry.updateFromObject( object );

		}

		var index = geometry.index;
		var attributes = geometry.attributes;

		if ( index !== null ) {

			updateAttribute( index, gl.ELEMENT_ARRAY_BUFFER );

		}

		for ( var name in attributes ) {

			updateAttribute( attributes[ name ], gl.ARRAY_BUFFER );

		}

		// morph targets

		var morphAttributes = geometry.morphAttributes;

		for ( var name in morphAttributes ) {

			var array = morphAttributes[ name ];

			for ( var i = 0, l = array.length; i < l; i ++ ) {

				updateAttribute( array[ i ], gl.ARRAY_BUFFER );

			}

		}

		return geometry;

	}

	function updateAttribute( attribute, bufferType ) {

		var data = ( attribute.isInterleavedBufferAttribute ) ? attribute.data : attribute;

		var attributeProperties = properties.get( data );

		if ( attributeProperties.__webglBuffer === undefined ) {

			createBuffer( attributeProperties, data, bufferType );

		} else if ( attributeProperties.version !== data.version ) {

			updateBuffer( attributeProperties, data, bufferType );

		}

	}

	function createBuffer( attributeProperties, data, bufferType ) {

		attributeProperties.__webglBuffer = gl.createBuffer();
		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		var usage = data.dynamic ? gl.DYNAMIC_DRAW : gl.STATIC_DRAW;

		gl.bufferData( bufferType, data.array, usage );

		var type = gl.FLOAT;
		var array = data.array;

		if ( array instanceof Float32Array ) {

			type = gl.FLOAT;

		} else if ( array instanceof Float64Array ) {

			console.warn( "Unsupported data buffer format: Float64Array" );

		} else if ( array instanceof Uint16Array ) {

			type = gl.UNSIGNED_SHORT;

		} else if ( array instanceof Int16Array ) {

			type = gl.SHORT;

		} else if ( array instanceof Uint32Array ) {

			type = gl.UNSIGNED_INT;

		} else if ( array instanceof Int32Array ) {

			type = gl.INT;

		} else if ( array instanceof Int8Array ) {

			type = gl.BYTE;

		} else if ( array instanceof Uint8Array ) {

			type = gl.UNSIGNED_BYTE;

		}

		attributeProperties.bytesPerElement = array.BYTES_PER_ELEMENT;
		attributeProperties.type = type;
		attributeProperties.version = data.version;

		data.onUploadCallback();

	}

	function updateBuffer( attributeProperties, data, bufferType ) {

		gl.bindBuffer( bufferType, attributeProperties.__webglBuffer );

		if ( data.dynamic === false ) {

			gl.bufferData( bufferType, data.array, gl.STATIC_DRAW );

		} else if ( data.updateRange.count === - 1 ) {

			// Not using update ranges

			gl.bufferSubData( bufferType, 0, data.array );

		} else if ( data.updateRange.count === 0 ) {

			console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );

		} else {

			gl.bufferSubData( bufferType, data.updateRange.offset * data.array.BYTES_PER_ELEMENT,
							  data.array.subarray( data.updateRange.offset, data.updateRange.offset + data.updateRange.count ) );

			data.updateRange.count = 0; // reset range

		}

		attributeProperties.version = data.version;

	}

	function getAttributeBuffer( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) {

			return properties.get( attribute.data ).__webglBuffer;

		}

		return properties.get( attribute ).__webglBuffer;

	}

	function getAttributeProperties( attribute ) {

		if ( attribute.isInterleavedBufferAttribute ) {

			return properties.get( attribute.data );

		}

		return properties.get( attribute );

	}

	function getWireframeAttribute( geometry ) {

		var property = properties.get( geometry );

		if ( property.wireframe !== undefined ) {

			return property.wireframe;

		}

		var indices = [];

		var index = geometry.index;
		var attributes = geometry.attributes;
		var position = attributes.position;

		// console.time( 'wireframe' );

		if ( index !== null ) {

			var edges = {};
			var array = index.array;

			for ( var i = 0, l = array.length; i < l; i += 3 ) {

				var a = array[ i + 0 ];
				var b = array[ i + 1 ];
				var c = array[ i + 2 ];

				indices.push( a, b, b, c, c, a );

			}

		} else {

			var array = attributes.position.array;

			for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {

				var a = i + 0;
				var b = i + 1;
				var c = i + 2;

				indices.push( a, b, b, c, c, a );

			}

		}

		// console.timeEnd( 'wireframe' );

		var TypeArray = position.count > 65535 ? Uint32Array : Uint16Array;
		var attribute = new BufferAttribute( new TypeArray( indices ), 1 );

		updateAttribute( attribute, gl.ELEMENT_ARRAY_BUFFER );

		property.wireframe = attribute;

		return attribute;

	}

	return {

		getAttributeBuffer: getAttributeBuffer,
		getAttributeProperties: getAttributeProperties,
		getWireframeAttribute: getWireframeAttribute,

		update: update

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, info ) {

	var _infoMemory = info.memory;
	var _isWebGL2 = ( typeof WebGL2RenderingContext !== 'undefined' && _gl instanceof WebGL2RenderingContext );

	//

	function clampToMaxSize( image, maxSize ) {

		if ( image.width > maxSize || image.height > maxSize ) {

			// Warning: Scaling through the canvas will only work with images that use
			// premultiplied alpha.

			var scale = maxSize / Math.max( image.width, image.height );

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = Math.floor( image.width * scale );
			canvas.height = Math.floor( image.height * scale );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, image.width, image.height, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is too big (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function isPowerOfTwo( image ) {

		return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );

	}

	function makePowerOfTwo( image ) {

		if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement ) {

			var canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
			canvas.width = _Math.nearestPowerOfTwo( image.width );
			canvas.height = _Math.nearestPowerOfTwo( image.height );

			var context = canvas.getContext( '2d' );
			context.drawImage( image, 0, 0, canvas.width, canvas.height );

			console.warn( 'THREE.WebGLRenderer: image is not power of two (' + image.width + 'x' + image.height + '). Resized to ' + canvas.width + 'x' + canvas.height, image );

			return canvas;

		}

		return image;

	}

	function textureNeedsPowerOfTwo( texture ) {

		return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
			( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );

	}

	// Fallback filters for non-power-of-2 textures

	function filterFallback( f ) {

		if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {

			return _gl.NEAREST;

		}

		return _gl.LINEAR;

	}

	//

	function onTextureDispose( event ) {

		var texture = event.target;

		texture.removeEventListener( 'dispose', onTextureDispose );

		deallocateTexture( texture );

		_infoMemory.textures --;


	}

	function onRenderTargetDispose( event ) {

		var renderTarget = event.target;

		renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );

		deallocateRenderTarget( renderTarget );

		_infoMemory.textures --;

	}

	//

	function deallocateTexture( texture ) {

		var textureProperties = properties.get( texture );

		if ( texture.image && textureProperties.__image__webglTextureCube ) {

			// cube texture

			_gl.deleteTexture( textureProperties.__image__webglTextureCube );

		} else {

			// 2D texture

			if ( textureProperties.__webglInit === undefined ) return;

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		// remove all webgl properties
		properties.delete( texture );

	}

	function deallocateRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		if ( ! renderTarget ) return;

		if ( textureProperties.__webglTexture !== undefined ) {

			_gl.deleteTexture( textureProperties.__webglTexture );

		}

		if ( renderTarget.depthTexture ) {

			renderTarget.depthTexture.dispose();

		}

		if ( renderTarget.isWebGLRenderTargetCube ) {

			for ( var i = 0; i < 6; i ++ ) {

				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );

			}

		} else {

			_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
			if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );

		}

		properties.delete( renderTarget.texture );
		properties.delete( renderTarget );

	}

	//



	function setTexture2D( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

			var image = texture.image;

			if ( image === undefined ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined', texture );

			} else if ( image.complete === false ) {

				console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete', texture );

			} else {

				uploadTexture( textureProperties, texture, slot );
				return;

			}

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

	}

	function setTextureCube( texture, slot ) {

		var textureProperties = properties.get( texture );

		if ( texture.image.length === 6 ) {

			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {

				if ( ! textureProperties.__image__webglTextureCube ) {

					texture.addEventListener( 'dispose', onTextureDispose );

					textureProperties.__image__webglTextureCube = _gl.createTexture();

					_infoMemory.textures ++;

				}

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

				_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );

				var isCompressed = ( texture && texture.isCompressedTexture );
				var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );

				var cubeImage = [];

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed && ! isDataTexture ) {

						cubeImage[ i ] = clampToMaxSize( texture.image[ i ], capabilities.maxCubemapSize );

					} else {

						cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];

					}

				}

				var image = cubeImage[ 0 ],
				isPowerOfTwoImage = isPowerOfTwo( image ),
				glFormat = paramThreeToGL( texture.format ),
				glType = paramThreeToGL( texture.type );

				setTextureParameters( _gl.TEXTURE_CUBE_MAP, texture, isPowerOfTwoImage );

				for ( var i = 0; i < 6; i ++ ) {

					if ( ! isCompressed ) {

						if ( isDataTexture ) {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );

						} else {

							state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, 0, glFormat, glFormat, glType, cubeImage[ i ] );

						}

					} else {

						var mipmap, mipmaps = cubeImage[ i ].mipmaps;

						for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {

							mipmap = mipmaps[ j ];

							if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

								if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

									state.compressedTexImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

								} else {

									console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()" );

								}

							} else {

								state.texImage2D( _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i, j, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

							}

						}

					}

				}

				if ( texture.generateMipmaps && isPowerOfTwoImage ) {

					_gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );

				}

				textureProperties.__version = texture.version;

				if ( texture.onUpdate ) texture.onUpdate( texture );

			} else {

				state.activeTexture( _gl.TEXTURE0 + slot );
				state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__image__webglTextureCube );

			}

		}

	}

	function setTextureCubeDynamic( texture, slot ) {

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_CUBE_MAP, properties.get( texture ).__webglTexture );

	}

	function setTextureParameters( textureType, texture, isPowerOfTwoImage ) {

		var extension;

		if ( isPowerOfTwoImage ) {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, paramThreeToGL( texture.wrapS ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, paramThreeToGL( texture.wrapT ) );

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, paramThreeToGL( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, paramThreeToGL( texture.minFilter ) );

		} else {

			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_S, _gl.CLAMP_TO_EDGE );
			_gl.texParameteri( textureType, _gl.TEXTURE_WRAP_T, _gl.CLAMP_TO_EDGE );

			if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.', texture );

			}

			_gl.texParameteri( textureType, _gl.TEXTURE_MAG_FILTER, filterFallback( texture.magFilter ) );
			_gl.texParameteri( textureType, _gl.TEXTURE_MIN_FILTER, filterFallback( texture.minFilter ) );

			if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {

				console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.', texture );

			}

		}

		extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension ) {

			if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
			if ( texture.type === HalfFloatType && extensions.get( 'OES_texture_half_float_linear' ) === null ) return;

			if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {

				_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
				properties.get( texture ).__currentAnisotropy = texture.anisotropy;

			}

		}

	}

	function uploadTexture( textureProperties, texture, slot ) {

		if ( textureProperties.__webglInit === undefined ) {

			textureProperties.__webglInit = true;

			texture.addEventListener( 'dispose', onTextureDispose );

			textureProperties.__webglTexture = _gl.createTexture();

			_infoMemory.textures ++;

		}

		state.activeTexture( _gl.TEXTURE0 + slot );
		state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );

		_gl.pixelStorei( _gl.UNPACK_FLIP_Y_WEBGL, texture.flipY );
		_gl.pixelStorei( _gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, texture.premultiplyAlpha );
		_gl.pixelStorei( _gl.UNPACK_ALIGNMENT, texture.unpackAlignment );

		var image = clampToMaxSize( texture.image, capabilities.maxTextureSize );

		if ( textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( image ) === false ) {

			image = makePowerOfTwo( image );

		}

		var isPowerOfTwoImage = isPowerOfTwo( image ),
		glFormat = paramThreeToGL( texture.format ),
		glType = paramThreeToGL( texture.type );

		setTextureParameters( _gl.TEXTURE_2D, texture, isPowerOfTwoImage );

		var mipmap, mipmaps = texture.mipmaps;

		if ( texture.isDepthTexture ) {

			// populate depth texture with dummy data

			var internalFormat = _gl.DEPTH_COMPONENT;

			if ( texture.type === FloatType ) {

				if ( !_isWebGL2 ) throw new Error('Float Depth Texture only supported in WebGL2.0');
				internalFormat = _gl.DEPTH_COMPONENT32F;

			} else if ( _isWebGL2 ) {

				// WebGL 2.0 requires signed internalformat for glTexImage2D
				internalFormat = _gl.DEPTH_COMPONENT16;

			}

			if ( texture.format === DepthFormat && internalFormat === _gl.DEPTH_COMPONENT ) {

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {

				        console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );

					texture.type = UnsignedShortType;
					glType = paramThreeToGL( texture.type );

				}

			}

			// Depth stencil textures need the DEPTH_STENCIL internal format
			// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
			if ( texture.format === DepthStencilFormat ) {

				internalFormat = _gl.DEPTH_STENCIL;

				// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
				// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.type !== UnsignedInt248Type ) {

				        console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );

					texture.type = UnsignedInt248Type;
					glType = paramThreeToGL( texture.type );

				}

			}

			state.texImage2D( _gl.TEXTURE_2D, 0, internalFormat, image.width, image.height, 0, glFormat, glType, null );

		} else if ( texture.isDataTexture ) {

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, image.width, image.height, 0, glFormat, glType, image.data );

			}

		} else if ( texture.isCompressedTexture ) {

			for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

				mipmap = mipmaps[ i ];

				if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {

					if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {

						state.compressedTexImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, mipmap.data );

					} else {

						console.warn( "THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()" );

					}

				} else {

					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );

				}

			}

		} else {

			// regular Texture (image, video, canvas)

			// use manually created mipmaps if available
			// if there are no manual mipmaps
			// set 0 level mipmap and then use GL to generate other mipmap levels

			if ( mipmaps.length > 0 && isPowerOfTwoImage ) {

				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {

					mipmap = mipmaps[ i ];
					state.texImage2D( _gl.TEXTURE_2D, i, glFormat, glFormat, glType, mipmap );

				}

				texture.generateMipmaps = false;

			} else {

				state.texImage2D( _gl.TEXTURE_2D, 0, glFormat, glFormat, glType, image );

			}

		}

		if ( texture.generateMipmaps && isPowerOfTwoImage ) _gl.generateMipmap( _gl.TEXTURE_2D );

		textureProperties.__version = texture.version;

		if ( texture.onUpdate ) texture.onUpdate( texture );

	}

	// Render targets

	// Setup storage for target texture and bind it to correct framebuffer
	function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {

		var glFormat = paramThreeToGL( renderTarget.texture.format );
		var glType = paramThreeToGL( renderTarget.texture.type );
		state.texImage2D( textureTarget, 0, glFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
		_gl.framebufferTexture2D( _gl.FRAMEBUFFER, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
	function setupRenderBufferStorage( renderbuffer, renderTarget ) {

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, renderbuffer );

		if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_COMPONENT16, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {

			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.DEPTH_STENCIL, renderTarget.width, renderTarget.height );
			_gl.framebufferRenderbuffer( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.RENDERBUFFER, renderbuffer );

		} else {

			// FIXME: We don't support !depth !stencil
			_gl.renderbufferStorage( _gl.RENDERBUFFER, _gl.RGBA4, renderTarget.width, renderTarget.height );

		}

		_gl.bindRenderbuffer( _gl.RENDERBUFFER, null );

	}

	// Setup resources for a Depth Texture for a FBO (needs an extension)
	function setupDepthTexture( framebuffer, renderTarget ) {

		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
		if ( isCube ) throw new Error('Depth Texture with cube render targets is not supported!');

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

		if ( !( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {

			throw new Error('renderTarget.depthTexture must be an instance of THREE.DepthTexture');

		}

		// upload an empty depth texture with framebuffer size
		if ( !properties.get( renderTarget.depthTexture ).__webglTexture ||
				renderTarget.depthTexture.image.width !== renderTarget.width ||
				renderTarget.depthTexture.image.height !== renderTarget.height ) {
			renderTarget.depthTexture.image.width = renderTarget.width;
			renderTarget.depthTexture.image.height = renderTarget.height;
			renderTarget.depthTexture.needsUpdate = true;
		}

		setTexture2D( renderTarget.depthTexture, 0 );

		var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;

		if ( renderTarget.depthTexture.format === DepthFormat ) {

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

		} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {

			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.DEPTH_STENCIL_ATTACHMENT, _gl.TEXTURE_2D, webglDepthTexture, 0 );

		} else {

			throw new Error('Unknown depthTexture format')

		}

	}

	// Setup GL resources for a non-texture depth buffer
	function setupDepthRenderbuffer( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );

		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );

		if ( renderTarget.depthTexture ) {

			if ( isCube ) throw new Error('target.depthTexture not supported in Cube render targets');

			setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );

		} else {

			if ( isCube ) {

				renderTargetProperties.__webglDepthbuffer = [];

				for ( var i = 0; i < 6; i ++ ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer[ i ] );
					renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );

				}

			} else {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, renderTargetProperties.__webglFramebuffer );
				renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
				setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );

			}

		}

		_gl.bindFramebuffer( _gl.FRAMEBUFFER, null );

	}

	// Set up GL resources for the render target
	function setupRenderTarget( renderTarget ) {

		var renderTargetProperties = properties.get( renderTarget );
		var textureProperties = properties.get( renderTarget.texture );

		renderTarget.addEventListener( 'dispose', onRenderTargetDispose );

		textureProperties.__webglTexture = _gl.createTexture();

		_infoMemory.textures ++;

		var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
		var isTargetPowerOfTwo = isPowerOfTwo( renderTarget );

		// Setup framebuffer

		if ( isCube ) {

			renderTargetProperties.__webglFramebuffer = [];

			for ( var i = 0; i < 6; i ++ ) {

				renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();

			}

		} else {

			renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();

		}

		// Setup color buffer

		if ( isCube ) {

			state.bindTexture( _gl.TEXTURE_CUBE_MAP, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_CUBE_MAP, renderTarget.texture, isTargetPowerOfTwo );

			for ( var i = 0; i < 6; i ++ ) {

				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + i );

			}

			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_CUBE_MAP );
			state.bindTexture( _gl.TEXTURE_CUBE_MAP, null );

		} else {

			state.bindTexture( _gl.TEXTURE_2D, textureProperties.__webglTexture );
			setTextureParameters( _gl.TEXTURE_2D, renderTarget.texture, isTargetPowerOfTwo );
			setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_2D );

			if ( renderTarget.texture.generateMipmaps && isTargetPowerOfTwo ) _gl.generateMipmap( _gl.TEXTURE_2D );
			state.bindTexture( _gl.TEXTURE_2D, null );

		}

		// Setup depth and stencil buffers

		if ( renderTarget.depthBuffer ) {

			setupDepthRenderbuffer( renderTarget );

		}

	}

	function updateRenderTargetMipmap( renderTarget ) {

		var texture = renderTarget.texture;

		if ( texture.generateMipmaps && isPowerOfTwo( renderTarget ) &&
				texture.minFilter !== NearestFilter &&
				texture.minFilter !== LinearFilter ) {

			var target = (renderTarget && renderTarget.isWebGLRenderTargetCube) ? _gl.TEXTURE_CUBE_MAP : _gl.TEXTURE_2D;
			var webglTexture = properties.get( texture ).__webglTexture;

			state.bindTexture( target, webglTexture );
			_gl.generateMipmap( target );
			state.bindTexture( target, null );

		}

	}

	this.setTexture2D = setTexture2D;
	this.setTextureCube = setTextureCube;
	this.setTextureCubeDynamic = setTextureCubeDynamic;
	this.setupRenderTarget = setupRenderTarget;
	this.updateRenderTargetMipmap = updateRenderTargetMipmap;

}

/**
 * @author fordacious / fordacious.github.io
 */

function WebGLProperties() {

	var properties = {};

	return {

		get: function ( object ) {

			var uuid = object.uuid;
			var map = properties[ uuid ];

			if ( map === undefined ) {

				map = {};
				properties[ uuid ] = map;

			}

			return map;

		},

		delete: function ( object ) {

			delete properties[ object.uuid ];

		},

		clear: function () {

			properties = {};

		}

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLState( gl, extensions, paramThreeToGL ) {

	function ColorBuffer() {

		var locked = false;

		var color = new Vector4();
		var currentColorMask = null;
		var currentColorClear = new Vector4();

		return {

			setMask: function ( colorMask ) {

				if ( currentColorMask !== colorMask && ! locked ) {

					gl.colorMask( colorMask, colorMask, colorMask, colorMask );
					currentColorMask = colorMask;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( r, g, b, a, premultipliedAlpha ) {

				if ( premultipliedAlpha === true ) {

					r *= a; g *= a; b *= a;

				}

				color.set( r, g, b, a );

				if ( currentColorClear.equals( color ) === false ) {

					gl.clearColor( r, g, b, a );
					currentColorClear.copy( color );

				}

			},

			reset: function () {

				locked = false;

				currentColorMask = null;
				currentColorClear.set( 0, 0, 0, 1 );

			}

		};

	}

	function DepthBuffer() {

		var locked = false;

		var currentDepthMask = null;
		var currentDepthFunc = null;
		var currentDepthClear = null;

		return {

			setTest: function ( depthTest ) {

				if ( depthTest ) {

					enable( gl.DEPTH_TEST );

				} else {

					disable( gl.DEPTH_TEST );

				}

			},

			setMask: function ( depthMask ) {

				if ( currentDepthMask !== depthMask && ! locked ) {

					gl.depthMask( depthMask );
					currentDepthMask = depthMask;

				}

			},

			setFunc: function ( depthFunc ) {

				if ( currentDepthFunc !== depthFunc ) {

					if ( depthFunc ) {

						switch ( depthFunc ) {

							case NeverDepth:

								gl.depthFunc( gl.NEVER );
								break;

							case AlwaysDepth:

								gl.depthFunc( gl.ALWAYS );
								break;

							case LessDepth:

								gl.depthFunc( gl.LESS );
								break;

							case LessEqualDepth:

								gl.depthFunc( gl.LEQUAL );
								break;

							case EqualDepth:

								gl.depthFunc( gl.EQUAL );
								break;

							case GreaterEqualDepth:

								gl.depthFunc( gl.GEQUAL );
								break;

							case GreaterDepth:

								gl.depthFunc( gl.GREATER );
								break;

							case NotEqualDepth:

								gl.depthFunc( gl.NOTEQUAL );
								break;

							default:

								gl.depthFunc( gl.LEQUAL );

						}

					} else {

						gl.depthFunc( gl.LEQUAL );

					}

					currentDepthFunc = depthFunc;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( depth ) {

				if ( currentDepthClear !== depth ) {

					gl.clearDepth( depth );
					currentDepthClear = depth;

				}

			},

			reset: function () {

				locked = false;

				currentDepthMask = null;
				currentDepthFunc = null;
				currentDepthClear = null;

			}

		};

	}

	function StencilBuffer() {

		var locked = false;

		var currentStencilMask = null;
		var currentStencilFunc = null;
		var currentStencilRef = null;
		var currentStencilFuncMask = null;
		var currentStencilFail = null;
		var currentStencilZFail = null;
		var currentStencilZPass = null;
		var currentStencilClear = null;

		return {

			setTest: function ( stencilTest ) {

				if ( stencilTest ) {

					enable( gl.STENCIL_TEST );

				} else {

					disable( gl.STENCIL_TEST );

				}

			},

			setMask: function ( stencilMask ) {

				if ( currentStencilMask !== stencilMask && ! locked ) {

					gl.stencilMask( stencilMask );
					currentStencilMask = stencilMask;

				}

			},

			setFunc: function ( stencilFunc, stencilRef, stencilMask ) {

				if ( currentStencilFunc !== stencilFunc ||
				     currentStencilRef 	!== stencilRef 	||
				     currentStencilFuncMask !== stencilMask ) {

					gl.stencilFunc( stencilFunc, stencilRef, stencilMask );

					currentStencilFunc = stencilFunc;
					currentStencilRef = stencilRef;
					currentStencilFuncMask = stencilMask;

				}

			},

			setOp: function ( stencilFail, stencilZFail, stencilZPass ) {

				if ( currentStencilFail	 !== stencilFail 	||
				     currentStencilZFail !== stencilZFail ||
				     currentStencilZPass !== stencilZPass ) {

					gl.stencilOp( stencilFail, stencilZFail, stencilZPass );

					currentStencilFail = stencilFail;
					currentStencilZFail = stencilZFail;
					currentStencilZPass = stencilZPass;

				}

			},

			setLocked: function ( lock ) {

				locked = lock;

			},

			setClear: function ( stencil ) {

				if ( currentStencilClear !== stencil ) {

					gl.clearStencil( stencil );
					currentStencilClear = stencil;

				}

			},

			reset: function () {

				locked = false;

				currentStencilMask = null;
				currentStencilFunc = null;
				currentStencilRef = null;
				currentStencilFuncMask = null;
				currentStencilFail = null;
				currentStencilZFail = null;
				currentStencilZPass = null;
				currentStencilClear = null;

			}

		};

	}

	//

	var colorBuffer = new ColorBuffer();
	var depthBuffer = new DepthBuffer();
	var stencilBuffer = new StencilBuffer();

	var maxVertexAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var newAttributes = new Uint8Array( maxVertexAttributes );
	var enabledAttributes = new Uint8Array( maxVertexAttributes );
	var attributeDivisors = new Uint8Array( maxVertexAttributes );

	var capabilities = {};

	var compressedTextureFormats = null;

	var currentBlending = null;
	var currentBlendEquation = null;
	var currentBlendSrc = null;
	var currentBlendDst = null;
	var currentBlendEquationAlpha = null;
	var currentBlendSrcAlpha = null;
	var currentBlendDstAlpha = null;
	var currentPremultipledAlpha = false;

	var currentFlipSided = null;
	var currentCullFace = null;

	var currentLineWidth = null;

	var currentPolygonOffsetFactor = null;
	var currentPolygonOffsetUnits = null;

	var currentScissorTest = null;

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );

	var version = parseFloat( /^WebGL\ ([0-9])/.exec( gl.getParameter( gl.VERSION ) )[ 1 ] );
	var lineWidthAvailable = parseFloat( version ) >= 1.0;

	var currentTextureSlot = null;
	var currentBoundTextures = {};

	var currentScissor = new Vector4();
	var currentViewport = new Vector4();

	function createTexture( type, target, count ) {

		var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
		var texture = gl.createTexture();

		gl.bindTexture( type, texture );
		gl.texParameteri( type, gl.TEXTURE_MIN_FILTER, gl.NEAREST );
		gl.texParameteri( type, gl.TEXTURE_MAG_FILTER, gl.NEAREST );

		for ( var i = 0; i < count; i ++ ) {

			gl.texImage2D( target + i, 0, gl.RGBA, 1, 1, 0, gl.RGBA, gl.UNSIGNED_BYTE, data );

		}

		return texture;

	}

	var emptyTextures = {};
	emptyTextures[ gl.TEXTURE_2D ] = createTexture( gl.TEXTURE_2D, gl.TEXTURE_2D, 1 );
	emptyTextures[ gl.TEXTURE_CUBE_MAP ] = createTexture( gl.TEXTURE_CUBE_MAP, gl.TEXTURE_CUBE_MAP_POSITIVE_X, 6 );

	//

	function init() {

		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );

		enable( gl.DEPTH_TEST );
		setDepthFunc( LessEqualDepth );

		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( gl.CULL_FACE );

		enable( gl.BLEND );
		setBlending( NormalBlending );

	}

	function initAttributes() {

		for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {

			newAttributes[ i ] = 0;

		}

	}

	function enableAttribute( attribute ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== 0 ) {

			var extension = extensions.get( 'ANGLE_instanced_arrays' );

			extension.vertexAttribDivisorANGLE( attribute, 0 );
			attributeDivisors[ attribute ] = 0;

		}

	}

	function enableAttributeAndDivisor( attribute, meshPerAttribute, extension ) {

		newAttributes[ attribute ] = 1;

		if ( enabledAttributes[ attribute ] === 0 ) {

			gl.enableVertexAttribArray( attribute );
			enabledAttributes[ attribute ] = 1;

		}

		if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {

			extension.vertexAttribDivisorANGLE( attribute, meshPerAttribute );
			attributeDivisors[ attribute ] = meshPerAttribute;

		}

	}

	function disableUnusedAttributes() {

		for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {

			if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

	}

	function enable( id ) {

		if ( capabilities[ id ] !== true ) {

			gl.enable( id );
			capabilities[ id ] = true;

		}

	}

	function disable( id ) {

		if ( capabilities[ id ] !== false ) {

			gl.disable( id );
			capabilities[ id ] = false;

		}

	}

	function getCompressedTextureFormats() {

		if ( compressedTextureFormats === null ) {

			compressedTextureFormats = [];

			if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
			     extensions.get( 'WEBGL_compressed_texture_etc1' ) ) {

				var formats = gl.getParameter( gl.COMPRESSED_TEXTURE_FORMATS );

				for ( var i = 0; i < formats.length; i ++ ) {

					compressedTextureFormats.push( formats[ i ] );

				}

			}

		}

		return compressedTextureFormats;

	}

	function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {

		if ( blending !== NoBlending ) {

			enable( gl.BLEND );

		} else {

			disable( gl.BLEND );

		}

		if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {

			if ( blending === AdditiveBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ONE, gl.ONE, gl.ONE, gl.ONE );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.SRC_ALPHA, gl.ONE );

				}

			} else if ( blending === SubtractiveBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ZERO, gl.ZERO, gl.ONE_MINUS_SRC_COLOR, gl.ONE_MINUS_SRC_ALPHA );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.ONE_MINUS_SRC_COLOR );

				}

			} else if ( blending === MultiplyBlending ) {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ZERO, gl.SRC_COLOR, gl.ZERO, gl.SRC_ALPHA );

				} else {

					gl.blendEquation( gl.FUNC_ADD );
					gl.blendFunc( gl.ZERO, gl.SRC_COLOR );

				}

			} else {

				if ( premultipliedAlpha ) {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.ONE, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				} else {

					gl.blendEquationSeparate( gl.FUNC_ADD, gl.FUNC_ADD );
					gl.blendFuncSeparate( gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA, gl.ONE, gl.ONE_MINUS_SRC_ALPHA );

				}

			}

			currentBlending = blending;
			currentPremultipledAlpha = premultipliedAlpha;

		}

		if ( blending === CustomBlending ) {

			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;

			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {

				gl.blendEquationSeparate( paramThreeToGL( blendEquation ), paramThreeToGL( blendEquationAlpha ) );

				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;

			}

			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {

				gl.blendFuncSeparate( paramThreeToGL( blendSrc ), paramThreeToGL( blendDst ), paramThreeToGL( blendSrcAlpha ), paramThreeToGL( blendDstAlpha ) );

				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;

			}

		} else {

			currentBlendEquation = null;
			currentBlendSrc = null;
			currentBlendDst = null;
			currentBlendEquationAlpha = null;
			currentBlendSrcAlpha = null;
			currentBlendDstAlpha = null;

		}

	}

	// TODO Deprecate

	function setColorWrite( colorWrite ) {

		colorBuffer.setMask( colorWrite );

	}

	function setDepthTest( depthTest ) {

		depthBuffer.setTest( depthTest );

	}

	function setDepthWrite( depthWrite ) {

		depthBuffer.setMask( depthWrite );

	}

	function setDepthFunc( depthFunc ) {

		depthBuffer.setFunc( depthFunc );

	}

	function setStencilTest( stencilTest ) {

		stencilBuffer.setTest( stencilTest );

	}

	function setStencilWrite( stencilWrite ) {

		stencilBuffer.setMask( stencilWrite );

	}

	function setStencilFunc( stencilFunc, stencilRef, stencilMask ) {

		stencilBuffer.setFunc( stencilFunc, stencilRef, stencilMask );

	}

	function setStencilOp( stencilFail, stencilZFail, stencilZPass ) {

		stencilBuffer.setOp( stencilFail, stencilZFail, stencilZPass );

	}

	//

	function setFlipSided( flipSided ) {

		if ( currentFlipSided !== flipSided ) {

			if ( flipSided ) {

				gl.frontFace( gl.CW );

			} else {

				gl.frontFace( gl.CCW );

			}

			currentFlipSided = flipSided;

		}

	}

	function setCullFace( cullFace ) {

		if ( cullFace !== CullFaceNone ) {

			enable( gl.CULL_FACE );

			if ( cullFace !== currentCullFace ) {

				if ( cullFace === CullFaceBack ) {

					gl.cullFace( gl.BACK );

				} else if ( cullFace === CullFaceFront ) {

					gl.cullFace( gl.FRONT );

				} else {

					gl.cullFace( gl.FRONT_AND_BACK );

				}

			}

		} else {

			disable( gl.CULL_FACE );

		}

		currentCullFace = cullFace;

	}

	function setLineWidth( width ) {

		if ( width !== currentLineWidth ) {

			if ( lineWidthAvailable ) gl.lineWidth( width );

			currentLineWidth = width;

		}

	}

	function setPolygonOffset( polygonOffset, factor, units ) {

		if ( polygonOffset ) {

			enable( gl.POLYGON_OFFSET_FILL );

			if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {

				gl.polygonOffset( factor, units );

				currentPolygonOffsetFactor = factor;
				currentPolygonOffsetUnits = units;

			}

		} else {

			disable( gl.POLYGON_OFFSET_FILL );

		}

	}

	function getScissorTest() {

		return currentScissorTest;

	}

	function setScissorTest( scissorTest ) {

		currentScissorTest = scissorTest;

		if ( scissorTest ) {

			enable( gl.SCISSOR_TEST );

		} else {

			disable( gl.SCISSOR_TEST );

		}

	}

	// texture

	function activeTexture( webglSlot ) {

		if ( webglSlot === undefined ) webglSlot = gl.TEXTURE0 + maxTextures - 1;

		if ( currentTextureSlot !== webglSlot ) {

			gl.activeTexture( webglSlot );
			currentTextureSlot = webglSlot;

		}

	}

	function bindTexture( webglType, webglTexture ) {

		if ( currentTextureSlot === null ) {

			activeTexture();

		}

		var boundTexture = currentBoundTextures[ currentTextureSlot ];

		if ( boundTexture === undefined ) {

			boundTexture = { type: undefined, texture: undefined };
			currentBoundTextures[ currentTextureSlot ] = boundTexture;

		}

		if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {

			gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );

			boundTexture.type = webglType;
			boundTexture.texture = webglTexture;

		}

	}

	function compressedTexImage2D() {

		try {

			gl.compressedTexImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	}

	function texImage2D() {

		try {

			gl.texImage2D.apply( gl, arguments );

		} catch ( error ) {

			console.error( error );

		}

	}

	//

	function scissor( scissor ) {

		if ( currentScissor.equals( scissor ) === false ) {

			gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
			currentScissor.copy( scissor );

		}

	}

	function viewport( viewport ) {

		if ( currentViewport.equals( viewport ) === false ) {

			gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
			currentViewport.copy( viewport );

		}

	}

	//

	function reset() {

		for ( var i = 0; i < enabledAttributes.length; i ++ ) {

			if ( enabledAttributes[ i ] === 1 ) {

				gl.disableVertexAttribArray( i );
				enabledAttributes[ i ] = 0;

			}

		}

		capabilities = {};

		compressedTextureFormats = null;

		currentTextureSlot = null;
		currentBoundTextures = {};

		currentBlending = null;

		currentFlipSided = null;
		currentCullFace = null;

		colorBuffer.reset();
		depthBuffer.reset();
		stencilBuffer.reset();

	}

	return {

		buffers: {
			color: colorBuffer,
			depth: depthBuffer,
			stencil: stencilBuffer
		},

		init: init,
		initAttributes: initAttributes,
		enableAttribute: enableAttribute,
		enableAttributeAndDivisor: enableAttributeAndDivisor,
		disableUnusedAttributes: disableUnusedAttributes,
		enable: enable,
		disable: disable,
		getCompressedTextureFormats: getCompressedTextureFormats,

		setBlending: setBlending,

		setColorWrite: setColorWrite,
		setDepthTest: setDepthTest,
		setDepthWrite: setDepthWrite,
		setDepthFunc: setDepthFunc,
		setStencilTest: setStencilTest,
		setStencilWrite: setStencilWrite,
		setStencilFunc: setStencilFunc,
		setStencilOp: setStencilOp,

		setFlipSided: setFlipSided,
		setCullFace: setCullFace,

		setLineWidth: setLineWidth,
		setPolygonOffset: setPolygonOffset,

		getScissorTest: getScissorTest,
		setScissorTest: setScissorTest,

		activeTexture: activeTexture,
		bindTexture: bindTexture,
		compressedTexImage2D: compressedTexImage2D,
		texImage2D: texImage2D,

		scissor: scissor,
		viewport: viewport,

		reset: reset

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLCapabilities( gl, extensions, parameters ) {

	var maxAnisotropy;

	function getMaxAnisotropy() {

		if ( maxAnisotropy !== undefined ) return maxAnisotropy;

		var extension = extensions.get( 'EXT_texture_filter_anisotropic' );

		if ( extension !== null ) {

			maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );

		} else {

			maxAnisotropy = 0;

		}

		return maxAnisotropy;

	}

	function getMaxPrecision( precision ) {

		if ( precision === 'highp' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.HIGH_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.HIGH_FLOAT ).precision > 0 ) {

				return 'highp';

			}

			precision = 'mediump';

		}

		if ( precision === 'mediump' ) {

			if ( gl.getShaderPrecisionFormat( gl.VERTEX_SHADER, gl.MEDIUM_FLOAT ).precision > 0 &&
			     gl.getShaderPrecisionFormat( gl.FRAGMENT_SHADER, gl.MEDIUM_FLOAT ).precision > 0 ) {

				return 'mediump';

			}

		}

		return 'lowp';

	}

	var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
	var maxPrecision = getMaxPrecision( precision );

	if ( maxPrecision !== precision ) {

		console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
		precision = maxPrecision;

	}

	var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true && !! extensions.get( 'EXT_frag_depth' );

	var maxTextures = gl.getParameter( gl.MAX_TEXTURE_IMAGE_UNITS );
	var maxVertexTextures = gl.getParameter( gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS );
	var maxTextureSize = gl.getParameter( gl.MAX_TEXTURE_SIZE );
	var maxCubemapSize = gl.getParameter( gl.MAX_CUBE_MAP_TEXTURE_SIZE );

	var maxAttributes = gl.getParameter( gl.MAX_VERTEX_ATTRIBS );
	var maxVertexUniforms = gl.getParameter( gl.MAX_VERTEX_UNIFORM_VECTORS );
	var maxVaryings = gl.getParameter( gl.MAX_VARYING_VECTORS );
	var maxFragmentUniforms = gl.getParameter( gl.MAX_FRAGMENT_UNIFORM_VECTORS );

	var vertexTextures = maxVertexTextures > 0;
	var floatFragmentTextures = !! extensions.get( 'OES_texture_float' );
	var floatVertexTextures = vertexTextures && floatFragmentTextures;

	return {

		getMaxAnisotropy: getMaxAnisotropy,
		getMaxPrecision: getMaxPrecision,

		precision: precision,
		logarithmicDepthBuffer: logarithmicDepthBuffer,

		maxTextures: maxTextures,
		maxVertexTextures: maxVertexTextures,
		maxTextureSize: maxTextureSize,
		maxCubemapSize: maxCubemapSize,

		maxAttributes: maxAttributes,
		maxVertexUniforms: maxVertexUniforms,
		maxVaryings: maxVaryings,
		maxFragmentUniforms: maxFragmentUniforms,

		vertexTextures: vertexTextures,
		floatFragmentTextures: floatFragmentTextures,
		floatVertexTextures: floatVertexTextures

	};

}

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WebGLExtensions( gl ) {

	var extensions = {};

	return {

		get: function ( name ) {

			if ( extensions[ name ] !== undefined ) {

				return extensions[ name ];

			}

			var extension;

			switch ( name ) {

				case 'WEBGL_depth_texture':
					extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
					break;

				case 'EXT_texture_filter_anisotropic':
					extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
					break;

				case 'WEBGL_compressed_texture_s3tc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
					break;

				case 'WEBGL_compressed_texture_pvrtc':
					extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
					break;

				case 'WEBGL_compressed_texture_etc1':
					extension = gl.getExtension( 'WEBGL_compressed_texture_etc1' );
					break;

				default:
					extension = gl.getExtension( name );

			}

			if ( extension === null ) {

				console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );

			}

			extensions[ name ] = extension;

			return extension;

		}

	};

}

/**
 * @author tschw
 */

function WebGLClipping() {

	var scope = this,

		globalState = null,
		numGlobalPlanes = 0,
		localClippingEnabled = false,
		renderingShadows = false,

		plane = new Plane(),
		viewNormalMatrix = new Matrix3(),

		uniform = { value: null, needsUpdate: false };

	this.uniform = uniform;
	this.numPlanes = 0;
	this.numIntersection = 0;

	this.init = function( planes, enableLocalClipping, camera ) {

		var enabled =
			planes.length !== 0 ||
			enableLocalClipping ||
			// enable state of previous frame - the clipping code has to
			// run another frame in order to reset the state:
			numGlobalPlanes !== 0 ||
			localClippingEnabled;

		localClippingEnabled = enableLocalClipping;

		globalState = projectPlanes( planes, camera, 0 );
		numGlobalPlanes = planes.length;

		return enabled;

	};

	this.beginShadows = function() {

		renderingShadows = true;
		projectPlanes( null );

	};

	this.endShadows = function() {

		renderingShadows = false;
		resetGlobalState();

	};

	this.setState = function( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {

		if ( ! localClippingEnabled ||
				planes === null || planes.length === 0 ||
				renderingShadows && ! clipShadows ) {
			// there's no local clipping

			if ( renderingShadows ) {
				// there's no global clipping

				projectPlanes( null );

			} else {

				resetGlobalState();
			}

		} else {

			var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
				lGlobal = nGlobal * 4,

				dstArray = cache.clippingState || null;

			uniform.value = dstArray; // ensure unique state

			dstArray = projectPlanes( planes, camera, lGlobal, fromCache );

			for ( var i = 0; i !== lGlobal; ++ i ) {

				dstArray[ i ] = globalState[ i ];

			}

			cache.clippingState = dstArray;
			this.numIntersection = clipIntersection ? this.numPlanes : 0;
			this.numPlanes += nGlobal;

		}


	};

	function resetGlobalState() {

		if ( uniform.value !== globalState ) {

			uniform.value = globalState;
			uniform.needsUpdate = numGlobalPlanes > 0;

		}

		scope.numPlanes = numGlobalPlanes;
		scope.numIntersection = 0;

	}

	function projectPlanes( planes, camera, dstOffset, skipTransform ) {

		var nPlanes = planes !== null ? planes.length : 0,
			dstArray = null;

		if ( nPlanes !== 0 ) {

			dstArray = uniform.value;

			if ( skipTransform !== true || dstArray === null ) {

				var flatSize = dstOffset + nPlanes * 4,
					viewMatrix = camera.matrixWorldInverse;

				viewNormalMatrix.getNormalMatrix( viewMatrix );

				if ( dstArray === null || dstArray.length < flatSize ) {

					dstArray = new Float32Array( flatSize );

				}

				for ( var i = 0, i4 = dstOffset;
									i !== nPlanes; ++ i, i4 += 4 ) {

					plane.copy( planes[ i ] ).
							applyMatrix4( viewMatrix, viewNormalMatrix );

					plane.normal.toArray( dstArray, i4 );
					dstArray[ i4 + 3 ] = plane.constant;

				}

			}

			uniform.value = dstArray;
			uniform.needsUpdate = true;

		}

		scope.numPlanes = nPlanes;
		
		return dstArray;

	}

}

/**
 * @author supereggbert / http://www.paulbrunt.co.uk/
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 * @author szimek / https://github.com/szimek/
 * @author tschw
 */

function WebGLRenderer( parameters ) {

	console.log( 'THREE.WebGLRenderer', REVISION );

	parameters = parameters || {};

	var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
		_context = parameters.context !== undefined ? parameters.context : null,

		_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
		_depth = parameters.depth !== undefined ? parameters.depth : true,
		_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
		_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
		_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
		_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false;

	var lights = [];

	var opaqueObjects = [];
	var opaqueObjectsLastIndex = - 1;
	var transparentObjects = [];
	var transparentObjectsLastIndex = - 1;

	var morphInfluences = new Float32Array( 8 );

	var sprites = [];
	var lensFlares = [];

	// public properties

	this.domElement = _canvas;
	this.context = null;

	// clearing

	this.autoClear = true;
	this.autoClearColor = true;
	this.autoClearDepth = true;
	this.autoClearStencil = true;

	// scene graph

	this.sortObjects = true;

	// user-defined clipping

	this.clippingPlanes = [];
	this.localClippingEnabled = false;

	// physically based shading

	this.gammaFactor = 2.0;	// for backwards compatibility
	this.gammaInput = false;
	this.gammaOutput = false;

	// physical lights

	this.physicallyCorrectLights = false;

	// tone mapping

	this.toneMapping = LinearToneMapping;
	this.toneMappingExposure = 1.0;
	this.toneMappingWhitePoint = 1.0;

	// morphs

	this.maxMorphTargets = 8;
	this.maxMorphNormals = 4;

	// internal properties

	var _this = this,

		// internal state cache

		_currentProgram = null,
		_currentRenderTarget = null,
		_currentFramebuffer = null,
		_currentMaterialId = - 1,
		_currentGeometryProgram = '',
		_currentCamera = null,

		_currentScissor = new Vector4(),
		_currentScissorTest = null,

		_currentViewport = new Vector4(),

		//

		_usedTextureUnits = 0,

		//

		_clearColor = new Color( 0x000000 ),
		_clearAlpha = 0,

		_width = _canvas.width,
		_height = _canvas.height,

		_pixelRatio = 1,

		_scissor = new Vector4( 0, 0, _width, _height ),
		_scissorTest = false,

		_viewport = new Vector4( 0, 0, _width, _height ),

		// frustum

		_frustum = new Frustum(),

		// clipping

		_clipping = new WebGLClipping(),
		_clippingEnabled = false,
		_localClippingEnabled = false,

		_sphere = new Sphere(),

		// camera matrices cache

		_projScreenMatrix = new Matrix4(),

		_vector3 = new Vector3(),
		_matrix4 = new Matrix4(),
		_matrix42 = new Matrix4(),

		// light arrays cache

		_lights = {

			hash: '',

		ambient: [ 0, 0, 0 ],
		directional: [],
		directionalShadowMap: [],
		directionalShadowMatrix: [],
		spot: [],
		spotShadowMap: [],
		spotShadowMatrix: [],
		rectArea: [],
		point: [],
		pointShadowMap: [],
		pointShadowMatrix: [],
		hemi: [],

			shadows: []

		},

		// info

		_infoRender = {

			calls: 0,
			vertices: 0,
			faces: 0,
			points: 0

		};

	this.info = {

		render: _infoRender,
		memory: {

			geometries: 0,
			textures: 0

		},
		programs: null

	};


	// initialize

	var _gl;

	try {

		var attributes = {
			alpha: _alpha,
			depth: _depth,
			stencil: _stencil,
			antialias: _antialias,
			premultipliedAlpha: _premultipliedAlpha,
			preserveDrawingBuffer: _preserveDrawingBuffer
		};

		_gl = _context || _canvas.getContext( 'webgl', attributes ) || _canvas.getContext( 'experimental-webgl', attributes );

		if ( _gl === null ) {

			if ( _canvas.getContext( 'webgl' ) !== null ) {

				throw 'Error creating WebGL context with your selected attributes.';

			} else {

				throw 'Error creating WebGL context.';

			}

		}

		// Some experimental-webgl implementations do not have getShaderPrecisionFormat

		if ( _gl.getShaderPrecisionFormat === undefined ) {

			_gl.getShaderPrecisionFormat = function () {

				return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };

			};

		}

		_canvas.addEventListener( 'webglcontextlost', onContextLost, false );

	} catch ( error ) {

		console.error( 'THREE.WebGLRenderer: ' + error );

	}

	var extensions = new WebGLExtensions( _gl );

	extensions.get( 'WEBGL_depth_texture' );
	extensions.get( 'OES_texture_float' );
	extensions.get( 'OES_texture_float_linear' );
	extensions.get( 'OES_texture_half_float' );
	extensions.get( 'OES_texture_half_float_linear' );
	extensions.get( 'OES_standard_derivatives' );
	extensions.get( 'ANGLE_instanced_arrays' );

	if ( extensions.get( 'OES_element_index_uint' ) ) {

		BufferGeometry.MaxIndex = 4294967296;

	}

	var capabilities = new WebGLCapabilities( _gl, extensions, parameters );

	var state = new WebGLState( _gl, extensions, paramThreeToGL );
	var properties = new WebGLProperties();
	var textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, paramThreeToGL, this.info );
	var objects = new WebGLObjects( _gl, properties, this.info );
	var programCache = new WebGLPrograms( this, capabilities );
	var lightCache = new WebGLLights();

	this.info.programs = programCache.programs;

	var bufferRenderer = new WebGLBufferRenderer( _gl, extensions, _infoRender );
	var indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, _infoRender );

	//

	var backgroundCamera = new OrthographicCamera( - 1, 1, 1, - 1, 0, 1 );
	var backgroundCamera2 = new PerspectiveCamera();
	var backgroundPlaneMesh = new Mesh(
		new PlaneBufferGeometry( 2, 2 ),
		new MeshBasicMaterial( { depthTest: false, depthWrite: false, fog: false } )
	);
	var backgroundBoxShader = ShaderLib[ 'cube' ];
	var backgroundBoxMesh = new Mesh(
		new BoxBufferGeometry( 5, 5, 5 ),
		new ShaderMaterial( {
			uniforms: backgroundBoxShader.uniforms,
			vertexShader: backgroundBoxShader.vertexShader,
			fragmentShader: backgroundBoxShader.fragmentShader,
			side: BackSide,
			depthTest: false,
			depthWrite: false,
			fog: false
		} )
	);

	//

	function getTargetPixelRatio() {

		return _currentRenderTarget === null ? _pixelRatio : 1;

	}

	function setDefaultGLState() {

		state.init();

		state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
		state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );

		state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

	}

	function resetGLState() {

		_currentProgram = null;
		_currentCamera = null;

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;

		state.reset();

	}

	setDefaultGLState();

	this.context = _gl;
	this.capabilities = capabilities;
	this.extensions = extensions;
	this.properties = properties;
	this.state = state;

	// shadow map

	var shadowMap = new WebGLShadowMap( this, _lights, objects, capabilities );

	this.shadowMap = shadowMap;


	// Plugins

	var spritePlugin = new SpritePlugin( this, sprites );
	var lensFlarePlugin = new LensFlarePlugin( this, lensFlares );

	// API

	this.getContext = function () {

		return _gl;

	};

	this.getContextAttributes = function () {

		return _gl.getContextAttributes();

	};

	this.forceContextLoss = function () {

		extensions.get( 'WEBGL_lose_context' ).loseContext();

	};

	this.getMaxAnisotropy = function () {

		return capabilities.getMaxAnisotropy();

	};

	this.getPrecision = function () {

		return capabilities.precision;

	};

	this.getPixelRatio = function () {

		return _pixelRatio;

	};

	this.setPixelRatio = function ( value ) {

		if ( value === undefined ) return;

		_pixelRatio = value;

		this.setSize( _viewport.z, _viewport.w, false );

	};

	this.getSize = function () {

		return {
			width: _width,
			height: _height
		};

	};

	this.setSize = function ( width, height, updateStyle ) {

		_width = width;
		_height = height;

		_canvas.width = width * _pixelRatio;
		_canvas.height = height * _pixelRatio;

		if ( updateStyle !== false ) {

			_canvas.style.width = width + 'px';
			_canvas.style.height = height + 'px';

		}

		this.setViewport( 0, 0, width, height );

	};

	this.setViewport = function ( x, y, width, height ) {

		state.viewport( _viewport.set( x, y, width, height ) );

	};

	this.setScissor = function ( x, y, width, height ) {

		state.scissor( _scissor.set( x, y, width, height ) );

	};

	this.setScissorTest = function ( boolean ) {

		state.setScissorTest( _scissorTest = boolean );

	};

	// Clearing

	this.getClearColor = function () {

		return _clearColor;

	};

	this.setClearColor = function ( color, alpha ) {

		_clearColor.set( color );

		_clearAlpha = alpha !== undefined ? alpha : 1;

		state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

	};

	this.getClearAlpha = function () {

		return _clearAlpha;

	};

	this.setClearAlpha = function ( alpha ) {

		_clearAlpha = alpha;

		state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

	};

	this.clear = function ( color, depth, stencil ) {

		var bits = 0;

		if ( color === undefined || color ) bits |= _gl.COLOR_BUFFER_BIT;
		if ( depth === undefined || depth ) bits |= _gl.DEPTH_BUFFER_BIT;
		if ( stencil === undefined || stencil ) bits |= _gl.STENCIL_BUFFER_BIT;

		_gl.clear( bits );

	};

	this.clearColor = function () {

		this.clear( true, false, false );

	};

	this.clearDepth = function () {

		this.clear( false, true, false );

	};

	this.clearStencil = function () {

		this.clear( false, false, true );

	};

	this.clearTarget = function ( renderTarget, color, depth, stencil ) {

		this.setRenderTarget( renderTarget );
		this.clear( color, depth, stencil );

	};

	// Reset

	this.resetGLState = resetGLState;

	this.dispose = function() {

		transparentObjects = [];
		transparentObjectsLastIndex = -1;
		opaqueObjects = [];
		opaqueObjectsLastIndex = -1;

		_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );

	};

	// Events

	function onContextLost( event ) {

		event.preventDefault();

		resetGLState();
		setDefaultGLState();

		properties.clear();

	}

	function onMaterialDispose( event ) {

		var material = event.target;

		material.removeEventListener( 'dispose', onMaterialDispose );

		deallocateMaterial( material );

	}

	// Buffer deallocation

	function deallocateMaterial( material ) {

		releaseMaterialProgramReference( material );

		properties.delete( material );

	}


	function releaseMaterialProgramReference( material ) {

		var programInfo = properties.get( material ).program;

		material.program = undefined;

		if ( programInfo !== undefined ) {

			programCache.releaseProgram( programInfo );

		}

	}

	// Buffer rendering

	this.renderBufferImmediate = function ( object, program, material ) {

		state.initAttributes();

		var buffers = properties.get( object );

		if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
		if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
		if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
		if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();

		var attributes = program.getAttributes();

		if ( object.hasPositions ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.position );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.positionArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.position );
			_gl.vertexAttribPointer( attributes.position, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasNormals ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.normal );

			if ( ! material.isMeshPhongMaterial &&
				! material.isMeshStandardMaterial &&
				! material.isMeshNormalMaterial &&
				material.shading === FlatShading ) {

				for ( var i = 0, l = object.count * 3; i < l; i += 9 ) {

					var array = object.normalArray;

					var nx = ( array[ i + 0 ] + array[ i + 3 ] + array[ i + 6 ] ) / 3;
					var ny = ( array[ i + 1 ] + array[ i + 4 ] + array[ i + 7 ] ) / 3;
					var nz = ( array[ i + 2 ] + array[ i + 5 ] + array[ i + 8 ] ) / 3;

					array[ i + 0 ] = nx;
					array[ i + 1 ] = ny;
					array[ i + 2 ] = nz;

					array[ i + 3 ] = nx;
					array[ i + 4 ] = ny;
					array[ i + 5 ] = nz;

					array[ i + 6 ] = nx;
					array[ i + 7 ] = ny;
					array[ i + 8 ] = nz;

				}

			}

			_gl.bufferData( _gl.ARRAY_BUFFER, object.normalArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.normal );

			_gl.vertexAttribPointer( attributes.normal, 3, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasUvs && material.map ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.uv );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.uvArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.uv );

			_gl.vertexAttribPointer( attributes.uv, 2, _gl.FLOAT, false, 0, 0 );

		}

		if ( object.hasColors && material.vertexColors !== NoColors ) {

			_gl.bindBuffer( _gl.ARRAY_BUFFER, buffers.color );
			_gl.bufferData( _gl.ARRAY_BUFFER, object.colorArray, _gl.DYNAMIC_DRAW );

			state.enableAttribute( attributes.color );

			_gl.vertexAttribPointer( attributes.color, 3, _gl.FLOAT, false, 0, 0 );

		}

		state.disableUnusedAttributes();

		_gl.drawArrays( _gl.TRIANGLES, 0, object.count );

		object.count = 0;

	};

	this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {

		setMaterial( material );

		var program = setProgram( camera, fog, material, object );

		var updateBuffers = false;
		var geometryProgram = geometry.id + '_' + program.id + '_' + material.wireframe;

		if ( geometryProgram !== _currentGeometryProgram ) {

			_currentGeometryProgram = geometryProgram;
			updateBuffers = true;

		}

		// morph targets

		var morphTargetInfluences = object.morphTargetInfluences;

		if ( morphTargetInfluences !== undefined ) {

			var activeInfluences = [];

			for ( var i = 0, l = morphTargetInfluences.length; i < l; i ++ ) {

				var influence = morphTargetInfluences[ i ];
				activeInfluences.push( [ influence, i ] );

			}

			activeInfluences.sort( absNumericalSort );

			if ( activeInfluences.length > 8 ) {

				activeInfluences.length = 8;

			}

			var morphAttributes = geometry.morphAttributes;

			for ( var i = 0, l = activeInfluences.length; i < l; i ++ ) {

				var influence = activeInfluences[ i ];
				morphInfluences[ i ] = influence[ 0 ];

				if ( influence[ 0 ] !== 0 ) {

					var index = influence[ 1 ];

					if ( material.morphTargets === true && morphAttributes.position ) geometry.addAttribute( 'morphTarget' + i, morphAttributes.position[ index ] );
					if ( material.morphNormals === true && morphAttributes.normal ) geometry.addAttribute( 'morphNormal' + i, morphAttributes.normal[ index ] );

				} else {

					if ( material.morphTargets === true ) geometry.removeAttribute( 'morphTarget' + i );
					if ( material.morphNormals === true ) geometry.removeAttribute( 'morphNormal' + i );

				}

			}

			for ( var i = activeInfluences.length, il = morphInfluences.length; i < il; i ++ ) {

				morphInfluences[ i ] = 0.0;

			}

			program.getUniforms().setValue(
				_gl, 'morphTargetInfluences', morphInfluences );

			updateBuffers = true;

		}

		//

		var index = geometry.index;
		var position = geometry.attributes.position;
		var rangeFactor = 1;

		if ( material.wireframe === true ) {

			index = objects.getWireframeAttribute( geometry );
			rangeFactor = 2;

		}

		var renderer;

		if ( index !== null ) {

			renderer = indexedBufferRenderer;
			renderer.setIndex( index );

		} else {

			renderer = bufferRenderer;

		}

		if ( updateBuffers ) {

			setupVertexAttributes( material, program, geometry );

			if ( index !== null ) {

				_gl.bindBuffer( _gl.ELEMENT_ARRAY_BUFFER, objects.getAttributeBuffer( index ) );

			}

		}

		//

		var dataCount = 0;

		if ( index !== null ) {

			dataCount = index.count;

		} else if ( position !== undefined ) {

			dataCount = position.count;

		}

		var rangeStart = geometry.drawRange.start * rangeFactor;
		var rangeCount = geometry.drawRange.count * rangeFactor;

		var groupStart = group !== null ? group.start * rangeFactor : 0;
		var groupCount = group !== null ? group.count * rangeFactor : Infinity;

		var drawStart = Math.max( rangeStart, groupStart );
		var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;

		var drawCount = Math.max( 0, drawEnd - drawStart + 1 );

		if ( drawCount === 0 ) return;

		//

		if ( object.isMesh ) {

			if ( material.wireframe === true ) {

				state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
				renderer.setMode( _gl.LINES );

			} else {

				switch ( object.drawMode ) {

					case TrianglesDrawMode:
						renderer.setMode( _gl.TRIANGLES );
						break;

					case TriangleStripDrawMode:
						renderer.setMode( _gl.TRIANGLE_STRIP );
						break;

					case TriangleFanDrawMode:
						renderer.setMode( _gl.TRIANGLE_FAN );
						break;

				}

			}


		} else if ( object.isLine ) {

			var lineWidth = material.linewidth;

			if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material

			state.setLineWidth( lineWidth * getTargetPixelRatio() );

			if ( object.isLineSegments ) {

				renderer.setMode( _gl.LINES );

			} else {

				renderer.setMode( _gl.LINE_STRIP );

			}

		} else if ( object.isPoints ) {

			renderer.setMode( _gl.POINTS );

		}

		if ( geometry && geometry.isInstancedBufferGeometry ) {

			if ( geometry.maxInstancedCount > 0 ) {

				renderer.renderInstances( geometry, drawStart, drawCount );

			}

		} else {

			renderer.render( drawStart, drawCount );

		}

	};

	function setupVertexAttributes( material, program, geometry, startIndex ) {

		var extension;

		if ( geometry && geometry.isInstancedBufferGeometry ) {

			extension = extensions.get( 'ANGLE_instanced_arrays' );

			if ( extension === null ) {

				console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
				return;

			}

		}

		if ( startIndex === undefined ) startIndex = 0;

		state.initAttributes();

		var geometryAttributes = geometry.attributes;

		var programAttributes = program.getAttributes();

		var materialDefaultAttributeValues = material.defaultAttributeValues;

		for ( var name in programAttributes ) {

			var programAttribute = programAttributes[ name ];

			if ( programAttribute >= 0 ) {

				var geometryAttribute = geometryAttributes[ name ];

				if ( geometryAttribute !== undefined ) {

					var normalized = geometryAttribute.normalized;
					var size = geometryAttribute.itemSize;

					var attributeProperties = objects.getAttributeProperties( geometryAttribute );

					var buffer = attributeProperties.__webglBuffer;
					var type = attributeProperties.type;
					var bytesPerElement = attributeProperties.bytesPerElement;

					if ( geometryAttribute.isInterleavedBufferAttribute ) {

						var data = geometryAttribute.data;
						var stride = data.stride;
						var offset = geometryAttribute.offset;

						if ( data && data.isInstancedInterleavedBuffer ) {

							state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = data.meshPerAttribute * data.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, ( startIndex * stride + offset ) * bytesPerElement );

					} else {

						if ( geometryAttribute.isInstancedBufferAttribute ) {

							state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute, extension );

							if ( geometry.maxInstancedCount === undefined ) {

								geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;

							}

						} else {

							state.enableAttribute( programAttribute );

						}

						_gl.bindBuffer( _gl.ARRAY_BUFFER, buffer );
						_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, startIndex * size * bytesPerElement );

					}

				} else if ( materialDefaultAttributeValues !== undefined ) {

					var value = materialDefaultAttributeValues[ name ];

					if ( value !== undefined ) {

						switch ( value.length ) {

							case 2:
								_gl.vertexAttrib2fv( programAttribute, value );
								break;

							case 3:
								_gl.vertexAttrib3fv( programAttribute, value );
								break;

							case 4:
								_gl.vertexAttrib4fv( programAttribute, value );
								break;

							default:
								_gl.vertexAttrib1fv( programAttribute, value );

						}

					}

				}

			}

		}

		state.disableUnusedAttributes();

	}

	// Sorting

	function absNumericalSort( a, b ) {

		return Math.abs( b[ 0 ] ) - Math.abs( a[ 0 ] );

	}

	function painterSortStable( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} else if ( a.material.program && b.material.program && a.material.program !== b.material.program ) {

			return a.material.program.id - b.material.program.id;

		} else if ( a.material.id !== b.material.id ) {

			return a.material.id - b.material.id;

		} else if ( a.z !== b.z ) {

			return a.z - b.z;

		} else {

			return a.id - b.id;

		}

	}

	function reversePainterSortStable( a, b ) {

		if ( a.object.renderOrder !== b.object.renderOrder ) {

			return a.object.renderOrder - b.object.renderOrder;

		} if ( a.z !== b.z ) {

			return b.z - a.z;

		} else {

			return a.id - b.id;

		}

	}

	// Rendering

	this.render = function ( scene, camera, renderTarget, forceClear ) {

		if ( camera !== undefined && camera.isCamera !== true ) {

			console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
			return;

		}

		// reset caching for this frame

		_currentGeometryProgram = '';
		_currentMaterialId = - 1;
		_currentCamera = null;

		// update scene graph

		if ( scene.autoUpdate === true ) scene.updateMatrixWorld();

		// update camera matrices and frustum

		if ( camera.parent === null ) camera.updateMatrixWorld();

		camera.matrixWorldInverse.getInverse( camera.matrixWorld );

		_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
		_frustum.setFromMatrix( _projScreenMatrix );

		lights.length = 0;

		opaqueObjectsLastIndex = - 1;
		transparentObjectsLastIndex = - 1;

		sprites.length = 0;
		lensFlares.length = 0;

		_localClippingEnabled = this.localClippingEnabled;
		_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );

		projectObject( scene, camera );

		opaqueObjects.length = opaqueObjectsLastIndex + 1;
		transparentObjects.length = transparentObjectsLastIndex + 1;

		if ( _this.sortObjects === true ) {

			opaqueObjects.sort( painterSortStable );
			transparentObjects.sort( reversePainterSortStable );

		}

		//

		if ( _clippingEnabled ) _clipping.beginShadows();

		setupShadows( lights );

		shadowMap.render( scene, camera );

		setupLights( lights, camera );

		if ( _clippingEnabled ) _clipping.endShadows();

		//

		_infoRender.calls = 0;
		_infoRender.vertices = 0;
		_infoRender.faces = 0;
		_infoRender.points = 0;

		if ( renderTarget === undefined ) {

			renderTarget = null;

		}

		this.setRenderTarget( renderTarget );

		//

		var background = scene.background;

		if ( background === null ) {

			state.buffers.color.setClear( _clearColor.r, _clearColor.g, _clearColor.b, _clearAlpha, _premultipliedAlpha );

		} else if ( background && background.isColor ) {

			state.buffers.color.setClear( background.r, background.g, background.b, 1, _premultipliedAlpha );
			forceClear = true;

		}

		if ( this.autoClear || forceClear ) {

			this.clear( this.autoClearColor, this.autoClearDepth, this.autoClearStencil );

		}

		if ( background && background.isCubeTexture ) {

			backgroundCamera2.projectionMatrix.copy( camera.projectionMatrix );

			backgroundCamera2.matrixWorld.extractRotation( camera.matrixWorld );
			backgroundCamera2.matrixWorldInverse.getInverse( backgroundCamera2.matrixWorld );

			backgroundBoxMesh.material.uniforms[ "tCube" ].value = background;
			backgroundBoxMesh.modelViewMatrix.multiplyMatrices( backgroundCamera2.matrixWorldInverse, backgroundBoxMesh.matrixWorld );

			objects.update( backgroundBoxMesh );

			_this.renderBufferDirect( backgroundCamera2, null, backgroundBoxMesh.geometry, backgroundBoxMesh.material, backgroundBoxMesh, null );

		} else if ( background && background.isTexture ) {

			backgroundPlaneMesh.material.map = background;

			objects.update( backgroundPlaneMesh );

			_this.renderBufferDirect( backgroundCamera, null, backgroundPlaneMesh.geometry, backgroundPlaneMesh.material, backgroundPlaneMesh, null );

		}

		//

		if ( scene.overrideMaterial ) {

			var overrideMaterial = scene.overrideMaterial;

			renderObjects( opaqueObjects, scene, camera, overrideMaterial );
			renderObjects( transparentObjects, scene, camera, overrideMaterial );

		} else {

			// opaque pass (front-to-back order)

			state.setBlending( NoBlending );
			renderObjects( opaqueObjects, scene, camera );

			// transparent pass (back-to-front order)

			renderObjects( transparentObjects, scene, camera );

		}

		// custom render plugins (post pass)

		spritePlugin.render( scene, camera );
		lensFlarePlugin.render( scene, camera, _currentViewport );

		// Generate mipmap if we're using any kind of mipmap filtering

		if ( renderTarget ) {

			textures.updateRenderTargetMipmap( renderTarget );

		}

		// Ensure depth buffer writing is enabled so it can be cleared on next render

		state.setDepthTest( true );
		state.setDepthWrite( true );
		state.setColorWrite( true );

		// _gl.finish();

	};

	function pushRenderItem( object, geometry, material, z, group ) {

		var array, index;

		// allocate the next position in the appropriate array

		if ( material.transparent ) {

			array = transparentObjects;
			index = ++ transparentObjectsLastIndex;

		} else {

			array = opaqueObjects;
			index = ++ opaqueObjectsLastIndex;

		}

		// recycle existing render item or grow the array

		var renderItem = array[ index ];

		if ( renderItem !== undefined ) {

			renderItem.id = object.id;
			renderItem.object = object;
			renderItem.geometry = geometry;
			renderItem.material = material;
			renderItem.z = _vector3.z;
			renderItem.group = group;

		} else {

			renderItem = {
				id: object.id,
				object: object,
				geometry: geometry,
				material: material,
				z: _vector3.z,
				group: group
			};

			// assert( index === array.length );
			array.push( renderItem );

		}

	}

	// TODO Duplicated code (Frustum)

	function isObjectViewable( object ) {

		var geometry = object.geometry;

		if ( geometry.boundingSphere === null )
			geometry.computeBoundingSphere();

		_sphere.copy( geometry.boundingSphere ).
		applyMatrix4( object.matrixWorld );

		return isSphereViewable( _sphere );

	}

	function isSpriteViewable( sprite ) {

		_sphere.center.set( 0, 0, 0 );
		_sphere.radius = 0.7071067811865476;
		_sphere.applyMatrix4( sprite.matrixWorld );

		return isSphereViewable( _sphere );

	}

	function isSphereViewable( sphere ) {

		if ( ! _frustum.intersectsSphere( sphere ) ) return false;

		var numPlanes = _clipping.numPlanes;

		if ( numPlanes === 0 ) return true;

		var planes = _this.clippingPlanes,

			center = sphere.center,
			negRad = - sphere.radius,
			i = 0;

		do {

			// out when deeper than radius in the negative halfspace
			if ( planes[ i ].distanceToPoint( center ) < negRad ) return false;

		} while ( ++ i !== numPlanes );

		return true;

	}

	function projectObject( object, camera ) {

		if ( object.visible === false ) return;

		var visible = ( object.layers.mask & camera.layers.mask ) !== 0;

		if ( visible ) {

			if ( object.isLight ) {

				lights.push( object );

			} else if ( object.isSprite ) {

				if ( object.frustumCulled === false || isSpriteViewable( object ) === true ) {

					sprites.push( object );

				}

			} else if ( object.isLensFlare ) {

				lensFlares.push( object );

			} else if ( object.isImmediateRenderObject ) {

				if ( _this.sortObjects === true ) {

					_vector3.setFromMatrixPosition( object.matrixWorld );
					_vector3.applyProjection( _projScreenMatrix );

				}

				pushRenderItem( object, null, object.material, _vector3.z, null );

			} else if ( object.isMesh || object.isLine || object.isPoints ) {

				if ( object.isSkinnedMesh ) {

					object.skeleton.update();

				}

				if ( object.frustumCulled === false || isObjectViewable( object ) === true ) {

					var material = object.material;

					if ( material.visible === true ) {

						if ( _this.sortObjects === true ) {

							_vector3.setFromMatrixPosition( object.matrixWorld );
							_vector3.applyProjection( _projScreenMatrix );

						}

						var geometry = objects.update( object );

						if ( material.isMultiMaterial ) {

							var groups = geometry.groups;
							var materials = material.materials;

							for ( var i = 0, l = groups.length; i < l; i ++ ) {

								var group = groups[ i ];
								var groupMaterial = materials[ group.materialIndex ];

								if ( groupMaterial.visible === true ) {

									pushRenderItem( object, geometry, groupMaterial, _vector3.z, group );

								}

							}

						} else {

							pushRenderItem( object, geometry, material, _vector3.z, null );

						}

					}

				}

			}

		}

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			projectObject( children[ i ], camera );

		}

	}

	function renderObjects( renderList, scene, camera, overrideMaterial ) {

		for ( var i = 0, l = renderList.length; i < l; i ++ ) {

			var renderItem = renderList[ i ];

			var object = renderItem.object;
			var geometry = renderItem.geometry;
			var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
			var group = renderItem.group;

			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );

			object.onBeforeRender( _this, scene, camera, geometry, material, group );

			if ( object.isImmediateRenderObject ) {

				setMaterial( material );

				var program = setProgram( camera, scene.fog, material, object );

				_currentGeometryProgram = '';

				object.render( function ( object ) {

					_this.renderBufferImmediate( object, program, material );

				} );

			} else {

				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );

			}

			object.onAfterRender( _this, scene, camera, geometry, material, group );


		}

	}

	function initMaterial( material, fog, object ) {

		var materialProperties = properties.get( material );

		var parameters = programCache.getParameters(
			material, _lights, fog, _clipping.numPlanes, _clipping.numIntersection, object );

		var code = programCache.getProgramCode( material, parameters );

		var program = materialProperties.program;
		var programChange = true;

		if ( program === undefined ) {

			// new material
			material.addEventListener( 'dispose', onMaterialDispose );

		} else if ( program.code !== code ) {

			// changed glsl or parameters
			releaseMaterialProgramReference( material );

		} else if ( parameters.shaderID !== undefined ) {

			// same glsl and uniform list
			return;

		} else {

			// only rebuild uniform list
			programChange = false;

		}

		if ( programChange ) {

			if ( parameters.shaderID ) {

				var shader = ShaderLib[ parameters.shaderID ];

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: UniformsUtils.clone( shader.uniforms ),
					vertexShader: shader.vertexShader,
					fragmentShader: shader.fragmentShader
				};

			} else {

				materialProperties.__webglShader = {
					name: material.type,
					uniforms: material.uniforms,
					vertexShader: material.vertexShader,
					fragmentShader: material.fragmentShader
				};

			}

			material.__webglShader = materialProperties.__webglShader;

			program = programCache.acquireProgram( material, parameters, code );

			materialProperties.program = program;
			material.program = program;

		}

		var attributes = program.getAttributes();

		if ( material.morphTargets ) {

			material.numSupportedMorphTargets = 0;

			for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {

				if ( attributes[ 'morphTarget' + i ] >= 0 ) {

					material.numSupportedMorphTargets ++;

				}

			}

		}

		if ( material.morphNormals ) {

			material.numSupportedMorphNormals = 0;

			for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {

				if ( attributes[ 'morphNormal' + i ] >= 0 ) {

					material.numSupportedMorphNormals ++;

				}

			}

		}

		var uniforms = materialProperties.__webglShader.uniforms;

		if ( ! material.isShaderMaterial &&
			! material.isRawShaderMaterial ||
			material.clipping === true ) {

			materialProperties.numClippingPlanes = _clipping.numPlanes;
			materialProperties.numIntersection = _clipping.numIntersection;
			uniforms.clippingPlanes = _clipping.uniform;

		}

		materialProperties.fog = fog;

		// store the light setup it was created for

		materialProperties.lightsHash = _lights.hash;

		if ( material.lights ) {

			// wire up the material to this renderer's lighting state

			uniforms.ambientLightColor.value = _lights.ambient;
			uniforms.directionalLights.value = _lights.directional;
			uniforms.spotLights.value = _lights.spot;
			uniforms.rectAreaLights.value = _lights.rectArea;
			uniforms.pointLights.value = _lights.point;
			uniforms.hemisphereLights.value = _lights.hemi;

			uniforms.directionalShadowMap.value = _lights.directionalShadowMap;
			uniforms.directionalShadowMatrix.value = _lights.directionalShadowMatrix;
			uniforms.spotShadowMap.value = _lights.spotShadowMap;
			uniforms.spotShadowMatrix.value = _lights.spotShadowMatrix;
			uniforms.pointShadowMap.value = _lights.pointShadowMap;
			uniforms.pointShadowMatrix.value = _lights.pointShadowMatrix;
			// TODO (abelnation): add area lights shadow info to uniforms

		}

		var progUniforms = materialProperties.program.getUniforms(),
			uniformsList =
				WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );

		materialProperties.uniformsList = uniformsList;

	}

	function setMaterial( material ) {

		material.side === DoubleSide
			? state.disable( _gl.CULL_FACE )
			: state.enable( _gl.CULL_FACE );

		state.setFlipSided( material.side === BackSide );

		material.transparent === true
			? state.setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha )
			: state.setBlending( NoBlending );

		state.setDepthFunc( material.depthFunc );
		state.setDepthTest( material.depthTest );
		state.setDepthWrite( material.depthWrite );
		state.setColorWrite( material.colorWrite );
		state.setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );

	}

	function setProgram( camera, fog, material, object ) {

		_usedTextureUnits = 0;

		var materialProperties = properties.get( material );

		if ( _clippingEnabled ) {

			if ( _localClippingEnabled || camera !== _currentCamera ) {

				var useCache =
					camera === _currentCamera &&
					material.id === _currentMaterialId;

				// we might want to call this function with some ClippingGroup
				// object instead of the material, once it becomes feasible
				// (#8465, #8379)
				_clipping.setState(
					material.clippingPlanes, material.clipIntersection, material.clipShadows,
					camera, materialProperties, useCache );

			}

		}

		if ( material.needsUpdate === false ) {

			if ( materialProperties.program === undefined ) {

				material.needsUpdate = true;

			} else if ( material.fog && materialProperties.fog !== fog ) {

				material.needsUpdate = true;

			} else if ( material.lights && materialProperties.lightsHash !== _lights.hash ) {

				material.needsUpdate = true;

			} else if ( materialProperties.numClippingPlanes !== undefined &&
				( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
				materialProperties.numIntersection  !== _clipping.numIntersection ) ) {

				material.needsUpdate = true;

			}

		}

		if ( material.needsUpdate ) {

			initMaterial( material, fog, object );
			material.needsUpdate = false;

		}

		var refreshProgram = false;
		var refreshMaterial = false;
		var refreshLights = false;

		var program = materialProperties.program,
			p_uniforms = program.getUniforms(),
			m_uniforms = materialProperties.__webglShader.uniforms;

		if ( program.id !== _currentProgram ) {

			_gl.useProgram( program.program );
			_currentProgram = program.id;

			refreshProgram = true;
			refreshMaterial = true;
			refreshLights = true;

		}

		if ( material.id !== _currentMaterialId ) {

			_currentMaterialId = material.id;

			refreshMaterial = true;

		}

		if ( refreshProgram || camera !== _currentCamera ) {

			p_uniforms.set( _gl, camera, 'projectionMatrix' );

			if ( capabilities.logarithmicDepthBuffer ) {

				p_uniforms.setValue( _gl, 'logDepthBufFC',
					2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );

			}


			if ( camera !== _currentCamera ) {

				_currentCamera = camera;

				// lighting uniforms depend on the camera so enforce an update
				// now, in case this material supports lights - or later, when
				// the next material that does gets activated:

				refreshMaterial = true;		// set to true on material change
				refreshLights = true;		// remains set until update done

			}

			// load material specific uniforms
			// (shader material also gets them for the sake of genericity)

			if ( material.isShaderMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial ||
				material.envMap ) {

				var uCamPos = p_uniforms.map.cameraPosition;

				if ( uCamPos !== undefined ) {

					uCamPos.setValue( _gl,
						_vector3.setFromMatrixPosition( camera.matrixWorld ) );

				}

			}

			if ( material.isMeshPhongMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshBasicMaterial ||
				material.isMeshStandardMaterial ||
				material.isShaderMaterial ||
				material.skinning ) {

				p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );

			}

			p_uniforms.set( _gl, _this, 'toneMappingExposure' );
			p_uniforms.set( _gl, _this, 'toneMappingWhitePoint' );

		}

		// skinning uniforms must be set even if material didn't change
		// auto-setting of texture unit for bone texture must go before other textures
		// not sure why, but otherwise weird things happen

		if ( material.skinning ) {

			p_uniforms.setOptional( _gl, object, 'bindMatrix' );
			p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );

			var skeleton = object.skeleton;

			if ( skeleton ) {

				if ( capabilities.floatVertexTextures && skeleton.useVertexTexture ) {

					p_uniforms.set( _gl, skeleton, 'boneTexture' );
					p_uniforms.set( _gl, skeleton, 'boneTextureWidth' );
					p_uniforms.set( _gl, skeleton, 'boneTextureHeight' );

				} else {

					p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );

				}

			}

		}

		if ( refreshMaterial ) {

			if ( material.lights ) {

				// the current material requires lighting info

				// note: all lighting uniforms are always set correctly
				// they simply reference the renderer's state for their
				// values
				//
				// use the current material's .needsUpdate flags to set
				// the GL state when required

				markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );

			}

			// refresh uniforms common to several materials

			if ( fog && material.fog ) {

				refreshUniformsFog( m_uniforms, fog );

			}

			if ( material.isMeshBasicMaterial ||
				material.isMeshLambertMaterial ||
				material.isMeshPhongMaterial ||
				material.isMeshStandardMaterial ||
				material.isMeshNormalMaterial ||
				material.isMeshDepthMaterial ) {

				refreshUniformsCommon( m_uniforms, material );

			}

			// refresh single material specific uniforms

			if ( material.isLineBasicMaterial ) {

				refreshUniformsLine( m_uniforms, material );

			} else if ( material.isLineDashedMaterial ) {

				refreshUniformsLine( m_uniforms, material );
				refreshUniformsDash( m_uniforms, material );

			} else if ( material.isPointsMaterial ) {

				refreshUniformsPoints( m_uniforms, material );

			} else if ( material.isMeshLambertMaterial ) {

				refreshUniformsLambert( m_uniforms, material );

			} else if ( material.isMeshToonMaterial ) {

				refreshUniformsToon( m_uniforms, material );

			} else if ( material.isMeshPhongMaterial ) {

				refreshUniformsPhong( m_uniforms, material );

			} else if ( material.isMeshPhysicalMaterial ) {

				refreshUniformsPhysical( m_uniforms, material );

			} else if ( material.isMeshStandardMaterial ) {

				refreshUniformsStandard( m_uniforms, material );

			} else if ( material.isMeshDepthMaterial ) {

				if ( material.displacementMap ) {

					m_uniforms.displacementMap.value = material.displacementMap;
					m_uniforms.displacementScale.value = material.displacementScale;
					m_uniforms.displacementBias.value = material.displacementBias;

				}

			} else if ( material.isMeshNormalMaterial ) {

				refreshUniformsNormal( m_uniforms, material );

			}

			// RectAreaLight Texture
			// TODO (mrdoob): Find a nicer implementation

			if ( m_uniforms.ltcMat !== undefined ) m_uniforms.ltcMat.value = THREE.UniformsLib.LTC_MAT_TEXTURE;
			if ( m_uniforms.ltcMag !== undefined ) m_uniforms.ltcMag.value = THREE.UniformsLib.LTC_MAG_TEXTURE;

			WebGLUniforms.upload(
				_gl, materialProperties.uniformsList, m_uniforms, _this );

		}


		// common matrices

		p_uniforms.set( _gl, object, 'modelViewMatrix' );
		p_uniforms.set( _gl, object, 'normalMatrix' );
		p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );

		return program;

	}

	// Uniforms (refresh uniforms objects)

	function refreshUniformsCommon( uniforms, material ) {

		uniforms.opacity.value = material.opacity;

		uniforms.diffuse.value = material.color;

		if ( material.emissive ) {

			uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );

		}

		uniforms.map.value = material.map;
		uniforms.specularMap.value = material.specularMap;
		uniforms.alphaMap.value = material.alphaMap;

		if ( material.lightMap ) {

			uniforms.lightMap.value = material.lightMap;
			uniforms.lightMapIntensity.value = material.lightMapIntensity;

		}

		if ( material.aoMap ) {

			uniforms.aoMap.value = material.aoMap;
			uniforms.aoMapIntensity.value = material.aoMapIntensity;

		}

		// uv repeat and offset setting priorities
		// 1. color map
		// 2. specular map
		// 3. normal map
		// 4. bump map
		// 5. alpha map
		// 6. emissive map

		var uvScaleMap;

		if ( material.map ) {

			uvScaleMap = material.map;

		} else if ( material.specularMap ) {

			uvScaleMap = material.specularMap;

		} else if ( material.displacementMap ) {

			uvScaleMap = material.displacementMap;

		} else if ( material.normalMap ) {

			uvScaleMap = material.normalMap;

		} else if ( material.bumpMap ) {

			uvScaleMap = material.bumpMap;

		} else if ( material.roughnessMap ) {

			uvScaleMap = material.roughnessMap;

		} else if ( material.metalnessMap ) {

			uvScaleMap = material.metalnessMap;

		} else if ( material.alphaMap ) {

			uvScaleMap = material.alphaMap;

		} else if ( material.emissiveMap ) {

			uvScaleMap = material.emissiveMap;

		}

		if ( uvScaleMap !== undefined ) {

			// backwards compatibility
			if ( uvScaleMap.isWebGLRenderTarget ) {

				uvScaleMap = uvScaleMap.texture;

			}

			var offset = uvScaleMap.offset;
			var repeat = uvScaleMap.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

		uniforms.envMap.value = material.envMap;

		// don't flip CubeTexture envMaps, flip everything else:
		//  WebGLRenderTargetCube will be flipped for backwards compatibility
		//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
		// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
		uniforms.flipEnvMap.value = ( ! ( material.envMap && material.envMap.isCubeTexture ) ) ? 1 : - 1;

		uniforms.reflectivity.value = material.reflectivity;
		uniforms.refractionRatio.value = material.refractionRatio;

	}

	function refreshUniformsLine( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;

	}

	function refreshUniformsDash( uniforms, material ) {

		uniforms.dashSize.value = material.dashSize;
		uniforms.totalSize.value = material.dashSize + material.gapSize;
		uniforms.scale.value = material.scale;

	}

	function refreshUniformsPoints( uniforms, material ) {

		uniforms.diffuse.value = material.color;
		uniforms.opacity.value = material.opacity;
		uniforms.size.value = material.size * _pixelRatio;
		uniforms.scale.value = _height * 0.5;

		uniforms.map.value = material.map;

		if ( material.map !== null ) {

			var offset = material.map.offset;
			var repeat = material.map.repeat;

			uniforms.offsetRepeat.value.set( offset.x, offset.y, repeat.x, repeat.y );

		}

	}

	function refreshUniformsFog( uniforms, fog ) {

		uniforms.fogColor.value = fog.color;

		if ( fog.isFog ) {

			uniforms.fogNear.value = fog.near;
			uniforms.fogFar.value = fog.far;

		} else if ( fog.isFogExp2 ) {

			uniforms.fogDensity.value = fog.density;

		}

	}

	function refreshUniformsLambert( uniforms, material ) {

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

	}

	function refreshUniformsPhong( uniforms, material ) {

		uniforms.specular.value = material.specular;
		uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	function refreshUniformsToon( uniforms, material ) {

		refreshUniformsPhong( uniforms, material );

		if ( material.gradientMap ) {

			uniforms.gradientMap.value = material.gradientMap;

		}

	}

	function refreshUniformsStandard( uniforms, material ) {

		uniforms.roughness.value = material.roughness;
		uniforms.metalness.value = material.metalness;

		if ( material.roughnessMap ) {

			uniforms.roughnessMap.value = material.roughnessMap;

		}

		if ( material.metalnessMap ) {

			uniforms.metalnessMap.value = material.metalnessMap;

		}

		if ( material.emissiveMap ) {

			uniforms.emissiveMap.value = material.emissiveMap;

		}

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

		if ( material.envMap ) {

			//uniforms.envMap.value = material.envMap; // part of uniforms common
			uniforms.envMapIntensity.value = material.envMapIntensity;

		}

	}

	function refreshUniformsPhysical( uniforms, material ) {

		uniforms.clearCoat.value = material.clearCoat;
		uniforms.clearCoatRoughness.value = material.clearCoatRoughness;

		refreshUniformsStandard( uniforms, material );

	}

	function refreshUniformsNormal( uniforms, material ) {

		if ( material.bumpMap ) {

			uniforms.bumpMap.value = material.bumpMap;
			uniforms.bumpScale.value = material.bumpScale;

		}

		if ( material.normalMap ) {

			uniforms.normalMap.value = material.normalMap;
			uniforms.normalScale.value.copy( material.normalScale );

		}

		if ( material.displacementMap ) {

			uniforms.displacementMap.value = material.displacementMap;
			uniforms.displacementScale.value = material.displacementScale;
			uniforms.displacementBias.value = material.displacementBias;

		}

	}

	// If uniforms are marked as clean, they don't need to be loaded to the GPU.

	function markUniformsLightsNeedsUpdate( uniforms, value ) {

		uniforms.ambientLightColor.needsUpdate = value;

		uniforms.directionalLights.needsUpdate = value;
		uniforms.pointLights.needsUpdate = value;
		uniforms.spotLights.needsUpdate = value;
		uniforms.rectAreaLights.needsUpdate = value;
		uniforms.hemisphereLights.needsUpdate = value;

	}

	// Lighting

	function setupShadows( lights ) {

		var lightShadowsLength = 0;

		for ( var i = 0, l = lights.length; i < l; i ++ ) {

			var light = lights[ i ];

			if ( light.castShadow ) {

				_lights.shadows[ lightShadowsLength ++ ] = light;

			}

		}

		_lights.shadows.length = lightShadowsLength;

	}

	function setupLights( lights, camera ) {

		var l, ll, light,
			r = 0, g = 0, b = 0,
			color,
			intensity,
			distance,
			shadowMap,

			viewMatrix = camera.matrixWorldInverse,

		directionalLength = 0,
		pointLength = 0,
		spotLength = 0,
		rectAreaLength = 0,
		hemiLength = 0;

		for ( l = 0, ll = lights.length; l < ll; l ++ ) {

			light = lights[ l ];

			color = light.color;
			intensity = light.intensity;
			distance = light.distance;

			shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;

			if ( light.isAmbientLight ) {

				r += color.r * intensity;
				g += color.g * intensity;
				b += color.b * intensity;

			} else if ( light.isDirectionalLight ) {

				var uniforms = lightCache.get( light );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( _vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.directionalShadowMap[ directionalLength ] = shadowMap;
				_lights.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
				_lights.directional[ directionalLength ++ ] = uniforms;

			} else if ( light.isSpotLight ) {

				var uniforms = lightCache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( color ).multiplyScalar( intensity );
				uniforms.distance = distance;

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				_vector3.setFromMatrixPosition( light.target.matrixWorld );
				uniforms.direction.sub( _vector3 );
				uniforms.direction.transformDirection( viewMatrix );

				uniforms.coneCos = Math.cos( light.angle );
				uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.spotShadowMap[ spotLength ] = shadowMap;
				_lights.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
				_lights.spot[ spotLength ++ ] = uniforms;

			} else if ( light.isRectAreaLight ) {

				var uniforms = lightCache.get( light );

				// (a) intensity controls irradiance of entire light
				uniforms.color
					.copy( color )
					.multiplyScalar( intensity / ( light.width * light.height ) );

				// (b) intensity controls the radiance per light area
				// uniforms.color.copy( color ).multiplyScalar( intensity );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				// extract local rotation of light to derive width/height half vectors
				_matrix42.identity();
				_matrix4.copy( light.matrixWorld );
				_matrix4.premultiply( viewMatrix );
				_matrix42.extractRotation( _matrix4 );

				uniforms.halfWidth.set( light.width * 0.5,                0.0, 0.0 );
				uniforms.halfHeight.set(              0.0, light.height * 0.5, 0.0 );

				uniforms.halfWidth.applyMatrix4( _matrix42 );
				uniforms.halfHeight.applyMatrix4( _matrix42 );

				// TODO (abelnation): RectAreaLight distance?
				// uniforms.distance = distance;

				_lights.rectArea[ rectAreaLength ++ ] = uniforms;

			} else if ( light.isPointLight ) {

				var uniforms = lightCache.get( light );

				uniforms.position.setFromMatrixPosition( light.matrixWorld );
				uniforms.position.applyMatrix4( viewMatrix );

				uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
				uniforms.distance = light.distance;
				uniforms.decay = ( light.distance === 0 ) ? 0.0 : light.decay;

				uniforms.shadow = light.castShadow;

				if ( light.castShadow ) {

					uniforms.shadowBias = light.shadow.bias;
					uniforms.shadowRadius = light.shadow.radius;
					uniforms.shadowMapSize = light.shadow.mapSize;

				}

				_lights.pointShadowMap[ pointLength ] = shadowMap;

				if ( _lights.pointShadowMatrix[ pointLength ] === undefined ) {

					_lights.pointShadowMatrix[ pointLength ] = new Matrix4();

				}

				// for point lights we set the shadow matrix to be a translation-only matrix
				// equal to inverse of the light's position
				_vector3.setFromMatrixPosition( light.matrixWorld ).negate();
				_lights.pointShadowMatrix[ pointLength ].identity().setPosition( _vector3 );

				_lights.point[ pointLength ++ ] = uniforms;

			} else if ( light.isHemisphereLight ) {

				var uniforms = lightCache.get( light );

				uniforms.direction.setFromMatrixPosition( light.matrixWorld );
				uniforms.direction.transformDirection( viewMatrix );
				uniforms.direction.normalize();

				uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
				uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );

				_lights.hemi[ hemiLength ++ ] = uniforms;

			}

		}

		_lights.ambient[ 0 ] = r;
		_lights.ambient[ 1 ] = g;
		_lights.ambient[ 2 ] = b;

		_lights.directional.length = directionalLength;
		_lights.spot.length = spotLength;
		_lights.rectArea.length = rectAreaLength;
		_lights.point.length = pointLength;
		_lights.hemi.length = hemiLength;

		// TODO (sam-g-steel) why aren't we using join
		_lights.hash = directionalLength + ',' + pointLength + ',' + spotLength + ',' + rectAreaLength + ',' + hemiLength + ',' + _lights.shadows.length;

	}

	// GL state setting

	this.setFaceCulling = function ( cullFace, frontFaceDirection ) {

		state.setCullFace( cullFace );
		state.setFlipSided( frontFaceDirection === FrontFaceDirectionCW );

	};

	// Textures

	function allocTextureUnit() {

		var textureUnit = _usedTextureUnits;

		if ( textureUnit >= capabilities.maxTextures ) {

			console.warn( 'WebGLRenderer: trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );

		}

		_usedTextureUnits += 1;

		return textureUnit;

	}

	this.allocTextureUnit = allocTextureUnit;

	// this.setTexture2D = setTexture2D;
	this.setTexture2D = ( function() {

		var warned = false;

		// backwards compatibility: peel texture.texture
		return function setTexture2D( texture, slot ) {

			if ( texture && texture.isWebGLRenderTarget ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
					warned = true;

				}

				texture = texture.texture;

			}

			textures.setTexture2D( texture, slot );

		};

	}() );

	this.setTexture = ( function() {

		var warned = false;

		return function setTexture( texture, slot ) {

			if ( ! warned ) {

				console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
				warned = true;

			}

			textures.setTexture2D( texture, slot );

		};

	}() );

	this.setTextureCube = ( function() {

		var warned = false;

		return function setTextureCube( texture, slot ) {

			// backwards compatibility: peel texture.texture
			if ( texture && texture.isWebGLRenderTargetCube ) {

				if ( ! warned ) {

					console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
					warned = true;

				}

				texture = texture.texture;

			}

			// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
			// TODO: unify these code paths
			if ( ( texture && texture.isCubeTexture ) ||
				( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {

				// CompressedTexture can have Array in image :/

				// this function alone should take care of cube textures
				textures.setTextureCube( texture, slot );

			} else {

				// assumed: texture property of THREE.WebGLRenderTargetCube

				textures.setTextureCubeDynamic( texture, slot );

			}

		};

	}() );

	this.getCurrentRenderTarget = function() {

		return _currentRenderTarget;

	};

	this.setRenderTarget = function ( renderTarget ) {

		_currentRenderTarget = renderTarget;

		if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {

			textures.setupRenderTarget( renderTarget );

		}

		var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
		var framebuffer;

		if ( renderTarget ) {

			var renderTargetProperties = properties.get( renderTarget );

			if ( isCube ) {

				framebuffer = renderTargetProperties.__webglFramebuffer[ renderTarget.activeCubeFace ];

			} else {

				framebuffer = renderTargetProperties.__webglFramebuffer;

			}

			_currentScissor.copy( renderTarget.scissor );
			_currentScissorTest = renderTarget.scissorTest;

			_currentViewport.copy( renderTarget.viewport );

		} else {

			framebuffer = null;

			_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
			_currentScissorTest = _scissorTest;

			_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );

		}

		if ( _currentFramebuffer !== framebuffer ) {

			_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );
			_currentFramebuffer = framebuffer;

		}

		state.scissor( _currentScissor );
		state.setScissorTest( _currentScissorTest );

		state.viewport( _currentViewport );

		if ( isCube ) {

			var textureProperties = properties.get( renderTarget.texture );
			_gl.framebufferTexture2D( _gl.FRAMEBUFFER, _gl.COLOR_ATTACHMENT0, _gl.TEXTURE_CUBE_MAP_POSITIVE_X + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );

		}

	};

	this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {

		if ( ( renderTarget && renderTarget.isWebGLRenderTarget ) === false ) {

			console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
			return;

		}

		var framebuffer = properties.get( renderTarget ).__webglFramebuffer;

		if ( framebuffer ) {

			var restore = false;

			if ( framebuffer !== _currentFramebuffer ) {

				_gl.bindFramebuffer( _gl.FRAMEBUFFER, framebuffer );

				restore = true;

			}

			try {

				var texture = renderTarget.texture;
				var textureFormat = texture.format;
				var textureType = texture.type;

				if ( textureFormat !== RGBAFormat && paramThreeToGL( textureFormat ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_FORMAT ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
					return;

				}

				if ( textureType !== UnsignedByteType && paramThreeToGL( textureType ) !== _gl.getParameter( _gl.IMPLEMENTATION_COLOR_READ_TYPE ) && // IE11, Edge and Chrome Mac < 52 (#9513)
					! ( textureType === FloatType && ( extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
					! ( textureType === HalfFloatType && extensions.get( 'EXT_color_buffer_half_float' ) ) ) {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
					return;

				}

				if ( _gl.checkFramebufferStatus( _gl.FRAMEBUFFER ) === _gl.FRAMEBUFFER_COMPLETE ) {

					// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)

					if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {

						_gl.readPixels( x, y, width, height, paramThreeToGL( textureFormat ), paramThreeToGL( textureType ), buffer );

					}

				} else {

					console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );

				}

			} finally {

				if ( restore ) {

					_gl.bindFramebuffer( _gl.FRAMEBUFFER, _currentFramebuffer );

				}

			}

		}

	};

	// Map three.js constants to WebGL constants

	function paramThreeToGL( p ) {

		var extension;

		if ( p === RepeatWrapping ) return _gl.REPEAT;
		if ( p === ClampToEdgeWrapping ) return _gl.CLAMP_TO_EDGE;
		if ( p === MirroredRepeatWrapping ) return _gl.MIRRORED_REPEAT;

		if ( p === NearestFilter ) return _gl.NEAREST;
		if ( p === NearestMipMapNearestFilter ) return _gl.NEAREST_MIPMAP_NEAREST;
		if ( p === NearestMipMapLinearFilter ) return _gl.NEAREST_MIPMAP_LINEAR;

		if ( p === LinearFilter ) return _gl.LINEAR;
		if ( p === LinearMipMapNearestFilter ) return _gl.LINEAR_MIPMAP_NEAREST;
		if ( p === LinearMipMapLinearFilter ) return _gl.LINEAR_MIPMAP_LINEAR;

		if ( p === UnsignedByteType ) return _gl.UNSIGNED_BYTE;
		if ( p === UnsignedShort4444Type ) return _gl.UNSIGNED_SHORT_4_4_4_4;
		if ( p === UnsignedShort5551Type ) return _gl.UNSIGNED_SHORT_5_5_5_1;
		if ( p === UnsignedShort565Type ) return _gl.UNSIGNED_SHORT_5_6_5;

		if ( p === ByteType ) return _gl.BYTE;
		if ( p === ShortType ) return _gl.SHORT;
		if ( p === UnsignedShortType ) return _gl.UNSIGNED_SHORT;
		if ( p === IntType ) return _gl.INT;
		if ( p === UnsignedIntType ) return _gl.UNSIGNED_INT;
		if ( p === FloatType ) return _gl.FLOAT;

		if ( p === HalfFloatType ) {

			extension = extensions.get( 'OES_texture_half_float' );

			if ( extension !== null ) return extension.HALF_FLOAT_OES;

		}

		if ( p === AlphaFormat ) return _gl.ALPHA;
		if ( p === RGBFormat ) return _gl.RGB;
		if ( p === RGBAFormat ) return _gl.RGBA;
		if ( p === LuminanceFormat ) return _gl.LUMINANCE;
		if ( p === LuminanceAlphaFormat ) return _gl.LUMINANCE_ALPHA;
		if ( p === DepthFormat ) return _gl.DEPTH_COMPONENT;
		if ( p === DepthStencilFormat ) return _gl.DEPTH_STENCIL;

		if ( p === AddEquation ) return _gl.FUNC_ADD;
		if ( p === SubtractEquation ) return _gl.FUNC_SUBTRACT;
		if ( p === ReverseSubtractEquation ) return _gl.FUNC_REVERSE_SUBTRACT;

		if ( p === ZeroFactor ) return _gl.ZERO;
		if ( p === OneFactor ) return _gl.ONE;
		if ( p === SrcColorFactor ) return _gl.SRC_COLOR;
		if ( p === OneMinusSrcColorFactor ) return _gl.ONE_MINUS_SRC_COLOR;
		if ( p === SrcAlphaFactor ) return _gl.SRC_ALPHA;
		if ( p === OneMinusSrcAlphaFactor ) return _gl.ONE_MINUS_SRC_ALPHA;
		if ( p === DstAlphaFactor ) return _gl.DST_ALPHA;
		if ( p === OneMinusDstAlphaFactor ) return _gl.ONE_MINUS_DST_ALPHA;

		if ( p === DstColorFactor ) return _gl.DST_COLOR;
		if ( p === OneMinusDstColorFactor ) return _gl.ONE_MINUS_DST_COLOR;
		if ( p === SrcAlphaSaturateFactor ) return _gl.SRC_ALPHA_SATURATE;

		if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
			p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );

			if ( extension !== null ) {

				if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
				if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
				if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;

			}

		}

		if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
			p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );

			if ( extension !== null ) {

				if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
				if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
				if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
				if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;

			}

		}

		if ( p === RGB_ETC1_Format ) {

			extension = extensions.get( 'WEBGL_compressed_texture_etc1' );

			if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;

		}

		if ( p === MinEquation || p === MaxEquation ) {

			extension = extensions.get( 'EXT_blend_minmax' );

			if ( extension !== null ) {

				if ( p === MinEquation ) return extension.MIN_EXT;
				if ( p === MaxEquation ) return extension.MAX_EXT;

			}

		}

		if ( p === UnsignedInt248Type ) {

			extension = extensions.get( 'WEBGL_depth_texture' );

			if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;

		}

		return 0;

	}

}

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function FogExp2 ( color, density ) {

	this.name = '';

	this.color = new Color( color );
	this.density = ( density !== undefined ) ? density : 0.00025;

}

FogExp2.prototype.isFogExp2 = true;

FogExp2.prototype.clone = function () {

	return new FogExp2( this.color.getHex(), this.density );

};

FogExp2.prototype.toJSON = function ( meta ) {

	return {
		type: 'FogExp2',
		color: this.color.getHex(),
		density: this.density
	};

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Fog ( color, near, far ) {

	this.name = '';

	this.color = new Color( color );

	this.near = ( near !== undefined ) ? near : 1;
	this.far = ( far !== undefined ) ? far : 1000;

}

Fog.prototype.isFog = true;

Fog.prototype.clone = function () {

	return new Fog( this.color.getHex(), this.near, this.far );

};

Fog.prototype.toJSON = function ( meta ) {

	return {
		type: 'Fog',
		color: this.color.getHex(),
		near: this.near,
		far: this.far
	};

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Scene () {

	Object3D.call( this );

	this.type = 'Scene';

	this.background = null;
	this.fog = null;
	this.overrideMaterial = null;

	this.autoUpdate = true; // checked by the renderer

}

Scene.prototype = Object.create( Object3D.prototype );

Scene.prototype.constructor = Scene;

Scene.prototype.copy = function ( source, recursive ) {

	Object3D.prototype.copy.call( this, source, recursive );

	if ( source.background !== null ) this.background = source.background.clone();
	if ( source.fog !== null ) this.fog = source.fog.clone();
	if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();

	this.autoUpdate = source.autoUpdate;
	this.matrixAutoUpdate = source.matrixAutoUpdate;

	return this;

};

Scene.prototype.toJSON = function ( meta ) {

	var data = Object3D.prototype.toJSON.call( this, meta );

	if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
	if ( this.fog !== null ) data.object.fog = this.fog.toJSON();

	return data;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function LensFlare( texture, size, distance, blending, color ) {

	Object3D.call( this );

	this.lensFlares = [];

	this.positionScreen = new Vector3();
	this.customUpdateCallback = undefined;

	if ( texture !== undefined ) {

		this.add( texture, size, distance, blending, color );

	}

}

LensFlare.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: LensFlare,

	isLensFlare: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.positionScreen.copy( source.positionScreen );
		this.customUpdateCallback = source.customUpdateCallback;

		for ( var i = 0, l = source.lensFlares.length; i < l; i ++ ) {

			this.lensFlares.push( source.lensFlares[ i ] );

		}

		return this;

	},

	add: function ( texture, size, distance, blending, color, opacity ) {

		if ( size === undefined ) size = - 1;
		if ( distance === undefined ) distance = 0;
		if ( opacity === undefined ) opacity = 1;
		if ( color === undefined ) color = new Color( 0xffffff );
		if ( blending === undefined ) blending = NormalBlending;

		distance = Math.min( distance, Math.max( 0, distance ) );

		this.lensFlares.push( {
			texture: texture,	// THREE.Texture
			size: size, 		// size in pixels (-1 = use texture.width)
			distance: distance, 	// distance (0-1) from light source (0=at light source)
			x: 0, y: 0, z: 0,	// screen position (-1 => 1) z = 0 is in front z = 1 is back
			scale: 1, 		// scale
			rotation: 0, 		// rotation
			opacity: opacity,	// opacity
			color: color,		// color
			blending: blending	// blending
		} );

	},

	/*
	 * Update lens flares update positions on all flares based on the screen position
	 * Set myLensFlare.customUpdateCallback to alter the flares in your project specific way.
	 */

	updateLensFlares: function () {

		var f, fl = this.lensFlares.length;
		var flare;
		var vecX = - this.positionScreen.x * 2;
		var vecY = - this.positionScreen.y * 2;

		for ( f = 0; f < fl; f ++ ) {

			flare = this.lensFlares[ f ];

			flare.x = this.positionScreen.x + vecX * flare.distance;
			flare.y = this.positionScreen.y + vecY * flare.distance;

			flare.wantedRotation = flare.x * Math.PI * 0.25;
			flare.rotation += ( flare.wantedRotation - flare.rotation ) * 0.25;

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *	uvOffset: new THREE.Vector2(),
 *	uvScale: new THREE.Vector2()
 * }
 */

function SpriteMaterial( parameters ) {

	Material.call( this );

	this.type = 'SpriteMaterial';

	this.color = new Color( 0xffffff );
	this.map = null;

	this.rotation = 0;

	this.fog = false;
	this.lights = false;

	this.setValues( parameters );

}

SpriteMaterial.prototype = Object.create( Material.prototype );
SpriteMaterial.prototype.constructor = SpriteMaterial;

SpriteMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.map = source.map;

	this.rotation = source.rotation;

	return this;

};

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 */

function Sprite( material ) {

	Object3D.call( this );

	this.type = 'Sprite';

	this.material = ( material !== undefined ) ? material : new SpriteMaterial();

}

Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Sprite,

	isSprite: true,

	raycast: ( function () {

		var matrixPosition = new Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distanceSq = raycaster.ray.distanceSqToPoint( matrixPosition );
			var guessSizeSq = this.scale.x * this.scale.y / 4;

			if ( distanceSq > guessSizeSq ) {

				return;

			}

			intersects.push( {

				distance: Math.sqrt( distanceSq ),
				point: this.position,
				face: null,
				object: this

			} );

		};

	}() ),

	clone: function () {

		return new this.constructor( this.material ).copy( this );

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function LOD() {

	Object3D.call( this );

	this.type = 'LOD';

	Object.defineProperties( this, {
		levels: {
			enumerable: true,
			value: []
		}
	} );

}


LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: LOD,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source, false );

		var levels = source.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			this.addLevel( level.object.clone(), level.distance );

		}

		return this;

	},

	addLevel: function ( object, distance ) {

		if ( distance === undefined ) distance = 0;

		distance = Math.abs( distance );

		var levels = this.levels;

		for ( var l = 0; l < levels.length; l ++ ) {

			if ( distance < levels[ l ].distance ) {

				break;

			}

		}

		levels.splice( l, 0, { distance: distance, object: object } );

		this.add( object );

	},

	getObjectForDistance: function ( distance ) {

		var levels = this.levels;

		for ( var i = 1, l = levels.length; i < l; i ++ ) {

			if ( distance < levels[ i ].distance ) {

				break;

			}

		}

		return levels[ i - 1 ].object;

	},

	raycast: ( function () {

		var matrixPosition = new Vector3();

		return function raycast( raycaster, intersects ) {

			matrixPosition.setFromMatrixPosition( this.matrixWorld );

			var distance = raycaster.ray.origin.distanceTo( matrixPosition );

			this.getObjectForDistance( distance ).raycast( raycaster, intersects );

		};

	}() ),

	update: function () {

		var v1 = new Vector3();
		var v2 = new Vector3();

		return function update( camera ) {

			var levels = this.levels;

			if ( levels.length > 1 ) {

				v1.setFromMatrixPosition( camera.matrixWorld );
				v2.setFromMatrixPosition( this.matrixWorld );

				var distance = v1.distanceTo( v2 );

				levels[ 0 ].object.visible = true;

				for ( var i = 1, l = levels.length; i < l; i ++ ) {

					if ( distance >= levels[ i ].distance ) {

						levels[ i - 1 ].object.visible = false;
						levels[ i ].object.visible = true;

					} else {

						break;

					}

				}

				for ( ; i < l; i ++ ) {

					levels[ i ].object.visible = false;

				}

			}

		};

	}(),

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.levels = [];

		var levels = this.levels;

		for ( var i = 0, l = levels.length; i < l; i ++ ) {

			var level = levels[ i ];

			data.object.levels.push( {
				object: level.object.uuid,
				distance: level.distance
			} );

		}

		return data;

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author michael guerrero / http://realitymeltdown.com
 * @author ikerr / http://verold.com
 */

function Skeleton( bones, boneInverses, useVertexTexture ) {

	this.useVertexTexture = useVertexTexture !== undefined ? useVertexTexture : true;

	this.identityMatrix = new Matrix4();

	// copy the bone array

	bones = bones || [];

	this.bones = bones.slice( 0 );

	// create a bone texture or an array of floats

	if ( this.useVertexTexture ) {

		// layout (1 matrix = 4 pixels)
		//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
		//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
		//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
		//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
		//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)


		var size = Math.sqrt( this.bones.length * 4 ); // 4 pixels needed for 1 matrix
		size = _Math.nextPowerOfTwo( Math.ceil( size ) );
		size = Math.max( size, 4 );

		this.boneTextureWidth = size;
		this.boneTextureHeight = size;

		this.boneMatrices = new Float32Array( this.boneTextureWidth * this.boneTextureHeight * 4 ); // 4 floats per RGBA pixel
		this.boneTexture = new DataTexture( this.boneMatrices, this.boneTextureWidth, this.boneTextureHeight, RGBAFormat, FloatType );

	} else {

		this.boneMatrices = new Float32Array( 16 * this.bones.length );

	}

	// use the supplied bone inverses or calculate the inverses

	if ( boneInverses === undefined ) {

		this.calculateInverses();

	} else {

		if ( this.bones.length === boneInverses.length ) {

			this.boneInverses = boneInverses.slice( 0 );

		} else {

			console.warn( 'THREE.Skeleton bonInverses is the wrong length.' );

			this.boneInverses = [];

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				this.boneInverses.push( new Matrix4() );

			}

		}

	}

}

Object.assign( Skeleton.prototype, {

	calculateInverses: function () {

		this.boneInverses = [];

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			var inverse = new Matrix4();

			if ( this.bones[ b ] ) {

				inverse.getInverse( this.bones[ b ].matrixWorld );

			}

			this.boneInverses.push( inverse );

		}

	},

	pose: function () {

		var bone;

		// recover the bind-time world matrices

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				bone.matrixWorld.getInverse( this.boneInverses[ b ] );

			}

		}

		// compute the local matrices, positions, rotations and scales

		for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

			bone = this.bones[ b ];

			if ( bone ) {

				if ( bone.parent && bone.parent.isBone ) {

					bone.matrix.getInverse( bone.parent.matrixWorld );
					bone.matrix.multiply( bone.matrixWorld );

				} else {

					bone.matrix.copy( bone.matrixWorld );

				}

				bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );

			}

		}

	},

	update: ( function () {

		var offsetMatrix = new Matrix4();

		return function update() {

			// flatten bone matrices to array

			for ( var b = 0, bl = this.bones.length; b < bl; b ++ ) {

				// compute the offset between the current and the original transform

				var matrix = this.bones[ b ] ? this.bones[ b ].matrixWorld : this.identityMatrix;

				offsetMatrix.multiplyMatrices( matrix, this.boneInverses[ b ] );
				offsetMatrix.toArray( this.boneMatrices, b * 16 );

			}

			if ( this.useVertexTexture ) {

				this.boneTexture.needsUpdate = true;

			}

		};

	} )(),

	clone: function () {

		return new Skeleton( this.bones, this.boneInverses, this.useVertexTexture );

	}

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function Bone() {

	Object3D.call( this );

	this.type = 'Bone';

}

Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Bone,

	isBone: true

} );

/**
 * @author mikael emtinger / http://gomo.se/
 * @author alteredq / http://alteredqualia.com/
 * @author ikerr / http://verold.com
 */

function SkinnedMesh( geometry, material, useVertexTexture ) {

	Mesh.call( this, geometry, material );

	this.type = 'SkinnedMesh';

	this.bindMode = "attached";
	this.bindMatrix = new Matrix4();
	this.bindMatrixInverse = new Matrix4();

	// init bones

	// TODO: remove bone creation as there is no reason (other than
	// convenience) for THREE.SkinnedMesh to do this.

	var bones = [];

	if ( this.geometry && this.geometry.bones !== undefined ) {

		var bone, gbone;

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			bone = new Bone();
			bones.push( bone );

			bone.name = gbone.name;
			bone.position.fromArray( gbone.pos );
			bone.quaternion.fromArray( gbone.rotq );
			if ( gbone.scl !== undefined ) bone.scale.fromArray( gbone.scl );

		}

		for ( var b = 0, bl = this.geometry.bones.length; b < bl; ++ b ) {

			gbone = this.geometry.bones[ b ];

			if ( gbone.parent !== - 1 && gbone.parent !== null &&
					bones[ gbone.parent ] !== undefined ) {

				bones[ gbone.parent ].add( bones[ b ] );

			} else {

				this.add( bones[ b ] );

			}

		}

	}

	this.normalizeSkinWeights();

	this.updateMatrixWorld( true );
	this.bind( new Skeleton( bones, undefined, useVertexTexture ), this.matrixWorld );

}


SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {

	constructor: SkinnedMesh,

	isSkinnedMesh: true,

	bind: function( skeleton, bindMatrix ) {

		this.skeleton = skeleton;

		if ( bindMatrix === undefined ) {

			this.updateMatrixWorld( true );

			this.skeleton.calculateInverses();

			bindMatrix = this.matrixWorld;

		}

		this.bindMatrix.copy( bindMatrix );
		this.bindMatrixInverse.getInverse( bindMatrix );

	},

	pose: function () {

		this.skeleton.pose();

	},

	normalizeSkinWeights: function () {

		if ( this.geometry && this.geometry.isGeometry ) {

			for ( var i = 0; i < this.geometry.skinWeights.length; i ++ ) {

				var sw = this.geometry.skinWeights[ i ];

				var scale = 1.0 / sw.lengthManhattan();

				if ( scale !== Infinity ) {

					sw.multiplyScalar( scale );

				} else {

					sw.set( 1, 0, 0, 0 ); // do something reasonable

				}

			}

		} else if ( this.geometry && this.geometry.isBufferGeometry ) {

			var vec = new Vector4();

			var skinWeight = this.geometry.attributes.skinWeight;

			for ( var i = 0; i < skinWeight.count; i ++ ) {

				vec.x = skinWeight.getX( i );
				vec.y = skinWeight.getY( i );
				vec.z = skinWeight.getZ( i );
				vec.w = skinWeight.getW( i );

				var scale = 1.0 / vec.lengthManhattan();

				if ( scale !== Infinity ) {

					vec.multiplyScalar( scale );

				} else {

					vec.set( 1, 0, 0, 0 ); // do something reasonable

				}

				skinWeight.setXYZW( i, vec.x, vec.y, vec.z, vec.w );

			}

		}

	},

	updateMatrixWorld: function( force ) {

		Mesh.prototype.updateMatrixWorld.call( this, true );

		if ( this.bindMode === "attached" ) {

			this.bindMatrixInverse.getInverse( this.matrixWorld );

		} else if ( this.bindMode === "detached" ) {

			this.bindMatrixInverse.getInverse( this.bindMatrix );

		} else {

			console.warn( 'THREE.SkinnedMesh unrecognized bindMode: ' + this.bindMode );

		}

	},

	clone: function() {

		return new this.constructor( this.geometry, this.material, this.skeleton.useVertexTexture ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *  linecap: "round",
 *  linejoin: "round"
 * }
 */

function LineBasicMaterial( parameters ) {

	Material.call( this );

	this.type = 'LineBasicMaterial';

	this.color = new Color( 0xffffff );

	this.linewidth = 1;
	this.linecap = 'round';
	this.linejoin = 'round';

	this.lights = false;

	this.setValues( parameters );

}

LineBasicMaterial.prototype = Object.create( Material.prototype );
LineBasicMaterial.prototype.constructor = LineBasicMaterial;

LineBasicMaterial.prototype.isLineBasicMaterial = true;

LineBasicMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;
	this.linecap = source.linecap;
	this.linejoin = source.linejoin;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Line( geometry, material, mode ) {

	if ( mode === 1 ) {

		console.warn( 'THREE.Line: parameter THREE.LinePieces no longer supported. Created THREE.LineSegments instead.' );
		return new LineSegments( geometry, material );

	}

	Object3D.call( this );

	this.type = 'Line';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );

}

Line.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Line,

	isLine: true,

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		return function raycast( raycaster, intersects ) {

			var precision = raycaster.linePrecision;
			var precisionSq = precision * precision;

			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var vStart = new Vector3();
			var vEnd = new Vector3();
			var interSegment = new Vector3();
			var interRay = new Vector3();
			var step = (this && this.isLineSegments) ? 2 : 1;

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, l = indices.length - 1; i < l; i += step ) {

						var a = indices[ i ];
						var b = indices[ i + 1 ];

						vStart.fromArray( positions, a * 3 );
						vEnd.fromArray( positions, b * 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				} else {

					for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {

						vStart.fromArray( positions, 3 * i );
						vEnd.fromArray( positions, 3 * i + 3 );

						var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );

						if ( distSq > precisionSq ) continue;

						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

						var distance = raycaster.ray.origin.distanceTo( interRay );

						if ( distance < raycaster.near || distance > raycaster.far ) continue;

						intersects.push( {

							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this

						} );

					}

				}

			} else if ( geometry.isGeometry ) {

				var vertices = geometry.vertices;
				var nbVertices = vertices.length;

				for ( var i = 0; i < nbVertices - 1; i += step ) {

					var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );

					if ( distSq > precisionSq ) continue;

					interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation

					var distance = raycaster.ray.origin.distanceTo( interRay );

					if ( distance < raycaster.near || distance > raycaster.far ) continue;

					intersects.push( {

						distance: distance,
						// What do we want? intersection point on the ray or on the segment??
						// point: raycaster.ray.at( distance ),
						point: interSegment.clone().applyMatrix4( this.matrixWorld ),
						index: i,
						face: null,
						faceIndex: null,
						object: this

					} );

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LineSegments( geometry, material ) {

	Line.call( this, geometry, material );

	this.type = 'LineSegments';

}

LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {

	constructor: LineSegments,

	isLineSegments: true

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *  map: new THREE.Texture( <Image> ),
 *
 *  size: <float>,
 *  sizeAttenuation: <bool>
 * }
 */

function PointsMaterial( parameters ) {

	Material.call( this );

	this.type = 'PointsMaterial';

	this.color = new Color( 0xffffff );

	this.map = null;

	this.size = 1;
	this.sizeAttenuation = true;

	this.lights = false;

	this.setValues( parameters );

}

PointsMaterial.prototype = Object.create( Material.prototype );
PointsMaterial.prototype.constructor = PointsMaterial;

PointsMaterial.prototype.isPointsMaterial = true;

PointsMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.size = source.size;
	this.sizeAttenuation = source.sizeAttenuation;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Points( geometry, material ) {

	Object3D.call( this );

	this.type = 'Points';

	this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
	this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );

}

Points.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Points,

	isPoints: true,

	raycast: ( function () {

		var inverseMatrix = new Matrix4();
		var ray = new Ray();
		var sphere = new Sphere();

		return function raycast( raycaster, intersects ) {

			var object = this;
			var geometry = this.geometry;
			var matrixWorld = this.matrixWorld;
			var threshold = raycaster.params.Points.threshold;

			// Checking boundingSphere distance to ray

			if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();

			sphere.copy( geometry.boundingSphere );
			sphere.applyMatrix4( matrixWorld );

			if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;

			//

			inverseMatrix.getInverse( matrixWorld );
			ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );

			var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
			var localThresholdSq = localThreshold * localThreshold;
			var position = new Vector3();

			function testPoint( point, index ) {

				var rayPointDistanceSq = ray.distanceSqToPoint( point );

				if ( rayPointDistanceSq < localThresholdSq ) {

					var intersectPoint = ray.closestPointToPoint( point );
					intersectPoint.applyMatrix4( matrixWorld );

					var distance = raycaster.ray.origin.distanceTo( intersectPoint );

					if ( distance < raycaster.near || distance > raycaster.far ) return;

					intersects.push( {

						distance: distance,
						distanceToRay: Math.sqrt( rayPointDistanceSq ),
						point: intersectPoint.clone(),
						index: index,
						face: null,
						object: object

					} );

				}

			}

			if ( geometry.isBufferGeometry ) {

				var index = geometry.index;
				var attributes = geometry.attributes;
				var positions = attributes.position.array;

				if ( index !== null ) {

					var indices = index.array;

					for ( var i = 0, il = indices.length; i < il; i ++ ) {

						var a = indices[ i ];

						position.fromArray( positions, a * 3 );

						testPoint( position, a );

					}

				} else {

					for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {

						position.fromArray( positions, i * 3 );

						testPoint( position, i );

					}

				}

			} else {

				var vertices = geometry.vertices;

				for ( var i = 0, l = vertices.length; i < l; i ++ ) {

					testPoint( vertices[ i ], i );

				}

			}

		};

	}() ),

	clone: function () {

		return new this.constructor( this.geometry, this.material ).copy( this );

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Group() {

	Object3D.call( this );

	this.type = 'Group';

}

Group.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Group

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.generateMipmaps = false;

	var scope = this;

	function update() {

		requestAnimationFrame( update );

		if ( video.readyState >= video.HAVE_CURRENT_DATA ) {

			scope.needsUpdate = true;

		}

	}

	update();

}

VideoTexture.prototype = Object.create( Texture.prototype );
VideoTexture.prototype.constructor = VideoTexture;

/**
 * @author alteredq / http://alteredqualia.com/
 */

function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );

	this.image = { width: width, height: height };
	this.mipmaps = mipmaps;

	// no flipping for cube textures
	// (also flipping doesn't work for compressed textures )

	this.flipY = false;

	// can't generate mipmaps for compressed textures
	// mips must be embedded in DDS files

	this.generateMipmaps = false;

}

CompressedTexture.prototype = Object.create( Texture.prototype );
CompressedTexture.prototype.constructor = CompressedTexture;

CompressedTexture.prototype.isCompressedTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {

	Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.needsUpdate = true;

}

CanvasTexture.prototype = Object.create( Texture.prototype );
CanvasTexture.prototype.constructor = CanvasTexture;

/**
 * @author Matt DesLauriers / @mattdesl
 * @author atix / arthursilber.de
 */

function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {

	format = format !== undefined ? format : DepthFormat;

	if ( format !== DepthFormat && format !== DepthStencilFormat ) {

		throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' )

	}

	if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
	if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;

	Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );

	this.image = { width: width, height: height };

	this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
	this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;

	this.flipY = false;
	this.generateMipmaps	= false;

}

DepthTexture.prototype = Object.create( Texture.prototype );
DepthTexture.prototype.constructor = DepthTexture;
DepthTexture.prototype.isDepthTexture = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function WireframeGeometry( geometry ) {

	BufferGeometry.call( this );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	if ( geometry && geometry.isGeometry ) {

		var vertices = geometry.vertices;
		var faces = geometry.faces;
		var numEdges = 0;

		// allocate maximal size
		var edges = new Uint32Array( 6 * faces.length );

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			for ( var j = 0; j < 3; j ++ ) {

				edge[ 0 ] = face[ keys[ j ] ];
				edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
				edge.sort( sortFunction );

				var key = edge.toString();

				if ( hash[ key ] === undefined ) {

					edges[ 2 * numEdges ] = edge[ 0 ];
					edges[ 2 * numEdges + 1 ] = edge[ 1 ];
					hash[ key ] = true;
					numEdges ++;

				}

			}

		}

		var coords = new Float32Array( numEdges * 2 * 3 );

		for ( var i = 0, l = numEdges; i < l; i ++ ) {

			for ( var j = 0; j < 2; j ++ ) {

				var vertex = vertices[ edges [ 2 * i + j ] ];

				var index = 6 * i + 3 * j;
				coords[ index + 0 ] = vertex.x;
				coords[ index + 1 ] = vertex.y;
				coords[ index + 2 ] = vertex.z;

			}

		}

		this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

	} else if ( geometry && geometry.isBufferGeometry ) {

		if ( geometry.index !== null ) {

			// Indexed BufferGeometry

			var indices = geometry.index.array;
			var vertices = geometry.attributes.position;
			var groups = geometry.groups;
			var numEdges = 0;

			if ( groups.length === 0 ) {

				geometry.addGroup( 0, indices.length );

			}

			// allocate maximal size
			var edges = new Uint32Array( 2 * indices.length );

			for ( var o = 0, ol = groups.length; o < ol; ++ o ) {

				var group = groups[ o ];

				var start = group.start;
				var count = group.count;

				for ( var i = start, il = start + count; i < il; i += 3 ) {

					for ( var j = 0; j < 3; j ++ ) {

						edge[ 0 ] = indices[ i + j ];
						edge[ 1 ] = indices[ i + ( j + 1 ) % 3 ];
						edge.sort( sortFunction );

						var key = edge.toString();

						if ( hash[ key ] === undefined ) {

							edges[ 2 * numEdges ] = edge[ 0 ];
							edges[ 2 * numEdges + 1 ] = edge[ 1 ];
							hash[ key ] = true;
							numEdges ++;

						}

					}

				}

			}

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numEdges; i < l; i ++ ) {

				for ( var j = 0; j < 2; j ++ ) {

					var index = 6 * i + 3 * j;
					var index2 = edges[ 2 * i + j ];

					coords[ index + 0 ] = vertices.getX( index2 );
					coords[ index + 1 ] = vertices.getY( index2 );
					coords[ index + 2 ] = vertices.getZ( index2 );

				}

			}

			this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

		} else {

			// non-indexed BufferGeometry

			var vertices = geometry.attributes.position.array;
			var numEdges = vertices.length / 3;
			var numTris = numEdges / 3;

			var coords = new Float32Array( numEdges * 2 * 3 );

			for ( var i = 0, l = numTris; i < l; i ++ ) {

				for ( var j = 0; j < 3; j ++ ) {

					var index = 18 * i + 6 * j;

					var index1 = 9 * i + 3 * j;
					coords[ index + 0 ] = vertices[ index1 ];
					coords[ index + 1 ] = vertices[ index1 + 1 ];
					coords[ index + 2 ] = vertices[ index1 + 2 ];

					var index2 = 9 * i + 3 * ( ( j + 1 ) % 3 );
					coords[ index + 3 ] = vertices[ index2 ];
					coords[ index + 4 ] = vertices[ index2 + 1 ];
					coords[ index + 5 ] = vertices[ index2 + 2 ];

				}

			}

			this.addAttribute( 'position', new BufferAttribute( coords, 3 ) );

		}

	}

}

WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
WireframeGeometry.prototype.constructor = WireframeGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */

function ParametricBufferGeometry( func, slices, stacks ) {

	BufferGeometry.call( this );

	this.type = 'ParametricBufferGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	// generate vertices and uvs

	var vertices = [];
	var uvs = [];

	var i, j, p;
	var u, v;

	var sliceCount = slices + 1;

	for ( i = 0; i <= stacks; i ++ ) {

		v = i / stacks;

		for ( j = 0; j <= slices; j ++ ) {

			u = j / slices;

			p = func( u, v );
			vertices.push( p.x, p.y, p.z );

			uvs.push( u, v );

		}

	}

	// generate indices

	var indices = [];
	var a, b, c, d;

	for ( i = 0; i < stacks; i ++ ) {

		for ( j = 0; j < slices; j ++ ) {

			a = i * sliceCount + j;
			b = i * sliceCount + j + 1;
			c = ( i + 1 ) * sliceCount + j + 1;
			d = ( i + 1 ) * sliceCount + j;

			// faces one and two

			indices.push( a, b, d );
			indices.push( b, c, d );

		}

	}

	// build geometry

	this.setIndex( new ( indices.length > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 ) );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// generate normals

	this.computeVertexNormals();

}

ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;

/**
 * @author zz85 / https://github.com/zz85
 *
 * Parametric Surfaces Geometry
 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
 */

function ParametricGeometry( func, slices, stacks ) {

	Geometry.call( this );

	this.type = 'ParametricGeometry';

	this.parameters = {
		func: func,
		slices: slices,
		stacks: stacks
	};

	this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
	this.mergeVertices();

}

ParametricGeometry.prototype = Object.create( Geometry.prototype );
ParametricGeometry.prototype.constructor = ParametricGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {

	BufferGeometry.call( this );

	this.type = 'PolyhedronBufferGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	radius = radius || 1;
	detail = detail || 0;

	// default buffer data

	var vertexBuffer = [];
	var uvBuffer = [];

	// the subdivision creates the vertex buffer data

	subdivide( detail );

	// all vertices should lie on a conceptual sphere with a given radius

	appplyRadius( radius );

	// finally, create the uv data

	generateUVs();

	// build non-indexed geometry

	this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );
	this.normalizeNormals();

	this.boundingSphere = new Sphere( new Vector3(), radius );

	// helper functions

	function subdivide( detail ) {

		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();

		// iterate over all faces and apply a subdivison with the given detail value

		for ( var i = 0; i < indices.length; i += 3 ) {

			// get the vertices of the face

			getVertexByIndex( indices[ i + 0 ], a );
			getVertexByIndex( indices[ i + 1 ], b );
			getVertexByIndex( indices[ i + 2 ], c );

			// perform subdivision

			subdivideFace( a, b, c, detail );

		}

	}

	function subdivideFace( a, b, c, detail ) {

		var cols = Math.pow( 2, detail );

		// we use this multidimensional array as a data structure for creating the subdivision

		var v = [];

		var i, j;

		// construct all of the vertices for this subdivision

		for ( i = 0 ; i <= cols; i ++ ) {

			v[ i ] = [];

			var aj = a.clone().lerp( c, i / cols );
			var bj = b.clone().lerp( c, i / cols );

			var rows = cols - i;

			for ( j = 0; j <= rows; j ++ ) {

				if ( j === 0 && i === cols ) {

					v[ i ][ j ] = aj;

				} else {

					v[ i ][ j ] = aj.clone().lerp( bj, j / rows );

				}

			}

		}

		// construct all of the faces

		for ( i = 0; i < cols ; i ++ ) {

			for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {

				var k = Math.floor( j / 2 );

				if ( j % 2 === 0 ) {

					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );
					pushVertex( v[ i ][ k ] );

				} else {

					pushVertex( v[ i ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k + 1 ] );
					pushVertex( v[ i + 1 ][ k ] );

				}

			}

		}

	}

	function appplyRadius( radius ) {

		var vertex = new Vector3();

		// iterate over the entire buffer and apply the radius to each vertex

		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];

			vertex.normalize().multiplyScalar( radius );

			vertexBuffer[ i + 0 ] = vertex.x;
			vertexBuffer[ i + 1 ] = vertex.y;
			vertexBuffer[ i + 2 ] = vertex.z;

		}

	}

	function generateUVs() {

		var vertex = new Vector3();

		for ( var i = 0; i < vertexBuffer.length; i += 3 ) {

			vertex.x = vertexBuffer[ i + 0 ];
			vertex.y = vertexBuffer[ i + 1 ];
			vertex.z = vertexBuffer[ i + 2 ];

			var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
			var v = inclination( vertex ) / Math.PI + 0.5;
			uvBuffer.push( u, 1 - v );

		}

		correctUVs();

		correctSeam();

	}

	function correctSeam() {

		// handle case when face straddles the seam, see #3269

		for ( var i = 0; i < uvBuffer.length; i += 6 ) {

			// uv data of a single face

			var x0 = uvBuffer[ i + 0 ];
			var x1 = uvBuffer[ i + 2 ];
			var x2 = uvBuffer[ i + 4 ];

			var max = Math.max( x0, x1, x2 );
			var min = Math.min( x0, x1, x2 );

			// 0.9 is somewhat arbitrary

			if ( max > 0.9 && min < 0.1 ) {

				if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
				if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
				if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;

			}

		}

	}

	function pushVertex( vertex ) {

		vertexBuffer.push( vertex.x, vertex.y, vertex.z );

	}

	function getVertexByIndex( index, vertex ) {

		var stride = index * 3;

		vertex.x = vertices[ stride + 0 ];
		vertex.y = vertices[ stride + 1 ];
		vertex.z = vertices[ stride + 2 ];

	}

	function correctUVs() {

		var a = new Vector3();
		var b = new Vector3();
		var c = new Vector3();

		var centroid = new Vector3();

		var uvA = new Vector2();
		var uvB = new Vector2();
		var uvC = new Vector2();

		for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {

			a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
			b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
			c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );

			uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
			uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
			uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );

			centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );

			var azi = azimuth( centroid );

			correctUV( uvA, j + 0, a, azi );
			correctUV( uvB, j + 2, b, azi );
			correctUV( uvC, j + 4, c, azi );

		}

	}

	function correctUV( uv, stride, vector, azimuth  ) {

		if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {

			uvBuffer[ stride ] =  uv.x - 1;

		}

		if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {

			uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;

		}

	}

	// Angle around the Y axis, counter-clockwise when looking from above.

	function azimuth( vector ) {

		return Math.atan2( vector.z, - vector.x );

	}


	// Angle above the XZ plane.

	function inclination( vector ) {

		return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );

	}

}

PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function TetrahedronBufferGeometry( radius, detail ) {

	var vertices = [
		1,  1,  1,   - 1, - 1,  1,   - 1,  1, - 1,    1, - 1, - 1
	];

	var indices = [
		2,  1,  0,    0,  3,  2,    1,  3,  0,    2,  3,  1
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'TetrahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 */

function TetrahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'TetrahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function OctahedronBufferGeometry( radius,detail ) {

	var vertices = [
		1, 0, 0,   - 1, 0, 0,    0, 1, 0,    0, - 1, 0,    0, 0, 1,    0, 0, - 1
	];

	var indices = [
		0, 2, 4,    0, 4, 3,    0, 3, 5,    0, 5, 2,    1, 2, 5,    1, 5, 3,    1, 3, 4,    1, 4, 2
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'OctahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 */

function OctahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'OctahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

OctahedronGeometry.prototype = Object.create( Geometry.prototype );
OctahedronGeometry.prototype.constructor = OctahedronGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function IcosahedronBufferGeometry( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;

	var vertices = [
		- 1,  t,  0,    1,  t,  0,   - 1, - t,  0,    1, - t,  0,
		 0, - 1,  t,    0,  1,  t,    0, - 1, - t,    0,  1, - t,
		 t,  0, - 1,    t,  0,  1,   - t,  0, - 1,   - t,  0,  1
	];

	var indices = [
		 0, 11,  5,    0,  5,  1,    0,  1,  7,    0,  7, 10,    0, 10, 11,
		 1,  5,  9,    5, 11,  4,   11, 10,  2,   10,  7,  6,    7,  1,  8,
		 3,  9,  4,    3,  4,  2,    3,  2,  6,    3,  6,  8,    3,  8,  9,
		 4,  9,  5,    2,  4, 11,    6,  2, 10,    8,  6,  7,    9,  8,  1
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'IcosahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;

/**
 * @author timothypratley / https://github.com/timothypratley
 */

function IcosahedronGeometry( radius, detail ) {

 	Geometry.call( this );

	this.type = 'IcosahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function DodecahedronBufferGeometry( radius, detail ) {

	var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	var r = 1 / t;

	var vertices = [

		// (±1, ±1, ±1)
		- 1, - 1, - 1,    - 1, - 1,  1,
		- 1,  1, - 1,    - 1,  1,  1,
		 1, - 1, - 1,     1, - 1,  1,
		 1,  1, - 1,     1,  1,  1,

		// (0, ±1/φ, ±φ)
		 0, - r, - t,     0, - r,  t,
		 0,  r, - t,     0,  r,  t,

		// (±1/φ, ±φ, 0)
		- r, - t,  0,    - r,  t,  0,
		 r, - t,  0,     r,  t,  0,

		// (±φ, 0, ±1/φ)
		- t,  0, - r,     t,  0, - r,
		- t,  0,  r,     t,  0,  r
	];

	var indices = [
		 3, 11,  7,      3,  7, 15,      3, 15, 13,
		 7, 19, 17,      7, 17,  6,      7,  6, 15,
		17,  4,  8,     17,  8, 10,     17, 10,  6,
		 8,  0, 16,      8, 16,  2,      8,  2, 10,
		 0, 12,  1,      0,  1, 18,      0, 18, 16,
		 6, 10,  2,      6,  2, 13,      6, 13, 15,
		 2, 16, 18,      2, 18,  3,      2,  3, 13,
		18,  1,  9,     18,  9, 11,     18, 11,  3,
		 4, 14, 12,      4, 12,  0,      4,  0,  8,
		11,  9,  5,     11,  5, 19,     11, 19,  7,
		19,  5, 14,     19, 14,  4,     19,  4, 17,
		 1, 12, 14,      1, 14,  5,      1,  5,  9
	];

	PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );

	this.type = 'DodecahedronBufferGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

}

DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;

/**
 * @author Abe Pazos / https://hamoid.com
 */

function DodecahedronGeometry( radius, detail ) {

	Geometry.call( this );

	this.type = 'DodecahedronGeometry';

	this.parameters = {
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
	this.mergeVertices();

}

DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;

/**
 * @author clockworkgeek / https://github.com/clockworkgeek
 * @author timothypratley / https://github.com/timothypratley
 * @author WestLangley / http://github.com/WestLangley
*/

function PolyhedronGeometry( vertices, indices, radius, detail ) {

	Geometry.call( this );

	this.type = 'PolyhedronGeometry';

	this.parameters = {
		vertices: vertices,
		indices: indices,
		radius: radius,
		detail: detail
	};

	this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
	this.mergeVertices();

}

PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Creates a tube which extrudes along a 3d spline.
 *
 */

function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {

	BufferGeometry.call( this );

	this.type = 'TubeBufferGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	tubularSegments = tubularSegments || 64;
	radius = radius || 1;
	radialSegments = radialSegments || 8;
	closed = closed || false;

	var frames = path.computeFrenetFrames( tubularSegments, closed );

	// expose internals

	this.tangents = frames.tangents;
	this.normals = frames.normals;
	this.binormals = frames.binormals;

	// helper variables

	var vertex = new Vector3();
	var normal = new Vector3();
	var uv = new Vector2();

	var i, j;

	// buffer

	var vertices = [];
	var normals = [];
	var uvs = [];
	var indices = [];

	// create buffer data

	generateBufferData();

	// build geometry

	this.setIndex( new ( indices.length > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 ) );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );

	// functions

	function generateBufferData() {

		for ( i = 0; i < tubularSegments; i ++ ) {

			generateSegment( i );

		}

		// if the geometry is not closed, generate the last row of vertices and normals
		// at the regular position on the given path
		//
		// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)

		generateSegment( ( closed === false ) ? tubularSegments : 0 );

		// uvs are generated in a separate function.
		// this makes it easy compute correct values for closed geometries

		generateUVs();

		// finally create faces

		generateIndices();

	}

	function generateSegment( i ) {

		// we use getPointAt to sample evenly distributed points from the given path

		var P = path.getPointAt( i / tubularSegments );

		// retrieve corresponding normal and binormal

		var N = frames.normals[ i ];
		var B = frames.binormals[ i ];

		// generate normals and vertices for the current segment

		for ( j = 0; j <= radialSegments; j ++ ) {

			var v = j / radialSegments * Math.PI * 2;

			var sin =   Math.sin( v );
			var cos = - Math.cos( v );

			// normal

			normal.x = ( cos * N.x + sin * B.x );
			normal.y = ( cos * N.y + sin * B.y );
			normal.z = ( cos * N.z + sin * B.z );
			normal.normalize();

			normals.push( normal.x, normal.y, normal.z );

			// vertex

			vertex.x = P.x + radius * normal.x;
			vertex.y = P.y + radius * normal.y;
			vertex.z = P.z + radius * normal.z;

			vertices.push( vertex.x, vertex.y, vertex.z );

		}

	}

	function generateIndices() {

		for ( j = 1; j <= tubularSegments; j ++ ) {

			for ( i = 1; i <= radialSegments; i ++ ) {

				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

				// faces

				indices.push( a, b, d );
				indices.push( b, c, d );

			}

		}

	}

	function generateUVs() {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			for ( j = 0; j <= radialSegments; j ++ ) {

				uv.x = i / tubularSegments;
				uv.y = j / radialSegments;

				uvs.push( uv.x, uv.y );

			}

		}

	}

}

TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;

/**
 * @author oosmoxiecode / https://github.com/oosmoxiecode
 * @author WestLangley / https://github.com/WestLangley
 * @author zz85 / https://github.com/zz85
 * @author miningold / https://github.com/miningold
 * @author jonobr1 / https://github.com/jonobr1
 *
 * Creates a tube which extrudes along a 3d spline.
 */

function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {

	Geometry.call( this );

	this.type = 'TubeGeometry';

	this.parameters = {
		path: path,
		tubularSegments: tubularSegments,
		radius: radius,
		radialSegments: radialSegments,
		closed: closed
	};

	if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );

	var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );

	// expose internals

	this.tangents = bufferGeometry.tangents;
	this.normals = bufferGeometry.normals;
	this.binormals = bufferGeometry.binormals;

	// create geometry

	this.fromBufferGeometry( bufferGeometry );
	this.mergeVertices();

}

TubeGeometry.prototype = Object.create( Geometry.prototype );
TubeGeometry.prototype.constructor = TubeGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * see: http://www.blackpawn.com/texts/pqtorus/
 */
function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {

	BufferGeometry.call( this );

	this.type = 'TorusKnotBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	radius = radius || 100;
	tube = tube || 40;
	tubularSegments = Math.floor( tubularSegments ) || 64;
	radialSegments = Math.floor( radialSegments ) || 8;
	p = p || 2;
	q = q || 3;

	// used to calculate buffer length
	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
	var indexCount = radialSegments * tubularSegments * 2 * 3;

	// buffers
	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// helper variables
	var i, j, index = 0, indexOffset = 0;

	var vertex = new Vector3();
	var normal = new Vector3();
	var uv = new Vector2();

	var P1 = new Vector3();
	var P2 = new Vector3();

	var B = new Vector3();
	var T = new Vector3();
	var N = new Vector3();

	// generate vertices, normals and uvs

	for ( i = 0; i <= tubularSegments; ++ i ) {

		// the radian "u" is used to calculate the position on the torus curve of the current tubular segement

		var u = i / tubularSegments * p * Math.PI * 2;

		// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
		// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions

		calculatePositionOnCurve( u, p, q, radius, P1 );
		calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );

		// calculate orthonormal basis

		T.subVectors( P2, P1 );
		N.addVectors( P2, P1 );
		B.crossVectors( T, N );
		N.crossVectors( B, T );

		// normalize B, N. T can be ignored, we don't use it

		B.normalize();
		N.normalize();

		for ( j = 0; j <= radialSegments; ++ j ) {

			// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
			// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.

			var v = j / radialSegments * Math.PI * 2;
			var cx = - tube * Math.cos( v );
			var cy = tube * Math.sin( v );

			// now calculate the final vertex position.
			// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve

			vertex.x = P1.x + ( cx * N.x + cy * B.x );
			vertex.y = P1.y + ( cx * N.y + cy * B.y );
			vertex.z = P1.z + ( cx * N.z + cy * B.z );

			// vertex
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
			normal.subVectors( vertex, P1 ).normalize();
			normals.setXYZ( index, normal.x, normal.y, normal.z );

			// uv
			uv.x = i / tubularSegments;
			uv.y = j / radialSegments;
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

	}

	// generate indices

	for ( j = 1; j <= tubularSegments; j ++ ) {

		for ( i = 1; i <= radialSegments; i ++ ) {

			// indices
			var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
			var b = ( radialSegments + 1 ) * j + ( i - 1 );
			var c = ( radialSegments + 1 ) * j + i;
			var d = ( radialSegments + 1 ) * ( j - 1 ) + i;

			// face one
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

			// face two
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	// this function calculates the current position on the torus curve

	function calculatePositionOnCurve( u, p, q, radius, position ) {

		var cu = Math.cos( u );
		var su = Math.sin( u );
		var quOverP = q / p * u;
		var cs = Math.cos( quOverP );

		position.x = radius * ( 2 + cs ) * 0.5 * cu;
		position.y = radius * ( 2 + cs ) * su * 0.5;
		position.z = radius * Math.sin( quOverP ) * 0.5;

	}

}

TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;

/**
 * @author oosmoxiecode
 */

function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {

	Geometry.call( this );

	this.type = 'TorusKnotGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		tubularSegments: tubularSegments,
		radialSegments: radialSegments,
		p: p,
		q: q
	};

	if( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );

	this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
	this.mergeVertices();

}

TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

	BufferGeometry.call( this );

	this.type = 'TorusBufferGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	radius = radius || 100;
	tube = tube || 40;
	radialSegments = Math.floor( radialSegments ) || 8;
	tubularSegments = Math.floor( tubularSegments ) || 6;
	arc = arc || Math.PI * 2;

	// used to calculate buffer length
	var vertexCount = ( ( radialSegments + 1 ) * ( tubularSegments + 1 ) );
	var indexCount = radialSegments * tubularSegments * 2 * 3;

	// buffers
	var indices = new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount );
	var vertices = new Float32Array( vertexCount * 3 );
	var normals = new Float32Array( vertexCount * 3 );
	var uvs = new Float32Array( vertexCount * 2 );

	// offset variables
	var vertexBufferOffset = 0;
	var uvBufferOffset = 0;
	var indexBufferOffset = 0;

	// helper variables
	var center = new Vector3();
	var vertex = new Vector3();
	var normal = new Vector3();

	var j, i;

	// generate vertices, normals and uvs

	for ( j = 0; j <= radialSegments; j ++ ) {

		for ( i = 0; i <= tubularSegments; i ++ ) {

			var u = i / tubularSegments * arc;
			var v = j / radialSegments * Math.PI * 2;

			// vertex
			vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
			vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
			vertex.z = tube * Math.sin( v );

			vertices[ vertexBufferOffset ] = vertex.x;
			vertices[ vertexBufferOffset + 1 ] = vertex.y;
			vertices[ vertexBufferOffset + 2 ] = vertex.z;

			// this vector is used to calculate the normal
			center.x = radius * Math.cos( u );
			center.y = radius * Math.sin( u );

			// normal
			normal.subVectors( vertex, center ).normalize();

			normals[ vertexBufferOffset ] = normal.x;
			normals[ vertexBufferOffset + 1 ] = normal.y;
			normals[ vertexBufferOffset + 2 ] = normal.z;

			// uv
			uvs[ uvBufferOffset ] = i / tubularSegments;
			uvs[ uvBufferOffset + 1 ] = j / radialSegments;

			// update offsets
			vertexBufferOffset += 3;
			uvBufferOffset += 2;

		}

	}

	// generate indices

	for ( j = 1; j <= radialSegments; j ++ ) {

		for ( i = 1; i <= tubularSegments; i ++ ) {

			// indices
			var a = ( tubularSegments + 1 ) * j + i - 1;
			var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
			var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
			var d = ( tubularSegments + 1 ) * j + i;

			// face one
			indices[ indexBufferOffset ] = a;
			indices[ indexBufferOffset + 1 ] = b;
			indices[ indexBufferOffset + 2 ] = d;

			// face two
			indices[ indexBufferOffset + 3 ] = b;
			indices[ indexBufferOffset + 4 ] = c;
			indices[ indexBufferOffset + 5 ] = d;

			// update offset
			indexBufferOffset += 6;

		}

	}

	// build geometry
	this.setIndex( new BufferAttribute( indices, 1 ) );
	this.addAttribute( 'position', new BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

}

TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;

/**
 * @author oosmoxiecode
 * @author mrdoob / http://mrdoob.com/
 * based on http://code.google.com/p/away3d/source/browse/trunk/fp10/Away3DLite/src/away3dlite/primitives/Torus.as?r=2888
 */

function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {

	Geometry.call( this );

	this.type = 'TorusGeometry';

	this.parameters = {
		radius: radius,
		tube: tube,
		radialSegments: radialSegments,
		tubularSegments: tubularSegments,
		arc: arc
	};

	this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );

}

TorusGeometry.prototype = Object.create( Geometry.prototype );
TorusGeometry.prototype.constructor = TorusGeometry;

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

var ShapeUtils = {

	// calculate area of the contour polygon

	area: function ( contour ) {

		var n = contour.length;
		var a = 0.0;

		for ( var p = n - 1, q = 0; q < n; p = q ++ ) {

			a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;

		}

		return a * 0.5;

	},

	triangulate: ( function () {

		/**
		 * This code is a quick port of code written in C++ which was submitted to
		 * flipcode.com by John W. Ratcliff  // July 22, 2000
		 * See original code and more information here:
		 * http://www.flipcode.com/archives/Efficient_Polygon_Triangulation.shtml
		 *
		 * ported to actionscript by Zevan Rosser
		 * www.actionsnippet.com
		 *
		 * ported to javascript by Joshua Koo
		 * http://www.lab4games.net/zz85/blog
		 *
		 */

		function snip( contour, u, v, w, n, verts ) {

			var p;
			var ax, ay, bx, by;
			var cx, cy, px, py;

			ax = contour[ verts[ u ] ].x;
			ay = contour[ verts[ u ] ].y;

			bx = contour[ verts[ v ] ].x;
			by = contour[ verts[ v ] ].y;

			cx = contour[ verts[ w ] ].x;
			cy = contour[ verts[ w ] ].y;

			if ( ( bx - ax ) * ( cy - ay ) - ( by - ay ) * ( cx - ax ) <= 0 ) return false;

			var aX, aY, bX, bY, cX, cY;
			var apx, apy, bpx, bpy, cpx, cpy;
			var cCROSSap, bCROSScp, aCROSSbp;

			aX = cx - bx;  aY = cy - by;
			bX = ax - cx;  bY = ay - cy;
			cX = bx - ax;  cY = by - ay;

			for ( p = 0; p < n; p ++ ) {

				px = contour[ verts[ p ] ].x;
				py = contour[ verts[ p ] ].y;

				if ( ( ( px === ax ) && ( py === ay ) ) ||
					 ( ( px === bx ) && ( py === by ) ) ||
					 ( ( px === cx ) && ( py === cy ) ) )	continue;

				apx = px - ax;  apy = py - ay;
				bpx = px - bx;  bpy = py - by;
				cpx = px - cx;  cpy = py - cy;

				// see if p is inside triangle abc

				aCROSSbp = aX * bpy - aY * bpx;
				cCROSSap = cX * apy - cY * apx;
				bCROSScp = bX * cpy - bY * cpx;

				if ( ( aCROSSbp >= - Number.EPSILON ) && ( bCROSScp >= - Number.EPSILON ) && ( cCROSSap >= - Number.EPSILON ) ) return false;

			}

			return true;

		}

		// takes in an contour array and returns

		return function triangulate( contour, indices ) {

			var n = contour.length;

			if ( n < 3 ) return null;

			var result = [],
				verts = [],
				vertIndices = [];

			/* we want a counter-clockwise polygon in verts */

			var u, v, w;

			if ( ShapeUtils.area( contour ) > 0.0 ) {

				for ( v = 0; v < n; v ++ ) verts[ v ] = v;

			} else {

				for ( v = 0; v < n; v ++ ) verts[ v ] = ( n - 1 ) - v;

			}

			var nv = n;

			/*  remove nv - 2 vertices, creating 1 triangle every time */

			var count = 2 * nv;   /* error detection */

			for ( v = nv - 1; nv > 2; ) {

				/* if we loop, it is probably a non-simple polygon */

				if ( ( count -- ) <= 0 ) {

					//** Triangulate: ERROR - probable bad polygon!

					//throw ( "Warning, unable to triangulate polygon!" );
					//return null;
					// Sometimes warning is fine, especially polygons are triangulated in reverse.
					console.warn( 'THREE.ShapeUtils: Unable to triangulate polygon! in triangulate()' );

					if ( indices ) return vertIndices;
					return result;

				}

				/* three consecutive vertices in current polygon, <u,v,w> */

				u = v; 	 	if ( nv <= u ) u = 0;     /* previous */
				v = u + 1;  if ( nv <= v ) v = 0;     /* new v    */
				w = v + 1;  if ( nv <= w ) w = 0;     /* next     */

				if ( snip( contour, u, v, w, nv, verts ) ) {

					var a, b, c, s, t;

					/* true names of the vertices */

					a = verts[ u ];
					b = verts[ v ];
					c = verts[ w ];

					/* output Triangle */

					result.push( [ contour[ a ],
						contour[ b ],
						contour[ c ] ] );


					vertIndices.push( [ verts[ u ], verts[ v ], verts[ w ] ] );

					/* remove v from the remaining polygon */

					for ( s = v, t = v + 1; t < nv; s ++, t ++ ) {

						verts[ s ] = verts[ t ];

					}

					nv --;

					/* reset error detection counter */

					count = 2 * nv;

				}

			}

			if ( indices ) return vertIndices;
			return result;

		}

	} )(),

	triangulateShape: function ( contour, holes ) {

		function removeDupEndPts(points) {

			var l = points.length;

			if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {

				points.pop();

			}

		}

		removeDupEndPts( contour );
		holes.forEach( removeDupEndPts );

		function point_in_segment_2D_colin( inSegPt1, inSegPt2, inOtherPt ) {

			// inOtherPt needs to be collinear to the inSegment
			if ( inSegPt1.x !== inSegPt2.x ) {

				if ( inSegPt1.x < inSegPt2.x ) {

					return	( ( inSegPt1.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt2.x ) );

				} else {

					return	( ( inSegPt2.x <= inOtherPt.x ) && ( inOtherPt.x <= inSegPt1.x ) );

				}

			} else {

				if ( inSegPt1.y < inSegPt2.y ) {

					return	( ( inSegPt1.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt2.y ) );

				} else {

					return	( ( inSegPt2.y <= inOtherPt.y ) && ( inOtherPt.y <= inSegPt1.y ) );

				}

			}

		}

		function intersect_segments_2D( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1, inSeg2Pt2, inExcludeAdjacentSegs ) {

			var seg1dx = inSeg1Pt2.x - inSeg1Pt1.x,   seg1dy = inSeg1Pt2.y - inSeg1Pt1.y;
			var seg2dx = inSeg2Pt2.x - inSeg2Pt1.x,   seg2dy = inSeg2Pt2.y - inSeg2Pt1.y;

			var seg1seg2dx = inSeg1Pt1.x - inSeg2Pt1.x;
			var seg1seg2dy = inSeg1Pt1.y - inSeg2Pt1.y;

			var limit		= seg1dy * seg2dx - seg1dx * seg2dy;
			var perpSeg1	= seg1dy * seg1seg2dx - seg1dx * seg1seg2dy;

			if ( Math.abs( limit ) > Number.EPSILON ) {

				// not parallel

				var perpSeg2;
				if ( limit > 0 ) {

					if ( ( perpSeg1 < 0 ) || ( perpSeg1 > limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 < 0 ) || ( perpSeg2 > limit ) ) 		return [];

				} else {

					if ( ( perpSeg1 > 0 ) || ( perpSeg1 < limit ) ) 		return [];
					perpSeg2 = seg2dy * seg1seg2dx - seg2dx * seg1seg2dy;
					if ( ( perpSeg2 > 0 ) || ( perpSeg2 < limit ) ) 		return [];

				}

				// i.e. to reduce rounding errors
				// intersection at endpoint of segment#1?
				if ( perpSeg2 === 0 ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt1 ];

				}
				if ( perpSeg2 === limit ) {

					if ( ( inExcludeAdjacentSegs ) &&
						 ( ( perpSeg1 === 0 ) || ( perpSeg1 === limit ) ) )		return [];
					return [ inSeg1Pt2 ];

				}
				// intersection at endpoint of segment#2?
				if ( perpSeg1 === 0 )		return [ inSeg2Pt1 ];
				if ( perpSeg1 === limit )	return [ inSeg2Pt2 ];

				// return real intersection point
				var factorSeg1 = perpSeg2 / limit;
				return	[ { x: inSeg1Pt1.x + factorSeg1 * seg1dx,
							y: inSeg1Pt1.y + factorSeg1 * seg1dy } ];

			} else {

				// parallel or collinear
				if ( ( perpSeg1 !== 0 ) ||
					 ( seg2dy * seg1seg2dx !== seg2dx * seg1seg2dy ) ) 			return [];

				// they are collinear or degenerate
				var seg1Pt = ( ( seg1dx === 0 ) && ( seg1dy === 0 ) );	// segment1 is just a point?
				var seg2Pt = ( ( seg2dx === 0 ) && ( seg2dy === 0 ) );	// segment2 is just a point?
				// both segments are points
				if ( seg1Pt && seg2Pt ) {

					if ( ( inSeg1Pt1.x !== inSeg2Pt1.x ) ||
						 ( inSeg1Pt1.y !== inSeg2Pt1.y ) )		return [];	// they are distinct  points
					return [ inSeg1Pt1 ];                 						// they are the same point

				}
				// segment#1  is a single point
				if ( seg1Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg2Pt1, inSeg2Pt2, inSeg1Pt1 ) )		return [];		// but not in segment#2
					return [ inSeg1Pt1 ];

				}
				// segment#2  is a single point
				if ( seg2Pt ) {

					if ( ! point_in_segment_2D_colin( inSeg1Pt1, inSeg1Pt2, inSeg2Pt1 ) )		return [];		// but not in segment#1
					return [ inSeg2Pt1 ];

				}

				// they are collinear segments, which might overlap
				var seg1min, seg1max, seg1minVal, seg1maxVal;
				var seg2min, seg2max, seg2minVal, seg2maxVal;
				if ( seg1dx !== 0 ) {

					// the segments are NOT on a vertical line
					if ( inSeg1Pt1.x < inSeg1Pt2.x ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.x;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.x;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.x;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.x;

					}
					if ( inSeg2Pt1.x < inSeg2Pt2.x ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.x;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.x;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.x;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.x;

					}

				} else {

					// the segments are on a vertical line
					if ( inSeg1Pt1.y < inSeg1Pt2.y ) {

						seg1min = inSeg1Pt1; seg1minVal = inSeg1Pt1.y;
						seg1max = inSeg1Pt2; seg1maxVal = inSeg1Pt2.y;

					} else {

						seg1min = inSeg1Pt2; seg1minVal = inSeg1Pt2.y;
						seg1max = inSeg1Pt1; seg1maxVal = inSeg1Pt1.y;

					}
					if ( inSeg2Pt1.y < inSeg2Pt2.y ) {

						seg2min = inSeg2Pt1; seg2minVal = inSeg2Pt1.y;
						seg2max = inSeg2Pt2; seg2maxVal = inSeg2Pt2.y;

					} else {

						seg2min = inSeg2Pt2; seg2minVal = inSeg2Pt2.y;
						seg2max = inSeg2Pt1; seg2maxVal = inSeg2Pt1.y;

					}

				}
				if ( seg1minVal <= seg2minVal ) {

					if ( seg1maxVal <  seg2minVal )	return [];
					if ( seg1maxVal === seg2minVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg2min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg2min, seg1max ];
					return	[ seg2min, seg2max ];

				} else {

					if ( seg1minVal >  seg2maxVal )	return [];
					if ( seg1minVal === seg2maxVal )	{

						if ( inExcludeAdjacentSegs )		return [];
						return [ seg1min ];

					}
					if ( seg1maxVal <= seg2maxVal )	return [ seg1min, seg1max ];
					return	[ seg1min, seg2max ];

				}

			}

		}

		function isPointInsideAngle( inVertex, inLegFromPt, inLegToPt, inOtherPt ) {

			// The order of legs is important

			// translation of all points, so that Vertex is at (0,0)
			var legFromPtX	= inLegFromPt.x - inVertex.x,  legFromPtY	= inLegFromPt.y - inVertex.y;
			var legToPtX	= inLegToPt.x	- inVertex.x,  legToPtY		= inLegToPt.y	- inVertex.y;
			var otherPtX	= inOtherPt.x	- inVertex.x,  otherPtY		= inOtherPt.y	- inVertex.y;

			// main angle >0: < 180 deg.; 0: 180 deg.; <0: > 180 deg.
			var from2toAngle	= legFromPtX * legToPtY - legFromPtY * legToPtX;
			var from2otherAngle	= legFromPtX * otherPtY - legFromPtY * otherPtX;

			if ( Math.abs( from2toAngle ) > Number.EPSILON ) {

				// angle != 180 deg.

				var other2toAngle		= otherPtX * legToPtY - otherPtY * legToPtX;
				// console.log( "from2to: " + from2toAngle + ", from2other: " + from2otherAngle + ", other2to: " + other2toAngle );

				if ( from2toAngle > 0 ) {

					// main angle < 180 deg.
					return	( ( from2otherAngle >= 0 ) && ( other2toAngle >= 0 ) );

				} else {

					// main angle > 180 deg.
					return	( ( from2otherAngle >= 0 ) || ( other2toAngle >= 0 ) );

				}

			} else {

				// angle == 180 deg.
				// console.log( "from2to: 180 deg., from2other: " + from2otherAngle  );
				return	( from2otherAngle > 0 );

			}

		}


		function removeHoles( contour, holes ) {

			var shape = contour.concat(); // work on this shape
			var hole;

			function isCutLineInsideAngles( inShapeIdx, inHoleIdx ) {

				// Check if hole point lies within angle around shape point
				var lastShapeIdx = shape.length - 1;

				var prevShapeIdx = inShapeIdx - 1;
				if ( prevShapeIdx < 0 )			prevShapeIdx = lastShapeIdx;

				var nextShapeIdx = inShapeIdx + 1;
				if ( nextShapeIdx > lastShapeIdx )	nextShapeIdx = 0;

				var insideAngle = isPointInsideAngle( shape[ inShapeIdx ], shape[ prevShapeIdx ], shape[ nextShapeIdx ], hole[ inHoleIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Shape): " + inShapeIdx + ", Point: " + hole[inHoleIdx].x + "/" + hole[inHoleIdx].y );
					return	false;

				}

				// Check if shape point lies within angle around hole point
				var lastHoleIdx = hole.length - 1;

				var prevHoleIdx = inHoleIdx - 1;
				if ( prevHoleIdx < 0 )			prevHoleIdx = lastHoleIdx;

				var nextHoleIdx = inHoleIdx + 1;
				if ( nextHoleIdx > lastHoleIdx )	nextHoleIdx = 0;

				insideAngle = isPointInsideAngle( hole[ inHoleIdx ], hole[ prevHoleIdx ], hole[ nextHoleIdx ], shape[ inShapeIdx ] );
				if ( ! insideAngle ) {

					// console.log( "Vertex (Hole): " + inHoleIdx + ", Point: " + shape[inShapeIdx].x + "/" + shape[inShapeIdx].y );
					return	false;

				}

				return	true;

			}

			function intersectsShapeEdge( inShapePt, inHolePt ) {

				// checks for intersections with shape edges
				var sIdx, nextIdx, intersection;
				for ( sIdx = 0; sIdx < shape.length; sIdx ++ ) {

					nextIdx = sIdx + 1; nextIdx %= shape.length;
					intersection = intersect_segments_2D( inShapePt, inHolePt, shape[ sIdx ], shape[ nextIdx ], true );
					if ( intersection.length > 0 )		return	true;

				}

				return	false;

			}

			var indepHoles = [];

			function intersectsHoleEdge( inShapePt, inHolePt ) {

				// checks for intersections with hole edges
				var ihIdx, chkHole,
					hIdx, nextIdx, intersection;
				for ( ihIdx = 0; ihIdx < indepHoles.length; ihIdx ++ ) {

					chkHole = holes[ indepHoles[ ihIdx ]];
					for ( hIdx = 0; hIdx < chkHole.length; hIdx ++ ) {

						nextIdx = hIdx + 1; nextIdx %= chkHole.length;
						intersection = intersect_segments_2D( inShapePt, inHolePt, chkHole[ hIdx ], chkHole[ nextIdx ], true );
						if ( intersection.length > 0 )		return	true;

					}

				}
				return	false;

			}

			var holeIndex, shapeIndex,
				shapePt, holePt,
				holeIdx, cutKey, failedCuts = [],
				tmpShape1, tmpShape2,
				tmpHole1, tmpHole2;

			for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

				indepHoles.push( h );

			}

			var minShapeIndex = 0;
			var counter = indepHoles.length * 2;
			while ( indepHoles.length > 0 ) {

				counter --;
				if ( counter < 0 ) {

					console.log( "Infinite Loop! Holes left:" + indepHoles.length + ", Probably Hole outside Shape!" );
					break;

				}

				// search for shape-vertex and hole-vertex,
				// which can be connected without intersections
				for ( shapeIndex = minShapeIndex; shapeIndex < shape.length; shapeIndex ++ ) {

					shapePt = shape[ shapeIndex ];
					holeIndex	= - 1;

					// search for hole which can be reached without intersections
					for ( var h = 0; h < indepHoles.length; h ++ ) {

						holeIdx = indepHoles[ h ];

						// prevent multiple checks
						cutKey = shapePt.x + ":" + shapePt.y + ":" + holeIdx;
						if ( failedCuts[ cutKey ] !== undefined )			continue;

						hole = holes[ holeIdx ];
						for ( var h2 = 0; h2 < hole.length; h2 ++ ) {

							holePt = hole[ h2 ];
							if ( ! isCutLineInsideAngles( shapeIndex, h2 ) )		continue;
							if ( intersectsShapeEdge( shapePt, holePt ) )		continue;
							if ( intersectsHoleEdge( shapePt, holePt ) )		continue;

							holeIndex = h2;
							indepHoles.splice( h, 1 );

							tmpShape1 = shape.slice( 0, shapeIndex + 1 );
							tmpShape2 = shape.slice( shapeIndex );
							tmpHole1 = hole.slice( holeIndex );
							tmpHole2 = hole.slice( 0, holeIndex + 1 );

							shape = tmpShape1.concat( tmpHole1 ).concat( tmpHole2 ).concat( tmpShape2 );

							minShapeIndex = shapeIndex;

							// Debug only, to show the selected cuts
							// glob_CutLines.push( [ shapePt, holePt ] );

							break;

						}
						if ( holeIndex >= 0 )	break;		// hole-vertex found

						failedCuts[ cutKey ] = true;			// remember failure

					}
					if ( holeIndex >= 0 )	break;		// hole-vertex found

				}

			}

			return shape; 			/* shape with no holes */

		}


		var i, il, f, face,
			key, index,
			allPointsMap = {};

		// To maintain reference to old shape, one must match coordinates, or offset the indices from original arrays. It's probably easier to do the first.

		var allpoints = contour.concat();

		for ( var h = 0, hl = holes.length; h < hl; h ++ ) {

			Array.prototype.push.apply( allpoints, holes[ h ] );

		}

		//console.log( "allpoints",allpoints, allpoints.length );

		// prepare all points map

		for ( i = 0, il = allpoints.length; i < il; i ++ ) {

			key = allpoints[ i ].x + ":" + allpoints[ i ].y;

			if ( allPointsMap[ key ] !== undefined ) {

				console.warn( "THREE.ShapeUtils: Duplicate point", key, i );

			}

			allPointsMap[ key ] = i;

		}

		// remove holes by cutting paths to holes and adding them to the shape
		var shapeWithoutHoles = removeHoles( contour, holes );

		var triangles = ShapeUtils.triangulate( shapeWithoutHoles, false ); // True returns indices for points of spooled shape
		//console.log( "triangles",triangles, triangles.length );

		// check all face vertices against all points map

		for ( i = 0, il = triangles.length; i < il; i ++ ) {

			face = triangles[ i ];

			for ( f = 0; f < 3; f ++ ) {

				key = face[ f ].x + ":" + face[ f ].y;

				index = allPointsMap[ key ];

				if ( index !== undefined ) {

					face[ f ] = index;

				}

			}

		}

		return triangles.concat();

	},

	isClockWise: function ( pts ) {

		return ShapeUtils.area( pts ) < 0;

	},

	// Bezier Curves formulas obtained from
	// http://en.wikipedia.org/wiki/B%C3%A9zier_curve

	// Quad Bezier Functions

	b2: ( function () {

		function b2p0( t, p ) {

			var k = 1 - t;
			return k * k * p;

		}

		function b2p1( t, p ) {

			return 2 * ( 1 - t ) * t * p;

		}

		function b2p2( t, p ) {

			return t * t * p;

		}

		return function b2( t, p0, p1, p2 ) {

			return b2p0( t, p0 ) + b2p1( t, p1 ) + b2p2( t, p2 );

		};

	} )(),

	// Cubic Bezier Functions

	b3: ( function () {

		function b3p0( t, p ) {

			var k = 1 - t;
			return k * k * k * p;

		}

		function b3p1( t, p ) {

			var k = 1 - t;
			return 3 * k * k * t * p;

		}

		function b3p2( t, p ) {

			var k = 1 - t;
			return 3 * k * t * t * p;

		}

		function b3p3( t, p ) {

			return t * t * t * p;

		}

		return function b3( t, p0, p1, p2, p3 ) {

			return b3p0( t, p0 ) + b3p1( t, p1 ) + b3p2( t, p2 ) + b3p3( t, p3 );

		};

	} )()

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 * Creates extruded geometry from a path shape.
 *
 * parameters = {
 *
 *  curveSegments: <int>, // number of points on the curves
 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
 *  amount: <int>, // Depth to extrude the shape
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into the original shape bevel goes
 *  bevelSize: <float>, // how far from shape outline is bevel
 *  bevelSegments: <int>, // number of bevel layers
 *
 *  extrudePath: <THREE.Curve> // curve to extrude shape along
 *  frames: <Object> // containing arrays of tangents, normals, binormals
 *
 *  uvGenerator: <Object> // object that provides UV generator functions
 *
 * }
 **/

function ExtrudeGeometry( shapes, options ) {

	if ( typeof( shapes ) === "undefined" ) {

		shapes = [];
		return;

	}

	Geometry.call( this );

	this.type = 'ExtrudeGeometry';

	shapes = Array.isArray( shapes ) ? shapes : [ shapes ];

	this.addShapeList( shapes, options );

	this.computeFaceNormals();

	// can't really use automatic vertex normals
	// as then front and back sides get smoothed too
	// should do separate smoothing just for sides

	//this.computeVertexNormals();

	//console.log( "took", ( Date.now() - startTime ) );

}

ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;

ExtrudeGeometry.prototype.addShapeList = function ( shapes, options ) {

	var sl = shapes.length;

	for ( var s = 0; s < sl; s ++ ) {

		var shape = shapes[ s ];
		this.addShape( shape, options );

	}

};

ExtrudeGeometry.prototype.addShape = function ( shape, options ) {

	var amount = options.amount !== undefined ? options.amount : 100;

	var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6; // 10
	var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2; // 8
	var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;

	var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true; // false

	var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;

	var steps = options.steps !== undefined ? options.steps : 1;

	var extrudePath = options.extrudePath;
	var extrudePts, extrudeByPath = false;

	// Use default WorldUVGenerator if no UV generators are specified.
	var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : ExtrudeGeometry.WorldUVGenerator;

	var splineTube, binormal, normal, position2;
	if ( extrudePath ) {

		extrudePts = extrudePath.getSpacedPoints( steps );

		extrudeByPath = true;
		bevelEnabled = false; // bevels not supported for path extrusion

		// SETUP TNB variables

		// TODO1 - have a .isClosed in spline?

		splineTube = options.frames !== undefined ? options.frames : extrudePath.computeFrenetFrames( steps, false );

		// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);

		binormal = new Vector3();
		normal = new Vector3();
		position2 = new Vector3();

	}

	// Safeguards if bevels are not enabled

	if ( ! bevelEnabled ) {

		bevelSegments = 0;
		bevelThickness = 0;
		bevelSize = 0;

	}

	// Variables initialization

	var ahole, h, hl; // looping of holes
	var scope = this;

	var shapesOffset = this.vertices.length;

	var shapePoints = shape.extractPoints( curveSegments );

	var vertices = shapePoints.shape;
	var holes = shapePoints.holes;

	var reverse = ! ShapeUtils.isClockWise( vertices );

	if ( reverse ) {

		vertices = vertices.reverse();

		// Maybe we should also check if holes are in the opposite direction, just to be safe ...

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];

			if ( ShapeUtils.isClockWise( ahole ) ) {

				holes[ h ] = ahole.reverse();

			}

		}

		reverse = false; // If vertices are in order now, we shouldn't need to worry about them again (hopefully)!

	}


	var faces = ShapeUtils.triangulateShape( vertices, holes );

	/* Vertices */

	var contour = vertices; // vertices has all points but contour has only points of circumference

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		vertices = vertices.concat( ahole );

	}


	function scalePt2( pt, vec, size ) {

		if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );

		return vec.clone().multiplyScalar( size ).add( pt );

	}

	var b, bs, t, z,
		vert, vlen = vertices.length,
		face, flen = faces.length;


	// Find directions for point movement


	function getBevelVec( inPt, inPrev, inNext ) {

		// computes for inPt the corresponding point inPt' on a new contour
		//   shifted by 1 unit (length of normalized vector) to the left
		// if we walk along contour clockwise, this new contour is outside the old one
		//
		// inPt' is the intersection of the two lines parallel to the two
		//  adjacent edges of inPt at a distance of 1 unit on the left side.

		var v_trans_x, v_trans_y, shrink_by = 1;		// resulting translation vector for inPt

		// good reading for geometry algorithms (here: line-line intersection)
		// http://geomalgorithms.com/a05-_intersect-1.html

		var v_prev_x = inPt.x - inPrev.x, v_prev_y = inPt.y - inPrev.y;
		var v_next_x = inNext.x - inPt.x, v_next_y = inNext.y - inPt.y;

		var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );

		// check for collinear edges
		var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );

		if ( Math.abs( collinear0 ) > Number.EPSILON ) {

			// not collinear

			// length of vectors for normalizing

			var v_prev_len = Math.sqrt( v_prev_lensq );
			var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );

			// shift adjacent points by unit vectors to the left

			var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
			var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );

			var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
			var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );

			// scaling factor for v_prev to intersection point

			var sf = (  ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
						( ptNextShift_y - ptPrevShift_y ) * v_next_x    ) /
					  ( v_prev_x * v_next_y - v_prev_y * v_next_x );

			// vector from inPt to intersection point

			v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
			v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );

			// Don't normalize!, otherwise sharp corners become ugly
			//  but prevent crazy spikes
			var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
			if ( v_trans_lensq <= 2 ) {

				return	new Vector2( v_trans_x, v_trans_y );

			} else {

				shrink_by = Math.sqrt( v_trans_lensq / 2 );

			}

		} else {

			// handle special case of collinear edges

			var direction_eq = false;		// assumes: opposite
			if ( v_prev_x > Number.EPSILON ) {

				if ( v_next_x > Number.EPSILON ) {

					direction_eq = true;

				}

			} else {

				if ( v_prev_x < - Number.EPSILON ) {

					if ( v_next_x < - Number.EPSILON ) {

						direction_eq = true;

					}

				} else {

					if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {

						direction_eq = true;

					}

				}

			}

			if ( direction_eq ) {

				// console.log("Warning: lines are a straight sequence");
				v_trans_x = - v_prev_y;
				v_trans_y =  v_prev_x;
				shrink_by = Math.sqrt( v_prev_lensq );

			} else {

				// console.log("Warning: lines are a straight spike");
				v_trans_x = v_prev_x;
				v_trans_y = v_prev_y;
				shrink_by = Math.sqrt( v_prev_lensq / 2 );

			}

		}

		return	new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );

	}


	var contourMovements = [];

	for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

		if ( j === il ) j = 0;
		if ( k === il ) k = 0;

		//  (j)---(i)---(k)
		// console.log('i,j,k', i, j , k)

		contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );

	}

	var holesMovements = [], oneHoleMovements, verticesMovements = contourMovements.concat();

	for ( h = 0, hl = holes.length; h < hl; h ++ ) {

		ahole = holes[ h ];

		oneHoleMovements = [];

		for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {

			if ( j === il ) j = 0;
			if ( k === il ) k = 0;

			//  (j)---(i)---(k)
			oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );

		}

		holesMovements.push( oneHoleMovements );
		verticesMovements = verticesMovements.concat( oneHoleMovements );

	}


	// Loop bevelSegments, 1 for the front, 1 for the back

	for ( b = 0; b < bevelSegments; b ++ ) {

		//for ( b = bevelSegments; b > 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * Math.cos( t * Math.PI / 2 );
		bs = bevelSize * Math.sin( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );

			v( vert.x, vert.y,  - z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				v( vert.x, vert.y,  - z );

			}

		}

	}

	bs = bevelSize;

	// Back facing vertices

	for ( i = 0; i < vlen; i ++ ) {

		vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

		if ( ! extrudeByPath ) {

			v( vert.x, vert.y, 0 );

		} else {

			// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );

			normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
			binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );

			position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );

			v( position2.x, position2.y, position2.z );

		}

	}

	// Add stepped vertices...
	// Including front facing vertices

	var s;

	for ( s = 1; s <= steps; s ++ ) {

		for ( i = 0; i < vlen; i ++ ) {

			vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];

			if ( ! extrudeByPath ) {

				v( vert.x, vert.y, amount / steps * s );

			} else {

				// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );

				normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
				binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );

				position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );

				v( position2.x, position2.y, position2.z );

			}

		}

	}


	// Add bevel segments planes

	//for ( b = 1; b <= bevelSegments; b ++ ) {
	for ( b = bevelSegments - 1; b >= 0; b -- ) {

		t = b / bevelSegments;
		z = bevelThickness * Math.cos ( t * Math.PI / 2 );
		bs = bevelSize * Math.sin( t * Math.PI / 2 );

		// contract shape

		for ( i = 0, il = contour.length; i < il; i ++ ) {

			vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
			v( vert.x, vert.y,  amount + z );

		}

		// expand holes

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			oneHoleMovements = holesMovements[ h ];

			for ( i = 0, il = ahole.length; i < il; i ++ ) {

				vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );

				if ( ! extrudeByPath ) {

					v( vert.x, vert.y,  amount + z );

				} else {

					v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );

				}

			}

		}

	}

	/* Faces */

	// Top and bottom faces

	buildLidFaces();

	// Sides faces

	buildSideFaces();


	/////  Internal functions

	function buildLidFaces() {

		if ( bevelEnabled ) {

			var layer = 0; // steps + 1
			var offset = vlen * layer;

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );

			}

			layer = steps + bevelSegments * 2;
			offset = vlen * layer;

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );

			}

		} else {

			// Bottom faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 2 ], face[ 1 ], face[ 0 ] );

			}

			// Top faces

			for ( i = 0; i < flen; i ++ ) {

				face = faces[ i ];
				f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );

			}

		}

	}

	// Create faces for the z-sides of the shape

	function buildSideFaces() {

		var layeroffset = 0;
		sidewalls( contour, layeroffset );
		layeroffset += contour.length;

		for ( h = 0, hl = holes.length; h < hl; h ++ ) {

			ahole = holes[ h ];
			sidewalls( ahole, layeroffset );

			//, true
			layeroffset += ahole.length;

		}

	}

	function sidewalls( contour, layeroffset ) {

		var j, k;
		i = contour.length;

		while ( -- i >= 0 ) {

			j = i;
			k = i - 1;
			if ( k < 0 ) k = contour.length - 1;

			//console.log('b', i,j, i-1, k,vertices.length);

			var s = 0, sl = steps  + bevelSegments * 2;

			for ( s = 0; s < sl; s ++ ) {

				var slen1 = vlen * s;
				var slen2 = vlen * ( s + 1 );

				var a = layeroffset + j + slen1,
					b = layeroffset + k + slen1,
					c = layeroffset + k + slen2,
					d = layeroffset + j + slen2;

				f4( a, b, c, d, contour, s, sl, j, k );

			}

		}

	}


	function v( x, y, z ) {

		scope.vertices.push( new Vector3( x, y, z ) );

	}

	function f3( a, b, c ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;

		scope.faces.push( new Face3( a, b, c, null, null, 0 ) );

		var uvs = uvgen.generateTopUV( scope, a, b, c );

		scope.faceVertexUvs[ 0 ].push( uvs );

	}

	function f4( a, b, c, d, wallContour, stepIndex, stepsLength, contourIndex1, contourIndex2 ) {

		a += shapesOffset;
		b += shapesOffset;
		c += shapesOffset;
		d += shapesOffset;

		scope.faces.push( new Face3( a, b, d, null, null, 1 ) );
		scope.faces.push( new Face3( b, c, d, null, null, 1 ) );

		var uvs = uvgen.generateSideWallUV( scope, a, b, c, d );

		scope.faceVertexUvs[ 0 ].push( [ uvs[ 0 ], uvs[ 1 ], uvs[ 3 ] ] );
		scope.faceVertexUvs[ 0 ].push( [ uvs[ 1 ], uvs[ 2 ], uvs[ 3 ] ] );

	}

};

ExtrudeGeometry.WorldUVGenerator = {

	generateTopUV: function ( geometry, indexA, indexB, indexC ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];

		return [
			new Vector2( a.x, a.y ),
			new Vector2( b.x, b.y ),
			new Vector2( c.x, c.y )
		];

	},

	generateSideWallUV: function ( geometry, indexA, indexB, indexC, indexD ) {

		var vertices = geometry.vertices;

		var a = vertices[ indexA ];
		var b = vertices[ indexB ];
		var c = vertices[ indexC ];
		var d = vertices[ indexD ];

		if ( Math.abs( a.y - b.y ) < 0.01 ) {

			return [
				new Vector2( a.x, 1 - a.z ),
				new Vector2( b.x, 1 - b.z ),
				new Vector2( c.x, 1 - c.z ),
				new Vector2( d.x, 1 - d.z )
			];

		} else {

			return [
				new Vector2( a.y, 1 - a.z ),
				new Vector2( b.y, 1 - b.z ),
				new Vector2( c.y, 1 - c.z ),
				new Vector2( d.y, 1 - d.z )
			];

		}

	}
};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author alteredq / http://alteredqualia.com/
 *
 * Text = 3D Text
 *
 * parameters = {
 *  font: <THREE.Font>, // font
 *
 *  size: <float>, // size of the text
 *  height: <float>, // thickness to extrude text
 *  curveSegments: <int>, // number of points on the curves
 *
 *  bevelEnabled: <bool>, // turn on bevel
 *  bevelThickness: <float>, // how deep into text bevel goes
 *  bevelSize: <float> // how far from text outline is bevel
 * }
 */

function TextGeometry( text, parameters ) {

	parameters = parameters || {};

	var font = parameters.font;

	if ( (font && font.isFont) === false ) {

		console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
		return new Geometry();

	}

	var shapes = font.generateShapes( text, parameters.size, parameters.curveSegments );

	// translate parameters to ExtrudeGeometry API

	parameters.amount = parameters.height !== undefined ? parameters.height : 50;

	// defaults

	if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
	if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
	if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;

	ExtrudeGeometry.call( this, shapes, parameters );

	this.type = 'TextGeometry';

}

TextGeometry.prototype = Object.create( ExtrudeGeometry.prototype );
TextGeometry.prototype.constructor = TextGeometry;

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 * based on THREE.SphereGeometry
 */

function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'SphereBufferGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;

	widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
	heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );

	phiStart = phiStart !== undefined ? phiStart : 0;
	phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;

	var thetaEnd = thetaStart + thetaLength;

	var vertexCount = ( ( widthSegments + 1 ) * ( heightSegments + 1 ) );

	var positions = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	var index = 0, vertices = [], normal = new Vector3();

	for ( var y = 0; y <= heightSegments; y ++ ) {

		var verticesRow = [];

		var v = y / heightSegments;

		for ( var x = 0; x <= widthSegments; x ++ ) {

			var u = x / widthSegments;

			var px = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
			var py = radius * Math.cos( thetaStart + v * thetaLength );
			var pz = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );

			normal.set( px, py, pz ).normalize();

			positions.setXYZ( index, px, py, pz );
			normals.setXYZ( index, normal.x, normal.y, normal.z );
			uvs.setXY( index, u, 1 - v );

			verticesRow.push( index );

			index ++;

		}

		vertices.push( verticesRow );

	}

	var indices = [];

	for ( var y = 0; y < heightSegments; y ++ ) {

		for ( var x = 0; x < widthSegments; x ++ ) {

			var v1 = vertices[ y ][ x + 1 ];
			var v2 = vertices[ y ][ x ];
			var v3 = vertices[ y + 1 ][ x ];
			var v4 = vertices[ y + 1 ][ x + 1 ];

			if ( y !== 0 || thetaStart > 0 ) indices.push( v1, v2, v4 );
			if ( y !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( v2, v3, v4 );

		}

	}

	this.setIndex( new ( positions.count > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 ) );
	this.addAttribute( 'position', positions );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	this.boundingSphere = new Sphere( new Vector3(), radius );

}

SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'SphereGeometry';

	this.parameters = {
		radius: radius,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		phiStart: phiStart,
		phiLength: phiLength,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );

}

SphereGeometry.prototype = Object.create( Geometry.prototype );
SphereGeometry.prototype.constructor = SphereGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'RingBufferGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	innerRadius = innerRadius || 20;
	outerRadius = outerRadius || 50;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
	phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;

	// these are used to calculate buffer length
	var vertexCount = ( thetaSegments + 1 ) * ( phiSegments + 1 );
	var indexCount = thetaSegments * phiSegments * 2 * 3;

	// buffers
	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// some helper variables
	var index = 0, indexOffset = 0, segment;
	var radius = innerRadius;
	var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
	var vertex = new Vector3();
	var uv = new Vector2();
	var j, i;

	// generate vertices, normals and uvs

	// values are generate from the inside of the ring to the outside

	for ( j = 0; j <= phiSegments; j ++ ) {

		for ( i = 0; i <= thetaSegments; i ++ ) {

			segment = thetaStart + i / thetaSegments * thetaLength;

			// vertex
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// normal
			normals.setXYZ( index, 0, 0, 1 );

			// uv
			uv.x = ( vertex.x / outerRadius + 1 ) / 2;
			uv.y = ( vertex.y / outerRadius + 1 ) / 2;
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index++;

		}

		// increase the radius for next row of vertices
		radius += radiusStep;

	}

	// generate indices

	for ( j = 0; j < phiSegments; j ++ ) {

		var thetaSegmentLevel = j * ( thetaSegments + 1 );

		for ( i = 0; i < thetaSegments; i ++ ) {

			segment = i + thetaSegmentLevel;

			// indices
			var a = segment;
			var b = segment + thetaSegments + 1;
			var c = segment + thetaSegments + 2;
			var d = segment + 1;

			// face one
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;

			// face two
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

}

RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
RingBufferGeometry.prototype.constructor = RingBufferGeometry;

/**
 * @author Kaleb Murphy
 */

function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'RingGeometry';

	this.parameters = {
		innerRadius: innerRadius,
		outerRadius: outerRadius,
		thetaSegments: thetaSegments,
		phiSegments: phiSegments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );

}

RingGeometry.prototype = Object.create( Geometry.prototype );
RingGeometry.prototype.constructor = RingGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Plane.as
 */

function PlaneGeometry( width, height, widthSegments, heightSegments ) {

	Geometry.call( this );

	this.type = 'PlaneGeometry';

	this.parameters = {
		width: width,
		height: height,
		widthSegments: widthSegments,
		heightSegments: heightSegments
	};

	this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );

}

PlaneGeometry.prototype = Object.create( Geometry.prototype );
PlaneGeometry.prototype.constructor = PlaneGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

 // points - to create a closed torus, one must use a set of points
 //    like so: [ a, b, c, d, a ], see first is the same as last.
 // segments - the number of circumference segments to create
 // phiStart - the starting radian
 // phiLength - the radian (0 to 2PI) range of the lathed section
 //    2PI is a closed lathe, less than 2PI is a portion.

function LatheBufferGeometry( points, segments, phiStart, phiLength ) {

	BufferGeometry.call( this );

	this.type = 'LatheBufferGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	segments = Math.floor( segments ) || 12;
	phiStart = phiStart || 0;
	phiLength = phiLength || Math.PI * 2;

	// clamp phiLength so it's in range of [ 0, 2PI ]
	phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );

	// these are used to calculate buffer length
	var vertexCount = ( segments + 1 ) * points.length;
	var indexCount = segments * points.length * 2 * 3;

	// buffers
	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ) , 1 );
	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// helper variables
	var index = 0, indexOffset = 0, base;
	var inverseSegments = 1.0 / segments;
	var vertex = new Vector3();
	var uv = new Vector2();
	var i, j;

	// generate vertices and uvs

	for ( i = 0; i <= segments; i ++ ) {

		var phi = phiStart + i * inverseSegments * phiLength;

		var sin = Math.sin( phi );
		var cos = Math.cos( phi );

		for ( j = 0; j <= ( points.length - 1 ); j ++ ) {

			// vertex
			vertex.x = points[ j ].x * sin;
			vertex.y = points[ j ].y;
			vertex.z = points[ j ].x * cos;
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// uv
			uv.x = i / segments;
			uv.y = j / ( points.length - 1 );
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

	}

	// generate indices

	for ( i = 0; i < segments; i ++ ) {

		for ( j = 0; j < ( points.length - 1 ); j ++ ) {

			base = j + i * points.length;

			// indices
			var a = base;
			var b = base + points.length;
			var c = base + points.length + 1;
			var d = base + 1;

			// face one
			indices.setX( indexOffset, a ); indexOffset++;
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

			// face two
			indices.setX( indexOffset, b ); indexOffset++;
			indices.setX( indexOffset, c ); indexOffset++;
			indices.setX( indexOffset, d ); indexOffset++;

		}

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'uv', uvs );

	// generate normals

	this.computeVertexNormals();

	// if the geometry is closed, we need to average the normals along the seam.
	// because the corresponding vertices are identical (but still have different UVs).

	if( phiLength === Math.PI * 2 ) {

		var normals = this.attributes.normal.array;
		var n1 = new Vector3();
		var n2 = new Vector3();
		var n = new Vector3();

		// this is the buffer offset for the last line of vertices
		base = segments * points.length * 3;

		for( i = 0, j = 0; i < points.length; i ++, j += 3 ) {

			// select the normal of the vertex in the first line
			n1.x = normals[ j + 0 ];
			n1.y = normals[ j + 1 ];
			n1.z = normals[ j + 2 ];

			// select the normal of the vertex in the last line
			n2.x = normals[ base + j + 0 ];
			n2.y = normals[ base + j + 1 ];
			n2.z = normals[ base + j + 2 ];

			// average normals
			n.addVectors( n1, n2 ).normalize();

			// assign the new values to both normals
			normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
			normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
			normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;

		} // next row

	}

}

LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;

/**
 * @author astrodud / http://astrodud.isgreat.org/
 * @author zz85 / https://github.com/zz85
 * @author bhouston / http://clara.io
 */

// points - to create a closed torus, one must use a set of points
//    like so: [ a, b, c, d, a ], see first is the same as last.
// segments - the number of circumference segments to create
// phiStart - the starting radian
// phiLength - the radian (0 to 2PI) range of the lathed section
//    2PI is a closed lathe, less than 2PI is a portion.

function LatheGeometry( points, segments, phiStart, phiLength ) {

	Geometry.call( this );

	this.type = 'LatheGeometry';

	this.parameters = {
		points: points,
		segments: segments,
		phiStart: phiStart,
		phiLength: phiLength
	};

	this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
	this.mergeVertices();

}

LatheGeometry.prototype = Object.create( Geometry.prototype );
LatheGeometry.prototype.constructor = LatheGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Creates a one-sided polygonal geometry from one or more shapes.
 *
 **/

function ShapeBufferGeometry( shapes, curveSegments ) {

	BufferGeometry.call( this );

	this.type = 'ShapeBufferGeometry';

	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};

	curveSegments = curveSegments || 12;

	var vertices = [];
	var normals = [];
	var uvs = [];
	var indices = [];

	var groupStart = 0;
	var groupCount = 0;

	// allow single and array values for "shapes" parameter

	if ( Array.isArray( shapes ) === false ) {

		addShape( shapes );

	} else {

		for ( var i = 0; i < shapes.length; i++ ) {

			addShape( shapes[ i ] );

			this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support

			groupStart += groupCount;
			groupCount = 0;

		}

	}

	// build geometry

	this.setIndex( new ( indices.length > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 ) );
	this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );


	// helper functions

	function addShape( shape ) {

		var i, l, shapeHole;

		var indexOffset = vertices.length / 3;
		var points = shape.extractPoints( curveSegments );

		var shapeVertices = points.shape;
		var shapeHoles = points.holes;

		// check direction of vertices

		if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {

			shapeVertices = shapeVertices.reverse();

			// also check if holes are in the opposite direction

			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

				shapeHole = shapeHoles[ i ];

				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {

					shapeHoles[ i ] = shapeHole.reverse();

				}

			}

		}

		var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );

		// join vertices of inner and outer paths to a single array

		for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {

			shapeHole = shapeHoles[ i ];
			shapeVertices = shapeVertices.concat( shapeHole );

		}

		// vertices, normals, uvs

		for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {

			var vertex = shapeVertices[ i ];

			vertices.push( vertex.x, vertex.y, 0 );
			normals.push( 0, 0, 1 );
			uvs.push( vertex.x, vertex.y ); // world uvs

		}

		// incides

		for ( i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var a = face[ 0 ] + indexOffset;
			var b = face[ 1 ] + indexOffset;
			var c = face[ 2 ] + indexOffset;

			indices.push( a, b, c );
			groupCount += 3;

		}

	}

}

ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;

/**
 * @author jonobr1 / http://jonobr1.com
 *
 * Creates a one-sided polygonal geometry from a path shape.
 *
 **/

function ShapeGeometry( shapes, curveSegments ) {

	Geometry.call( this );

	this.type = 'ShapeGeometry';

	if ( typeof curveSegments === 'object' ) {

		console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );

		curveSegments = curveSegments.curveSegments;

	}

	this.parameters = {
		shapes: shapes,
		curveSegments: curveSegments
	};

	this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
	this.mergeVertices();

}

ShapeGeometry.prototype = Object.create( Geometry.prototype );
ShapeGeometry.prototype.constructor = ShapeGeometry;

/**
 * @author WestLangley / http://github.com/WestLangley
 */

function EdgesGeometry( geometry, thresholdAngle ) {

	BufferGeometry.call( this );

	thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;

	var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );

	var edge = [ 0, 0 ], hash = {};

	function sortFunction( a, b ) {

		return a - b;

	}

	var keys = [ 'a', 'b', 'c' ];

	var geometry2;

	if ( geometry.isBufferGeometry ) {

		geometry2 = new Geometry();
		geometry2.fromBufferGeometry( geometry );

	} else {

		geometry2 = geometry.clone();

	}

	geometry2.mergeVertices();
	geometry2.computeFaceNormals();

	var vertices = geometry2.vertices;
	var faces = geometry2.faces;

	for ( var i = 0, l = faces.length; i < l; i ++ ) {

		var face = faces[ i ];

		for ( var j = 0; j < 3; j ++ ) {

			edge[ 0 ] = face[ keys[ j ] ];
			edge[ 1 ] = face[ keys[ ( j + 1 ) % 3 ] ];
			edge.sort( sortFunction );

			var key = edge.toString();

			if ( hash[ key ] === undefined ) {

				hash[ key ] = { vert1: edge[ 0 ], vert2: edge[ 1 ], face1: i, face2: undefined };

			} else {

				hash[ key ].face2 = i;

			}

		}

	}

	var coords = [];

	for ( var key in hash ) {

		var h = hash[ key ];

		// An edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.

		if ( h.face2 === undefined || faces[ h.face1 ].normal.dot( faces[ h.face2 ].normal ) <= thresholdDot ) {

			var vertex = vertices[ h.vert1 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

			vertex = vertices[ h.vert2 ];
			coords.push( vertex.x );
			coords.push( vertex.y );
			coords.push( vertex.z );

		}

	}

	this.addAttribute( 'position', new Float32BufferAttribute( coords, 3 ) );

}

EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
EdgesGeometry.prototype.constructor = EdgesGeometry;

/**
 * @author Mugen87 / https://github.com/Mugen87
 */

function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'CylinderBufferGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	var scope = this;

	radiusTop = radiusTop !== undefined ? radiusTop : 20;
	radiusBottom = radiusBottom !== undefined ? radiusBottom : 20;
	height = height !== undefined ? height : 100;

	radialSegments = Math.floor( radialSegments ) || 8;
	heightSegments = Math.floor( heightSegments ) || 1;

	openEnded = openEnded !== undefined ? openEnded : false;
	thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
	thetaLength = thetaLength !== undefined ? thetaLength : 2.0 * Math.PI;

	// used to calculate buffer length

	var nbCap = 0;

	if ( openEnded === false ) {

		if ( radiusTop > 0 ) nbCap ++;
		if ( radiusBottom > 0 ) nbCap ++;

	}

	var vertexCount = calculateVertexCount();
	var indexCount = calculateIndexCount();

	// buffers

	var indices = new BufferAttribute( new ( indexCount > 65535 ? Uint32Array : Uint16Array )( indexCount ), 1 );
	var vertices = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var normals = new BufferAttribute( new Float32Array( vertexCount * 3 ), 3 );
	var uvs = new BufferAttribute( new Float32Array( vertexCount * 2 ), 2 );

	// helper variables

	var index = 0,
	    indexOffset = 0,
	    indexArray = [],
	    halfHeight = height / 2;

	// group variables
	var groupStart = 0;

	// generate geometry

	generateTorso();

	if ( openEnded === false ) {

		if ( radiusTop > 0 ) generateCap( true );
		if ( radiusBottom > 0 ) generateCap( false );

	}

	// build geometry

	this.setIndex( indices );
	this.addAttribute( 'position', vertices );
	this.addAttribute( 'normal', normals );
	this.addAttribute( 'uv', uvs );

	// helper functions

	function calculateVertexCount() {

		var count = ( radialSegments + 1 ) * ( heightSegments + 1 );

		if ( openEnded === false ) {

			count += ( ( radialSegments + 1 ) * nbCap ) + ( radialSegments * nbCap );

		}

		return count;

	}

	function calculateIndexCount() {

		var count = radialSegments * heightSegments * 2 * 3;

		if ( openEnded === false ) {

			count += radialSegments * nbCap * 3;

		}

		return count;

	}

	function generateTorso() {

		var x, y;
		var normal = new Vector3();
		var vertex = new Vector3();

		var groupCount = 0;

		// this will be used to calculate the normal
		var slope = ( radiusBottom - radiusTop ) / height;

		// generate vertices, normals and uvs

		for ( y = 0; y <= heightSegments; y ++ ) {

			var indexRow = [];

			var v = y / heightSegments;

			// calculate the radius of the current row
			var radius = v * ( radiusBottom - radiusTop ) + radiusTop;

			for ( x = 0; x <= radialSegments; x ++ ) {

				var u = x / radialSegments;

				var theta = u * thetaLength + thetaStart;

				var sinTheta = Math.sin( theta );
				var cosTheta = Math.cos( theta );

				// vertex
				vertex.x = radius * sinTheta;
				vertex.y = - v * height + halfHeight;
				vertex.z = radius * cosTheta;
				vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

				// normal
				normal.set( sinTheta, slope, cosTheta ).normalize();
				normals.setXYZ( index, normal.x, normal.y, normal.z );

				// uv
				uvs.setXY( index, u, 1 - v );

				// save index of vertex in respective row
				indexRow.push( index );

				// increase index
				index ++;

			}

			// now save vertices of the row in our index array
			indexArray.push( indexRow );

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			for ( y = 0; y < heightSegments; y ++ ) {

				// we use the index array to access the correct indices
				var i1 = indexArray[ y ][ x ];
				var i2 = indexArray[ y + 1 ][ x ];
				var i3 = indexArray[ y + 1 ][ x + 1 ];
				var i4 = indexArray[ y ][ x + 1 ];

				// face one
				indices.setX( indexOffset, i1 ); indexOffset ++;
				indices.setX( indexOffset, i2 ); indexOffset ++;
				indices.setX( indexOffset, i4 ); indexOffset ++;

				// face two
				indices.setX( indexOffset, i2 ); indexOffset ++;
				indices.setX( indexOffset, i3 ); indexOffset ++;
				indices.setX( indexOffset, i4 ); indexOffset ++;

				// update counters
				groupCount += 6;

			}

		}

		// add a group to the geometry. this will ensure multi material support
		scope.addGroup( groupStart, groupCount, 0 );

		// calculate new start value for groups
		groupStart += groupCount;

	}

	function generateCap( top ) {

		var x, centerIndexStart, centerIndexEnd;

		var uv = new Vector2();
		var vertex = new Vector3();

		var groupCount = 0;

		var radius = ( top === true ) ? radiusTop : radiusBottom;
		var sign = ( top === true ) ? 1 : - 1;

		// save the index of the first center vertex
		centerIndexStart = index;

		// first we generate the center vertex data of the cap.
		// because the geometry needs one set of uvs per face,
		// we must generate a center vertex per face/segment

		for ( x = 1; x <= radialSegments; x ++ ) {

			// vertex
			vertices.setXYZ( index, 0, halfHeight * sign, 0 );

			// normal
			normals.setXYZ( index, 0, sign, 0 );

			// uv
			uv.x = 0.5;
			uv.y = 0.5;

			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

		// save the index of the last center vertex
		centerIndexEnd = index;

		// now we generate the surrounding vertices, normals and uvs

		for ( x = 0; x <= radialSegments; x ++ ) {

			var u = x / radialSegments;
			var theta = u * thetaLength + thetaStart;

			var cosTheta = Math.cos( theta );
			var sinTheta = Math.sin( theta );

			// vertex
			vertex.x = radius * sinTheta;
			vertex.y = halfHeight * sign;
			vertex.z = radius * cosTheta;
			vertices.setXYZ( index, vertex.x, vertex.y, vertex.z );

			// normal
			normals.setXYZ( index, 0, sign, 0 );

			// uv
			uv.x = ( cosTheta * 0.5 ) + 0.5;
			uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
			uvs.setXY( index, uv.x, uv.y );

			// increase index
			index ++;

		}

		// generate indices

		for ( x = 0; x < radialSegments; x ++ ) {

			var c = centerIndexStart + x;
			var i = centerIndexEnd + x;

			if ( top === true ) {

				// face top
				indices.setX( indexOffset, i ); indexOffset ++;
				indices.setX( indexOffset, i + 1 ); indexOffset ++;
				indices.setX( indexOffset, c ); indexOffset ++;

			} else {

				// face bottom
				indices.setX( indexOffset, i + 1 ); indexOffset ++;
				indices.setX( indexOffset, i ); indexOffset ++;
				indices.setX( indexOffset, c ); indexOffset ++;

			}

			// update counters
			groupCount += 3;

		}

		// add a group to the geometry. this will ensure multi material support
		scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );

		// calculate new start value for groups
		groupStart += groupCount;

	}

}

CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'CylinderGeometry';

	this.parameters = {
		radiusTop: radiusTop,
		radiusBottom: radiusBottom,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
	this.mergeVertices();

}

CylinderGeometry.prototype = Object.create( Geometry.prototype );
CylinderGeometry.prototype.constructor = CylinderGeometry;

/**
 * @author abelnation / http://github.com/abelnation
 */

function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	this.type = 'ConeGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

}

ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
ConeGeometry.prototype.constructor = ConeGeometry;

/**
 * @author: abelnation / http://github.com/abelnation
 */

function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {

	CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );

	this.type = 'ConeBufferGeometry';

	this.parameters = {
		radius: radius,
		height: height,
		radialSegments: radialSegments,
		heightSegments: heightSegments,
		openEnded: openEnded,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

}

ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {

	BufferGeometry.call( this );

	this.type = 'CircleBufferGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	radius = radius || 50;
	segments = segments !== undefined ? Math.max( 3, segments ) : 8;

	thetaStart = thetaStart !== undefined ? thetaStart : 0;
	thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;

	var vertices = segments + 2;

	var positions = new Float32Array( vertices * 3 );
	var normals = new Float32Array( vertices * 3 );
	var uvs = new Float32Array( vertices * 2 );

	// center data is already zero, but need to set a few extras
	normals[ 2 ] = 1.0;
	uvs[ 0 ] = 0.5;
	uvs[ 1 ] = 0.5;

	for ( var s = 0, i = 3, ii = 2 ; s <= segments; s ++, i += 3, ii += 2 ) {

		var segment = thetaStart + s / segments * thetaLength;

		positions[ i ] = radius * Math.cos( segment );
		positions[ i + 1 ] = radius * Math.sin( segment );

		normals[ i + 2 ] = 1; // normal z

		uvs[ ii ] = ( positions[ i ] / radius + 1 ) / 2;
		uvs[ ii + 1 ] = ( positions[ i + 1 ] / radius + 1 ) / 2;

	}

	var indices = [];

	for ( var i = 1; i <= segments; i ++ ) {

		indices.push( i, i + 1, 0 );

	}

	this.setIndex( new BufferAttribute( new Uint16Array( indices ), 1 ) );
	this.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
	this.addAttribute( 'normal', new BufferAttribute( normals, 3 ) );
	this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ) );

	this.boundingSphere = new Sphere( new Vector3(), radius );

}

CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;

/**
 * @author hughes
 */

function CircleGeometry( radius, segments, thetaStart, thetaLength ) {

	Geometry.call( this );

	this.type = 'CircleGeometry';

	this.parameters = {
		radius: radius,
		segments: segments,
		thetaStart: thetaStart,
		thetaLength: thetaLength
	};

	this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );

}

CircleGeometry.prototype = Object.create( Geometry.prototype );
CircleGeometry.prototype.constructor = CircleGeometry;

/**
 * @author mrdoob / http://mrdoob.com/
 * based on http://papervision3d.googlecode.com/svn/trunk/as3/trunk/src/org/papervision3d/objects/primitives/Cube.as
 */

function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {

	Geometry.call( this );

	this.type = 'BoxGeometry';

	this.parameters = {
		width: width,
		height: height,
		depth: depth,
		widthSegments: widthSegments,
		heightSegments: heightSegments,
		depthSegments: depthSegments
	};

	this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
	this.mergeVertices();

}

BoxGeometry.prototype = Object.create( Geometry.prototype );
BoxGeometry.prototype.constructor = BoxGeometry;



var Geometries = Object.freeze({
	WireframeGeometry: WireframeGeometry,
	ParametricGeometry: ParametricGeometry,
	ParametricBufferGeometry: ParametricBufferGeometry,
	TetrahedronGeometry: TetrahedronGeometry,
	TetrahedronBufferGeometry: TetrahedronBufferGeometry,
	OctahedronGeometry: OctahedronGeometry,
	OctahedronBufferGeometry: OctahedronBufferGeometry,
	IcosahedronGeometry: IcosahedronGeometry,
	IcosahedronBufferGeometry: IcosahedronBufferGeometry,
	DodecahedronGeometry: DodecahedronGeometry,
	DodecahedronBufferGeometry: DodecahedronBufferGeometry,
	PolyhedronGeometry: PolyhedronGeometry,
	PolyhedronBufferGeometry: PolyhedronBufferGeometry,
	TubeGeometry: TubeGeometry,
	TubeBufferGeometry: TubeBufferGeometry,
	TorusKnotGeometry: TorusKnotGeometry,
	TorusKnotBufferGeometry: TorusKnotBufferGeometry,
	TorusGeometry: TorusGeometry,
	TorusBufferGeometry: TorusBufferGeometry,
	TextGeometry: TextGeometry,
	SphereBufferGeometry: SphereBufferGeometry,
	SphereGeometry: SphereGeometry,
	RingGeometry: RingGeometry,
	RingBufferGeometry: RingBufferGeometry,
	PlaneBufferGeometry: PlaneBufferGeometry,
	PlaneGeometry: PlaneGeometry,
	LatheGeometry: LatheGeometry,
	LatheBufferGeometry: LatheBufferGeometry,
	ShapeGeometry: ShapeGeometry,
	ShapeBufferGeometry: ShapeBufferGeometry,
	ExtrudeGeometry: ExtrudeGeometry,
	EdgesGeometry: EdgesGeometry,
	ConeGeometry: ConeGeometry,
	ConeBufferGeometry: ConeBufferGeometry,
	CylinderGeometry: CylinderGeometry,
	CylinderBufferGeometry: CylinderBufferGeometry,
	CircleBufferGeometry: CircleBufferGeometry,
	CircleGeometry: CircleGeometry,
	BoxBufferGeometry: BoxBufferGeometry,
	BoxGeometry: BoxGeometry
});

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ShadowMaterial() {

	ShaderMaterial.call( this, {
		uniforms: UniformsUtils.merge( [
			UniformsLib.lights,
			{
				opacity: { value: 1.0 }
			}
		] ),
		vertexShader: ShaderChunk[ 'shadow_vert' ],
		fragmentShader: ShaderChunk[ 'shadow_frag' ]
	} );

	this.lights = true;
	this.transparent = true;

	Object.defineProperties( this, {
		opacity: {
			enumerable: true,
			get: function () {
				return this.uniforms.opacity.value;
			},
			set: function ( value ) {
				this.uniforms.opacity.value = value;
			}
		}
	} );

}

ShadowMaterial.prototype = Object.create( ShaderMaterial.prototype );
ShadowMaterial.prototype.constructor = ShadowMaterial;

ShadowMaterial.prototype.isShadowMaterial = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function RawShaderMaterial( parameters ) {

	ShaderMaterial.call( this, parameters );

	this.type = 'RawShaderMaterial';

}

RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
RawShaderMaterial.prototype.constructor = RawShaderMaterial;

RawShaderMaterial.prototype.isRawShaderMaterial = true;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function MultiMaterial( materials ) {

	this.uuid = _Math.generateUUID();

	this.type = 'MultiMaterial';

	this.materials = Array.isArray( materials ) ? materials : [];

	this.visible = true;

}

MultiMaterial.prototype = {

	constructor: MultiMaterial,

	isMultiMaterial: true,

	toJSON: function ( meta ) {

		var output = {
			metadata: {
				version: 4.2,
				type: 'material',
				generator: 'MaterialExporter'
			},
			uuid: this.uuid,
			type: this.type,
			materials: []
		};

		var materials = this.materials;

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			var material = materials[ i ].toJSON( meta );
			delete material.metadata;

			output.materials.push( material );

		}

		output.visible = this.visible;

		return output;

	},

	clone: function () {

		var material = new this.constructor();

		for ( var i = 0; i < this.materials.length; i ++ ) {

			material.materials.push( this.materials[ i ].clone() );

		}

		material.visible = this.visible;

		return material;

	}

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  color: <hex>,
 *  roughness: <float>,
 *  metalness: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  roughnessMap: new THREE.Texture( <Image> ),
 *
 *  metalnessMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
 *  envMapIntensity: <float>
 *
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshStandardMaterial( parameters ) {

	Material.call( this );

	this.defines = { 'STANDARD': '' };

	this.type = 'MeshStandardMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.roughness = 0.5;
	this.metalness = 0.5;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.roughnessMap = null;

	this.metalnessMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.envMapIntensity = 1.0;

	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshStandardMaterial.prototype = Object.create( Material.prototype );
MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;

MeshStandardMaterial.prototype.isMeshStandardMaterial = true;

MeshStandardMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.defines = { 'STANDARD': '' };

	this.color.copy( source.color );
	this.roughness = source.roughness;
	this.metalness = source.metalness;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.roughnessMap = source.roughnessMap;

	this.metalnessMap = source.metalnessMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.envMapIntensity = source.envMapIntensity;

	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  reflectivity: <float>
 * }
 */

function MeshPhysicalMaterial( parameters ) {

	MeshStandardMaterial.call( this );

	this.defines = { 'PHYSICAL': '' };

	this.type = 'MeshPhysicalMaterial';

	this.reflectivity = 0.5; // maps to F0 = 0.04

	this.clearCoat = 0.0;
	this.clearCoatRoughness = 0.0;

	this.setValues( parameters );

}

MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;

MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;

MeshPhysicalMaterial.prototype.copy = function ( source ) {

	MeshStandardMaterial.prototype.copy.call( this, source );

	this.defines = { 'PHYSICAL': '' };

	this.reflectivity = source.reflectivity;

	this.clearCoat = source.clearCoat;
	this.clearCoatRoughness = source.clearCoatRoughness;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  specular: <hex>,
 *  shininess: <float>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshPhongMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshPhongMaterial';

	this.color = new Color( 0xffffff ); // diffuse
	this.specular = new Color( 0x111111 );
	this.shininess = 30;

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshPhongMaterial.prototype = Object.create( Material.prototype );
MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;

MeshPhongMaterial.prototype.isMeshPhongMaterial = true;

MeshPhongMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );
	this.specular.copy( source.specular );
	this.shininess = source.shininess;

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author takahirox / http://github.com/takahirox
 *
 * parameters = {
 *  gradientMap: new THREE.Texture( <Image> )
 * }
 */

function MeshToonMaterial( parameters ) {

	MeshPhongMaterial.call( this );

	this.defines = { 'TOON': '' };

	this.type = 'MeshToonMaterial';

	this.gradientMap = null;

	this.setValues( parameters );

}

MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
MeshToonMaterial.prototype.constructor = MeshToonMaterial;

MeshToonMaterial.prototype.isMeshToonMaterial = true;

MeshToonMaterial.prototype.copy = function ( source ) {

	MeshPhongMaterial.prototype.copy.call( this, source );

	this.gradientMap = source.gradientMap;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 *
 * parameters = {
 *  opacity: <float>,
 *
 *  bumpMap: new THREE.Texture( <Image> ),
 *  bumpScale: <float>,
 *
 *  normalMap: new THREE.Texture( <Image> ),
 *  normalScale: <Vector2>,
 *
 *  displacementMap: new THREE.Texture( <Image> ),
 *  displacementScale: <float>,
 *  displacementBias: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshNormalMaterial( parameters ) {

	Material.call( this, parameters );

	this.type = 'MeshNormalMaterial';

	this.bumpMap = null;
	this.bumpScale = 1;

	this.normalMap = null;
	this.normalScale = new Vector2( 1, 1 );

	this.displacementMap = null;
	this.displacementScale = 1;
	this.displacementBias = 0;

	this.wireframe = false;
	this.wireframeLinewidth = 1;

	this.fog = false;
	this.lights = false;

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshNormalMaterial.prototype = Object.create( Material.prototype );
MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;

MeshNormalMaterial.prototype.isMeshNormalMaterial = true;

MeshNormalMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.bumpMap = source.bumpMap;
	this.bumpScale = source.bumpScale;

	this.normalMap = source.normalMap;
	this.normalScale.copy( source.normalScale );

	this.displacementMap = source.displacementMap;
	this.displacementScale = source.displacementScale;
	this.displacementBias = source.displacementBias;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  map: new THREE.Texture( <Image> ),
 *
 *  lightMap: new THREE.Texture( <Image> ),
 *  lightMapIntensity: <float>
 *
 *  aoMap: new THREE.Texture( <Image> ),
 *  aoMapIntensity: <float>
 *
 *  emissive: <hex>,
 *  emissiveIntensity: <float>
 *  emissiveMap: new THREE.Texture( <Image> ),
 *
 *  specularMap: new THREE.Texture( <Image> ),
 *
 *  alphaMap: new THREE.Texture( <Image> ),
 *
 *  envMap: new THREE.TextureCube( [posx, negx, posy, negy, posz, negz] ),
 *  combine: THREE.Multiply,
 *  reflectivity: <float>,
 *  refractionRatio: <float>,
 *
 *  wireframe: <boolean>,
 *  wireframeLinewidth: <float>,
 *
 *  skinning: <bool>,
 *  morphTargets: <bool>,
 *  morphNormals: <bool>
 * }
 */

function MeshLambertMaterial( parameters ) {

	Material.call( this );

	this.type = 'MeshLambertMaterial';

	this.color = new Color( 0xffffff ); // diffuse

	this.map = null;

	this.lightMap = null;
	this.lightMapIntensity = 1.0;

	this.aoMap = null;
	this.aoMapIntensity = 1.0;

	this.emissive = new Color( 0x000000 );
	this.emissiveIntensity = 1.0;
	this.emissiveMap = null;

	this.specularMap = null;

	this.alphaMap = null;

	this.envMap = null;
	this.combine = MultiplyOperation;
	this.reflectivity = 1;
	this.refractionRatio = 0.98;

	this.wireframe = false;
	this.wireframeLinewidth = 1;
	this.wireframeLinecap = 'round';
	this.wireframeLinejoin = 'round';

	this.skinning = false;
	this.morphTargets = false;
	this.morphNormals = false;

	this.setValues( parameters );

}

MeshLambertMaterial.prototype = Object.create( Material.prototype );
MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;

MeshLambertMaterial.prototype.isMeshLambertMaterial = true;

MeshLambertMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.map = source.map;

	this.lightMap = source.lightMap;
	this.lightMapIntensity = source.lightMapIntensity;

	this.aoMap = source.aoMap;
	this.aoMapIntensity = source.aoMapIntensity;

	this.emissive.copy( source.emissive );
	this.emissiveMap = source.emissiveMap;
	this.emissiveIntensity = source.emissiveIntensity;

	this.specularMap = source.specularMap;

	this.alphaMap = source.alphaMap;

	this.envMap = source.envMap;
	this.combine = source.combine;
	this.reflectivity = source.reflectivity;
	this.refractionRatio = source.refractionRatio;

	this.wireframe = source.wireframe;
	this.wireframeLinewidth = source.wireframeLinewidth;
	this.wireframeLinecap = source.wireframeLinecap;
	this.wireframeLinejoin = source.wireframeLinejoin;

	this.skinning = source.skinning;
	this.morphTargets = source.morphTargets;
	this.morphNormals = source.morphNormals;

	return this;

};

/**
 * @author alteredq / http://alteredqualia.com/
 *
 * parameters = {
 *  color: <hex>,
 *  opacity: <float>,
 *
 *  linewidth: <float>,
 *
 *  scale: <float>,
 *  dashSize: <float>,
 *  gapSize: <float>
 * }
 */

function LineDashedMaterial( parameters ) {

	Material.call( this );

	this.type = 'LineDashedMaterial';

	this.color = new Color( 0xffffff );

	this.linewidth = 1;

	this.scale = 1;
	this.dashSize = 3;
	this.gapSize = 1;

	this.lights = false;

	this.setValues( parameters );

}

LineDashedMaterial.prototype = Object.create( Material.prototype );
LineDashedMaterial.prototype.constructor = LineDashedMaterial;

LineDashedMaterial.prototype.isLineDashedMaterial = true;

LineDashedMaterial.prototype.copy = function ( source ) {

	Material.prototype.copy.call( this, source );

	this.color.copy( source.color );

	this.linewidth = source.linewidth;

	this.scale = source.scale;
	this.dashSize = source.dashSize;
	this.gapSize = source.gapSize;

	return this;

};



var Materials = Object.freeze({
	ShadowMaterial: ShadowMaterial,
	SpriteMaterial: SpriteMaterial,
	RawShaderMaterial: RawShaderMaterial,
	ShaderMaterial: ShaderMaterial,
	PointsMaterial: PointsMaterial,
	MultiMaterial: MultiMaterial,
	MeshPhysicalMaterial: MeshPhysicalMaterial,
	MeshStandardMaterial: MeshStandardMaterial,
	MeshPhongMaterial: MeshPhongMaterial,
	MeshToonMaterial: MeshToonMaterial,
	MeshNormalMaterial: MeshNormalMaterial,
	MeshLambertMaterial: MeshLambertMaterial,
	MeshDepthMaterial: MeshDepthMaterial,
	MeshBasicMaterial: MeshBasicMaterial,
	LineDashedMaterial: LineDashedMaterial,
	LineBasicMaterial: LineBasicMaterial,
	Material: Material
});

/**
 * @author mrdoob / http://mrdoob.com/
 */

var Cache = {

	enabled: false,

	files: {},

	add: function ( key, file ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Adding key:', key );

		this.files[ key ] = file;

	},

	get: function ( key ) {

		if ( this.enabled === false ) return;

		// console.log( 'THREE.Cache', 'Checking key:', key );

		return this.files[ key ];

	},

	remove: function ( key ) {

		delete this.files[ key ];

	},

	clear: function () {

		this.files = {};

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LoadingManager( onLoad, onProgress, onError ) {

	var scope = this;

	var isLoading = false, itemsLoaded = 0, itemsTotal = 0;

	this.onStart = undefined;
	this.onLoad = onLoad;
	this.onProgress = onProgress;
	this.onError = onError;

	this.itemStart = function ( url ) {

		itemsTotal ++;

		if ( isLoading === false ) {

			if ( scope.onStart !== undefined ) {

				scope.onStart( url, itemsLoaded, itemsTotal );

			}

		}

		isLoading = true;

	};

	this.itemEnd = function ( url ) {

		itemsLoaded ++;

		if ( scope.onProgress !== undefined ) {

			scope.onProgress( url, itemsLoaded, itemsTotal );

		}

		if ( itemsLoaded === itemsTotal ) {

			isLoading = false;

			if ( scope.onLoad !== undefined ) {

				scope.onLoad();

			}

		}

	};

	this.itemError = function ( url ) {

		if ( scope.onError !== undefined ) {

			scope.onError( url );

		}

	};

}

var DefaultLoadingManager = new LoadingManager();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function FileLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( FileLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		if ( url === undefined ) url = '';

		if ( this.path !== undefined ) url = this.path + url;

		var scope = this;

		var cached = Cache.get( url );

		if ( cached !== undefined ) {

			scope.manager.itemStart( url );

			setTimeout( function () {

				if ( onLoad ) onLoad( cached );

				scope.manager.itemEnd( url );

			}, 0 );

			return cached;

		}

		// Check for data: URI
		var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
		var dataUriRegexResult = url.match( dataUriRegex );

		// Safari can not handle Data URIs through XMLHttpRequest so process manually
		if ( dataUriRegexResult ) {

			var mimeType = dataUriRegexResult[ 1 ];
			var isBase64 = !! dataUriRegexResult[ 2 ];
			var data = dataUriRegexResult[ 3 ];

			data = window.decodeURIComponent( data );

			if ( isBase64 ) data = window.atob( data );

			try {

				var response;
				var responseType = ( this.responseType || '' ).toLowerCase();

				switch ( responseType ) {

					case 'arraybuffer':
					case 'blob':

					 	response = new ArrayBuffer( data.length );

						var view = new Uint8Array( response );

						for ( var i = 0; i < data.length; i ++ ) {

							view[ i ] = data.charCodeAt( i );

						}

						if ( responseType === 'blob' ) {

							response = new Blob( [ response ], { type: mimeType } );

						}

						break;

					case 'document':

						var parser = new DOMParser();
						response = parser.parseFromString( data, mimeType );

						break;

					case 'json':

						response = JSON.parse( data );

						break;

					default: // 'text' or other

						response = data;

						break;

				}

				// Wait for next browser tick
				window.setTimeout( function () {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				}, 0 );

			} catch ( error ) {

				// Wait for next browser tick
				window.setTimeout( function () {

					if ( onError ) onError( error );

					scope.manager.itemError( url );

				}, 0 );

			}

		} else {

			var request = new XMLHttpRequest();
			request.open( 'GET', url, true );

			request.addEventListener( 'load', function ( event ) {

				var response = event.target.response;

				Cache.add( url, response );

				if ( this.status === 200 ) {

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				} else if ( this.status === 0 ) {

					// Some browsers return HTTP Status 0 when using non-http protocol
					// e.g. 'file://' or 'data://'. Handle as success.

					console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );

					if ( onLoad ) onLoad( response );

					scope.manager.itemEnd( url );

				} else {

					if ( onError ) onError( event );

					scope.manager.itemError( url );

				}

			}, false );

			if ( onProgress !== undefined ) {

				request.addEventListener( 'progress', function ( event ) {

					onProgress( event );

				}, false );

			}

			request.addEventListener( 'error', function ( event ) {

				if ( onError ) onError( event );

				scope.manager.itemError( url );

			}, false );

			if ( this.responseType !== undefined ) request.responseType = this.responseType;
			if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;

			if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );

			request.send( null );

		}

		scope.manager.itemStart( url );

		return request;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	},

	setResponseType: function ( value ) {

		this.responseType = value;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setMimeType: function ( value ) {

		this.mimeType = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 *
 * Abstract Base class to block based textures loader (dds, pvr, ...)
 */

function CompressedTextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

}

Object.assign( CompressedTextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var images = [];

		var texture = new CompressedTexture();
		texture.image = images;

		var loader = new FileLoader( this.manager );
		loader.setPath( this.path );
		loader.setResponseType( 'arraybuffer' );

		function loadTexture( i ) {

			loader.load( url[ i ], function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				images[ i ] = {
					width: texDatas.width,
					height: texDatas.height,
					format: texDatas.format,
					mipmaps: texDatas.mipmaps
				};

				loaded += 1;

				if ( loaded === 6 ) {

					if ( texDatas.mipmapCount === 1 )
						texture.minFilter = LinearFilter;

					texture.format = texDatas.format;
					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, onProgress, onError );

		}

		if ( Array.isArray( url ) ) {

			var loaded = 0;

			for ( var i = 0, il = url.length; i < il; ++ i ) {

				loadTexture( i );

			}

		} else {

			// compressed cubemap texture stored in a single DDS file

			loader.load( url, function ( buffer ) {

				var texDatas = scope._parser( buffer, true );

				if ( texDatas.isCubemap ) {

					var faces = texDatas.mipmaps.length / texDatas.mipmapCount;

					for ( var f = 0; f < faces; f ++ ) {

						images[ f ] = { mipmaps : [] };

						for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {

							images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
							images[ f ].format = texDatas.format;
							images[ f ].width = texDatas.width;
							images[ f ].height = texDatas.height;

						}

					}

				} else {

					texture.image.width = texDatas.width;
					texture.image.height = texDatas.height;
					texture.mipmaps = texDatas.mipmaps;

				}

				if ( texDatas.mipmapCount === 1 ) {

					texture.minFilter = LinearFilter;

				}

				texture.format = texDatas.format;
				texture.needsUpdate = true;

				if ( onLoad ) onLoad( texture );

			}, onProgress, onError );

		}

		return texture;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author Nikos M. / https://github.com/foo123/
 *
 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
 */

var DataTextureLoader = BinaryTextureLoader;
function BinaryTextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	// override in sub classes
	this._parser = null;

}

Object.assign( BinaryTextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texture = new DataTexture();

		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );

		loader.load( url, function ( buffer ) {

			var texData = scope._parser( buffer );

			if ( ! texData ) return;

			if ( undefined !== texData.image ) {

				texture.image = texData.image;

			} else if ( undefined !== texData.data ) {

				texture.image.width = texData.width;
				texture.image.height = texData.height;
				texture.image.data = texData.data;

			}

			texture.wrapS = undefined !== texData.wrapS ? texData.wrapS : ClampToEdgeWrapping;
			texture.wrapT = undefined !== texData.wrapT ? texData.wrapT : ClampToEdgeWrapping;

			texture.magFilter = undefined !== texData.magFilter ? texData.magFilter : LinearFilter;
			texture.minFilter = undefined !== texData.minFilter ? texData.minFilter : LinearMipMapLinearFilter;

			texture.anisotropy = undefined !== texData.anisotropy ? texData.anisotropy : 1;

			if ( undefined !== texData.format ) {

				texture.format = texData.format;

			}
			if ( undefined !== texData.type ) {

				texture.type = texData.type;

			}

			if ( undefined !== texData.mipmaps ) {

				texture.mipmaps = texData.mipmaps;

			}

			if ( 1 === texData.mipmapCount ) {

				texture.minFilter = LinearFilter;

			}

			texture.needsUpdate = true;

			if ( onLoad ) onLoad( texture, texData );

		}, onProgress, onError );


		return texture;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ImageLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( ImageLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
		image.onload = function () {

			image.onload = null;

			URL.revokeObjectURL( image.src );

			if ( onLoad ) onLoad( image );

			scope.manager.itemEnd( url );

		};
		image.onerror = onError;

		if ( url.indexOf( 'data:' ) === 0 ) {

			image.src = url;

		} else if ( this.crossOrigin !== undefined ) {

			// crossOrigin doesn't work with URL.createObjectURL()?

			image.crossOrigin = this.crossOrigin;
			image.src = url;

		} else {

			var loader = new FileLoader();
			loader.setPath( this.path );
			loader.setResponseType( 'blob' );
			loader.setWithCredentials( this.withCredentials );
			loader.load( url, function ( blob ) {

				image.src = URL.createObjectURL( blob );

			}, onProgress, onError );

		}

		scope.manager.itemStart( url );

		return image;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function CubeTextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( CubeTextureLoader.prototype, {

	load: function ( urls, onLoad, onProgress, onError ) {

		var texture = new CubeTexture();

		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setPath( this.path );

		var loaded = 0;

		function loadTexture( i ) {

			loader.load( urls[ i ], function ( image ) {

				texture.images[ i ] = image;

				loaded ++;

				if ( loaded === 6 ) {

					texture.needsUpdate = true;

					if ( onLoad ) onLoad( texture );

				}

			}, undefined, onError );

		}

		for ( var i = 0; i < urls.length; ++ i ) {

			loadTexture( i );

		}

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function TextureLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( TextureLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var texture = new Texture();

		var loader = new ImageLoader( this.manager );
		loader.setCrossOrigin( this.crossOrigin );
		loader.setWithCredentials( this.withCredentials );
		loader.setPath( this.path );
		loader.load( url, function ( image ) {

			// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
			var isJPEG = url.search( /\.(jpg|jpeg)$/ ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;

			texture.format = isJPEG ? RGBFormat : RGBAFormat;
			texture.image = image;
			texture.needsUpdate = true;

			if ( onLoad !== undefined ) {

				onLoad( texture );

			}

		}, onProgress, onError );

		return texture;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;
		return this;

	},

	setWithCredentials: function ( value ) {

		this.withCredentials = value;
		return this;

	},

	setPath: function ( value ) {

		this.path = value;
		return this;

	}



} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Light( color, intensity ) {

	Object3D.call( this );

	this.type = 'Light';

	this.color = new Color( color );
	this.intensity = intensity !== undefined ? intensity : 1;

	this.receiveShadow = undefined;

}

Light.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Light,

	isLight: true,

	copy: function ( source ) {

		Object3D.prototype.copy.call( this, source );

		this.color.copy( source.color );
		this.intensity = source.intensity;

		return this;

	},

	toJSON: function ( meta ) {

		var data = Object3D.prototype.toJSON.call( this, meta );

		data.object.color = this.color.getHex();
		data.object.intensity = this.intensity;

		if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();

		if ( this.distance !== undefined ) data.object.distance = this.distance;
		if ( this.angle !== undefined ) data.object.angle = this.angle;
		if ( this.decay !== undefined ) data.object.decay = this.decay;
		if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;

		if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();

		return data;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function HemisphereLight( skyColor, groundColor, intensity ) {

	Light.call( this, skyColor, intensity );

	this.type = 'HemisphereLight';

	this.castShadow = undefined;

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.groundColor = new Color( groundColor );

}

HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: HemisphereLight,

	isHemisphereLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.groundColor.copy( source.groundColor );

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function LightShadow( camera ) {

	this.camera = camera;

	this.bias = 0;
	this.radius = 1;

	this.mapSize = new Vector2( 512, 512 );

	this.map = null;
	this.matrix = new Matrix4();

}

Object.assign( LightShadow.prototype, {

	copy: function ( source ) {

		this.camera = source.camera.clone();

		this.bias = source.bias;
		this.radius = source.radius;

		this.mapSize.copy( source.mapSize );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	toJSON: function () {

		var object = {};

		if ( this.bias !== 0 ) object.bias = this.bias;
		if ( this.radius !== 1 ) object.radius = this.radius;
		if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();

		object.camera = this.camera.toJSON( false ).object;
		delete object.camera.matrix;

		return object;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function SpotLightShadow() {

	LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );

}

SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: SpotLightShadow,

	isSpotLightShadow: true,

	update: function ( light ) {

		var fov = _Math.RAD2DEG * 2 * light.angle;
		var aspect = this.mapSize.width / this.mapSize.height;
		var far = light.distance || 500;

		var camera = this.camera;

		if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {

			camera.fov = fov;
			camera.aspect = aspect;
			camera.far = far;
			camera.updateProjectionMatrix();

		}

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function SpotLight( color, intensity, distance, angle, penumbra, decay ) {

	Light.call( this, color, intensity );

	this.type = 'SpotLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	Object.defineProperty( this, 'power', {
		get: function () {
			// intensity = power per solid angle.
			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			return this.intensity * Math.PI;
		},
		set: function ( power ) {
			// intensity = power per solid angle.
			// ref: equation (17) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			this.intensity = power / Math.PI;
		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
	this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new SpotLightShadow();

}

SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: SpotLight,

	isSpotLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.angle = source.angle;
		this.penumbra = source.penumbra;
		this.decay = source.decay;

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */


function PointLight( color, intensity, distance, decay ) {

	Light.call( this, color, intensity );

	this.type = 'PointLight';

	Object.defineProperty( this, 'power', {
		get: function () {
			// intensity = power per solid angle.
			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			return this.intensity * 4 * Math.PI;

		},
		set: function ( power ) {
			// intensity = power per solid angle.
			// ref: equation (15) from http://www.frostbite.com/wp-content/uploads/2014/11/course_notes_moving_frostbite_to_pbr.pdf
			this.intensity = power / ( 4 * Math.PI );
		}
	} );

	this.distance = ( distance !== undefined ) ? distance : 0;
	this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.

	this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );

}

PointLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: PointLight,

	isPointLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.distance = source.distance;
		this.decay = source.decay;

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function DirectionalLightShadow( light ) {

	LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );

}

DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {

	constructor: DirectionalLightShadow

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function DirectionalLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'DirectionalLight';

	this.position.copy( Object3D.DefaultUp );
	this.updateMatrix();

	this.target = new Object3D();

	this.shadow = new DirectionalLightShadow();

}

DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: DirectionalLight,

	isDirectionalLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.target = source.target.clone();

		this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AmbientLight( color, intensity ) {

	Light.call( this, color, intensity );

	this.type = 'AmbientLight';

	this.castShadow = undefined;

}

AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: AmbientLight,

	isAmbientLight: true

} );

/**
 * @author tschw
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

var AnimationUtils = {

	// same as Array.prototype.slice, but also works on typed arrays
	arraySlice: function( array, from, to ) {

		if ( AnimationUtils.isTypedArray( array ) ) {

			return new array.constructor( array.subarray( from, to ) );

		}

		return array.slice( from, to );

	},

	// converts an array to a specific type
	convertArray: function( array, type, forceClone ) {

		if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;

		if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {

			return new type( array ); // create typed array

		}

		return Array.prototype.slice.call( array ); // create Array

	},

	isTypedArray: function( object ) {

		return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );

	},

	// returns an array by which times and values can be sorted
	getKeyframeOrder: function( times ) {

		function compareTime( i, j ) {

			return times[ i ] - times[ j ];

		}

		var n = times.length;
		var result = new Array( n );
		for ( var i = 0; i !== n; ++ i ) result[ i ] = i;

		result.sort( compareTime );

		return result;

	},

	// uses the array previously returned by 'getKeyframeOrder' to sort data
	sortedArray: function( values, stride, order ) {

		var nValues = values.length;
		var result = new values.constructor( nValues );

		for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {

			var srcOffset = order[ i ] * stride;

			for ( var j = 0; j !== stride; ++ j ) {

				result[ dstOffset ++ ] = values[ srcOffset + j ];

			}

		}

		return result;

	},

	// function for parsing AOS keyframe formats
	flattenJSON: function( jsonKeys, times, values, valuePropertyName ) {

		var i = 1, key = jsonKeys[ 0 ];

		while ( key !== undefined && key[ valuePropertyName ] === undefined ) {

			key = jsonKeys[ i ++ ];

		}

		if ( key === undefined ) return; // no data

		var value = key[ valuePropertyName ];
		if ( value === undefined ) return; // no data

		if ( Array.isArray( value ) ) {

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push.apply( values, value ); // push all elements

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else if ( value.toArray !== undefined ) {
			// ...assume THREE.Math-ish

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					value.toArray( values, values.length );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		} else {
			// otherwise push as-is

			do {

				value = key[ valuePropertyName ];

				if ( value !== undefined ) {

					times.push( key.time );
					values.push( value );

				}

				key = jsonKeys[ i ++ ];

			} while ( key !== undefined );

		}

	}

};

/**
 * Abstract base class of interpolants over parametric samples.
 *
 * The parameter domain is one dimensional, typically the time or a path
 * along a curve defined by the data.
 *
 * The sample values can have any dimensionality and derived classes may
 * apply special interpretations to the data.
 *
 * This class provides the interval seek in a Template Method, deferring
 * the actual interpolation to derived classes.
 *
 * Time complexity is O(1) for linear access crossing at most two points
 * and O(log N) for random access, where N is the number of positions.
 *
 * References:
 *
 * 		http://www.oodesign.com/template-method-pattern.html
 *
 * @author tschw
 */

function Interpolant(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	this.parameterPositions = parameterPositions;
	this._cachedIndex = 0;

	this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
	this.sampleValues = sampleValues;
	this.valueSize = sampleSize;

}

Interpolant.prototype = {

	constructor: Interpolant,

	evaluate: function( t ) {

		var pp = this.parameterPositions,
			i1 = this._cachedIndex,

			t1 = pp[   i1   ],
			t0 = pp[ i1 - 1 ];

		validate_interval: {

			seek: {

				var right;

				linear_scan: {
//- See http://jsperf.com/comparison-to-undefined/3
//- slower code:
//-
//- 				if ( t >= t1 || t1 === undefined ) {
					forward_scan: if ( ! ( t < t1 ) ) {

						for ( var giveUpAt = i1 + 2; ;) {

							if ( t1 === undefined ) {

								if ( t < t0 ) break forward_scan;

								// after end

								i1 = pp.length;
								this._cachedIndex = i1;
								return this.afterEnd_( i1 - 1, t, t0 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t0 = t1;
							t1 = pp[ ++ i1 ];

							if ( t < t1 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the right side of the index
						right = pp.length;
						break linear_scan;

					}

//- slower code:
//-					if ( t < t0 || t0 === undefined ) {
					if ( ! ( t >= t0 ) ) {

						// looping?

						var t1global = pp[ 1 ];

						if ( t < t1global ) {

							i1 = 2; // + 1, using the scan for the details
							t0 = t1global;

						}

						// linear reverse scan

						for ( var giveUpAt = i1 - 2; ;) {

							if ( t0 === undefined ) {

								// before start

								this._cachedIndex = 0;
								return this.beforeStart_( 0, t, t1 );

							}

							if ( i1 === giveUpAt ) break; // this loop

							t1 = t0;
							t0 = pp[ -- i1 - 1 ];

							if ( t >= t0 ) {

								// we have arrived at the sought interval
								break seek;

							}

						}

						// prepare binary search on the left side of the index
						right = i1;
						i1 = 0;
						break linear_scan;

					}

					// the interval is valid

					break validate_interval;

				} // linear scan

				// binary search

				while ( i1 < right ) {

					var mid = ( i1 + right ) >>> 1;

					if ( t < pp[ mid ] ) {

						right = mid;

					} else {

						i1 = mid + 1;

					}

				}

				t1 = pp[   i1   ];
				t0 = pp[ i1 - 1 ];

				// check boundary cases, again

				if ( t0 === undefined ) {

					this._cachedIndex = 0;
					return this.beforeStart_( 0, t, t1 );

				}

				if ( t1 === undefined ) {

					i1 = pp.length;
					this._cachedIndex = i1;
					return this.afterEnd_( i1 - 1, t0, t );

				}

			} // seek

			this._cachedIndex = i1;

			this.intervalChanged_( i1, t0, t1 );

		} // validate_interval

		return this.interpolate_( i1, t0, t, t1 );

	},

	settings: null, // optional, subclass-specific settings structure
	// Note: The indirection allows central control of many interpolants.

	// --- Protected interface

	DefaultSettings_: {},

	getSettings_: function() {

		return this.settings || this.DefaultSettings_;

	},

	copySampleValue_: function( index ) {

		// copies a sample value to the result buffer

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,
			offset = index * stride;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] = values[ offset + i ];

		}

		return result;

	},

	// Template methods for derived classes:

	interpolate_: function( i1, t0, t, t1 ) {

		throw new Error( "call to abstract method" );
		// implementations shall return this.resultBuffer

	},

	intervalChanged_: function( i1, t0, t1 ) {

		// empty

	}

};

Object.assign( Interpolant.prototype, {

	beforeStart_: //( 0, t, t0 ), returns this.resultBuffer
		Interpolant.prototype.copySampleValue_,

	afterEnd_: //( N-1, tN-1, t ), returns this.resultBuffer
		Interpolant.prototype.copySampleValue_

} );

/**
 * Fast and simple cubic spline interpolant.
 *
 * It was derived from a Hermitian construction setting the first derivative
 * at each sample position to the linear slope between neighboring positions
 * over their parameter interval.
 *
 * @author tschw
 */

function CubicInterpolant(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

	this._weightPrev = -0;
	this._offsetPrev = -0;
	this._weightNext = -0;
	this._offsetNext = -0;

}

CubicInterpolant.prototype =
		Object.assign( Object.create( Interpolant.prototype ), {

	constructor: CubicInterpolant,

	DefaultSettings_: {

		endingStart: 	ZeroCurvatureEnding,
		endingEnd:		ZeroCurvatureEnding

	},

	intervalChanged_: function( i1, t0, t1 ) {

		var pp = this.parameterPositions,
			iPrev = i1 - 2,
			iNext = i1 + 1,

			tPrev = pp[ iPrev ],
			tNext = pp[ iNext ];

		if ( tPrev === undefined ) {

			switch ( this.getSettings_().endingStart ) {

				case ZeroSlopeEnding:

					// f'(t0) = 0
					iPrev = i1;
					tPrev = 2 * t0 - t1;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iPrev = pp.length - 2;
					tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(t0) = 0 a.k.a. Natural Spline
					iPrev = i1;
					tPrev = t1;

			}

		}

		if ( tNext === undefined ) {

			switch ( this.getSettings_().endingEnd ) {

				case ZeroSlopeEnding:

					// f'(tN) = 0
					iNext = i1;
					tNext = 2 * t1 - t0;

					break;

				case WrapAroundEnding:

					// use the other end of the curve
					iNext = 1;
					tNext = t1 + pp[ 1 ] - pp[ 0 ];

					break;

				default: // ZeroCurvatureEnding

					// f''(tN) = 0, a.k.a. Natural Spline
					iNext = i1 - 1;
					tNext = t0;

			}

		}

		var halfDt = ( t1 - t0 ) * 0.5,
			stride = this.valueSize;

		this._weightPrev = halfDt / ( t0 - tPrev );
		this._weightNext = halfDt / ( tNext - t1 );
		this._offsetPrev = iPrev * stride;
		this._offsetNext = iNext * stride;

	},

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			o1 = i1 * stride,		o0 = o1 - stride,
			oP = this._offsetPrev, 	oN = this._offsetNext,
			wP = this._weightPrev,	wN = this._weightNext,

			p = ( t - t0 ) / ( t1 - t0 ),
			pp = p * p,
			ppp = pp * p;

		// evaluate polynomials

		var sP =     - wP   * ppp   +         2 * wP    * pp    -          wP   * p;
		var s0 = ( 1 + wP ) * ppp   + (-1.5 - 2 * wP )  * pp    + ( -0.5 + wP ) * p     + 1;
		var s1 = (-1 - wN ) * ppp   + ( 1.5 +   wN   )  * pp    +    0.5        * p;
		var sN =       wN   * ppp   -           wN      * pp;

		// combine data linearly

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					sP * values[ oP + i ] +
					s0 * values[ o0 + i ] +
					s1 * values[ o1 + i ] +
					sN * values[ oN + i ];

		}

		return result;

	}

} );

/**
 * @author tschw
 */

function LinearInterpolant(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

LinearInterpolant.prototype =
		Object.assign( Object.create( Interpolant.prototype ), {

	constructor: LinearInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset1 = i1 * stride,
			offset0 = offset1 - stride,

			weight1 = ( t - t0 ) / ( t1 - t0 ),
			weight0 = 1 - weight1;

		for ( var i = 0; i !== stride; ++ i ) {

			result[ i ] =
					values[ offset0 + i ] * weight0 +
					values[ offset1 + i ] * weight1;

		}

		return result;

	}

} );

/**
 *
 * Interpolant that evaluates to the sample value at the position preceeding
 * the parameter.
 *
 * @author tschw
 */

function DiscreteInterpolant(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

DiscreteInterpolant.prototype =
		Object.assign( Object.create( Interpolant.prototype ), {

	constructor: DiscreteInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		return this.copySampleValue_( i1 - 1 );

	}

} );

var KeyframeTrackPrototype;

KeyframeTrackPrototype = {

	TimeBufferType: Float32Array,
	ValueBufferType: Float32Array,

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodDiscrete: function ( result ) {

		return new DiscreteInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodLinear: function ( result ) {

		return new LinearInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: function ( result ) {

		return new CubicInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	setInterpolation: function ( interpolation ) {

		var factoryMethod;

		switch ( interpolation ) {

			case InterpolateDiscrete:

				factoryMethod = this.InterpolantFactoryMethodDiscrete;

				break;

			case InterpolateLinear:

				factoryMethod = this.InterpolantFactoryMethodLinear;

				break;

			case InterpolateSmooth:

				factoryMethod = this.InterpolantFactoryMethodSmooth;

				break;

		}

		if ( factoryMethod === undefined ) {

			var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;

			if ( this.createInterpolant === undefined ) {

				// fall back to default, unless the default itself is messed up
				if ( interpolation !== this.DefaultInterpolation ) {

					this.setInterpolation( this.DefaultInterpolation );

				} else {

					throw new Error( message ); // fatal, in this case

				}

			}

			console.warn( message );
			return;

		}

		this.createInterpolant = factoryMethod;

	},

	getInterpolation: function () {

		switch ( this.createInterpolant ) {

			case this.InterpolantFactoryMethodDiscrete:

				return InterpolateDiscrete;

			case this.InterpolantFactoryMethodLinear:

				return InterpolateLinear;

			case this.InterpolantFactoryMethodSmooth:

				return InterpolateSmooth;

		}

	},

	getValueSize: function () {

		return this.values.length / this.times.length;

	},

	// move all keyframes either forwards or backwards in time
	shift: function ( timeOffset ) {

		if ( timeOffset !== 0.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] += timeOffset;

			}

		}

		return this;

	},

	// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
	scale: function ( timeScale ) {

		if ( timeScale !== 1.0 ) {

			var times = this.times;

			for ( var i = 0, n = times.length; i !== n; ++ i ) {

				times[ i ] *= timeScale;

			}

		}

		return this;

	},

	// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
	// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
	trim: function ( startTime, endTime ) {

		var times = this.times,
			nKeys = times.length,
			from = 0,
			to = nKeys - 1;

		while ( from !== nKeys && times[ from ] < startTime ) ++ from;
		while ( to !== - 1 && times[ to ] > endTime ) -- to;

		++ to; // inclusive -> exclusive bound

		if ( from !== 0 || to !== nKeys ) {

			// empty tracks are forbidden, so keep at least one keyframe
			if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;

			var stride = this.getValueSize();
			this.times = AnimationUtils.arraySlice( times, from, to );
			this.values = AnimationUtils.
					arraySlice( this.values, from * stride, to * stride );

		}

		return this;

	},

	// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
	validate: function () {

		var valid = true;

		var valueSize = this.getValueSize();
		if ( valueSize - Math.floor( valueSize ) !== 0 ) {

			console.error( "invalid value size in track", this );
			valid = false;

		}

		var times = this.times,
			values = this.values,

			nKeys = times.length;

		if ( nKeys === 0 ) {

			console.error( "track is empty", this );
			valid = false;

		}

		var prevTime = null;

		for ( var i = 0; i !== nKeys; i ++ ) {

			var currTime = times[ i ];

			if ( typeof currTime === 'number' && isNaN( currTime ) ) {

				console.error( "time is not a valid number", this, i, currTime );
				valid = false;
				break;

			}

			if ( prevTime !== null && prevTime > currTime ) {

				console.error( "out of order keys", this, i, currTime, prevTime );
				valid = false;
				break;

			}

			prevTime = currTime;

		}

		if ( values !== undefined ) {

			if ( AnimationUtils.isTypedArray( values ) ) {

				for ( var i = 0, n = values.length; i !== n; ++ i ) {

					var value = values[ i ];

					if ( isNaN( value ) ) {

						console.error( "value is not a valid number", this, i, value );
						valid = false;
						break;

					}

				}

			}

		}

		return valid;

	},

	// removes equivalent sequential keys as common in morph target sequences
	// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
	optimize: function () {

		var times = this.times,
			values = this.values,
			stride = this.getValueSize(),

			smoothInterpolation = this.getInterpolation() === InterpolateSmooth,

			writeIndex = 1,
			lastIndex = times.length - 1;

		for ( var i = 1; i < lastIndex; ++ i ) {

			var keep = false;

			var time = times[ i ];
			var timeNext = times[ i + 1 ];

			// remove adjacent keyframes scheduled at the same time

			if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {

				if ( ! smoothInterpolation ) {

					// remove unnecessary keyframes same as their neighbors

					var offset = i * stride,
						offsetP = offset - stride,
						offsetN = offset + stride;

					for ( var j = 0; j !== stride; ++ j ) {

						var value = values[ offset + j ];

						if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {

							keep = true;
							break;

						}

					}

				} else keep = true;

			}

			// in-place compaction

			if ( keep ) {

				if ( i !== writeIndex ) {

					times[ writeIndex ] = times[ i ];

					var readOffset = i * stride,
						writeOffset = writeIndex * stride;

					for ( var j = 0; j !== stride; ++ j )

						values[ writeOffset + j ] = values[ readOffset + j ];

				}

				++ writeIndex;

			}

		}

		// flush last keyframe (compaction looks ahead)

		if ( lastIndex > 0 ) {

			times[ writeIndex ] = times[ lastIndex ];

			for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j )

				values[ writeOffset + j ] = values[ readOffset + j ];

			++ writeIndex;

		}

		if ( writeIndex !== times.length ) {

			this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
			this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );

		}

		return this;

	}

};

function KeyframeTrackConstructor( name, times, values, interpolation ) {

	if( name === undefined ) throw new Error( "track name is undefined" );

	if( times === undefined || times.length === 0 ) {

		throw new Error( "no keyframes in track named " + name );

	}

	this.name = name;

	this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
	this.values = AnimationUtils.convertArray( values, this.ValueBufferType );

	this.setInterpolation( interpolation || this.DefaultInterpolation );

	this.validate();
	this.optimize();

}

/**
 *
 * A Track of vectored keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function VectorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

VectorKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: VectorKeyframeTrack,

	ValueTypeName: 'vector'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 * Spherical linear unit quaternion interpolant.
 *
 * @author tschw
 */

function QuaternionLinearInterpolant(
		parameterPositions, sampleValues, sampleSize, resultBuffer ) {

	Interpolant.call(
			this, parameterPositions, sampleValues, sampleSize, resultBuffer );

}

QuaternionLinearInterpolant.prototype =
		Object.assign( Object.create( Interpolant.prototype ), {

	constructor: QuaternionLinearInterpolant,

	interpolate_: function( i1, t0, t, t1 ) {

		var result = this.resultBuffer,
			values = this.sampleValues,
			stride = this.valueSize,

			offset = i1 * stride,

			alpha = ( t - t0 ) / ( t1 - t0 );

		for ( var end = offset + stride; offset !== end; offset += 4 ) {

			Quaternion.slerpFlat( result, 0,
					values, offset - stride, values, offset, alpha );

		}

		return result;

	}

} );

/**
 *
 * A Track of quaternion keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function QuaternionKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

QuaternionKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: QuaternionKeyframeTrack,

	ValueTypeName: 'quaternion',

	// ValueBufferType is inherited

	DefaultInterpolation: InterpolateLinear,

	InterpolantFactoryMethodLinear: function( result ) {

		return new QuaternionLinearInterpolant(
				this.times, this.values, this.getValueSize(), result );

	},

	InterpolantFactoryMethodSmooth: undefined // not yet implemented

} );

/**
 *
 * A Track of numeric keyframe values.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function NumberKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

NumberKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: NumberKeyframeTrack,

	ValueTypeName: 'number'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited

} );

/**
 *
 * A Track that interpolates Strings
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function StringKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

StringKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: StringKeyframeTrack,

	ValueTypeName: 'string',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,

	InterpolantFactoryMethodSmooth: undefined

} );

/**
 *
 * A Track of Boolean keyframe values.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function BooleanKeyframeTrack( name, times, values ) {

	KeyframeTrackConstructor.call( this, name, times, values );

}

BooleanKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: BooleanKeyframeTrack,

	ValueTypeName: 'bool',
	ValueBufferType: Array,

	DefaultInterpolation: InterpolateDiscrete,

	InterpolantFactoryMethodLinear: undefined,
	InterpolantFactoryMethodSmooth: undefined

	// Note: Actually this track could have a optimized / compressed
	// representation of a single value and a custom interpolant that
	// computes "firstValue ^ isOdd( index )".

} );

/**
 *
 * A Track of keyframe values that represent color.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function ColorKeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.call( this, name, times, values, interpolation );

}

ColorKeyframeTrack.prototype =
		Object.assign( Object.create( KeyframeTrackPrototype ), {

	constructor: ColorKeyframeTrack,

	ValueTypeName: 'color'

	// ValueBufferType is inherited

	// DefaultInterpolation is inherited


	// Note: Very basic implementation and nothing special yet.
	// However, this is the place for color space parameterization.

} );

/**
 *
 * A timed sequence of keyframes for a specific property.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function KeyframeTrack( name, times, values, interpolation ) {

	KeyframeTrackConstructor.apply( this, arguments );

}

KeyframeTrack.prototype = KeyframeTrackPrototype;
KeyframeTrackPrototype.constructor = KeyframeTrack;

// Static methods:

Object.assign( KeyframeTrack, {

	// Serialization (in static context, because of constructor invocation
	// and automatic invocation of .toJSON):

	parse: function( json ) {

		if( json.type === undefined ) {

			throw new Error( "track type undefined, can not parse" );

		}

		var trackType = KeyframeTrack._getTrackTypeForValueTypeName( json.type );

		if ( json.times === undefined ) {

			var times = [], values = [];

			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );

			json.times = times;
			json.values = values;

		}

		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {

			return trackType.parse( json );

		} else {

			// by default, we asssume a constructor compatible with the base
			return new trackType(
					json.name, json.times, json.values, json.interpolation );

		}

	},

	toJSON: function( track ) {

		var trackType = track.constructor;

		var json;

		// derived classes can define a static toJSON method
		if ( trackType.toJSON !== undefined ) {

			json = trackType.toJSON( track );

		} else {

			// by default, we assume the data can be serialized as-is
			json = {

				'name': track.name,
				'times': AnimationUtils.convertArray( track.times, Array ),
				'values': AnimationUtils.convertArray( track.values, Array )

			};

			var interpolation = track.getInterpolation();

			if ( interpolation !== track.DefaultInterpolation ) {

				json.interpolation = interpolation;

			}

		}

		json.type = track.ValueTypeName; // mandatory

		return json;

	},

	_getTrackTypeForValueTypeName: function( typeName ) {

		switch( typeName.toLowerCase() ) {

			case "scalar":
			case "double":
			case "float":
			case "number":
			case "integer":

				return NumberKeyframeTrack;

			case "vector":
			case "vector2":
			case "vector3":
			case "vector4":

				return VectorKeyframeTrack;

			case "color":

				return ColorKeyframeTrack;

			case "quaternion":

				return QuaternionKeyframeTrack;

			case "bool":
			case "boolean":

				return BooleanKeyframeTrack;

			case "string":

				return StringKeyframeTrack;

		}

		throw new Error( "Unsupported typeName: " + typeName );

	}

} );

/**
 *
 * Reusable set of Tracks that represent an animation.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 */

function AnimationClip( name, duration, tracks ) {

	this.name = name;
	this.tracks = tracks;
	this.duration = ( duration !== undefined ) ? duration : -1;

	this.uuid = _Math.generateUUID();

	// this means it should figure out its duration by scanning the tracks
	if ( this.duration < 0 ) {

		this.resetDuration();

	}

	this.optimize();

}

AnimationClip.prototype = {

	constructor: AnimationClip,

	resetDuration: function() {

		var tracks = this.tracks,
			duration = 0;

		for ( var i = 0, n = tracks.length; i !== n; ++ i ) {

			var track = this.tracks[ i ];

			duration = Math.max( duration, track.times[ track.times.length - 1 ] );

		}

		this.duration = duration;

	},

	trim: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].trim( 0, this.duration );

		}

		return this;

	},

	optimize: function() {

		for ( var i = 0; i < this.tracks.length; i ++ ) {

			this.tracks[ i ].optimize();

		}

		return this;

	}

};

// Static methods:

Object.assign( AnimationClip, {

	parse: function( json ) {

		var tracks = [],
			jsonTracks = json.tracks,
			frameTime = 1.0 / ( json.fps || 1.0 );

		for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.parse( jsonTracks[ i ] ).scale( frameTime ) );

		}

		return new AnimationClip( json.name, json.duration, tracks );

	},


	toJSON: function( clip ) {

		var tracks = [],
			clipTracks = clip.tracks;

		var json = {

			'name': clip.name,
			'duration': clip.duration,
			'tracks': tracks

		};

		for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {

			tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );

		}

		return json;

	},


	CreateFromMorphTargetSequence: function( name, morphTargetSequence, fps, noLoop ) {

		var numMorphTargets = morphTargetSequence.length;
		var tracks = [];

		for ( var i = 0; i < numMorphTargets; i ++ ) {

			var times = [];
			var values = [];

			times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );

			values.push( 0, 1, 0 );

			var order = AnimationUtils.getKeyframeOrder( times );
			times = AnimationUtils.sortedArray( times, 1, order );
			values = AnimationUtils.sortedArray( values, 1, order );

			// if there is a key at the first frame, duplicate it as the
			// last frame as well for perfect loop.
			if ( ! noLoop && times[ 0 ] === 0 ) {

				times.push( numMorphTargets );
				values.push( values[ 0 ] );

			}

			tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );
		}

		return new AnimationClip( name, -1, tracks );

	},

	findByName: function( objectOrClipArray, name ) {

		var clipArray = objectOrClipArray;

		if ( ! Array.isArray( objectOrClipArray ) ) {

			var o = objectOrClipArray;
			clipArray = o.geometry && o.geometry.animations || o.animations;

		}

		for ( var i = 0; i < clipArray.length; i ++ ) {

			if ( clipArray[ i ].name === name ) {

				return clipArray[ i ];

			}
		}

		return null;

	},

	CreateClipsFromMorphTargetSequences: function( morphTargets, fps, noLoop ) {

		var animationToMorphTargets = {};

		// tested with https://regex101.com/ on trick sequences
		// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
		var pattern = /^([\w-]*?)([\d]+)$/;

		// sort morph target names into animation groups based
		// patterns like Walk_001, Walk_002, Run_001, Run_002
		for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {

			var morphTarget = morphTargets[ i ];
			var parts = morphTarget.name.match( pattern );

			if ( parts && parts.length > 1 ) {

				var name = parts[ 1 ];

				var animationMorphTargets = animationToMorphTargets[ name ];
				if ( ! animationMorphTargets ) {

					animationToMorphTargets[ name ] = animationMorphTargets = [];

				}

				animationMorphTargets.push( morphTarget );

			}

		}

		var clips = [];

		for ( var name in animationToMorphTargets ) {

			clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );

		}

		return clips;

	},

	// parse the animation.hierarchy format
	parseAnimation: function( animation, bones ) {

		if ( ! animation ) {

			console.error( "  no animation in JSONLoader data" );
			return null;

		}

		var addNonemptyTrack = function(
				trackType, trackName, animationKeys, propertyName, destTracks ) {

			// only return track if there are actually keys.
			if ( animationKeys.length !== 0 ) {

				var times = [];
				var values = [];

				AnimationUtils.flattenJSON(
						animationKeys, times, values, propertyName );

				// empty keys are filtered out, so check again
				if ( times.length !== 0 ) {

					destTracks.push( new trackType( trackName, times, values ) );

				}

			}

		};

		var tracks = [];

		var clipName = animation.name || 'default';
		// automatic length determination in AnimationClip.
		var duration = animation.length || -1;
		var fps = animation.fps || 30;

		var hierarchyTracks = animation.hierarchy || [];

		for ( var h = 0; h < hierarchyTracks.length; h ++ ) {

			var animationKeys = hierarchyTracks[ h ].keys;

			// skip empty tracks
			if ( ! animationKeys || animationKeys.length === 0 ) continue;

			// process morph targets in a way exactly compatible
			// with AnimationHandler.init( animation )
			if ( animationKeys[0].morphTargets ) {

				// figure out all morph targets used in this track
				var morphTargetNames = {};
				for ( var k = 0; k < animationKeys.length; k ++ ) {

					if ( animationKeys[k].morphTargets ) {

						for ( var m = 0; m < animationKeys[k].morphTargets.length; m ++ ) {

							morphTargetNames[ animationKeys[k].morphTargets[m] ] = -1;
						}

					}

				}

				// create a track for each morph target with all zero
				// morphTargetInfluences except for the keys in which
				// the morphTarget is named.
				for ( var morphTargetName in morphTargetNames ) {

					var times = [];
					var values = [];

					for ( var m = 0; m !== animationKeys[k].morphTargets.length; ++ m ) {

						var animationKey = animationKeys[k];

						times.push( animationKey.time );
						values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );

					}

					tracks.push( new NumberKeyframeTrack('.morphTargetInfluence[' + morphTargetName + ']', times, values ) );

				}

				duration = morphTargetNames.length * ( fps || 1.0 );

			} else {
				// ...assume skeletal animation

				var boneName = '.bones[' + bones[ h ].name + ']';

				addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );

				addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );

				addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );

			}

		}

		if ( tracks.length === 0 ) {

			return null;

		}

		var clip = new AnimationClip( clipName, duration, tracks );

		return clip;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function MaterialLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this.textures = {};

}

Object.assign( MaterialLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	setTextures: function ( value ) {

		this.textures = value;

	},

	parse: function ( json ) {

		var textures = this.textures;

		function getTexture( name ) {

			if ( textures[ name ] === undefined ) {

				console.warn( 'THREE.MaterialLoader: Undefined texture', name );

			}

			return textures[ name ];

		}

		var material = new Materials[ json.type ]();

		if ( json.uuid !== undefined ) material.uuid = json.uuid;
		if ( json.name !== undefined ) material.name = json.name;
		if ( json.color !== undefined ) material.color.setHex( json.color );
		if ( json.roughness !== undefined ) material.roughness = json.roughness;
		if ( json.metalness !== undefined ) material.metalness = json.metalness;
		if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
		if ( json.specular !== undefined ) material.specular.setHex( json.specular );
		if ( json.shininess !== undefined ) material.shininess = json.shininess;
		if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
		if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
		if ( json.uniforms !== undefined ) material.uniforms = json.uniforms;
		if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
		if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
		if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
		if ( json.fog !== undefined ) material.fog = json.fog;
		if ( json.shading !== undefined ) material.shading = json.shading;
		if ( json.blending !== undefined ) material.blending = json.blending;
		if ( json.side !== undefined ) material.side = json.side;
		if ( json.opacity !== undefined ) material.opacity = json.opacity;
		if ( json.transparent !== undefined ) material.transparent = json.transparent;
		if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
		if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
		if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
		if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
		if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
		if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
		if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
		if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
		if ( json.skinning !== undefined ) material.skinning = json.skinning;
		if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;

		// for PointsMaterial

		if ( json.size !== undefined ) material.size = json.size;
		if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;

		// maps

		if ( json.map !== undefined ) material.map = getTexture( json.map );

		if ( json.alphaMap !== undefined ) {

			material.alphaMap = getTexture( json.alphaMap );
			material.transparent = true;

		}

		if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
		if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;

		if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
		if ( json.normalScale !== undefined ) {

			var normalScale = json.normalScale;

			if ( Array.isArray( normalScale ) === false ) {

				// Blender exporter used to export a scalar. See #7459

				normalScale = [ normalScale, normalScale ];

			}

			material.normalScale = new Vector2().fromArray( normalScale );

		}

		if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
		if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
		if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;

		if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
		if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );

		if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
		if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;

		if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );

		if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );

		if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;

		if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
		if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;

		if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
		if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;

		if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );

		// MultiMaterial

		if ( json.materials !== undefined ) {

			for ( var i = 0, l = json.materials.length; i < l; i ++ ) {

				material.materials.push( this.parse( json.materials[ i ] ) );

			}

		}

		return material;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BufferGeometryLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( BufferGeometryLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {

			onLoad( scope.parse( JSON.parse( text ) ) );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		var geometry = new BufferGeometry();

		var index = json.data.index;

		var TYPED_ARRAYS = {
			'Int8Array': Int8Array,
			'Uint8Array': Uint8Array,
			'Uint8ClampedArray': Uint8ClampedArray,
			'Int16Array': Int16Array,
			'Uint16Array': Uint16Array,
			'Int32Array': Int32Array,
			'Uint32Array': Uint32Array,
			'Float32Array': Float32Array,
			'Float64Array': Float64Array
		};

		if ( index !== undefined ) {

			var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
			geometry.setIndex( new BufferAttribute( typedArray, 1 ) );

		}

		var attributes = json.data.attributes;

		for ( var key in attributes ) {

			var attribute = attributes[ key ];
			var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );

			geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );

		}

		var groups = json.data.groups || json.data.drawcalls || json.data.offsets;

		if ( groups !== undefined ) {

			for ( var i = 0, n = groups.length; i !== n; ++ i ) {

				var group = groups[ i ];

				geometry.addGroup( group.start, group.count, group.materialIndex );

			}

		}

		var boundingSphere = json.data.boundingSphere;

		if ( boundingSphere !== undefined ) {

			var center = new Vector3();

			if ( boundingSphere.center !== undefined ) {

				center.fromArray( boundingSphere.center );

			}

			geometry.boundingSphere = new Sphere( center, boundingSphere.radius );

		}

		return geometry;

	}

} );

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Loader() {

	this.onLoadStart = function () {};
	this.onLoadProgress = function () {};
	this.onLoadComplete = function () {};

}

Loader.prototype = {

	constructor: Loader,

	crossOrigin: undefined,

	extractUrlBase: function ( url ) {

		var parts = url.split( '/' );

		if ( parts.length === 1 ) return './';

		parts.pop();

		return parts.join( '/' ) + '/';

	},

	initMaterials: function ( materials, texturePath, crossOrigin ) {

		var array = [];

		for ( var i = 0; i < materials.length; ++ i ) {

			array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );

		}

		return array;

	},

	createMaterial: ( function () {

		var color, textureLoader, materialLoader;

		return function createMaterial( m, texturePath, crossOrigin ) {

			if ( color === undefined ) color = new Color();
			if ( textureLoader === undefined ) textureLoader = new TextureLoader();
			if ( materialLoader === undefined ) materialLoader = new MaterialLoader();

			// convert from old material format

			var textures = {};

			function loadTexture( path, repeat, offset, wrap, anisotropy ) {

				var fullPath = texturePath + path;
				var loader = Loader.Handlers.get( fullPath );

				var texture;

				if ( loader !== null ) {

					texture = loader.load( fullPath );

				} else {

					textureLoader.setCrossOrigin( crossOrigin );
					texture = textureLoader.load( fullPath );

				}

				if ( repeat !== undefined ) {

					texture.repeat.fromArray( repeat );

					if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
					if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;

				}

				if ( offset !== undefined ) {

					texture.offset.fromArray( offset );

				}

				if ( wrap !== undefined ) {

					if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
					if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;

					if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
					if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;

				}

				if ( anisotropy !== undefined ) {

					texture.anisotropy = anisotropy;

				}

				var uuid = _Math.generateUUID();

				textures[ uuid ] = texture;

				return uuid;

			}

			//

			var json = {
				uuid: _Math.generateUUID(),
				type: 'MeshLambertMaterial'
			};

			for ( var name in m ) {

				var value = m[ name ];

				switch ( name ) {
					case 'DbgColor':
					case 'DbgIndex':
					case 'opticalDensity':
					case 'illumination':
						break;
					case 'DbgName':
						json.name = value;
						break;
					case 'blending':
						json.blending = BlendingMode[ value ];
						break;
					case 'colorAmbient':
					case 'mapAmbient':
						console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
						break;
					case 'colorDiffuse':
						json.color = color.fromArray( value ).getHex();
						break;
					case 'colorSpecular':
						json.specular = color.fromArray( value ).getHex();
						break;
					case 'colorEmissive':
						json.emissive = color.fromArray( value ).getHex();
						break;
					case 'specularCoef':
						json.shininess = value;
						break;
					case 'shading':
						if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
						if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
						if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
						break;
					case 'mapDiffuse':
						json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
						break;
					case 'mapDiffuseRepeat':
					case 'mapDiffuseOffset':
					case 'mapDiffuseWrap':
					case 'mapDiffuseAnisotropy':
						break;
					case 'mapEmissive':
						json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
						break;
					case 'mapEmissiveRepeat':
					case 'mapEmissiveOffset':
					case 'mapEmissiveWrap':
					case 'mapEmissiveAnisotropy':
						break;
					case 'mapLight':
						json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
						break;
					case 'mapLightRepeat':
					case 'mapLightOffset':
					case 'mapLightWrap':
					case 'mapLightAnisotropy':
						break;
					case 'mapAO':
						json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
						break;
					case 'mapAORepeat':
					case 'mapAOOffset':
					case 'mapAOWrap':
					case 'mapAOAnisotropy':
						break;
					case 'mapBump':
						json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
						break;
					case 'mapBumpScale':
						json.bumpScale = value;
						break;
					case 'mapBumpRepeat':
					case 'mapBumpOffset':
					case 'mapBumpWrap':
					case 'mapBumpAnisotropy':
						break;
					case 'mapNormal':
						json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
						break;
					case 'mapNormalFactor':
						json.normalScale = [ value, value ];
						break;
					case 'mapNormalRepeat':
					case 'mapNormalOffset':
					case 'mapNormalWrap':
					case 'mapNormalAnisotropy':
						break;
					case 'mapSpecular':
						json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
						break;
					case 'mapSpecularRepeat':
					case 'mapSpecularOffset':
					case 'mapSpecularWrap':
					case 'mapSpecularAnisotropy':
						break;
					case 'mapMetalness':
						json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
						break;
					case 'mapMetalnessRepeat':
					case 'mapMetalnessOffset':
					case 'mapMetalnessWrap':
					case 'mapMetalnessAnisotropy':
						break;
					case 'mapRoughness':
						json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
						break;
					case 'mapRoughnessRepeat':
					case 'mapRoughnessOffset':
					case 'mapRoughnessWrap':
					case 'mapRoughnessAnisotropy':
						break;
					case 'mapAlpha':
						json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
						break;
					case 'mapAlphaRepeat':
					case 'mapAlphaOffset':
					case 'mapAlphaWrap':
					case 'mapAlphaAnisotropy':
						break;
					case 'flipSided':
						json.side = BackSide;
						break;
					case 'doubleSided':
						json.side = DoubleSide;
						break;
					case 'transparency':
						console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
						json.opacity = value;
						break;
					case 'depthTest':
					case 'depthWrite':
					case 'colorWrite':
					case 'opacity':
					case 'reflectivity':
					case 'transparent':
					case 'visible':
					case 'wireframe':
						json[ name ] = value;
						break;
					case 'vertexColors':
						if ( value === true ) json.vertexColors = VertexColors;
						if ( value === 'face' ) json.vertexColors = FaceColors;
						break;
					default:
						console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
						break;
				}

			}

			if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
			if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;

			if ( json.opacity < 1 ) json.transparent = true;

			materialLoader.setTextures( textures );

			return materialLoader.parse( json );

		};

	} )()

};

Loader.Handlers = {

	handlers: [],

	add: function ( regex, loader ) {

		this.handlers.push( regex, loader );

	},

	get: function ( file ) {

		var handlers = this.handlers;

		for ( var i = 0, l = handlers.length; i < l; i += 2 ) {

			var regex = handlers[ i ];
			var loader  = handlers[ i + 1 ];

			if ( regex.test( file ) ) {

				return loader;

			}

		}

		return null;

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function JSONLoader( manager ) {

	if ( typeof manager === 'boolean' ) {

		console.warn( 'THREE.JSONLoader: showStatus parameter has been removed from constructor.' );
		manager = undefined;

	}

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

	this.withCredentials = false;

}

Object.assign( JSONLoader.prototype, {

	load: function( url, onLoad, onProgress, onError ) {

		var scope = this;

		var texturePath = this.texturePath && ( typeof this.texturePath === "string" ) ? this.texturePath : Loader.prototype.extractUrlBase( url );

		var loader = new FileLoader( this.manager );
		loader.setWithCredentials( this.withCredentials );
		loader.load( url, function ( text ) {

			var json = JSON.parse( text );
			var metadata = json.metadata;

			if ( metadata !== undefined ) {

				var type = metadata.type;

				if ( type !== undefined ) {

					if ( type.toLowerCase() === 'object' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.ObjectLoader instead.' );
						return;

					}

					if ( type.toLowerCase() === 'scene' ) {

						console.error( 'THREE.JSONLoader: ' + url + ' should be loaded with THREE.SceneLoader instead.' );
						return;

					}

				}

			}

			var object = scope.parse( json, texturePath );
			onLoad( object.geometry, object.materials );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	parse: function ( json, texturePath ) {

		var geometry = new Geometry(),
		scale = ( json.scale !== undefined ) ? 1.0 / json.scale : 1.0;

		parseModel( scale );

		parseSkin();
		parseMorphing( scale );
		parseAnimations();

		geometry.computeFaceNormals();
		geometry.computeBoundingSphere();

		function parseModel( scale ) {

			function isBitSet( value, position ) {

				return value & ( 1 << position );

			}

			var i, j, fi,

			offset, zLength,

		colorIndex, normalIndex, uvIndex, materialIndex,

			type,
			isQuad,
			hasMaterial,
			hasFaceVertexUv,
			hasFaceNormal, hasFaceVertexNormal,
			hasFaceColor, hasFaceVertexColor,

		vertex, face, faceA, faceB, hex, normal,

			uvLayer, uv, u, v,

			faces = json.faces,
			vertices = json.vertices,
			normals = json.normals,
			colors = json.colors,

			nUvLayers = 0;

			if ( json.uvs !== undefined ) {

				// disregard empty arrays

				for ( i = 0; i < json.uvs.length; i ++ ) {

					if ( json.uvs[ i ].length ) nUvLayers ++;

				}

				for ( i = 0; i < nUvLayers; i ++ ) {

					geometry.faceVertexUvs[ i ] = [];

				}

			}

			offset = 0;
			zLength = vertices.length;

			while ( offset < zLength ) {

				vertex = new Vector3();

				vertex.x = vertices[ offset ++ ] * scale;
				vertex.y = vertices[ offset ++ ] * scale;
				vertex.z = vertices[ offset ++ ] * scale;

				geometry.vertices.push( vertex );

			}

			offset = 0;
			zLength = faces.length;

			while ( offset < zLength ) {

				type = faces[ offset ++ ];


				isQuad              = isBitSet( type, 0 );
				hasMaterial         = isBitSet( type, 1 );
				hasFaceVertexUv     = isBitSet( type, 3 );
				hasFaceNormal       = isBitSet( type, 4 );
				hasFaceVertexNormal = isBitSet( type, 5 );
				hasFaceColor	     = isBitSet( type, 6 );
				hasFaceVertexColor  = isBitSet( type, 7 );

				// console.log("type", type, "bits", isQuad, hasMaterial, hasFaceVertexUv, hasFaceNormal, hasFaceVertexNormal, hasFaceColor, hasFaceVertexColor);

				if ( isQuad ) {

					faceA = new Face3();
					faceA.a = faces[ offset ];
					faceA.b = faces[ offset + 1 ];
					faceA.c = faces[ offset + 3 ];

					faceB = new Face3();
					faceB.a = faces[ offset + 1 ];
					faceB.b = faces[ offset + 2 ];
					faceB.c = faces[ offset + 3 ];

					offset += 4;

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						faceA.materialIndex = materialIndex;
						faceB.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];
							geometry.faceVertexUvs[ i ][ fi + 1 ] = [];

							for ( j = 0; j < 4; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new Vector2( u, v );

								if ( j !== 2 ) geometry.faceVertexUvs[ i ][ fi ].push( uv );
								if ( j !== 0 ) geometry.faceVertexUvs[ i ][ fi + 1 ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						faceA.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

						faceB.normal.copy( faceA.normal );

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 4; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);


							if ( i !== 2 ) faceA.vertexNormals.push( normal );
							if ( i !== 0 ) faceB.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						hex = colors[ colorIndex ];

						faceA.color.setHex( hex );
						faceB.color.setHex( hex );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 4; i ++ ) {

							colorIndex = faces[ offset ++ ];
							hex = colors[ colorIndex ];

							if ( i !== 2 ) faceA.vertexColors.push( new Color( hex ) );
							if ( i !== 0 ) faceB.vertexColors.push( new Color( hex ) );

						}

					}

					geometry.faces.push( faceA );
					geometry.faces.push( faceB );

				} else {

					face = new Face3();
					face.a = faces[ offset ++ ];
					face.b = faces[ offset ++ ];
					face.c = faces[ offset ++ ];

					if ( hasMaterial ) {

						materialIndex = faces[ offset ++ ];
						face.materialIndex = materialIndex;

					}

					// to get face <=> uv index correspondence

					fi = geometry.faces.length;

					if ( hasFaceVertexUv ) {

						for ( i = 0; i < nUvLayers; i ++ ) {

							uvLayer = json.uvs[ i ];

							geometry.faceVertexUvs[ i ][ fi ] = [];

							for ( j = 0; j < 3; j ++ ) {

								uvIndex = faces[ offset ++ ];

								u = uvLayer[ uvIndex * 2 ];
								v = uvLayer[ uvIndex * 2 + 1 ];

								uv = new Vector2( u, v );

								geometry.faceVertexUvs[ i ][ fi ].push( uv );

							}

						}

					}

					if ( hasFaceNormal ) {

						normalIndex = faces[ offset ++ ] * 3;

						face.normal.set(
							normals[ normalIndex ++ ],
							normals[ normalIndex ++ ],
							normals[ normalIndex ]
						);

					}

					if ( hasFaceVertexNormal ) {

						for ( i = 0; i < 3; i ++ ) {

							normalIndex = faces[ offset ++ ] * 3;

							normal = new Vector3(
								normals[ normalIndex ++ ],
								normals[ normalIndex ++ ],
								normals[ normalIndex ]
							);

							face.vertexNormals.push( normal );

						}

					}


					if ( hasFaceColor ) {

						colorIndex = faces[ offset ++ ];
						face.color.setHex( colors[ colorIndex ] );

					}


					if ( hasFaceVertexColor ) {

						for ( i = 0; i < 3; i ++ ) {

							colorIndex = faces[ offset ++ ];
							face.vertexColors.push( new Color( colors[ colorIndex ] ) );

						}

					}

					geometry.faces.push( face );

				}

			}

		}

		function parseSkin() {

			var influencesPerVertex = ( json.influencesPerVertex !== undefined ) ? json.influencesPerVertex : 2;

			if ( json.skinWeights ) {

				for ( var i = 0, l = json.skinWeights.length; i < l; i += influencesPerVertex ) {

					var x =                               json.skinWeights[ i ];
					var y = ( influencesPerVertex > 1 ) ? json.skinWeights[ i + 1 ] : 0;
					var z = ( influencesPerVertex > 2 ) ? json.skinWeights[ i + 2 ] : 0;
					var w = ( influencesPerVertex > 3 ) ? json.skinWeights[ i + 3 ] : 0;

					geometry.skinWeights.push( new Vector4( x, y, z, w ) );

				}

			}

			if ( json.skinIndices ) {

				for ( var i = 0, l = json.skinIndices.length; i < l; i += influencesPerVertex ) {

					var a =                               json.skinIndices[ i ];
					var b = ( influencesPerVertex > 1 ) ? json.skinIndices[ i + 1 ] : 0;
					var c = ( influencesPerVertex > 2 ) ? json.skinIndices[ i + 2 ] : 0;
					var d = ( influencesPerVertex > 3 ) ? json.skinIndices[ i + 3 ] : 0;

					geometry.skinIndices.push( new Vector4( a, b, c, d ) );

				}

			}

			geometry.bones = json.bones;

			if ( geometry.bones && geometry.bones.length > 0 && ( geometry.skinWeights.length !== geometry.skinIndices.length || geometry.skinIndices.length !== geometry.vertices.length ) ) {

				console.warn( 'When skinning, number of vertices (' + geometry.vertices.length + '), skinIndices (' +
					geometry.skinIndices.length + '), and skinWeights (' + geometry.skinWeights.length + ') should match.' );

			}

		}

		function parseMorphing( scale ) {

			if ( json.morphTargets !== undefined ) {

				for ( var i = 0, l = json.morphTargets.length; i < l; i ++ ) {

					geometry.morphTargets[ i ] = {};
					geometry.morphTargets[ i ].name = json.morphTargets[ i ].name;
					geometry.morphTargets[ i ].vertices = [];

					var dstVertices = geometry.morphTargets[ i ].vertices;
					var srcVertices = json.morphTargets[ i ].vertices;

					for ( var v = 0, vl = srcVertices.length; v < vl; v += 3 ) {

						var vertex = new Vector3();
						vertex.x = srcVertices[ v ] * scale;
						vertex.y = srcVertices[ v + 1 ] * scale;
						vertex.z = srcVertices[ v + 2 ] * scale;

						dstVertices.push( vertex );

					}

				}

			}

			if ( json.morphColors !== undefined && json.morphColors.length > 0 ) {

				console.warn( 'THREE.JSONLoader: "morphColors" no longer supported. Using them as face colors.' );

				var faces = geometry.faces;
				var morphColors = json.morphColors[ 0 ].colors;

				for ( var i = 0, l = faces.length; i < l; i ++ ) {

					faces[ i ].color.fromArray( morphColors, i * 3 );

				}

			}

		}

		function parseAnimations() {

			var outputAnimations = [];

			// parse old style Bone/Hierarchy animations
			var animations = [];

			if ( json.animation !== undefined ) {

				animations.push( json.animation );

			}

			if ( json.animations !== undefined ) {

				if ( json.animations.length ) {

					animations = animations.concat( json.animations );

				} else {

					animations.push( json.animations );

				}

			}

			for ( var i = 0; i < animations.length; i ++ ) {

				var clip = AnimationClip.parseAnimation( animations[ i ], geometry.bones );
				if ( clip ) outputAnimations.push( clip );

			}

			// parse implicit morph animations
			if ( geometry.morphTargets ) {

				// TODO: Figure out what an appropraite FPS is for morph target animations -- defaulting to 10, but really it is completely arbitrary.
				var morphAnimationClips = AnimationClip.CreateClipsFromMorphTargetSequences( geometry.morphTargets, 10 );
				outputAnimations = outputAnimations.concat( morphAnimationClips );

			}

			if ( outputAnimations.length > 0 ) geometry.animations = outputAnimations;

		}

		if ( json.materials === undefined || json.materials.length === 0 ) {

			return { geometry: geometry };

		} else {

			var materials = Loader.prototype.initMaterials( json.materials, texturePath, this.crossOrigin );

			return { geometry: geometry, materials: materials };

		}

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function ObjectLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	this.texturePath = '';

}

Object.assign( ObjectLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		if ( this.texturePath === '' ) {

			this.texturePath = url.substring( 0, url.lastIndexOf( '/' ) + 1 );

		}

		var scope = this;

		var loader = new FileLoader( scope.manager );
		loader.load( url, function ( text ) {

			var json = null;

			try {

				json = JSON.parse( text );

			} catch ( error ) {

				console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );
				return;

			}

			var metadata = json.metadata;

			if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {

				console.error( 'THREE.ObjectLoader: Can\'t load ' + url + '. Use THREE.JSONLoader instead.' );
				return;

			}

			scope.parse( json, onLoad );

		}, onProgress, onError );

	},

	setTexturePath: function ( value ) {

		this.texturePath = value;

	},

	setCrossOrigin: function ( value ) {

		this.crossOrigin = value;

	},

	parse: function ( json, onLoad ) {

		var geometries = this.parseGeometries( json.geometries );

		var images = this.parseImages( json.images, function () {

			if ( onLoad !== undefined ) onLoad( object );

		} );

		var textures = this.parseTextures( json.textures, images );
		var materials = this.parseMaterials( json.materials, textures );

		var object = this.parseObject( json.object, geometries, materials );

		if ( json.animations ) {

			object.animations = this.parseAnimations( json.animations );

		}

		if ( json.images === undefined || json.images.length === 0 ) {

			if ( onLoad !== undefined ) onLoad( object );

		}

		return object;

	},

	parseGeometries: function ( json ) {

		var geometries = {};

		if ( json !== undefined ) {

			var geometryLoader = new JSONLoader();
			var bufferGeometryLoader = new BufferGeometryLoader();

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var geometry;
				var data = json[ i ];

				switch ( data.type ) {

					case 'PlaneGeometry':
					case 'PlaneBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.widthSegments,
							data.heightSegments
						);

						break;

					case 'BoxGeometry':
					case 'BoxBufferGeometry':
					case 'CubeGeometry': // backwards compatible

						geometry = new Geometries[ data.type ](
							data.width,
							data.height,
							data.depth,
							data.widthSegments,
							data.heightSegments,
							data.depthSegments
						);

						break;

					case 'CircleGeometry':
					case 'CircleBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.segments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'CylinderGeometry':
					case 'CylinderBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radiusTop,
							data.radiusBottom,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'ConeGeometry':
					case 'ConeBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.height,
							data.radialSegments,
							data.heightSegments,
							data.openEnded,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'SphereGeometry':
					case 'SphereBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.widthSegments,
							data.heightSegments,
							data.phiStart,
							data.phiLength,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'DodecahedronGeometry':
					case 'IcosahedronGeometry':
					case 'OctahedronGeometry':
					case 'TetrahedronGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.detail
						);

						break;

					case 'RingGeometry':
					case 'RingBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.innerRadius,
							data.outerRadius,
							data.thetaSegments,
							data.phiSegments,
							data.thetaStart,
							data.thetaLength
						);

						break;

					case 'TorusGeometry':
					case 'TorusBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.radialSegments,
							data.tubularSegments,
							data.arc
						);

						break;

					case 'TorusKnotGeometry':
					case 'TorusKnotBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.radius,
							data.tube,
							data.tubularSegments,
							data.radialSegments,
							data.p,
							data.q
						);

						break;

					case 'LatheGeometry':
					case 'LatheBufferGeometry':

						geometry = new Geometries[ data.type ](
							data.points,
							data.segments,
							data.phiStart,
							data.phiLength
						);

						break;

					case 'BufferGeometry':

						geometry = bufferGeometryLoader.parse( data );

						break;

					case 'Geometry':

						geometry = geometryLoader.parse( data.data, this.texturePath ).geometry;

						break;

					default:

						console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );

						continue;

				}

				geometry.uuid = data.uuid;

				if ( data.name !== undefined ) geometry.name = data.name;

				geometries[ data.uuid ] = geometry;

			}

		}

		return geometries;

	},

	parseMaterials: function ( json, textures ) {

		var materials = {};

		if ( json !== undefined ) {

			var loader = new MaterialLoader();
			loader.setTextures( textures );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var material = loader.parse( json[ i ] );
				materials[ material.uuid ] = material;

			}

		}

		return materials;

	},

	parseAnimations: function ( json ) {

		var animations = [];

		for ( var i = 0; i < json.length; i ++ ) {

			var clip = AnimationClip.parse( json[ i ] );

			animations.push( clip );

		}

		return animations;

	},

	parseImages: function ( json, onLoad ) {

		var scope = this;
		var images = {};

		function loadImage( url ) {

			scope.manager.itemStart( url );

			return loader.load( url, function () {

				scope.manager.itemEnd( url );

			}, undefined, function () {

				scope.manager.itemError( url );

			} );

		}

		if ( json !== undefined && json.length > 0 ) {

			var manager = new LoadingManager( onLoad );

			var loader = new ImageLoader( manager );
			loader.setCrossOrigin( this.crossOrigin );

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var image = json[ i ];
				var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.texturePath + image.url;

				images[ image.uuid ] = loadImage( path );

			}

		}

		return images;

	},

	parseTextures: function ( json, images ) {

		function parseConstant( value, type ) {

			if ( typeof( value ) === 'number' ) return value;

			console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );

			return type[ value ];

		}

		var textures = {};

		if ( json !== undefined ) {

			for ( var i = 0, l = json.length; i < l; i ++ ) {

				var data = json[ i ];

				if ( data.image === undefined ) {

					console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );

				}

				if ( images[ data.image ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined image', data.image );

				}

				var texture = new Texture( images[ data.image ] );
				texture.needsUpdate = true;

				texture.uuid = data.uuid;

				if ( data.name !== undefined ) texture.name = data.name;

				if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TextureMapping );

				if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
				if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
				if ( data.wrap !== undefined ) {

					texture.wrapS = parseConstant( data.wrap[ 0 ], TextureWrapping );
					texture.wrapT = parseConstant( data.wrap[ 1 ], TextureWrapping );

				}

				if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TextureFilter );
				if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TextureFilter );
				if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;

				if ( data.flipY !== undefined ) texture.flipY = data.flipY;

				textures[ data.uuid ] = texture;

			}

		}

		return textures;

	},

	parseObject: function () {

		var matrix = new Matrix4();

		return function parseObject( data, geometries, materials ) {

			var object;

			function getGeometry( name ) {

				if ( geometries[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );

				}

				return geometries[ name ];

			}

			function getMaterial( name ) {

				if ( name === undefined ) return undefined;

				if ( materials[ name ] === undefined ) {

					console.warn( 'THREE.ObjectLoader: Undefined material', name );

				}

				return materials[ name ];

			}

			switch ( data.type ) {

				case 'Scene':

					object = new Scene();

					if ( data.background !== undefined ) {

						if ( Number.isInteger( data.background ) ) {

							object.background = new Color( data.background );

						}

					}

					if ( data.fog !== undefined ) {

						if ( data.fog.type === 'Fog' ) {

							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );

						} else if ( data.fog.type === 'FogExp2' ) {

							object.fog = new FogExp2( data.fog.color, data.fog.density );

						}

					}

					break;

				case 'PerspectiveCamera':

					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );

					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );

					break;

				case 'OrthographicCamera':

					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );

					break;

				case 'AmbientLight':

					object = new AmbientLight( data.color, data.intensity );

					break;

				case 'DirectionalLight':

					object = new DirectionalLight( data.color, data.intensity );

					break;

				case 'PointLight':

					object = new PointLight( data.color, data.intensity, data.distance, data.decay );

					break;

				case 'SpotLight':

					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );

					break;

				case 'HemisphereLight':

					object = new HemisphereLight( data.color, data.groundColor, data.intensity );

					break;

				case 'Mesh':

					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );

					if ( geometry.bones && geometry.bones.length > 0 ) {

						object = new SkinnedMesh( geometry, material );

					} else {

						object = new Mesh( geometry, material );

					}

					break;

				case 'LOD':

					object = new LOD();

					break;

				case 'Line':

					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );

					break;

				case 'LineSegments':

					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'PointCloud':
				case 'Points':

					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );

					break;

				case 'Sprite':

					object = new Sprite( getMaterial( data.material ) );

					break;

				case 'Group':

					object = new Group();

					break;

				case 'SkinnedMesh':

					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh type. Instantiates Object3D instead.' );

				default:

					object = new Object3D();

			}

			object.uuid = data.uuid;

			if ( data.name !== undefined ) object.name = data.name;
			if ( data.matrix !== undefined ) {

				matrix.fromArray( data.matrix );
				matrix.decompose( object.position, object.quaternion, object.scale );

			} else {

				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );

			}

			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;

			if ( data.shadow ) {

				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );

			}

			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.userData !== undefined ) object.userData = data.userData;

			if ( data.children !== undefined ) {

				for ( var child in data.children ) {

					object.add( this.parseObject( data.children[ child ], geometries, materials ) );

				}

			}

			if ( data.type === 'LOD' ) {

				var levels = data.levels;

				for ( var l = 0; l < levels.length; l ++ ) {

					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );

					if ( child !== undefined ) {

						object.addLevel( child, level.distance );

					}

				}

			}

			return object;

		};

	}()

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Extensible curve object
 *
 * Some common of Curve methods
 * .getPoint(t), getTangent(t)
 * .getPointAt(u), getTangentAt(u)
 * .getPoints(), .getSpacedPoints()
 * .getLength()
 * .updateArcLengths()
 *
 * This following classes subclasses THREE.Curve:
 *
 * -- 2d classes --
 * THREE.LineCurve
 * THREE.QuadraticBezierCurve
 * THREE.CubicBezierCurve
 * THREE.SplineCurve
 * THREE.ArcCurve
 * THREE.EllipseCurve
 *
 * -- 3d classes --
 * THREE.LineCurve3
 * THREE.QuadraticBezierCurve3
 * THREE.CubicBezierCurve3
 * THREE.SplineCurve3
 *
 * A series of curves can be represented as a THREE.CurvePath
 *
 **/

/**************************************************************
 *	Abstract Curve base class
 **************************************************************/

function Curve() {}

Curve.prototype = {

	constructor: Curve,

	// Virtual base class method to overwrite and implement in subclasses
	//	- t [0 .. 1]

	getPoint: function ( t ) {

		console.warn( "THREE.Curve: Warning, getPoint() not implemented!" );
		return null;

	},

	// Get point at relative position in curve according to arc length
	// - u [0 .. 1]

	getPointAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getPoint( t );

	},

	// Get sequence of points using getPoint( t )

	getPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var points = [];

		for ( var d = 0; d <= divisions; d ++ ) {

			points.push( this.getPoint( d / divisions ) );

		}

		return points;

	},

	// Get sequence of points using getPointAt( u )

	getSpacedPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 5;

		var points = [];

		for ( var d = 0; d <= divisions; d ++ ) {

			points.push( this.getPointAt( d / divisions ) );

		}

		return points;

	},

	// Get total curve arc length

	getLength: function () {

		var lengths = this.getLengths();
		return lengths[ lengths.length - 1 ];

	},

	// Get list of cumulative segment lengths

	getLengths: function ( divisions ) {

		if ( ! divisions ) divisions = ( this.__arcLengthDivisions ) ? ( this.__arcLengthDivisions ) : 200;

		if ( this.cacheArcLengths
			&& ( this.cacheArcLengths.length === divisions + 1 )
			&& ! this.needsUpdate ) {

			//console.log( "cached", this.cacheArcLengths );
			return this.cacheArcLengths;

		}

		this.needsUpdate = false;

		var cache = [];
		var current, last = this.getPoint( 0 );
		var p, sum = 0;

		cache.push( 0 );

		for ( p = 1; p <= divisions; p ++ ) {

			current = this.getPoint ( p / divisions );
			sum += current.distanceTo( last );
			cache.push( sum );
			last = current;

		}

		this.cacheArcLengths = cache;

		return cache; // { sums: cache, sum:sum }; Sum is in the last element.

	},

	updateArcLengths: function() {

		this.needsUpdate = true;
		this.getLengths();

	},

	// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant

	getUtoTmapping: function ( u, distance ) {

		var arcLengths = this.getLengths();

		var i = 0, il = arcLengths.length;

		var targetArcLength; // The targeted u distance value to get

		if ( distance ) {

			targetArcLength = distance;

		} else {

			targetArcLength = u * arcLengths[ il - 1 ];

		}

		//var time = Date.now();

		// binary search for the index with largest value smaller than target u distance

		var low = 0, high = il - 1, comparison;

		while ( low <= high ) {

			i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats

			comparison = arcLengths[ i ] - targetArcLength;

			if ( comparison < 0 ) {

				low = i + 1;

			} else if ( comparison > 0 ) {

				high = i - 1;

			} else {

				high = i;
				break;

				// DONE

			}

		}

		i = high;

		//console.log('b' , i, low, high, Date.now()- time);

		if ( arcLengths[ i ] === targetArcLength ) {

			var t = i / ( il - 1 );
			return t;

		}

		// we could get finer grain at lengths, or use simple interpolation between two points

		var lengthBefore = arcLengths[ i ];
		var lengthAfter = arcLengths[ i + 1 ];

		var segmentLength = lengthAfter - lengthBefore;

		// determine where we are between the 'before' and 'after' points

		var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;

		// add that fractional amount to t

		var t = ( i + segmentFraction ) / ( il - 1 );

		return t;

	},

	// Returns a unit vector tangent at t
	// In case any sub curve does not implement its tangent derivation,
	// 2 points a small delta apart will be used to find its gradient
	// which seems to give a reasonable approximation

	getTangent: function( t ) {

		var delta = 0.0001;
		var t1 = t - delta;
		var t2 = t + delta;

		// Capping in case of danger

		if ( t1 < 0 ) t1 = 0;
		if ( t2 > 1 ) t2 = 1;

		var pt1 = this.getPoint( t1 );
		var pt2 = this.getPoint( t2 );

		var vec = pt2.clone().sub( pt1 );
		return vec.normalize();

	},

	getTangentAt: function ( u ) {

		var t = this.getUtoTmapping( u );
		return this.getTangent( t );

	},

	computeFrenetFrames: function ( segments, closed ) {

		// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf

		var normal = new Vector3();

		var tangents = [];
		var normals = [];
		var binormals = [];

		var vec = new Vector3();
		var mat = new Matrix4();

		var i, u, theta;

		// compute the tangent vectors for each segment on the curve

		for ( i = 0; i <= segments; i ++ ) {

			u = i / segments;

			tangents[ i ] = this.getTangentAt( u );
			tangents[ i ].normalize();

		}

		// select an initial normal vector perpendicular to the first tangent vector,
		// and in the direction of the minimum tangent xyz component

		normals[ 0 ] = new Vector3();
		binormals[ 0 ] = new Vector3();
		var min = Number.MAX_VALUE;
		var tx = Math.abs( tangents[ 0 ].x );
		var ty = Math.abs( tangents[ 0 ].y );
		var tz = Math.abs( tangents[ 0 ].z );

		if ( tx <= min ) {

			min = tx;
			normal.set( 1, 0, 0 );

		}

		if ( ty <= min ) {

			min = ty;
			normal.set( 0, 1, 0 );

		}

		if ( tz <= min ) {

			normal.set( 0, 0, 1 );

		}

		vec.crossVectors( tangents[ 0 ], normal ).normalize();

		normals[ 0 ].crossVectors( tangents[ 0 ], vec );
		binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );


		// compute the slowly-varying normal and binormal vectors for each segment on the curve

		for ( i = 1; i <= segments; i ++ ) {

			normals[ i ] = normals[ i - 1 ].clone();

			binormals[ i ] = binormals[ i - 1 ].clone();

			vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );

			if ( vec.length() > Number.EPSILON ) {

				vec.normalize();

				theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors

				normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );

			}

			binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

		}

		// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same

		if ( closed === true ) {

			theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
			theta /= segments;

			if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {

				theta = - theta;

			}

			for ( i = 1; i <= segments; i ++ ) {

				// twist a little...
				normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );

			}

		}

		return {
			tangents: tangents,
			normals: normals,
			binormals: binormals
		};

	}

};

// TODO: Transformation for Curves?

/**************************************************************
 *	3D Curves
 **************************************************************/

// A Factory method for creating new curve subclasses

Curve.create = function ( constructor, getPointFunc ) {

	constructor.prototype = Object.create( Curve.prototype );
	constructor.prototype.constructor = constructor;
	constructor.prototype.getPoint = getPointFunc;

	return constructor;

};

/**************************************************************
 *	Line
 **************************************************************/

function LineCurve( v1, v2 ) {

	this.v1 = v1;
	this.v2 = v2;

}

LineCurve.prototype = Object.create( Curve.prototype );
LineCurve.prototype.constructor = LineCurve;

LineCurve.prototype.isLineCurve = true;

LineCurve.prototype.getPoint = function ( t ) {

	if ( t === 1 ) {

		return this.v2.clone();

	}

	var point = this.v2.clone().sub( this.v1 );
	point.multiplyScalar( t ).add( this.v1 );

	return point;

};

// Line curve is linear, so we can overwrite default getPointAt

LineCurve.prototype.getPointAt = function ( u ) {

	return this.getPoint( u );

};

LineCurve.prototype.getTangent = function( t ) {

	var tangent = this.v2.clone().sub( this.v1 );

	return tangent.normalize();

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 *
 **/

/**************************************************************
 *	Curved Path - a curve path is simply a array of connected
 *  curves, but retains the api of a curve
 **************************************************************/

function CurvePath() {

	this.curves = [];

	this.autoClose = false; // Automatically closes the path

}

CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {

	constructor: CurvePath,

	add: function ( curve ) {

		this.curves.push( curve );

	},

	closePath: function () {

		// Add a line curve if start and end of lines are not connected
		var startPoint = this.curves[ 0 ].getPoint( 0 );
		var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );

		if ( ! startPoint.equals( endPoint ) ) {

			this.curves.push( new LineCurve( endPoint, startPoint ) );

		}

	},

	// To get accurate point with reference to
	// entire path distance at time t,
	// following has to be done:

	// 1. Length of each sub path have to be known
	// 2. Locate and identify type of curve
	// 3. Get t for the curve
	// 4. Return curve.getPointAt(t')

	getPoint: function ( t ) {

		var d = t * this.getLength();
		var curveLengths = this.getCurveLengths();
		var i = 0;

		// To think about boundaries points.

		while ( i < curveLengths.length ) {

			if ( curveLengths[ i ] >= d ) {

				var diff = curveLengths[ i ] - d;
				var curve = this.curves[ i ];

				var segmentLength = curve.getLength();
				var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;

				return curve.getPointAt( u );

			}

			i ++;

		}

		return null;

		// loop where sum != 0, sum > d , sum+1 <d

	},

	// We cannot use the default THREE.Curve getPoint() with getLength() because in
	// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
	// getPoint() depends on getLength

	getLength: function () {

		var lens = this.getCurveLengths();
		return lens[ lens.length - 1 ];

	},

	// cacheLengths must be recalculated.
	updateArcLengths: function () {

		this.needsUpdate = true;
		this.cacheLengths = null;
		this.getLengths();

	},

	// Compute lengths and cache them
	// We cannot overwrite getLengths() because UtoT mapping uses it.

	getCurveLengths: function () {

		// We use cache values if curves and cache array are same length

		if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {

			return this.cacheLengths;

		}

		// Get length of sub-curve
		// Push sums into cached array

		var lengths = [], sums = 0;

		for ( var i = 0, l = this.curves.length; i < l; i ++ ) {

			sums += this.curves[ i ].getLength();
			lengths.push( sums );

		}

		this.cacheLengths = lengths;

		return lengths;

	},

	getSpacedPoints: function ( divisions ) {

		if ( ! divisions ) divisions = 40;

		var points = [];

		for ( var i = 0; i <= divisions; i ++ ) {

			points.push( this.getPoint( i / divisions ) );

		}

		if ( this.autoClose ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	getPoints: function ( divisions ) {

		divisions = divisions || 12;

		var points = [], last;

		for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {

			var curve = curves[ i ];
			var resolution = (curve && curve.isEllipseCurve) ? divisions * 2
				: (curve && curve.isLineCurve) ? 1
				: (curve && curve.isSplineCurve) ? divisions * curve.points.length
				: divisions;

			var pts = curve.getPoints( resolution );

			for ( var j = 0; j < pts.length; j++ ) {

				var point = pts[ j ];

				if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates

				points.push( point );
				last = point;

			}

		}

		if ( this.autoClose && points.length > 1 && !points[ points.length - 1 ].equals( points[ 0 ] ) ) {

			points.push( points[ 0 ] );

		}

		return points;

	},

	/**************************************************************
	 *	Create Geometries Helpers
	 **************************************************************/

	/// Generate geometry from path points (for Line or Points objects)

	createPointsGeometry: function ( divisions ) {

		var pts = this.getPoints( divisions );
		return this.createGeometry( pts );

	},

	// Generate geometry from equidistant sampling along the path

	createSpacedPointsGeometry: function ( divisions ) {

		var pts = this.getSpacedPoints( divisions );
		return this.createGeometry( pts );

	},

	createGeometry: function ( points ) {

		var geometry = new Geometry();

		for ( var i = 0, l = points.length; i < l; i ++ ) {

			var point = points[ i ];
			geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );

		}

		return geometry;

	}

} );

/**************************************************************
 *	Ellipse curve
 **************************************************************/

function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

	this.aX = aX;
	this.aY = aY;

	this.xRadius = xRadius;
	this.yRadius = yRadius;

	this.aStartAngle = aStartAngle;
	this.aEndAngle = aEndAngle;

	this.aClockwise = aClockwise;

	this.aRotation = aRotation || 0;

}

EllipseCurve.prototype = Object.create( Curve.prototype );
EllipseCurve.prototype.constructor = EllipseCurve;

EllipseCurve.prototype.isEllipseCurve = true;

EllipseCurve.prototype.getPoint = function( t ) {

	var twoPi = Math.PI * 2;
	var deltaAngle = this.aEndAngle - this.aStartAngle;
	var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;

	// ensures that deltaAngle is 0 .. 2 PI
	while ( deltaAngle < 0 ) deltaAngle += twoPi;
	while ( deltaAngle > twoPi ) deltaAngle -= twoPi;

	if ( deltaAngle < Number.EPSILON ) {

		if ( samePoints ) {

			deltaAngle = 0;

		} else {

			deltaAngle = twoPi;

		}

	}

	if ( this.aClockwise === true && ! samePoints ) {

		if ( deltaAngle === twoPi ) {

			deltaAngle = - twoPi;

		} else {

			deltaAngle = deltaAngle - twoPi;

		}

	}

	var angle = this.aStartAngle + t * deltaAngle;
	var x = this.aX + this.xRadius * Math.cos( angle );
	var y = this.aY + this.yRadius * Math.sin( angle );

	if ( this.aRotation !== 0 ) {

		var cos = Math.cos( this.aRotation );
		var sin = Math.sin( this.aRotation );

		var tx = x - this.aX;
		var ty = y - this.aY;

		// Rotate the point about the center of the ellipse.
		x = tx * cos - ty * sin + this.aX;
		y = tx * sin + ty * cos + this.aY;

	}

	return new Vector2( x, y );

};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 */

var CurveUtils = {

	tangentQuadraticBezier: function ( t, p0, p1, p2 ) {

		return 2 * ( 1 - t ) * ( p1 - p0 ) + 2 * t * ( p2 - p1 );

	},

	// Puay Bing, thanks for helping with this derivative!

	tangentCubicBezier: function ( t, p0, p1, p2, p3 ) {

		return - 3 * p0 * ( 1 - t ) * ( 1 - t )  +
			3 * p1 * ( 1 - t ) * ( 1 - t ) - 6 * t * p1 * ( 1 - t ) +
			6 * t *  p2 * ( 1 - t ) - 3 * t * t * p2 +
			3 * t * t * p3;

	},

	tangentSpline: function ( t, p0, p1, p2, p3 ) {

		// To check if my formulas are correct

		var h00 = 6 * t * t - 6 * t; 	// derived from 2t^3 − 3t^2 + 1
		var h10 = 3 * t * t - 4 * t + 1; // t^3 − 2t^2 + t
		var h01 = - 6 * t * t + 6 * t; 	// − 2t3 + 3t2
		var h11 = 3 * t * t - 2 * t;	// t3 − t2

		return h00 + h10 + h01 + h11;

	},

	// Catmull-Rom

	interpolate: function( p0, p1, p2, p3, t ) {

		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

};

/**************************************************************
 *	Spline curve
 **************************************************************/

function SplineCurve( points /* array of Vector2 */ ) {

	this.points = ( points === undefined ) ? [] : points;

}

SplineCurve.prototype = Object.create( Curve.prototype );
SplineCurve.prototype.constructor = SplineCurve;

SplineCurve.prototype.isSplineCurve = true;

SplineCurve.prototype.getPoint = function ( t ) {

	var points = this.points;
	var point = ( points.length - 1 ) * t;

	var intPoint = Math.floor( point );
	var weight = point - intPoint;

	var point0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
	var point1 = points[ intPoint ];
	var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
	var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

	var interpolate = CurveUtils.interpolate;

	return new Vector2(
		interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
		interpolate( point0.y, point1.y, point2.y, point3.y, weight )
	);

};

/**************************************************************
 *	Cubic Bezier curve
 **************************************************************/

function CubicBezierCurve( v0, v1, v2, v3 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;
	this.v3 = v3;

}

CubicBezierCurve.prototype = Object.create( Curve.prototype );
CubicBezierCurve.prototype.constructor = CubicBezierCurve;

CubicBezierCurve.prototype.getPoint = function ( t ) {

	var b3 = ShapeUtils.b3;

	return new Vector2(
		b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	);

};

CubicBezierCurve.prototype.getTangent = function( t ) {

	var tangentCubicBezier = CurveUtils.tangentCubicBezier;

	return new Vector2(
		tangentCubicBezier( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
		tangentCubicBezier( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y )
	).normalize();

};

/**************************************************************
 *	Quadratic Bezier curve
 **************************************************************/


function QuadraticBezierCurve( v0, v1, v2 ) {

	this.v0 = v0;
	this.v1 = v1;
	this.v2 = v2;

}

QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;


QuadraticBezierCurve.prototype.getPoint = function ( t ) {

	var b2 = ShapeUtils.b2;

	return new Vector2(
		b2( t, this.v0.x, this.v1.x, this.v2.x ),
		b2( t, this.v0.y, this.v1.y, this.v2.y )
	);

};


QuadraticBezierCurve.prototype.getTangent = function( t ) {

	var tangentQuadraticBezier = CurveUtils.tangentQuadraticBezier;

	return new Vector2(
		tangentQuadraticBezier( t, this.v0.x, this.v1.x, this.v2.x ),
		tangentQuadraticBezier( t, this.v0.y, this.v1.y, this.v2.y )
	).normalize();

};

var PathPrototype = Object.assign( Object.create( CurvePath.prototype ), {

	fromPoints: function ( vectors ) {

		this.moveTo( vectors[ 0 ].x, vectors[ 0 ].y );

		for ( var i = 1, l = vectors.length; i < l; i ++ ) {

			this.lineTo( vectors[ i ].x, vectors[ i ].y );

		}

	},

	moveTo: function ( x, y ) {

		this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?

	},

	lineTo: function ( x, y ) {

		var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
		this.curves.push( curve );

		this.currentPoint.set( x, y );

	},

	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {

		var curve = new QuadraticBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCPx, aCPy ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

	},

	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {

		var curve = new CubicBezierCurve(
			this.currentPoint.clone(),
			new Vector2( aCP1x, aCP1y ),
			new Vector2( aCP2x, aCP2y ),
			new Vector2( aX, aY )
		);

		this.curves.push( curve );

		this.currentPoint.set( aX, aY );

	},

	splineThru: function ( pts /*Array of Vector*/ ) {

		var npts = [ this.currentPoint.clone() ].concat( pts );

		var curve = new SplineCurve( npts );
		this.curves.push( curve );

		this.currentPoint.copy( pts[ pts.length - 1 ] );

	},

	arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absarc( aX + x0, aY + y0, aRadius,
			aStartAngle, aEndAngle, aClockwise );

	},

	absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

		this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

	},

	ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var x0 = this.currentPoint.x;
		var y0 = this.currentPoint.y;

		this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

	},

	absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {

		var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );

		if ( this.curves.length > 0 ) {

			// if a previous curve is present, attempt to join
			var firstPoint = curve.getPoint( 0 );

			if ( ! firstPoint.equals( this.currentPoint ) ) {

				this.lineTo( firstPoint.x, firstPoint.y );

			}

		}

		this.curves.push( curve );

		var lastPoint = curve.getPoint( 1 );
		this.currentPoint.copy( lastPoint );

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Defines a 2d shape plane using paths.
 **/

// STEP 1 Create a path.
// STEP 2 Turn path into shape.
// STEP 3 ExtrudeGeometry takes in Shape/Shapes
// STEP 3a - Extract points from each shape, turn to vertices
// STEP 3b - Triangulate each shape, add faces.

function Shape() {

	Path.apply( this, arguments );

	this.holes = [];

}

Shape.prototype = Object.assign( Object.create( PathPrototype ), {

	constructor: Shape,

	getPointsHoles: function ( divisions ) {

		var holesPts = [];

		for ( var i = 0, l = this.holes.length; i < l; i ++ ) {

			holesPts[ i ] = this.holes[ i ].getPoints( divisions );

		}

		return holesPts;

	},

	// Get points of shape and holes (keypoints based on segments parameter)

	extractAllPoints: function ( divisions ) {

		return {

			shape: this.getPoints( divisions ),
			holes: this.getPointsHoles( divisions )

		};

	},

	extractPoints: function ( divisions ) {

		return this.extractAllPoints( divisions );

	}

} );

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * Creates free form 2d path using series of points, lines or curves.
 *
 **/

function Path( points ) {

	CurvePath.call( this );
	this.currentPoint = new Vector2();

	if ( points ) {

		this.fromPoints( points );

	}

}

Path.prototype = PathPrototype;
PathPrototype.constructor = Path;


// minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
function ShapePath() {
	this.subPaths = [];
	this.currentPath = null;
}

ShapePath.prototype = {
	moveTo: function ( x, y ) {
		this.currentPath = new Path();
		this.subPaths.push(this.currentPath);
		this.currentPath.moveTo( x, y );
	},
	lineTo: function ( x, y ) {
		this.currentPath.lineTo( x, y );
	},
	quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
		this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
	},
	bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
		this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
	},
	splineThru: function ( pts ) {
		this.currentPath.splineThru( pts );
	},

	toShapes: function ( isCCW, noHoles ) {

		function toShapesNoHoles( inSubpaths ) {

			var shapes = [];

			for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {

				var tmpPath = inSubpaths[ i ];

				var tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;

				shapes.push( tmpShape );

			}

			return shapes;

		}

		function isPointInsidePolygon( inPt, inPolygon ) {

			var polyLen = inPolygon.length;

			// inPt on polygon contour => immediate success    or
			// toggling of inside/outside at every single! intersection point of an edge
			//  with the horizontal line through inPt, left of inPt
			//  not counting lowerY endpoints of edges and whole edges on that line
			var inside = false;
			for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {

				var edgeLowPt  = inPolygon[ p ];
				var edgeHighPt = inPolygon[ q ];

				var edgeDx = edgeHighPt.x - edgeLowPt.x;
				var edgeDy = edgeHighPt.y - edgeLowPt.y;

				if ( Math.abs( edgeDy ) > Number.EPSILON ) {

					// not parallel
					if ( edgeDy < 0 ) {

						edgeLowPt  = inPolygon[ q ]; edgeDx = - edgeDx;
						edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;

					}
					if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;

					if ( inPt.y === edgeLowPt.y ) {

						if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
						// continue;				// no intersection or edgeLowPt => doesn't count !!!

					} else {

						var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
						if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
						if ( perpEdge < 0 ) 				continue;
						inside = ! inside;		// true intersection left of inPt

					}

				} else {

					// parallel or collinear
					if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
					// edge lies on the same horizontal line as inPt
					if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
						 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
					// continue;

				}

			}

			return	inside;

		}

		var isClockWise = ShapeUtils.isClockWise;

		var subPaths = this.subPaths;
		if ( subPaths.length === 0 ) return [];

		if ( noHoles === true )	return	toShapesNoHoles( subPaths );


		var solid, tmpPath, tmpShape, shapes = [];

		if ( subPaths.length === 1 ) {

			tmpPath = subPaths[ 0 ];
			tmpShape = new Shape();
			tmpShape.curves = tmpPath.curves;
			shapes.push( tmpShape );
			return shapes;

		}

		var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
		holesFirst = isCCW ? ! holesFirst : holesFirst;

		// console.log("Holes first", holesFirst);

		var betterShapeHoles = [];
		var newShapes = [];
		var newShapeHoles = [];
		var mainIdx = 0;
		var tmpPoints;

		newShapes[ mainIdx ] = undefined;
		newShapeHoles[ mainIdx ] = [];

		for ( var i = 0, l = subPaths.length; i < l; i ++ ) {

			tmpPath = subPaths[ i ];
			tmpPoints = tmpPath.getPoints();
			solid = isClockWise( tmpPoints );
			solid = isCCW ? ! solid : solid;

			if ( solid ) {

				if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;

				newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
				newShapes[ mainIdx ].s.curves = tmpPath.curves;

				if ( holesFirst )	mainIdx ++;
				newShapeHoles[ mainIdx ] = [];

				//console.log('cw', i);

			} else {

				newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );

				//console.log('ccw', i);

			}

		}

		// only Holes? -> probably all Shapes with wrong orientation
		if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );


		if ( newShapes.length > 1 ) {

			var ambiguous = false;
			var toChange = [];

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				betterShapeHoles[ sIdx ] = [];

			}

			for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {

				var sho = newShapeHoles[ sIdx ];

				for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {

					var ho = sho[ hIdx ];
					var hole_unassigned = true;

					for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {

						if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {

							if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
							if ( hole_unassigned ) {

								hole_unassigned = false;
								betterShapeHoles[ s2Idx ].push( ho );

							} else {

								ambiguous = true;

							}

						}

					}
					if ( hole_unassigned ) {

						betterShapeHoles[ sIdx ].push( ho );

					}

				}

			}
			// console.log("ambiguous: ", ambiguous);
			if ( toChange.length > 0 ) {

				// console.log("to change: ", toChange);
				if ( ! ambiguous )	newShapeHoles = betterShapeHoles;

			}

		}

		var tmpHoles;

		for ( var i = 0, il = newShapes.length; i < il; i ++ ) {

			tmpShape = newShapes[ i ].s;
			shapes.push( tmpShape );
			tmpHoles = newShapeHoles[ i ];

			for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {

				tmpShape.holes.push( tmpHoles[ j ].h );

			}

		}

		//console.log("shape", shapes);

		return shapes;

	}
};

/**
 * @author zz85 / http://www.lab4games.net/zz85/blog
 * @author mrdoob / http://mrdoob.com/
 */

function Font( data ) {

	this.data = data;

}

Object.assign( Font.prototype, {

	isFont: true,

	generateShapes: function ( text, size, divisions ) {

		function createPaths( text ) {

			var chars = String( text ).split( '' );
			var scale = size / data.resolution;
			var offset = 0;

			var paths = [];

			for ( var i = 0; i < chars.length; i ++ ) {

				var ret = createPath( chars[ i ], scale, offset );
				offset += ret.offset;

				paths.push( ret.path );

			}

			return paths;

		}

		function createPath( c, scale, offset ) {

			var glyph = data.glyphs[ c ] || data.glyphs[ '?' ];

			if ( ! glyph ) return;

			var path = new ShapePath();

			var pts = [], b2 = ShapeUtils.b2, b3 = ShapeUtils.b3;
			var x, y, cpx, cpy, cpx0, cpy0, cpx1, cpy1, cpx2, cpy2, laste;

			if ( glyph.o ) {

				var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );

				for ( var i = 0, l = outline.length; i < l; ) {

					var action = outline[ i ++ ];

					switch ( action ) {

						case 'm': // moveTo

							x = outline[ i ++ ] * scale + offset;
							y = outline[ i ++ ] * scale;

							path.moveTo( x, y );

							break;

						case 'l': // lineTo

							x = outline[ i ++ ] * scale + offset;
							y = outline[ i ++ ] * scale;

							path.lineTo( x, y );

							break;

						case 'q': // quadraticCurveTo

							cpx  = outline[ i ++ ] * scale + offset;
							cpy  = outline[ i ++ ] * scale;
							cpx1 = outline[ i ++ ] * scale + offset;
							cpy1 = outline[ i ++ ] * scale;

							path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );

							laste = pts[ pts.length - 1 ];

							if ( laste ) {

								cpx0 = laste.x;
								cpy0 = laste.y;

								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

									var t = i2 / divisions;
									b2( t, cpx0, cpx1, cpx );
									b2( t, cpy0, cpy1, cpy );

								}

							}

							break;

						case 'b': // bezierCurveTo

							cpx  = outline[ i ++ ] * scale + offset;
							cpy  = outline[ i ++ ] * scale;
							cpx1 = outline[ i ++ ] * scale + offset;
							cpy1 = outline[ i ++ ] * scale;
							cpx2 = outline[ i ++ ] * scale + offset;
							cpy2 = outline[ i ++ ] * scale;

							path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );

							laste = pts[ pts.length - 1 ];

							if ( laste ) {

								cpx0 = laste.x;
								cpy0 = laste.y;

								for ( var i2 = 1; i2 <= divisions; i2 ++ ) {

									var t = i2 / divisions;
									b3( t, cpx0, cpx1, cpx2, cpx );
									b3( t, cpy0, cpy1, cpy2, cpy );

								}

							}

							break;

					}

				}

			}

			return { offset: glyph.ha * scale, path: path };

		}

		//

		if ( size === undefined ) size = 100;
		if ( divisions === undefined ) divisions = 4;

		var data = this.data;

		var paths = createPaths( text );
		var shapes = [];

		for ( var p = 0, pl = paths.length; p < pl; p ++ ) {

			Array.prototype.push.apply( shapes, paths[ p ].toShapes() );

		}

		return shapes;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function FontLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( FontLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var scope = this;

		var loader = new FileLoader( this.manager );
		loader.load( url, function ( text ) {

			var json;

			try {

				json = JSON.parse( text );

			} catch ( e ) {

				console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
				json = JSON.parse( text.substring( 65, text.length - 2 ) );

			}

			var font = scope.parse( json );

			if ( onLoad ) onLoad( font );

		}, onProgress, onError );

	},

	parse: function ( json ) {

		return new Font( json );

	}

} );

var context;

var AudioContext = {

	getContext: function () {

		if ( context === undefined ) {

			context = new ( window.AudioContext || window.webkitAudioContext )();

		}

		return context;

	},

	setContext: function ( value ) {

		context = value;

	}

};

/**
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function AudioLoader( manager ) {

	this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;

}

Object.assign( AudioLoader.prototype, {

	load: function ( url, onLoad, onProgress, onError ) {

		var loader = new FileLoader( this.manager );
		loader.setResponseType( 'arraybuffer' );
		loader.load( url, function ( buffer ) {

			var context = AudioContext.getContext();

			context.decodeAudioData( buffer, function ( audioBuffer ) {

				onLoad( audioBuffer );

			} );

		}, onProgress, onError );

	}

} );

/**
 * @author abelnation / http://github.com/abelnation
 */

function RectAreaLight ( color, intensity, width, height ) {

	Light.call( this, color, intensity );

	this.type = 'RectAreaLight';

	this.position.set( 0, 1, 0 );
	this.updateMatrix();

	this.width = ( width !== undefined ) ? width : 10;
	this.height = ( height !== undefined ) ? height : 10;

	// TODO (abelnation): distance/decay

	// TODO (abelnation): update method for RectAreaLight to update transform to lookat target

	// TODO (abelnation): shadows
	// this.shadow = new THREE.RectAreaLightShadow( new THREE.PerspectiveCamera( 90, 1, 0.5, 500 ) );

}

// TODO (abelnation): RectAreaLight update when light shape is changed
RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {

	constructor: RectAreaLight,

	isRectAreaLight: true,

	copy: function ( source ) {

		Light.prototype.copy.call( this, source );

		this.width = source.width;
		this.height = source.height;

		// this.shadow = source.shadow.clone();

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function StereoCamera() {

	this.type = 'StereoCamera';

	this.aspect = 1;

	this.eyeSep = 0.064;

	this.cameraL = new PerspectiveCamera();
	this.cameraL.layers.enable( 1 );
	this.cameraL.matrixAutoUpdate = false;

	this.cameraR = new PerspectiveCamera();
	this.cameraR.layers.enable( 2 );
	this.cameraR.matrixAutoUpdate = false;

}

Object.assign( StereoCamera.prototype, {

	update: ( function () {

		var instance, focus, fov, aspect, near, far, zoom;

		var eyeRight = new Matrix4();
		var eyeLeft = new Matrix4();

		return function update( camera ) {

			var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
												aspect !== camera.aspect * this.aspect || near !== camera.near ||
												far !== camera.far || zoom !== camera.zoom;

			if ( needsUpdate ) {

				instance = this;
				focus = camera.focus;
				fov = camera.fov;
				aspect = camera.aspect * this.aspect;
				near = camera.near;
				far = camera.far;
				zoom = camera.zoom;

				// Off-axis stereoscopic effect based on
				// http://paulbourke.net/stereographics/stereorender/

				var projectionMatrix = camera.projectionMatrix.clone();
				var eyeSep = this.eyeSep / 2;
				var eyeSepOnProjection = eyeSep * near / focus;
				var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
				var xmin, xmax;

				// translate xOffset

				eyeLeft.elements[ 12 ] = - eyeSep;
				eyeRight.elements[ 12 ] = eyeSep;

				// for left eye

				xmin = - ymax * aspect + eyeSepOnProjection;
				xmax = ymax * aspect + eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraL.projectionMatrix.copy( projectionMatrix );

				// for right eye

				xmin = - ymax * aspect - eyeSepOnProjection;
				xmax = ymax * aspect - eyeSepOnProjection;

				projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
				projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );

				this.cameraR.projectionMatrix.copy( projectionMatrix );

			}

			this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
			this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );

		};

	} )()

} );

/**
 * Camera for rendering cube maps
 *	- renders scene into axis-aligned cube
 *
 * @author alteredq / http://alteredqualia.com/
 */

function CubeCamera( near, far, cubeResolution ) {

	Object3D.call( this );

	this.type = 'CubeCamera';

	var fov = 90, aspect = 1;

	var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
	cameraPX.up.set( 0, - 1, 0 );
	cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
	this.add( cameraPX );

	var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
	cameraNX.up.set( 0, - 1, 0 );
	cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
	this.add( cameraNX );

	var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
	cameraPY.up.set( 0, 0, 1 );
	cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
	this.add( cameraPY );

	var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
	cameraNY.up.set( 0, 0, - 1 );
	cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
	this.add( cameraNY );

	var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraPZ.up.set( 0, - 1, 0 );
	cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
	this.add( cameraPZ );

	var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
	cameraNZ.up.set( 0, - 1, 0 );
	cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
	this.add( cameraNZ );

	var options = { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };

	this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );

	this.updateCubeMap = function ( renderer, scene ) {

		if ( this.parent === null ) this.updateMatrixWorld();

		var renderTarget = this.renderTarget;
		var generateMipmaps = renderTarget.texture.generateMipmaps;

		renderTarget.texture.generateMipmaps = false;

		renderTarget.activeCubeFace = 0;
		renderer.render( scene, cameraPX, renderTarget );

		renderTarget.activeCubeFace = 1;
		renderer.render( scene, cameraNX, renderTarget );

		renderTarget.activeCubeFace = 2;
		renderer.render( scene, cameraPY, renderTarget );

		renderTarget.activeCubeFace = 3;
		renderer.render( scene, cameraNY, renderTarget );

		renderTarget.activeCubeFace = 4;
		renderer.render( scene, cameraPZ, renderTarget );

		renderTarget.texture.generateMipmaps = generateMipmaps;

		renderTarget.activeCubeFace = 5;
		renderer.render( scene, cameraNZ, renderTarget );

		renderer.setRenderTarget( null );

	};

}

CubeCamera.prototype = Object.create( Object3D.prototype );
CubeCamera.prototype.constructor = CubeCamera;

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioListener() {

	Object3D.call( this );

	this.type = 'AudioListener';

	this.context = AudioContext.getContext();

	this.gain = this.context.createGain();
	this.gain.connect( this.context.destination );

	this.filter = null;

}

AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: AudioListener,

	getInput: function () {

		return this.gain;

	},

	removeFilter: function ( ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );
			this.gain.connect( this.context.destination );
			this.filter = null;

		}

	},

	getFilter: function () {

		return this.filter;

	},

	setFilter: function ( value ) {

		if ( this.filter !== null ) {

			this.gain.disconnect( this.filter );
			this.filter.disconnect( this.context.destination );

		} else {

			this.gain.disconnect( this.context.destination );

		}

		this.filter = value;
		this.gain.connect( this.filter );
		this.filter.connect( this.context.destination );

	},

	getMasterVolume: function () {

		return this.gain.gain.value;

	},

	setMasterVolume: function ( value ) {

		this.gain.gain.value = value;

	},

	updateMatrixWorld: ( function () {

		var position = new Vector3();
		var quaternion = new Quaternion();
		var scale = new Vector3();

		var orientation = new Vector3();

		return function updateMatrixWorld( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			var listener = this.context.listener;
			var up = this.up;

			this.matrixWorld.decompose( position, quaternion, scale );

			orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );

			if ( listener.positionX ) {

				listener.positionX.setValueAtTime( position.x, this.context.currentTime );
				listener.positionY.setValueAtTime( position.y, this.context.currentTime );
				listener.positionZ.setValueAtTime( position.z, this.context.currentTime );
				listener.forwardX.setValueAtTime( orientation.x, this.context.currentTime );
				listener.forwardY.setValueAtTime( orientation.y, this.context.currentTime );
				listener.forwardZ.setValueAtTime( orientation.z, this.context.currentTime );
				listener.upX.setValueAtTime( up.x, this.context.currentTime );
				listener.upY.setValueAtTime( up.y, this.context.currentTime );
				listener.upZ.setValueAtTime( up.z, this.context.currentTime );

			} else {

				listener.setPosition( position.x, position.y, position.z );
				listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );

			}

		};

	} )()

} );

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Reece Aaron Lecrivain / http://reecenotes.com/
 */

function Audio( listener ) {

	Object3D.call( this );

	this.type = 'Audio';

	this.context = listener.context;

	this.gain = this.context.createGain();
	this.gain.connect( listener.getInput() );

	this.autoplay = false;

	this.buffer = null;
	this.loop = false;
	this.startTime = 0;
	this.playbackRate = 1;
	this.isPlaying = false;
	this.hasPlaybackControl = true;
	this.sourceType = 'empty';

	this.filters = [];

}

Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {

	constructor: Audio,

	getOutput: function () {

		return this.gain;

	},

	setNodeSource: function ( audioNode ) {

		this.hasPlaybackControl = false;
		this.sourceType = 'audioNode';
		this.source = audioNode;
		this.connect();

		return this;

	},

	setBuffer: function ( audioBuffer ) {

		this.buffer = audioBuffer;
		this.sourceType = 'buffer';

		if ( this.autoplay ) this.play();

		return this;

	},

	play: function () {

		if ( this.isPlaying === true ) {

			console.warn( 'THREE.Audio: Audio is already playing.' );
			return;

		}

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		var source = this.context.createBufferSource();

		source.buffer = this.buffer;
		source.loop = this.loop;
		source.onended = this.onEnded.bind( this );
		source.playbackRate.setValueAtTime( this.playbackRate, this.startTime );
		source.start( 0, this.startTime );

		this.isPlaying = true;

		this.source = source;

		return this.connect();

	},

	pause: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.source.stop();
		this.startTime = this.context.currentTime;
		this.isPlaying = false;

		return this;

	},

	stop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.source.stop();
		this.startTime = 0;
		this.isPlaying = false;

		return this;

	},

	connect: function () {

		if ( this.filters.length > 0 ) {

			this.source.connect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].connect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].connect( this.getOutput() );

		} else {

			this.source.connect( this.getOutput() );

		}

		return this;

	},

	disconnect: function () {

		if ( this.filters.length > 0 ) {

			this.source.disconnect( this.filters[ 0 ] );

			for ( var i = 1, l = this.filters.length; i < l; i ++ ) {

				this.filters[ i - 1 ].disconnect( this.filters[ i ] );

			}

			this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );

		} else {

			this.source.disconnect( this.getOutput() );

		}

		return this;

	},

	getFilters: function () {

		return this.filters;

	},

	setFilters: function ( value ) {

		if ( ! value ) value = [];

		if ( this.isPlaying === true ) {

			this.disconnect();
			this.filters = value;
			this.connect();

		} else {

			this.filters = value;

		}

		return this;

	},

	getFilter: function () {

		return this.getFilters()[ 0 ];

	},

	setFilter: function ( filter ) {

		return this.setFilters( filter ? [ filter ] : [] );

	},

	setPlaybackRate: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.playbackRate = value;

		if ( this.isPlaying === true ) {

			this.source.playbackRate.setValueAtTime( this.playbackRate, this.context.currentTime );

		}

		return this;

	},

	getPlaybackRate: function () {

		return this.playbackRate;

	},

	onEnded: function () {

		this.isPlaying = false;

	},

	getLoop: function () {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return false;

		}

		return this.loop;

	},

	setLoop: function ( value ) {

		if ( this.hasPlaybackControl === false ) {

			console.warn( 'THREE.Audio: this Audio has no playback control.' );
			return;

		}

		this.loop = value;

		if ( this.isPlaying === true ) {

			this.source.loop = this.loop;

		}

		return this;

	},

	getVolume: function () {

		return this.gain.gain.value;

	},


	setVolume: function ( value ) {

		this.gain.gain.value = value;

		return this;

	}

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function PositionalAudio( listener ) {

	Audio.call( this, listener );

	this.panner = this.context.createPanner();
	this.panner.connect( this.gain );

}

PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {

	constructor: PositionalAudio,

	getOutput: function () {

		return this.panner;

	},

	getRefDistance: function () {

		return this.panner.refDistance;

	},

	setRefDistance: function ( value ) {

		this.panner.refDistance = value;

	},

	getRolloffFactor: function () {

		return this.panner.rolloffFactor;

	},

	setRolloffFactor: function ( value ) {

		this.panner.rolloffFactor = value;

	},

	getDistanceModel: function () {

		return this.panner.distanceModel;

	},

	setDistanceModel: function ( value ) {

		this.panner.distanceModel = value;

	},

	getMaxDistance: function () {

		return this.panner.maxDistance;

	},

	setMaxDistance: function ( value ) {

		this.panner.maxDistance = value;

	},

	updateMatrixWorld: ( function () {

		var position = new Vector3();

		return function updateMatrixWorld( force ) {

			Object3D.prototype.updateMatrixWorld.call( this, force );

			position.setFromMatrixPosition( this.matrixWorld );

			this.panner.setPosition( position.x, position.y, position.z );

		};

	} )()


} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function AudioAnalyser( audio, fftSize ) {

	this.analyser = audio.context.createAnalyser();
	this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;

	this.data = new Uint8Array( this.analyser.frequencyBinCount );

	audio.getOutput().connect( this.analyser );

}

Object.assign( AudioAnalyser.prototype, {

	getFrequencyData: function () {

		this.analyser.getByteFrequencyData( this.data );

		return this.data;

	},

	getAverageFrequency: function () {

		var value = 0, data = this.getFrequencyData();

		for ( var i = 0; i < data.length; i ++ ) {

			value += data[ i ];

		}

		return value / data.length;

	}

} );

/**
 *
 * Buffered scene graph property that allows weighted accumulation.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyMixer( binding, typeName, valueSize ) {

	this.binding = binding;
	this.valueSize = valueSize;

	var bufferType = Float64Array,
		mixFunction;

	switch ( typeName ) {

		case 'quaternion':
			mixFunction = this._slerp;
			break;

		case 'string':
		case 'bool':
			bufferType = Array;
			mixFunction = this._select;
			break;

		default:
			mixFunction = this._lerp;

	}

	this.buffer = new bufferType( valueSize * 4 );
	// layout: [ incoming | accu0 | accu1 | orig ]
	//
	// interpolators can use .buffer as their .result
	// the data then goes to 'incoming'
	//
	// 'accu0' and 'accu1' are used frame-interleaved for
	// the cumulative result and are compared to detect
	// changes
	//
	// 'orig' stores the original state of the property

	this._mixBufferRegion = mixFunction;

	this.cumulativeWeight = 0;

	this.useCount = 0;
	this.referenceCount = 0;

}

PropertyMixer.prototype = {

	constructor: PropertyMixer,

	// accumulate data in the 'incoming' region into 'accu<i>'
	accumulate: function( accuIndex, weight ) {

		// note: happily accumulating nothing when weight = 0, the caller knows
		// the weight and shouldn't have made the call in the first place

		var buffer = this.buffer,
			stride = this.valueSize,
			offset = accuIndex * stride + stride,

			currentWeight = this.cumulativeWeight;

		if ( currentWeight === 0 ) {

			// accuN := incoming * weight

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ offset + i ] = buffer[ i ];

			}

			currentWeight = weight;

		} else {

			// accuN := accuN + incoming * weight

			currentWeight += weight;
			var mix = weight / currentWeight;
			this._mixBufferRegion( buffer, offset, 0, mix, stride );

		}

		this.cumulativeWeight = currentWeight;

	},

	// apply the state of 'accu<i>' to the binding when accus differ
	apply: function( accuIndex ) {

		var stride = this.valueSize,
			buffer = this.buffer,
			offset = accuIndex * stride + stride,

			weight = this.cumulativeWeight,

			binding = this.binding;

		this.cumulativeWeight = 0;

		if ( weight < 1 ) {

			// accuN := accuN + original * ( 1 - cumulativeWeight )

			var originalValueOffset = stride * 3;

			this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );

		}

		for ( var i = stride, e = stride + stride; i !== e; ++ i ) {

			if ( buffer[ i ] !== buffer[ i + stride ] ) {

				// value has changed -> update scene graph

				binding.setValue( buffer, offset );
				break;

			}

		}

	},

	// remember the state of the bound property and copy it to both accus
	saveOriginalState: function() {

		var binding = this.binding;

		var buffer = this.buffer,
			stride = this.valueSize,

			originalValueOffset = stride * 3;

		binding.getValue( buffer, originalValueOffset );

		// accu[0..1] := orig -- initially detect changes against the original
		for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {

			buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];

		}

		this.cumulativeWeight = 0;

	},

	// apply the state previously taken via 'saveOriginalState' to the binding
	restoreOriginalState: function() {

		var originalValueOffset = this.valueSize * 3;
		this.binding.setValue( this.buffer, originalValueOffset );

	},


	// mix functions

	_select: function( buffer, dstOffset, srcOffset, t, stride ) {

		if ( t >= 0.5 ) {

			for ( var i = 0; i !== stride; ++ i ) {

				buffer[ dstOffset + i ] = buffer[ srcOffset + i ];

			}

		}

	},

	_slerp: function( buffer, dstOffset, srcOffset, t, stride ) {

		Quaternion.slerpFlat( buffer, dstOffset,
				buffer, dstOffset, buffer, srcOffset, t );

	},

	_lerp: function( buffer, dstOffset, srcOffset, t, stride ) {

		var s = 1 - t;

		for ( var i = 0; i !== stride; ++ i ) {

			var j = dstOffset + i;

			buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;

		}

	}

};

/**
 *
 * A reference to a real property in the scene graph.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function PropertyBinding( rootNode, path, parsedPath ) {

	this.path = path;
	this.parsedPath = parsedPath ||
			PropertyBinding.parseTrackName( path );

	this.node = PropertyBinding.findNode(
			rootNode, this.parsedPath.nodeName ) || rootNode;

	this.rootNode = rootNode;

}

PropertyBinding.prototype = {

	constructor: PropertyBinding,

	getValue: function getValue_unbound( targetArray, offset ) {

		this.bind();
		this.getValue( targetArray, offset );

		// Note: This class uses a State pattern on a per-method basis:
		// 'bind' sets 'this.getValue' / 'setValue' and shadows the
		// prototype version of these methods with one that represents
		// the bound state. When the property is not found, the methods
		// become no-ops.

	},

	setValue: function getValue_unbound( sourceArray, offset ) {

		this.bind();
		this.setValue( sourceArray, offset );

	},

	// create getter / setter pair for a property in the scene graph
	bind: function() {

		var targetObject = this.node,
			parsedPath = this.parsedPath,

			objectName = parsedPath.objectName,
			propertyName = parsedPath.propertyName,
			propertyIndex = parsedPath.propertyIndex;

		if ( ! targetObject ) {

			targetObject = PropertyBinding.findNode(
					this.rootNode, parsedPath.nodeName ) || this.rootNode;

			this.node = targetObject;

		}

		// set fail state so we can just 'return' on error
		this.getValue = this._getValue_unavailable;
		this.setValue = this._setValue_unavailable;

 		// ensure there is a value node
		if ( ! targetObject ) {

			console.error( "  trying to update node for track: " + this.path + " but it wasn't found." );
			return;

		}

		if ( objectName ) {

			var objectIndex = parsedPath.objectIndex;

			// special cases were we need to reach deeper into the hierarchy to get the face materials....
			switch ( objectName ) {

				case 'materials':

					if ( ! targetObject.material ) {

						console.error( '  can not bind to material as node does not have a material', this );
						return;

					}

					if ( ! targetObject.material.materials ) {

						console.error( '  can not bind to material.materials as node.material does not have a materials array', this );
						return;

					}

					targetObject = targetObject.material.materials;

					break;

				case 'bones':

					if ( ! targetObject.skeleton ) {

						console.error( '  can not bind to bones as node does not have a skeleton', this );
						return;

					}

					// potential future optimization: skip this if propertyIndex is already an integer
					// and convert the integer string to a true integer.

					targetObject = targetObject.skeleton.bones;

					// support resolving morphTarget names into indices.
					for ( var i = 0; i < targetObject.length; i ++ ) {

						if ( targetObject[ i ].name === objectIndex ) {

							objectIndex = i;
							break;

						}

					}

					break;

				default:

					if ( targetObject[ objectName ] === undefined ) {

						console.error( '  can not bind to objectName of node, undefined', this );
						return;

					}

					targetObject = targetObject[ objectName ];

			}


			if ( objectIndex !== undefined ) {

				if ( targetObject[ objectIndex ] === undefined ) {

					console.error( "  trying to bind to objectIndex of objectName, but is undefined:", this, targetObject );
					return;

				}

				targetObject = targetObject[ objectIndex ];

			}

		}

		// resolve property
		var nodeProperty = targetObject[ propertyName ];

		if ( nodeProperty === undefined ) {

			var nodeName = parsedPath.nodeName;

			console.error( "  trying to update property for track: " + nodeName +
					'.' + propertyName + " but it wasn't found.", targetObject );
			return;

		}

		// determine versioning scheme
		var versioning = this.Versioning.None;

		if ( targetObject.needsUpdate !== undefined ) { // material

			versioning = this.Versioning.NeedsUpdate;
			this.targetObject = targetObject;

		} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform

			versioning = this.Versioning.MatrixWorldNeedsUpdate;
			this.targetObject = targetObject;

		}

		// determine how the property gets bound
		var bindingType = this.BindingType.Direct;

		if ( propertyIndex !== undefined ) {
			// access a sub element of the property array (only primitives are supported right now)

			if ( propertyName === "morphTargetInfluences" ) {
				// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.

				// support resolving morphTarget names into indices.
				if ( ! targetObject.geometry ) {

					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry', this );
					return;

				}

				if ( ! targetObject.geometry.morphTargets ) {

					console.error( '  can not bind to morphTargetInfluences becasuse node does not have a geometry.morphTargets', this );
					return;

				}

				for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {

					if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {

						propertyIndex = i;
						break;

					}

				}

			}

			bindingType = this.BindingType.ArrayElement;

			this.resolvedProperty = nodeProperty;
			this.propertyIndex = propertyIndex;

		} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
			// must use copy for Object3D.Euler/Quaternion

			bindingType = this.BindingType.HasFromToArray;

			this.resolvedProperty = nodeProperty;

		} else if ( nodeProperty.length !== undefined ) {

			bindingType = this.BindingType.EntireArray;

			this.resolvedProperty = nodeProperty;

		} else {

			this.propertyName = propertyName;

		}

		// select getter / setter
		this.getValue = this.GetterByBindingType[ bindingType ];
		this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];

	},

	unbind: function() {

		this.node = null;

		// back to the prototype version of getValue / setValue
		// note: avoiding to mutate the shape of 'this' via 'delete'
		this.getValue = this._getValue_unbound;
		this.setValue = this._setValue_unbound;

	}

};

Object.assign( PropertyBinding.prototype, { // prototype, continued

	// these are used to "bind" a nonexistent property
	_getValue_unavailable: function() {},
	_setValue_unavailable: function() {},

	// initial state of these methods that calls 'bind'
	_getValue_unbound: PropertyBinding.prototype.getValue,
	_setValue_unbound: PropertyBinding.prototype.setValue,

	BindingType: {
		Direct: 0,
		EntireArray: 1,
		ArrayElement: 2,
		HasFromToArray: 3
	},

	Versioning: {
		None: 0,
		NeedsUpdate: 1,
		MatrixWorldNeedsUpdate: 2
	},

	GetterByBindingType: [

		function getValue_direct( buffer, offset ) {

			buffer[ offset ] = this.node[ this.propertyName ];

		},

		function getValue_array( buffer, offset ) {

			var source = this.resolvedProperty;

			for ( var i = 0, n = source.length; i !== n; ++ i ) {

				buffer[ offset ++ ] = source[ i ];

			}

		},

		function getValue_arrayElement( buffer, offset ) {

			buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];

		},

		function getValue_toArray( buffer, offset ) {

			this.resolvedProperty.toArray( buffer, offset );

		}

	],

	SetterByBindingTypeAndVersioning: [

		[
			// Direct

			function setValue_direct( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];

			},

			function setValue_direct_setNeedsUpdate( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.node[ this.propertyName ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// EntireArray

			function setValue_array( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

			},

			function setValue_array_setNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.needsUpdate = true;

			},

			function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {

				var dest = this.resolvedProperty;

				for ( var i = 0, n = dest.length; i !== n; ++ i ) {

					dest[ i ] = buffer[ offset ++ ];

				}

				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// ArrayElement

			function setValue_arrayElement( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];

			},

			function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.needsUpdate = true;

			},

			function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		], [

			// HasToFromArray

			function setValue_fromArray( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );

			},

			function setValue_fromArray_setNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.needsUpdate = true;

			},

			function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {

				this.resolvedProperty.fromArray( buffer, offset );
				this.targetObject.matrixWorldNeedsUpdate = true;

			}

		]

	]

} );

PropertyBinding.Composite =
		function( targetGroup, path, optionalParsedPath ) {

	var parsedPath = optionalParsedPath ||
			PropertyBinding.parseTrackName( path );

	this._targetGroup = targetGroup;
	this._bindings = targetGroup.subscribe_( path, parsedPath );

};

PropertyBinding.Composite.prototype = {

	constructor: PropertyBinding.Composite,

	getValue: function( array, offset ) {

		this.bind(); // bind all binding

		var firstValidIndex = this._targetGroup.nCachedObjects_,
			binding = this._bindings[ firstValidIndex ];

		// and only call .getValue on the first
		if ( binding !== undefined ) binding.getValue( array, offset );

	},

	setValue: function( array, offset ) {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].setValue( array, offset );

		}

	},

	bind: function() {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].bind();

		}

	},

	unbind: function() {

		var bindings = this._bindings;

		for ( var i = this._targetGroup.nCachedObjects_,
				n = bindings.length; i !== n; ++ i ) {

			bindings[ i ].unbind();

		}

	}

};

PropertyBinding.create = function( root, path, parsedPath ) {

	if ( ! ( root && root.isAnimationObjectGroup ) ) {

		return new PropertyBinding( root, path, parsedPath );

	} else {

		return new PropertyBinding.Composite( root, path, parsedPath );

	}

};

PropertyBinding.parseTrackName = function( trackName ) {

	// matches strings in the form of:
	//    nodeName.property
	//    nodeName.property[accessor]
	//    nodeName.material.property[accessor]
	//    uuid.property[accessor]
	//    uuid.objectName[objectIndex].propertyName[propertyIndex]
	//    parentName/nodeName.property
	//    parentName/parentName/nodeName.property[index]
	//    .bone[Armature.DEF_cog].position
	//    scene:helium_balloon_model:helium_balloon_model.position
	// created and tested via https://regex101.com/#javascript

	var re = /^((?:[\w-]+[\/:])*)([\w-]+)?(?:\.([\w-]+)(?:\[(.+)\])?)?\.([\w-]+)(?:\[(.+)\])?$/;
	var matches = re.exec( trackName );

	if ( ! matches ) {

		throw new Error( "cannot parse trackName at all: " + trackName );

	}

	var results = {
		// directoryName: matches[ 1 ], // (tschw) currently unused
		nodeName: matches[ 2 ], 	// allowed to be null, specified root node.
		objectName: matches[ 3 ],
		objectIndex: matches[ 4 ],
		propertyName: matches[ 5 ],
		propertyIndex: matches[ 6 ]	// allowed to be null, specifies that the whole property is set.
	};

	if ( results.propertyName === null || results.propertyName.length === 0 ) {

		throw new Error( "can not parse propertyName from trackName: " + trackName );

	}

	return results;

};

PropertyBinding.findNode = function( root, nodeName ) {

	if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === -1 || nodeName === root.name || nodeName === root.uuid ) {

		return root;

	}

	// search into skeleton bones.
	if ( root.skeleton ) {

		var searchSkeleton = function( skeleton ) {

			for( var i = 0; i < skeleton.bones.length; i ++ ) {

				var bone = skeleton.bones[ i ];

				if ( bone.name === nodeName ) {

					return bone;

				}
			}

			return null;

		};

		var bone = searchSkeleton( root.skeleton );

		if ( bone ) {

			return bone;

		}
	}

	// search into node subtree.
	if ( root.children ) {

		var searchNodeSubtree = function( children ) {

			for( var i = 0; i < children.length; i ++ ) {

				var childNode = children[ i ];

				if ( childNode.name === nodeName || childNode.uuid === nodeName ) {

					return childNode;

				}

				var result = searchNodeSubtree( childNode.children );

				if ( result ) return result;

			}

			return null;

		};

		var subTreeNode = searchNodeSubtree( root.children );

		if ( subTreeNode ) {

			return subTreeNode;

		}

	}

	return null;

};

/**
 *
 * A group of objects that receives a shared animation state.
 *
 * Usage:
 *
 * 	-	Add objects you would otherwise pass as 'root' to the
 * 		constructor or the .clipAction method of AnimationMixer.
 *
 * 	-	Instead pass this object as 'root'.
 *
 * 	-	You can also add and remove objects later when the mixer
 * 		is running.
 *
 * Note:
 *
 *  	Objects of this class appear as one object to the mixer,
 *  	so cache control of the individual objects must be done
 *  	on the group.
 *
 * Limitation:
 *
 * 	- 	The animated properties must be compatible among the
 * 		all objects in the group.
 *
 *  -	A single property can either be controlled through a
 *  	target group or directly, but not both.
 *
 * @author tschw
 */

function AnimationObjectGroup( var_args ) {

	this.uuid = _Math.generateUUID();

	// cached objects followed by the active ones
	this._objects = Array.prototype.slice.call( arguments );

	this.nCachedObjects_ = 0;			// threshold
	// note: read by PropertyBinding.Composite

	var indices = {};
	this._indicesByUUID = indices;		// for bookkeeping

	for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

		indices[ arguments[ i ].uuid ] = i;

	}

	this._paths = [];					// inside: string
	this._parsedPaths = [];				// inside: { we don't care, here }
	this._bindings = []; 				// inside: Array< PropertyBinding >
	this._bindingsIndicesByPath = {}; 	// inside: indices in these arrays

	var scope = this;

	this.stats = {

		objects: {
			get total() { return scope._objects.length; },
			get inUse() { return this.total - scope.nCachedObjects_;  }
		},

		get bindingsPerObject() { return scope._bindings.length; }

	};

}

AnimationObjectGroup.prototype = {

	constructor: AnimationObjectGroup,

	isAnimationObjectGroup: true,

	add: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			paths = this._paths,
			parsedPaths = this._parsedPaths,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ],
				knownObject = undefined;

			if ( index === undefined ) {

				// unknown object -> add it to the ACTIVE region

				index = nObjects ++;
				indicesByUUID[ uuid ] = index;
				objects.push( object );

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					bindings[ j ].push(
							new PropertyBinding(
								object, paths[ j ], parsedPaths[ j ] ) );

				}

			} else if ( index < nCachedObjects ) {

				knownObject = objects[ index ];

				// move existing object to the ACTIVE region

				var firstActiveIndex = -- nCachedObjects,
					lastCachedObject = objects[ firstActiveIndex ];

				indicesByUUID[ lastCachedObject.uuid ] = index;
				objects[ index ] = lastCachedObject;

				indicesByUUID[ uuid ] = firstActiveIndex;
				objects[ firstActiveIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						lastCached = bindingsForPath[ firstActiveIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = lastCached;

					if ( binding === undefined ) {

						// since we do not bother to create new bindings
						// for objects that are cached, the binding may
						// or may not exist

						binding = new PropertyBinding(
								object, paths[ j ], parsedPaths[ j ] );

					}

					bindingsForPath[ firstActiveIndex ] = binding;

				}

			} else if ( objects[ index ] !== knownObject) {

				console.error( "Different objects with the same UUID " +
						"detected. Clean the caches or recreate your " +
						"infrastructure when reloading scenes..." );

			} // else the object is already where we want it to be

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	remove: function( var_args ) {

		var objects = this._objects,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined && index >= nCachedObjects ) {

				// move existing object into the CACHED region

				var lastCachedIndex = nCachedObjects ++,
					firstActiveObject = objects[ lastCachedIndex ];

				indicesByUUID[ firstActiveObject.uuid ] = index;
				objects[ index ] = firstActiveObject;

				indicesByUUID[ uuid ] = lastCachedIndex;
				objects[ lastCachedIndex ] = object;

				// accounting is done, now do the same for all bindings

				for ( var j = 0, m = nBindings; j !== m; ++ j ) {

					var bindingsForPath = bindings[ j ],
						firstActive = bindingsForPath[ lastCachedIndex ],
						binding = bindingsForPath[ index ];

					bindingsForPath[ index ] = firstActive;
					bindingsForPath[ lastCachedIndex ] = binding;

				}

			}

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// remove & forget
	uncache: function( var_args ) {

		var objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			indicesByUUID = this._indicesByUUID,
			bindings = this._bindings,
			nBindings = bindings.length;

		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {

			var object = arguments[ i ],
				uuid = object.uuid,
				index = indicesByUUID[ uuid ];

			if ( index !== undefined ) {

				delete indicesByUUID[ uuid ];

				if ( index < nCachedObjects ) {

					// object is cached, shrink the CACHED region

					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ],
						lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					// last cached object takes this object's place
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;

					// last object goes to the activated slot and pop
					indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							last = bindingsForPath[ lastIndex ];

						bindingsForPath[ index ] = lastCached;
						bindingsForPath[ firstActiveIndex ] = last;
						bindingsForPath.pop();

					}

				} else {

					// object is active, just swap with the last and pop

					var lastIndex = -- nObjects,
						lastObject = objects[ lastIndex ];

					indicesByUUID[ lastObject.uuid ] = index;
					objects[ index ] = lastObject;
					objects.pop();

					// accounting is done, now do the same for all bindings

					for ( var j = 0, m = nBindings; j !== m; ++ j ) {

						var bindingsForPath = bindings[ j ];

						bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
						bindingsForPath.pop();

					}

				} // cached or active

			} // if object is known

		} // for arguments

		this.nCachedObjects_ = nCachedObjects;

	},

	// Internal interface used by befriended PropertyBinding.Composite:

	subscribe_: function( path, parsedPath ) {
		// returns an array of bindings for the given path that is changed
		// according to the contained objects in the group

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ],
			bindings = this._bindings;

		if ( index !== undefined ) return bindings[ index ];

		var paths = this._paths,
			parsedPaths = this._parsedPaths,
			objects = this._objects,
			nObjects = objects.length,
			nCachedObjects = this.nCachedObjects_,
			bindingsForPath = new Array( nObjects );

		index = bindings.length;

		indicesByPath[ path ] = index;

		paths.push( path );
		parsedPaths.push( parsedPath );
		bindings.push( bindingsForPath );

		for ( var i = nCachedObjects,
				n = objects.length; i !== n; ++ i ) {

			var object = objects[ i ];

			bindingsForPath[ i ] =
					new PropertyBinding( object, path, parsedPath );

		}

		return bindingsForPath;

	},

	unsubscribe_: function( path ) {
		// tells the group to forget about a property path and no longer
		// update the array previously obtained with 'subscribe_'

		var indicesByPath = this._bindingsIndicesByPath,
			index = indicesByPath[ path ];

		if ( index !== undefined ) {

			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				lastBindingsIndex = bindings.length - 1,
				lastBindings = bindings[ lastBindingsIndex ],
				lastBindingsPath = path[ lastBindingsIndex ];

			indicesByPath[ lastBindingsPath ] = index;

			bindings[ index ] = lastBindings;
			bindings.pop();

			parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
			parsedPaths.pop();

			paths[ index ] = paths[ lastBindingsIndex ];
			paths.pop();

		}

	}

};

/**
 *
 * Action provided by AnimationMixer for scheduling clip playback on specific
 * objects.
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 *
 */

function AnimationAction( mixer, clip, localRoot ) {

	this._mixer = mixer;
	this._clip = clip;
	this._localRoot = localRoot || null;

	var tracks = clip.tracks,
		nTracks = tracks.length,
		interpolants = new Array( nTracks );

	var interpolantSettings = {
			endingStart: 	ZeroCurvatureEnding,
			endingEnd:		ZeroCurvatureEnding
	};

	for ( var i = 0; i !== nTracks; ++ i ) {

		var interpolant = tracks[ i ].createInterpolant( null );
		interpolants[ i ] = interpolant;
		interpolant.settings = interpolantSettings;

	}

	this._interpolantSettings = interpolantSettings;

	this._interpolants = interpolants;	// bound by the mixer

	// inside: PropertyMixer (managed by the mixer)
	this._propertyBindings = new Array( nTracks );

	this._cacheIndex = null;			// for the memory manager
	this._byClipCacheIndex = null;		// for the memory manager

	this._timeScaleInterpolant = null;
	this._weightInterpolant = null;

	this.loop = LoopRepeat;
	this._loopCount = -1;

	// global mixer time when the action is to be started
	// it's set back to 'null' upon start of the action
	this._startTime = null;

	// scaled local time of the action
	// gets clamped or wrapped to 0..clip.duration according to loop
	this.time = 0;

	this.timeScale = 1;
	this._effectiveTimeScale = 1;

	this.weight = 1;
	this._effectiveWeight = 1;

	this.repetitions = Infinity; 		// no. of repetitions when looping

	this.paused = false;				// false -> zero effective time scale
	this.enabled = true;				// true -> zero effective weight

	this.clampWhenFinished 	= false;	// keep feeding the last frame?

	this.zeroSlopeAtStart 	= true;		// for smooth interpolation w/o separate
	this.zeroSlopeAtEnd		= true;		// clips for start, loop and end

}

AnimationAction.prototype = {

	constructor: AnimationAction,

	// State & Scheduling

	play: function() {

		this._mixer._activateAction( this );

		return this;

	},

	stop: function() {

		this._mixer._deactivateAction( this );

		return this.reset();

	},

	reset: function() {

		this.paused = false;
		this.enabled = true;

		this.time = 0;			// restart clip
		this._loopCount = -1;	// forget previous loops
		this._startTime = null;	// forget scheduling

		return this.stopFading().stopWarping();

	},

	isRunning: function() {

		return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );

	},

	// return true when play has been called
	isScheduled: function() {

		return this._mixer._isActiveAction( this );

	},

	startAt: function( time ) {

		this._startTime = time;

		return this;

	},

	setLoop: function( mode, repetitions ) {

		this.loop = mode;
		this.repetitions = repetitions;

		return this;

	},

	// Weight

	// set the weight stopping any scheduled fading
	// although .enabled = false yields an effective weight of zero, this
	// method does *not* change .enabled, because it would be confusing
	setEffectiveWeight: function( weight ) {

		this.weight = weight;

		// note: same logic as when updated at runtime
		this._effectiveWeight = this.enabled ? weight : 0;

		return this.stopFading();

	},

	// return the weight considering fading and .enabled
	getEffectiveWeight: function() {

		return this._effectiveWeight;

	},

	fadeIn: function( duration ) {

		return this._scheduleFading( duration, 0, 1 );

	},

	fadeOut: function( duration ) {

		return this._scheduleFading( duration, 1, 0 );

	},

	crossFadeFrom: function( fadeOutAction, duration, warp ) {

		fadeOutAction.fadeOut( duration );
		this.fadeIn( duration );

		if( warp ) {

			var fadeInDuration = this._clip.duration,
				fadeOutDuration = fadeOutAction._clip.duration,

				startEndRatio = fadeOutDuration / fadeInDuration,
				endStartRatio = fadeInDuration / fadeOutDuration;

			fadeOutAction.warp( 1.0, startEndRatio, duration );
			this.warp( endStartRatio, 1.0, duration );

		}

		return this;

	},

	crossFadeTo: function( fadeInAction, duration, warp ) {

		return fadeInAction.crossFadeFrom( this, duration, warp );

	},

	stopFading: function() {

		var weightInterpolant = this._weightInterpolant;

		if ( weightInterpolant !== null ) {

			this._weightInterpolant = null;
			this._mixer._takeBackControlInterpolant( weightInterpolant );

		}

		return this;

	},

	// Time Scale Control

	// set the weight stopping any scheduled warping
	// although .paused = true yields an effective time scale of zero, this
	// method does *not* change .paused, because it would be confusing
	setEffectiveTimeScale: function( timeScale ) {

		this.timeScale = timeScale;
		this._effectiveTimeScale = this.paused ? 0 :timeScale;

		return this.stopWarping();

	},

	// return the time scale considering warping and .paused
	getEffectiveTimeScale: function() {

		return this._effectiveTimeScale;

	},

	setDuration: function( duration ) {

		this.timeScale = this._clip.duration / duration;

		return this.stopWarping();

	},

	syncWith: function( action ) {

		this.time = action.time;
		this.timeScale = action.timeScale;

		return this.stopWarping();

	},

	halt: function( duration ) {

		return this.warp( this._effectiveTimeScale, 0, duration );

	},

	warp: function( startTimeScale, endTimeScale, duration ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._timeScaleInterpolant,

			timeScale = this.timeScale;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._timeScaleInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now;
		times[ 1 ] = now + duration;

		values[ 0 ] = startTimeScale / timeScale;
		values[ 1 ] = endTimeScale / timeScale;

		return this;

	},

	stopWarping: function() {

		var timeScaleInterpolant = this._timeScaleInterpolant;

		if ( timeScaleInterpolant !== null ) {

			this._timeScaleInterpolant = null;
			this._mixer._takeBackControlInterpolant( timeScaleInterpolant );

		}

		return this;

	},

	// Object Accessors

	getMixer: function() {

		return this._mixer;

	},

	getClip: function() {

		return this._clip;

	},

	getRoot: function() {

		return this._localRoot || this._mixer._root;

	},

	// Interna

	_update: function( time, deltaTime, timeDirection, accuIndex ) {
		// called by the mixer

		var startTime = this._startTime;

		if ( startTime !== null ) {

			// check for scheduled start of action

			var timeRunning = ( time - startTime ) * timeDirection;
			if ( timeRunning < 0 || timeDirection === 0 ) {

				return; // yet to come / don't decide when delta = 0

			}

			// start

			this._startTime = null; // unschedule
			deltaTime = timeDirection * timeRunning;

		}

		// apply time scale and advance time

		deltaTime *= this._updateTimeScale( time );
		var clipTime = this._updateTime( deltaTime );

		// note: _updateTime may disable the action resulting in
		// an effective weight of 0

		var weight = this._updateWeight( time );

		if ( weight > 0 ) {

			var interpolants = this._interpolants;
			var propertyMixers = this._propertyBindings;

			for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {

				interpolants[ j ].evaluate( clipTime );
				propertyMixers[ j ].accumulate( accuIndex, weight );

			}

		}

	},

	_updateWeight: function( time ) {

		var weight = 0;

		if ( this.enabled ) {

			weight = this.weight;
			var interpolant = this._weightInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				weight *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopFading();

					if ( interpolantValue === 0 ) {

						// faded out, disable
						this.enabled = false;

					}

				}

			}

		}

		this._effectiveWeight = weight;
		return weight;

	},

	_updateTimeScale: function( time ) {

		var timeScale = 0;

		if ( ! this.paused ) {

			timeScale = this.timeScale;

			var interpolant = this._timeScaleInterpolant;

			if ( interpolant !== null ) {

				var interpolantValue = interpolant.evaluate( time )[ 0 ];

				timeScale *= interpolantValue;

				if ( time > interpolant.parameterPositions[ 1 ] ) {

					this.stopWarping();

					if ( timeScale === 0 ) {

						// motion has halted, pause
						this.paused = true;

					} else {

						// warp done - apply final time scale
						this.timeScale = timeScale;

					}

				}

			}

		}

		this._effectiveTimeScale = timeScale;
		return timeScale;

	},

	_updateTime: function( deltaTime ) {

		var time = this.time + deltaTime;

		if ( deltaTime === 0 ) return time;

		var duration = this._clip.duration,

			loop = this.loop,
			loopCount = this._loopCount;

		if ( loop === LoopOnce ) {

			if ( loopCount === -1 ) {
				// just started

				this._loopCount = 0;
				this._setEndings( true, true, false );

			}

			handle_stop: {

				if ( time >= duration ) {

					time = duration;

				} else if ( time < 0 ) {

					time = 0;

				} else break handle_stop;

				if ( this.clampWhenFinished ) this.paused = true;
				else this.enabled = false;

				this._mixer.dispatchEvent( {
					type: 'finished', action: this,
					direction: deltaTime < 0 ? -1 : 1
				} );

			}

		} else { // repetitive Repeat or PingPong

			var pingPong = ( loop === LoopPingPong );

			if ( loopCount === -1 ) {
				// just started

				if ( deltaTime >= 0 ) {

					loopCount = 0;

					this._setEndings(
							true, this.repetitions === 0, pingPong );

				} else {

					// when looping in reverse direction, the initial
					// transition through zero counts as a repetition,
					// so leave loopCount at -1

					this._setEndings(
							this.repetitions === 0, true, pingPong );

				}

			}

			if ( time >= duration || time < 0 ) {
				// wrap around

				var loopDelta = Math.floor( time / duration ); // signed
				time -= duration * loopDelta;

				loopCount += Math.abs( loopDelta );

				var pending = this.repetitions - loopCount;

				if ( pending < 0 ) {
					// have to stop (switch state, clamp time, fire event)

					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;

					time = deltaTime > 0 ? duration : 0;

					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime > 0 ? 1 : -1
					} );

				} else {
					// keep running

					if ( pending === 0 ) {
						// entering the last round

						var atStart = deltaTime < 0;
						this._setEndings( atStart, ! atStart, pingPong );

					} else {

						this._setEndings( false, false, pingPong );

					}

					this._loopCount = loopCount;

					this._mixer.dispatchEvent( {
						type: 'loop', action: this, loopDelta: loopDelta
					} );

				}

			}

			if ( pingPong && ( loopCount & 1 ) === 1 ) {
				// invert time for the "pong round"

				this.time = time;
				return duration - time;

			}

		}

		this.time = time;
		return time;

	},

	_setEndings: function( atStart, atEnd, pingPong ) {

		var settings = this._interpolantSettings;

		if ( pingPong ) {

			settings.endingStart 	= ZeroSlopeEnding;
			settings.endingEnd		= ZeroSlopeEnding;

		} else {

			// assuming for LoopOnce atStart == atEnd == true

			if ( atStart ) {

				settings.endingStart = this.zeroSlopeAtStart ?
						ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingStart = WrapAroundEnding;

			}

			if ( atEnd ) {

				settings.endingEnd = this.zeroSlopeAtEnd ?
						ZeroSlopeEnding : ZeroCurvatureEnding;

			} else {

				settings.endingEnd 	 = WrapAroundEnding;

			}

		}

	},

	_scheduleFading: function( duration, weightNow, weightThen ) {

		var mixer = this._mixer, now = mixer.time,
			interpolant = this._weightInterpolant;

		if ( interpolant === null ) {

			interpolant = mixer._lendControlInterpolant();
			this._weightInterpolant = interpolant;

		}

		var times = interpolant.parameterPositions,
			values = interpolant.sampleValues;

		times[ 0 ] = now; 				values[ 0 ] = weightNow;
		times[ 1 ] = now + duration;	values[ 1 ] = weightThen;

		return this;

	}

};

/**
 *
 * Player for AnimationClips.
 *
 *
 * @author Ben Houston / http://clara.io/
 * @author David Sarno / http://lighthaus.us/
 * @author tschw
 */

function AnimationMixer( root ) {

	this._root = root;
	this._initMemoryManager();
	this._accuIndex = 0;

	this.time = 0;

	this.timeScale = 1.0;

}

Object.assign( AnimationMixer.prototype, EventDispatcher.prototype, {

	// return an action for a clip optionally using a custom root target
	// object (this method allocates a lot of dynamic memory in case a
	// previously unknown clip/root combination is specified)
	clipAction: function( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject !== null ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ],
			prototypeAction = null;

		if ( actionsForClip !== undefined ) {

			var existingAction =
					actionsForClip.actionByRoot[ rootUuid ];

			if ( existingAction !== undefined ) {

				return existingAction;

			}

			// we know the clip, so we don't have to parse all
			// the bindings again but can just copy
			prototypeAction = actionsForClip.knownActions[ 0 ];

			// also, take the clip from the prototype action
			if ( clipObject === null )
				clipObject = prototypeAction._clip;

		}

		// clip must be known when specified via string
		if ( clipObject === null ) return null;

		// allocate all resources required to run it
		var newAction = new AnimationAction( this, clipObject, optionalRoot );

		this._bindAction( newAction, prototypeAction );

		// and make the action known to the memory manager
		this._addInactiveAction( newAction, clipUuid, rootUuid );

		return newAction;

	},

	// get an existing action
	existingAction: function( clip, optionalRoot ) {

		var root = optionalRoot || this._root,
			rootUuid = root.uuid,

			clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,

			clipUuid = clipObject ? clipObject.uuid : clip,

			actionsForClip = this._actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			return actionsForClip.actionByRoot[ rootUuid ] || null;

		}

		return null;

	},

	// deactivates all previously scheduled actions
	stopAllAction: function() {

		var actions = this._actions,
			nActions = this._nActiveActions,
			bindings = this._bindings,
			nBindings = this._nActiveBindings;

		this._nActiveActions = 0;
		this._nActiveBindings = 0;

		for ( var i = 0; i !== nActions; ++ i ) {

			actions[ i ].reset();

		}

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].useCount = 0;

		}

		return this;

	},

	// advance the time and update apply the animation
	update: function( deltaTime ) {

		deltaTime *= this.timeScale;

		var actions = this._actions,
			nActions = this._nActiveActions,

			time = this.time += deltaTime,
			timeDirection = Math.sign( deltaTime ),

			accuIndex = this._accuIndex ^= 1;

		// run active actions

		for ( var i = 0; i !== nActions; ++ i ) {

			var action = actions[ i ];

			if ( action.enabled ) {

				action._update( time, deltaTime, timeDirection, accuIndex );

			}

		}

		// update scene graph

		var bindings = this._bindings,
			nBindings = this._nActiveBindings;

		for ( var i = 0; i !== nBindings; ++ i ) {

			bindings[ i ].apply( accuIndex );

		}

		return this;

	},

	// return this mixer's root target object
	getRoot: function() {

		return this._root;

	},

	// free all resources specific to a particular clip
	uncacheClip: function( clip ) {

		var actions = this._actions,
			clipUuid = clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip !== undefined ) {

			// note: just calling _removeInactiveAction would mess up the
			// iteration state and also require updating the state we can
			// just throw away

			var actionsToRemove = actionsForClip.knownActions;

			for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {

				var action = actionsToRemove[ i ];

				this._deactivateAction( action );

				var cacheIndex = action._cacheIndex,
					lastInactiveAction = actions[ actions.length - 1 ];

				action._cacheIndex = null;
				action._byClipCacheIndex = null;

				lastInactiveAction._cacheIndex = cacheIndex;
				actions[ cacheIndex ] = lastInactiveAction;
				actions.pop();

				this._removeInactiveBindingsForAction( action );

			}

			delete actionsByClip[ clipUuid ];

		}

	},

	// free all resources specific to a particular root target object
	uncacheRoot: function( root ) {

		var rootUuid = root.uuid,
			actionsByClip = this._actionsByClip;

		for ( var clipUuid in actionsByClip ) {

			var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
				action = actionByRoot[ rootUuid ];

			if ( action !== undefined ) {

				this._deactivateAction( action );
				this._removeInactiveAction( action );

			}

		}

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ];

		if ( bindingByName !== undefined ) {

			for ( var trackName in bindingByName ) {

				var binding = bindingByName[ trackName ];
				binding.restoreOriginalState();
				this._removeInactiveBinding( binding );

			}

		}

	},

	// remove a targeted clip from the cache
	uncacheAction: function( clip, optionalRoot ) {

		var action = this.existingAction( clip, optionalRoot );

		if ( action !== null ) {

			this._deactivateAction( action );
			this._removeInactiveAction( action );

		}

	}

} );

// Implementation details:

Object.assign( AnimationMixer.prototype, {

	_bindAction: function( action, prototypeAction ) {

		var root = action._localRoot || this._root,
			tracks = action._clip.tracks,
			nTracks = tracks.length,
			bindings = action._propertyBindings,
			interpolants = action._interpolants,
			rootUuid = root.uuid,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingsByName = bindingsByRoot[ rootUuid ];

		if ( bindingsByName === undefined ) {

			bindingsByName = {};
			bindingsByRoot[ rootUuid ] = bindingsByName;

		}

		for ( var i = 0; i !== nTracks; ++ i ) {

			var track = tracks[ i ],
				trackName = track.name,
				binding = bindingsByName[ trackName ];

			if ( binding !== undefined ) {

				bindings[ i ] = binding;

			} else {

				binding = bindings[ i ];

				if ( binding !== undefined ) {

					// existing binding, make sure the cache knows

					if ( binding._cacheIndex === null ) {

						++ binding.referenceCount;
						this._addInactiveBinding( binding, rootUuid, trackName );

					}

					continue;

				}

				var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;

				binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );

				++ binding.referenceCount;
				this._addInactiveBinding( binding, rootUuid, trackName );

				bindings[ i ] = binding;

			}

			interpolants[ i ].resultBuffer = binding.buffer;

		}

	},

	_activateAction: function( action ) {

		if ( ! this._isActiveAction( action ) ) {

			if ( action._cacheIndex === null ) {

				// this action has been forgotten by the cache, but the user
				// appears to be still using it -> rebind

				var rootUuid = ( action._localRoot || this._root ).uuid,
					clipUuid = action._clip.uuid,
					actionsForClip = this._actionsByClip[ clipUuid ];

				this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );

				this._addInactiveAction( action, clipUuid, rootUuid );

			}

			var bindings = action._propertyBindings;

			// increment reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( binding.useCount ++ === 0 ) {

					this._lendBinding( binding );
					binding.saveOriginalState();

				}

			}

			this._lendAction( action );

		}

	},

	_deactivateAction: function( action ) {

		if ( this._isActiveAction( action ) ) {

			var bindings = action._propertyBindings;

			// decrement reference counts / sort out state
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

				var binding = bindings[ i ];

				if ( -- binding.useCount === 0 ) {

					binding.restoreOriginalState();
					this._takeBackBinding( binding );

				}

			}

			this._takeBackAction( action );

		}

	},

	// Memory manager

	_initMemoryManager: function() {

		this._actions = []; // 'nActiveActions' followed by inactive ones
		this._nActiveActions = 0;

		this._actionsByClip = {};
		// inside:
		// {
		// 		knownActions: Array< AnimationAction >	- used as prototypes
		// 		actionByRoot: AnimationAction			- lookup
		// }


		this._bindings = []; // 'nActiveBindings' followed by inactive ones
		this._nActiveBindings = 0;

		this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >


		this._controlInterpolants = []; // same game as above
		this._nActiveControlInterpolants = 0;

		var scope = this;

		this.stats = {

			actions: {
				get total() { return scope._actions.length; },
				get inUse() { return scope._nActiveActions; }
			},
			bindings: {
				get total() { return scope._bindings.length; },
				get inUse() { return scope._nActiveBindings; }
			},
			controlInterpolants: {
				get total() { return scope._controlInterpolants.length; },
				get inUse() { return scope._nActiveControlInterpolants; }
			}

		};

	},

	// Memory management for AnimationAction objects

	_isActiveAction: function( action ) {

		var index = action._cacheIndex;
		return index !== null && index < this._nActiveActions;

	},

	_addInactiveAction: function( action, clipUuid, rootUuid ) {

		var actions = this._actions,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ];

		if ( actionsForClip === undefined ) {

			actionsForClip = {

				knownActions: [ action ],
				actionByRoot: {}

			};

			action._byClipCacheIndex = 0;

			actionsByClip[ clipUuid ] = actionsForClip;

		} else {

			var knownActions = actionsForClip.knownActions;

			action._byClipCacheIndex = knownActions.length;
			knownActions.push( action );

		}

		action._cacheIndex = actions.length;
		actions.push( action );

		actionsForClip.actionByRoot[ rootUuid ] = action;

	},

	_removeInactiveAction: function( action ) {

		var actions = this._actions,
			lastInactiveAction = actions[ actions.length - 1 ],
			cacheIndex = action._cacheIndex;

		lastInactiveAction._cacheIndex = cacheIndex;
		actions[ cacheIndex ] = lastInactiveAction;
		actions.pop();

		action._cacheIndex = null;


		var clipUuid = action._clip.uuid,
			actionsByClip = this._actionsByClip,
			actionsForClip = actionsByClip[ clipUuid ],
			knownActionsForClip = actionsForClip.knownActions,

			lastKnownAction =
				knownActionsForClip[ knownActionsForClip.length - 1 ],

			byClipCacheIndex = action._byClipCacheIndex;

		lastKnownAction._byClipCacheIndex = byClipCacheIndex;
		knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
		knownActionsForClip.pop();

		action._byClipCacheIndex = null;


		var actionByRoot = actionsForClip.actionByRoot,
			rootUuid = ( actions._localRoot || this._root ).uuid;

		delete actionByRoot[ rootUuid ];

		if ( knownActionsForClip.length === 0 ) {

			delete actionsByClip[ clipUuid ];

		}

		this._removeInactiveBindingsForAction( action );

	},

	_removeInactiveBindingsForAction: function( action ) {

		var bindings = action._propertyBindings;
		for ( var i = 0, n = bindings.length; i !== n; ++ i ) {

			var binding = bindings[ i ];

			if ( -- binding.referenceCount === 0 ) {

				this._removeInactiveBinding( binding );

			}

		}

	},

	_lendAction: function( action ) {

		// [ active actions |  inactive actions  ]
		// [  active actions >| inactive actions ]
		//                 s        a
		//                  <-swap->
		//                 a        s

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			lastActiveIndex = this._nActiveActions ++,

			firstInactiveAction = actions[ lastActiveIndex ];

		action._cacheIndex = lastActiveIndex;
		actions[ lastActiveIndex ] = action;

		firstInactiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = firstInactiveAction;

	},

	_takeBackAction: function( action ) {

		// [  active actions  | inactive actions ]
		// [ active actions |< inactive actions  ]
		//        a        s
		//         <-swap->
		//        s        a

		var actions = this._actions,
			prevIndex = action._cacheIndex,

			firstInactiveIndex = -- this._nActiveActions,

			lastActiveAction = actions[ firstInactiveIndex ];

		action._cacheIndex = firstInactiveIndex;
		actions[ firstInactiveIndex ] = action;

		lastActiveAction._cacheIndex = prevIndex;
		actions[ prevIndex ] = lastActiveAction;

	},

	// Memory management for PropertyMixer objects

	_addInactiveBinding: function( binding, rootUuid, trackName ) {

		var bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			bindings = this._bindings;

		if ( bindingByName === undefined ) {

			bindingByName = {};
			bindingsByRoot[ rootUuid ] = bindingByName;

		}

		bindingByName[ trackName ] = binding;

		binding._cacheIndex = bindings.length;
		bindings.push( binding );

	},

	_removeInactiveBinding: function( binding ) {

		var bindings = this._bindings,
			propBinding = binding.binding,
			rootUuid = propBinding.rootNode.uuid,
			trackName = propBinding.path,
			bindingsByRoot = this._bindingsByRootAndName,
			bindingByName = bindingsByRoot[ rootUuid ],

			lastInactiveBinding = bindings[ bindings.length - 1 ],
			cacheIndex = binding._cacheIndex;

		lastInactiveBinding._cacheIndex = cacheIndex;
		bindings[ cacheIndex ] = lastInactiveBinding;
		bindings.pop();

		delete bindingByName[ trackName ];

		remove_empty_map: {

			for ( var _ in bindingByName ) break remove_empty_map;

			delete bindingsByRoot[ rootUuid ];

		}

	},

	_lendBinding: function( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			lastActiveIndex = this._nActiveBindings ++,

			firstInactiveBinding = bindings[ lastActiveIndex ];

		binding._cacheIndex = lastActiveIndex;
		bindings[ lastActiveIndex ] = binding;

		firstInactiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = firstInactiveBinding;

	},

	_takeBackBinding: function( binding ) {

		var bindings = this._bindings,
			prevIndex = binding._cacheIndex,

			firstInactiveIndex = -- this._nActiveBindings,

			lastActiveBinding = bindings[ firstInactiveIndex ];

		binding._cacheIndex = firstInactiveIndex;
		bindings[ firstInactiveIndex ] = binding;

		lastActiveBinding._cacheIndex = prevIndex;
		bindings[ prevIndex ] = lastActiveBinding;

	},


	// Memory management of Interpolants for weight and time scale

	_lendControlInterpolant: function() {

		var interpolants = this._controlInterpolants,
			lastActiveIndex = this._nActiveControlInterpolants ++,
			interpolant = interpolants[ lastActiveIndex ];

		if ( interpolant === undefined ) {

			interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
						1, this._controlInterpolantsResultBuffer );

			interpolant.__cacheIndex = lastActiveIndex;
			interpolants[ lastActiveIndex ] = interpolant;

		}

		return interpolant;

	},

	_takeBackControlInterpolant: function( interpolant ) {

		var interpolants = this._controlInterpolants,
			prevIndex = interpolant.__cacheIndex,

			firstInactiveIndex = -- this._nActiveControlInterpolants,

			lastActiveInterpolant = interpolants[ firstInactiveIndex ];

		interpolant.__cacheIndex = firstInactiveIndex;
		interpolants[ firstInactiveIndex ] = interpolant;

		lastActiveInterpolant.__cacheIndex = prevIndex;
		interpolants[ prevIndex ] = lastActiveInterpolant;

	},

	_controlInterpolantsResultBuffer: new Float32Array( 1 )

} );

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Uniform( value ) {

	if ( typeof value === 'string' ) {

		console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
		value = arguments[ 1 ];

	}

	this.value = value;

}

Uniform.prototype.clone = function () {

	return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferGeometry() {

	BufferGeometry.call( this );

	this.type = 'InstancedBufferGeometry';
	this.maxInstancedCount = undefined;

}

InstancedBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
InstancedBufferGeometry.prototype.constructor = InstancedBufferGeometry;

InstancedBufferGeometry.prototype.isInstancedBufferGeometry = true;

InstancedBufferGeometry.prototype.addGroup = function ( start, count, materialIndex ) {

	this.groups.push( {

		start: start,
		count: count,
		materialIndex: materialIndex

	} );

};

InstancedBufferGeometry.prototype.copy = function ( source ) {

	var index = source.index;

	if ( index !== null ) {

		this.setIndex( index.clone() );

	}

	var attributes = source.attributes;

	for ( var name in attributes ) {

		var attribute = attributes[ name ];
		this.addAttribute( name, attribute.clone() );

	}

	var groups = source.groups;

	for ( var i = 0, l = groups.length; i < l; i ++ ) {

		var group = groups[ i ];
		this.addGroup( group.start, group.count, group.materialIndex );

	}

	return this;

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {

	this.uuid = _Math.generateUUID();

	this.data = interleavedBuffer;
	this.itemSize = itemSize;
	this.offset = offset;

	this.normalized = normalized === true;

}


InterleavedBufferAttribute.prototype = {

	constructor: InterleavedBufferAttribute,

	isInterleavedBufferAttribute: true,

	get count() {

		return this.data.count;

	},

	get array() {

		return this.data.array;

	},

	setX: function ( index, x ) {

		this.data.array[ index * this.data.stride + this.offset ] = x;

		return this;

	},

	setY: function ( index, y ) {

		this.data.array[ index * this.data.stride + this.offset + 1 ] = y;

		return this;

	},

	setZ: function ( index, z ) {

		this.data.array[ index * this.data.stride + this.offset + 2 ] = z;

		return this;

	},

	setW: function ( index, w ) {

		this.data.array[ index * this.data.stride + this.offset + 3 ] = w;

		return this;

	},

	getX: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset ];

	},

	getY: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 1 ];

	},

	getZ: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 2 ];

	},

	getW: function ( index ) {

		return this.data.array[ index * this.data.stride + this.offset + 3 ];

	},

	setXY: function ( index, x, y ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;

		return this;

	},

	setXYZ: function ( index, x, y, z ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;

		return this;

	},

	setXYZW: function ( index, x, y, z, w ) {

		index = index * this.data.stride + this.offset;

		this.data.array[ index + 0 ] = x;
		this.data.array[ index + 1 ] = y;
		this.data.array[ index + 2 ] = z;
		this.data.array[ index + 3 ] = w;

		return this;

	}

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InterleavedBuffer( array, stride ) {

	this.uuid = _Math.generateUUID();

	this.array = array;
	this.stride = stride;
	this.count = array !== undefined ? array.length / stride : 0;

	this.dynamic = false;
	this.updateRange = { offset: 0, count: - 1 };

	this.onUploadCallback = function () {};

	this.version = 0;

}

InterleavedBuffer.prototype = {

	constructor: InterleavedBuffer,

	isInterleavedBuffer: true,

	set needsUpdate( value ) {

		if ( value === true ) this.version ++;

	},

	setArray: function ( array ) {

		if ( Array.isArray( array ) ) {

			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );

		}

		this.count = array !== undefined ? array.length / this.stride : 0;
		this.array = array;

	},

	setDynamic: function ( value ) {

		this.dynamic = value;

		return this;

	},

	copy: function ( source ) {

		this.array = new source.array.constructor( source.array );
		this.count = source.count;
		this.stride = source.stride;
		this.dynamic = source.dynamic;

		return this;

	},

	copyAt: function ( index1, attribute, index2 ) {

		index1 *= this.stride;
		index2 *= attribute.stride;

		for ( var i = 0, l = this.stride; i < l; i ++ ) {

			this.array[ index1 + i ] = attribute.array[ index2 + i ];

		}

		return this;

	},

	set: function ( value, offset ) {

		if ( offset === undefined ) offset = 0;

		this.array.set( value, offset );

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	onUpload: function ( callback ) {

		this.onUploadCallback = callback;

		return this;

	}

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {

	InterleavedBuffer.call( this, array, stride );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedInterleavedBuffer.prototype = Object.create( InterleavedBuffer.prototype );
InstancedInterleavedBuffer.prototype.constructor = InstancedInterleavedBuffer;

InstancedInterleavedBuffer.prototype.isInstancedInterleavedBuffer = true;

InstancedInterleavedBuffer.prototype.copy = function ( source ) {

	InterleavedBuffer.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

/**
 * @author benaadams / https://twitter.com/ben_a_adams
 */

function InstancedBufferAttribute( array, itemSize, meshPerAttribute ) {

	BufferAttribute.call( this, array, itemSize );

	this.meshPerAttribute = meshPerAttribute || 1;

}

InstancedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
InstancedBufferAttribute.prototype.constructor = InstancedBufferAttribute;

InstancedBufferAttribute.prototype.isInstancedBufferAttribute = true;

InstancedBufferAttribute.prototype.copy = function ( source ) {

	BufferAttribute.prototype.copy.call( this, source );

	this.meshPerAttribute = source.meshPerAttribute;

	return this;

};

/**
 * @author mrdoob / http://mrdoob.com/
 * @author bhouston / http://clara.io/
 * @author stephomi / http://stephaneginier.com/
 */

function Raycaster( origin, direction, near, far ) {

	this.ray = new Ray( origin, direction );
	// direction is assumed to be normalized (for accurate distance calculations)

	this.near = near || 0;
	this.far = far || Infinity;

	this.params = {
		Mesh: {},
		Line: {},
		LOD: {},
		Points: { threshold: 1 },
		Sprite: {}
	};

	Object.defineProperties( this.params, {
		PointCloud: {
			get: function () {
				console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
				return this.Points;
			}
		}
	} );

}

function ascSort( a, b ) {

	return a.distance - b.distance;

}

function intersectObject( object, raycaster, intersects, recursive ) {

	if ( object.visible === false ) return;

	object.raycast( raycaster, intersects );

	if ( recursive === true ) {

		var children = object.children;

		for ( var i = 0, l = children.length; i < l; i ++ ) {

			intersectObject( children[ i ], raycaster, intersects, true );

		}

	}

}

//

Raycaster.prototype = {

	constructor: Raycaster,

	linePrecision: 1,

	set: function ( origin, direction ) {

		// direction is assumed to be normalized (for accurate distance calculations)

		this.ray.set( origin, direction );

	},

	setFromCamera: function ( coords, camera ) {

		if ( (camera && camera.isPerspectiveCamera) ) {

			this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
			this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();

		} else if ( (camera && camera.isOrthographicCamera) ) {

			this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
			this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );

		} else {

			console.error( 'THREE.Raycaster: Unsupported camera type.' );

		}

	},

	intersectObject: function ( object, recursive ) {

		var intersects = [];

		intersectObject( object, this, intersects, recursive );

		intersects.sort( ascSort );

		return intersects;

	},

	intersectObjects: function ( objects, recursive ) {

		var intersects = [];

		if ( Array.isArray( objects ) === false ) {

			console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
			return intersects;

		}

		for ( var i = 0, l = objects.length; i < l; i ++ ) {

			intersectObject( objects[ i ], this, intersects, recursive );

		}

		intersects.sort( ascSort );

		return intersects;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function Clock( autoStart ) {

	this.autoStart = ( autoStart !== undefined ) ? autoStart : true;

	this.startTime = 0;
	this.oldTime = 0;
	this.elapsedTime = 0;

	this.running = false;

}

Clock.prototype = {

	constructor: Clock,

	start: function () {

		this.startTime = ( performance || Date ).now();

		this.oldTime = this.startTime;
		this.elapsedTime = 0;
		this.running = true;

	},

	stop: function () {

		this.getElapsedTime();
		this.running = false;

	},

	getElapsedTime: function () {

		this.getDelta();
		return this.elapsedTime;

	},

	getDelta: function () {

		var diff = 0;

		if ( this.autoStart && ! this.running ) {

			this.start();

		}

		if ( this.running ) {

			var newTime = ( performance || Date ).now();

			diff = ( newTime - this.oldTime ) / 1000;
			this.oldTime = newTime;

			this.elapsedTime += diff;

		}

		return diff;

	}

};

/**
 * Spline from Tween.js, slightly optimized (and trashed)
 * http://sole.github.com/tween.js/examples/05_spline.html
 *
 * @author mrdoob / http://mrdoob.com/
 * @author alteredq / http://alteredqualia.com/
 */

function Spline( points ) {

	this.points = points;

	var c = [], v3 = { x: 0, y: 0, z: 0 },
	point, intPoint, weight, w2, w3,
	pa, pb, pc, pd;

	this.initFromArray = function ( a ) {

		this.points = [];

		for ( var i = 0; i < a.length; i ++ ) {

			this.points[ i ] = { x: a[ i ][ 0 ], y: a[ i ][ 1 ], z: a[ i ][ 2 ] };

		}

	};

	this.getPoint = function ( k ) {

		point = ( this.points.length - 1 ) * k;
		intPoint = Math.floor( point );
		weight = point - intPoint;

		c[ 0 ] = intPoint === 0 ? intPoint : intPoint - 1;
		c[ 1 ] = intPoint;
		c[ 2 ] = intPoint  > this.points.length - 2 ? this.points.length - 1 : intPoint + 1;
		c[ 3 ] = intPoint  > this.points.length - 3 ? this.points.length - 1 : intPoint + 2;

		pa = this.points[ c[ 0 ] ];
		pb = this.points[ c[ 1 ] ];
		pc = this.points[ c[ 2 ] ];
		pd = this.points[ c[ 3 ] ];

		w2 = weight * weight;
		w3 = weight * w2;

		v3.x = interpolate( pa.x, pb.x, pc.x, pd.x, weight, w2, w3 );
		v3.y = interpolate( pa.y, pb.y, pc.y, pd.y, weight, w2, w3 );
		v3.z = interpolate( pa.z, pb.z, pc.z, pd.z, weight, w2, w3 );

		return v3;

	};

	this.getControlPointsArray = function () {

		var i, p, l = this.points.length,
			coords = [];

		for ( i = 0; i < l; i ++ ) {

			p = this.points[ i ];
			coords[ i ] = [ p.x, p.y, p.z ];

		}

		return coords;

	};

	// approximate length by summing linear segments

	this.getLength = function ( nSubDivisions ) {

		var i, index, nSamples, position,
			point = 0, intPoint = 0, oldIntPoint = 0,
			oldPosition = new Vector3(),
			tmpVec = new Vector3(),
			chunkLengths = [],
			totalLength = 0;

		// first point has 0 length

		chunkLengths[ 0 ] = 0;

		if ( ! nSubDivisions ) nSubDivisions = 100;

		nSamples = this.points.length * nSubDivisions;

		oldPosition.copy( this.points[ 0 ] );

		for ( i = 1; i < nSamples; i ++ ) {

			index = i / nSamples;

			position = this.getPoint( index );
			tmpVec.copy( position );

			totalLength += tmpVec.distanceTo( oldPosition );

			oldPosition.copy( position );

			point = ( this.points.length - 1 ) * index;
			intPoint = Math.floor( point );

			if ( intPoint !== oldIntPoint ) {

				chunkLengths[ intPoint ] = totalLength;
				oldIntPoint = intPoint;

			}

		}

		// last point ends with total length

		chunkLengths[ chunkLengths.length ] = totalLength;

		return { chunks: chunkLengths, total: totalLength };

	};

	this.reparametrizeByArcLength = function ( samplingCoef ) {

		var i, j,
			index, indexCurrent, indexNext,
			realDistance,
			sampling, position,
			newpoints = [],
			tmpVec = new Vector3(),
			sl = this.getLength();

		newpoints.push( tmpVec.copy( this.points[ 0 ] ).clone() );

		for ( i = 1; i < this.points.length; i ++ ) {

			//tmpVec.copy( this.points[ i - 1 ] );
			//linearDistance = tmpVec.distanceTo( this.points[ i ] );

			realDistance = sl.chunks[ i ] - sl.chunks[ i - 1 ];

			sampling = Math.ceil( samplingCoef * realDistance / sl.total );

			indexCurrent = ( i - 1 ) / ( this.points.length - 1 );
			indexNext = i / ( this.points.length - 1 );

			for ( j = 1; j < sampling - 1; j ++ ) {

				index = indexCurrent + j * ( 1 / sampling ) * ( indexNext - indexCurrent );

				position = this.getPoint( index );
				newpoints.push( tmpVec.copy( position ).clone() );

			}

			newpoints.push( tmpVec.copy( this.points[ i ] ).clone() );

		}

		this.points = newpoints;

	};

	// Catmull-Rom

	function interpolate( p0, p1, p2, p3, t, t2, t3 ) {

		var v0 = ( p2 - p0 ) * 0.5,
			v1 = ( p3 - p1 ) * 0.5;

		return ( 2 * ( p1 - p2 ) + v0 + v1 ) * t3 + ( - 3 * ( p1 - p2 ) - 2 * v0 - v1 ) * t2 + v0 * t + p1;

	}

}

/**
 * @author bhouston / http://clara.io
 * @author WestLangley / http://github.com/WestLangley
 *
 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
 *
 * The poles (phi) are at the positive and negative y axis.
 * The equator starts at positive z.
 */

function Spherical( radius, phi, theta ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0;
	this.phi = ( phi !== undefined ) ? phi : 0; // up / down towards top and bottom pole
	this.theta = ( theta !== undefined ) ? theta : 0; // around the equator of the sphere

	return this;

}

Spherical.prototype = {

	constructor: Spherical,

	set: function ( radius, phi, theta ) {

		this.radius = radius;
		this.phi = phi;
		this.theta = theta;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius = other.radius;
		this.phi = other.phi;
		this.theta = other.theta;

		return this;

	},

	// restrict phi to be betwee EPS and PI-EPS
	makeSafe: function() {

		var EPS = 0.000001;
		this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );

		return this;

	},

	setFromVector3: function( vec3 ) {

		this.radius = vec3.length();

		if ( this.radius === 0 ) {

			this.theta = 0;
			this.phi = 0;

		} else {

			this.theta = Math.atan2( vec3.x, vec3.z ); // equator angle around y-up axis
			this.phi = Math.acos( _Math.clamp( vec3.y / this.radius, - 1, 1 ) ); // polar angle

		}

		return this;

	}

};

/**
 * @author Mugen87 / https://github.com/Mugen87
 *
 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
 *
 */

function Cylindrical( radius, theta, y ) {

	this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
	this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
	this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane

	return this;

}

Cylindrical.prototype = {

	constructor: Cylindrical,

	set: function ( radius, theta, y ) {

		this.radius = radius;
		this.theta = theta;
		this.y = y;

		return this;

	},

	clone: function () {

		return new this.constructor().copy( this );

	},

	copy: function ( other ) {

		this.radius = other.radius;
		this.theta = other.theta;
		this.y = other.y;

		return this;

	},

	setFromVector3: function( vec3 ) {

		this.radius = Math.sqrt( vec3.x * vec3.x + vec3.z * vec3.z );
		this.theta = Math.atan2( vec3.x, vec3.z );
		this.y = vec3.y;

		return this;

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function MorphBlendMesh( geometry, material ) {

	Mesh.call( this, geometry, material );

	this.animationsMap = {};
	this.animationsList = [];

	// prepare default animation
	// (all frames played together in 1 second)

	var numFrames = this.geometry.morphTargets.length;

	var name = "__default";

	var startFrame = 0;
	var endFrame = numFrames - 1;

	var fps = numFrames / 1;

	this.createAnimation( name, startFrame, endFrame, fps );
	this.setAnimationWeight( name, 1 );

}

MorphBlendMesh.prototype = Object.create( Mesh.prototype );
MorphBlendMesh.prototype.constructor = MorphBlendMesh;

MorphBlendMesh.prototype.createAnimation = function ( name, start, end, fps ) {

	var animation = {

		start: start,
		end: end,

		length: end - start + 1,

		fps: fps,
		duration: ( end - start ) / fps,

		lastFrame: 0,
		currentFrame: 0,

		active: false,

		time: 0,
		direction: 1,
		weight: 1,

		directionBackwards: false,
		mirroredLoop: false

	};

	this.animationsMap[ name ] = animation;
	this.animationsList.push( animation );

};

MorphBlendMesh.prototype.autoCreateAnimations = function ( fps ) {

	var pattern = /([a-z]+)_?(\d+)/i;

	var firstAnimation, frameRanges = {};

	var geometry = this.geometry;

	for ( var i = 0, il = geometry.morphTargets.length; i < il; i ++ ) {

		var morph = geometry.morphTargets[ i ];
		var chunks = morph.name.match( pattern );

		if ( chunks && chunks.length > 1 ) {

			var name = chunks[ 1 ];

			if ( ! frameRanges[ name ] ) frameRanges[ name ] = { start: Infinity, end: - Infinity };

			var range = frameRanges[ name ];

			if ( i < range.start ) range.start = i;
			if ( i > range.end ) range.end = i;

			if ( ! firstAnimation ) firstAnimation = name;

		}

	}

	for ( var name in frameRanges ) {

		var range = frameRanges[ name ];
		this.createAnimation( name, range.start, range.end, fps );

	}

	this.firstAnimation = firstAnimation;

};

MorphBlendMesh.prototype.setAnimationDirectionForward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = 1;
		animation.directionBackwards = false;

	}

};

MorphBlendMesh.prototype.setAnimationDirectionBackward = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.direction = - 1;
		animation.directionBackwards = true;

	}

};

MorphBlendMesh.prototype.setAnimationFPS = function ( name, fps ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.fps = fps;
		animation.duration = ( animation.end - animation.start ) / animation.fps;

	}

};

MorphBlendMesh.prototype.setAnimationDuration = function ( name, duration ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.duration = duration;
		animation.fps = ( animation.end - animation.start ) / animation.duration;

	}

};

MorphBlendMesh.prototype.setAnimationWeight = function ( name, weight ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.weight = weight;

	}

};

MorphBlendMesh.prototype.setAnimationTime = function ( name, time ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = time;

	}

};

MorphBlendMesh.prototype.getAnimationTime = function ( name ) {

	var time = 0;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		time = animation.time;

	}

	return time;

};

MorphBlendMesh.prototype.getAnimationDuration = function ( name ) {

	var duration = - 1;

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		duration = animation.duration;

	}

	return duration;

};

MorphBlendMesh.prototype.playAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.time = 0;
		animation.active = true;

	} else {

		console.warn( "THREE.MorphBlendMesh: animation[" + name + "] undefined in .playAnimation()" );

	}

};

MorphBlendMesh.prototype.stopAnimation = function ( name ) {

	var animation = this.animationsMap[ name ];

	if ( animation ) {

		animation.active = false;

	}

};

MorphBlendMesh.prototype.update = function ( delta ) {

	for ( var i = 0, il = this.animationsList.length; i < il; i ++ ) {

		var animation = this.animationsList[ i ];

		if ( ! animation.active ) continue;

		var frameTime = animation.duration / animation.length;

		animation.time += animation.direction * delta;

		if ( animation.mirroredLoop ) {

			if ( animation.time > animation.duration || animation.time < 0 ) {

				animation.direction *= - 1;

				if ( animation.time > animation.duration ) {

					animation.time = animation.duration;
					animation.directionBackwards = true;

				}

				if ( animation.time < 0 ) {

					animation.time = 0;
					animation.directionBackwards = false;

				}

			}

		} else {

			animation.time = animation.time % animation.duration;

			if ( animation.time < 0 ) animation.time += animation.duration;

		}

		var keyframe = animation.start + _Math.clamp( Math.floor( animation.time / frameTime ), 0, animation.length - 1 );
		var weight = animation.weight;

		if ( keyframe !== animation.currentFrame ) {

			this.morphTargetInfluences[ animation.lastFrame ] = 0;
			this.morphTargetInfluences[ animation.currentFrame ] = 1 * weight;

			this.morphTargetInfluences[ keyframe ] = 0;

			animation.lastFrame = animation.currentFrame;
			animation.currentFrame = keyframe;

		}

		var mix = ( animation.time % frameTime ) / frameTime;

		if ( animation.directionBackwards ) mix = 1 - mix;

		if ( animation.currentFrame !== animation.lastFrame ) {

			this.morphTargetInfluences[ animation.currentFrame ] = mix * weight;
			this.morphTargetInfluences[ animation.lastFrame ] = ( 1 - mix ) * weight;

		} else {

			this.morphTargetInfluences[ animation.currentFrame ] = weight;

		}

	}

};

/**
 * @author alteredq / http://alteredqualia.com/
 */

function ImmediateRenderObject( material ) {

	Object3D.call( this );

	this.material = material;
	this.render = function ( renderCallback ) {};

}

ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;

ImmediateRenderObject.prototype.isImmediateRenderObject = true;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

function VertexNormalsHelper( object, size, hex, linewidth ) {

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xff0000;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry && objGeometry.isGeometry ) {

		nNormals = objGeometry.faces.length * 3;

	} else if ( objGeometry && objGeometry.isBufferGeometry ) {

		nNormals = objGeometry.attributes.normal.count;

	}

	//

	var geometry = new BufferGeometry();

	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;

	this.update();

}

VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;

VertexNormalsHelper.prototype.update = ( function () {

	var v1 = new Vector3();
	var v2 = new Vector3();
	var normalMatrix = new Matrix3();

	return function update() {

		var keys = [ 'a', 'b', 'c' ];

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		if ( objGeometry && objGeometry.isGeometry ) {

			var vertices = objGeometry.vertices;

			var faces = objGeometry.faces;

			var idx = 0;

			for ( var i = 0, l = faces.length; i < l; i ++ ) {

				var face = faces[ i ];

				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {

					var vertex = vertices[ face[ keys[ j ] ] ];

					var normal = face.vertexNormals[ j ];

					v1.copy( vertex ).applyMatrix4( matrixWorld );

					v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

					position.setXYZ( idx, v1.x, v1.y, v1.z );

					idx = idx + 1;

					position.setXYZ( idx, v2.x, v2.y, v2.z );

					idx = idx + 1;

				}

			}

		} else if ( objGeometry && objGeometry.isBufferGeometry ) {

			var objPos = objGeometry.attributes.position;

			var objNorm = objGeometry.attributes.normal;

			var idx = 0;

			// for simplicity, ignore index and drawcalls, and render every normal

			for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {

				v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );

				v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );

				v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

				position.setXYZ( idx, v1.x, v1.y, v1.z );

				idx = idx + 1;

				position.setXYZ( idx, v2.x, v2.y, v2.z );

				idx = idx + 1;

			}

		}

		position.needsUpdate = true;

		return this;

	};

}() );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

function SpotLightHelper( light ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new BufferGeometry();

	var positions = [
		0, 0, 0,   0,   0,   1,
		0, 0, 0,   1,   0,   1,
		0, 0, 0, - 1,   0,   1,
		0, 0, 0,   0,   1,   1,
		0, 0, 0,   0, - 1,   1
	];

	for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {

		var p1 = ( i / l ) * Math.PI * 2;
		var p2 = ( j / l ) * Math.PI * 2;

		positions.push(
			Math.cos( p1 ), Math.sin( p1 ), 1,
			Math.cos( p2 ), Math.sin( p2 ), 1
		);

	}

	geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );

	var material = new LineBasicMaterial( { fog: false } );

	this.cone = new LineSegments( geometry, material );
	this.add( this.cone );

	this.update();

}

SpotLightHelper.prototype = Object.create( Object3D.prototype );
SpotLightHelper.prototype.constructor = SpotLightHelper;

SpotLightHelper.prototype.dispose = function () {

	this.cone.geometry.dispose();
	this.cone.material.dispose();

};

SpotLightHelper.prototype.update = function () {

	var vector = new Vector3();
	var vector2 = new Vector3();

	return function update() {

		var coneLength = this.light.distance ? this.light.distance : 1000;
		var coneWidth = coneLength * Math.tan( this.light.angle );

		this.cone.scale.set( coneWidth, coneWidth, coneLength );

		vector.setFromMatrixPosition( this.light.matrixWorld );
		vector2.setFromMatrixPosition( this.light.target.matrixWorld );

		this.cone.lookAt( vector2.sub( vector ) );

		this.cone.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	};

}();

/**
 * @author Sean Griffin / http://twitter.com/sgrif
 * @author Michael Guerrero / http://realitymeltdown.com
 * @author mrdoob / http://mrdoob.com/
 * @author ikerr / http://verold.com
 * @author Mugen87 / https://github.com/Mugen87
 */

function SkeletonHelper( object ) {

	this.bones = this.getBoneList( object );

	var geometry = new BufferGeometry();

	var vertices = [];
	var colors = [];

	var color1 = new Color( 0, 0, 1 );
	var color2 = new Color( 0, 1, 0 );

	for ( var i = 0; i < this.bones.length; i ++ ) {

		var bone = this.bones[ i ];

		if ( bone.parent && bone.parent.isBone ) {

			vertices.push( 0, 0, 0 );
			vertices.push( 0, 0, 0 );
			colors.push( color1.r, color1.g, color1.b );
			colors.push( color2.r, color2.g, color2.b );

		}

	}

	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );

	LineSegments.call( this, geometry, material );

	this.root = object;

	this.matrix = object.matrixWorld;
	this.matrixAutoUpdate = false;

	this.update();

}


SkeletonHelper.prototype = Object.create( LineSegments.prototype );
SkeletonHelper.prototype.constructor = SkeletonHelper;

SkeletonHelper.prototype.getBoneList = function( object ) {

	var boneList = [];

	if ( object && object.isBone ) {

		boneList.push( object );

	}

	for ( var i = 0; i < object.children.length; i ++ ) {

		boneList.push.apply( boneList, this.getBoneList( object.children[ i ] ) );

	}

	return boneList;

};

SkeletonHelper.prototype.update = function () {

	var vector = new Vector3();

	var boneMatrix = new Matrix4();
	var matrixWorldInv = new Matrix4();

	return function update() {

		var geometry = this.geometry;
		var position = geometry.getAttribute( 'position' );

		matrixWorldInv.getInverse( this.root.matrixWorld );

		for ( var i = 0, j = 0; i < this.bones.length; i ++ ) {

			var bone = this.bones[ i ];

			if ( bone.parent && bone.parent.isBone ) {

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
				vector.setFromMatrixPosition( boneMatrix );
				position.setXYZ( j, vector.x, vector.y, vector.z );

				boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
				vector.setFromMatrixPosition( boneMatrix );
				position.setXYZ( j + 1, vector.x, vector.y, vector.z );

				j += 2;

			}

		}

		geometry.getAttribute( 'position' ).needsUpdate = true;

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 */

function PointLightHelper( light, sphereSize ) {

	this.light = light;
	this.light.updateMatrixWorld();

	var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
	var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
	material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	Mesh.call( this, geometry, material );

	this.matrix = this.light.matrixWorld;
	this.matrixAutoUpdate = false;

	/*
	var distanceGeometry = new THREE.IcosahedronGeometry( 1, 2 );
	var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );

	this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
	this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );

	var d = light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.scale.set( d, d, d );

	}

	this.add( this.lightDistance );
	*/

}

PointLightHelper.prototype = Object.create( Mesh.prototype );
PointLightHelper.prototype.constructor = PointLightHelper;

PointLightHelper.prototype.dispose = function () {

	this.geometry.dispose();
	this.material.dispose();

};

PointLightHelper.prototype.update = function () {

	this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

	/*
	var d = this.light.distance;

	if ( d === 0.0 ) {

		this.lightDistance.visible = false;

	} else {

		this.lightDistance.visible = true;
		this.lightDistance.scale.set( d, d, d );

	}
	*/

};

/**
 * @author abelnation / http://github.com/abelnation
 * @author Mugen87 / http://github.com/Mugen87
 */

function RectAreaLightHelper( light ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	var materialFront = new MeshBasicMaterial( {
		color: light.color,
		fog: false
	} );

	var materialBack = new MeshBasicMaterial( {
		color: light.color,
		fog: false,
		wireframe: true
	} );

	var geometry = new BufferGeometry();

	geometry.addAttribute( 'position', new BufferAttribute( new Float32Array( 6 * 3 ), 3 ) );

	// shows the "front" of the light, e.g. where light comes from

	this.add( new Mesh( geometry, materialFront ) );

	// shows the "back" of the light, which does not emit light

	this.add( new Mesh( geometry, materialBack ) );

	this.update();

}

RectAreaLightHelper.prototype = Object.create( Object3D.prototype );
RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;

RectAreaLightHelper.prototype.dispose = function () {

	this.children[ 0 ].geometry.dispose();
	this.children[ 0 ].material.dispose();
	this.children[ 1 ].geometry.dispose();
	this.children[ 1 ].material.dispose();

};

RectAreaLightHelper.prototype.update = function () {

	var vector1 = new Vector3();
	var vector2 = new Vector3();

	return function update() {

		var mesh1 = this.children[ 0 ];
		var mesh2 = this.children[ 1 ];

		if ( this.light.target ) {

			vector1.setFromMatrixPosition( this.light.matrixWorld );
			vector2.setFromMatrixPosition( this.light.target.matrixWorld );

			var lookVec = vector2.clone().sub( vector1 );
			mesh1.lookAt( lookVec );
			mesh2.lookAt( lookVec );

		}

		// update materials

		mesh1.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
		mesh2.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		// calculate new dimensions of the helper

		var hx = this.light.width * 0.5;
		var hy = this.light.height * 0.5;

		// because the buffer attribute is shared over both geometries, we only have to update once

		var position = mesh1.geometry.getAttribute( 'position' );
		var array = position.array;

		// first face

		array[  0 ] =   hx; array[  1 ] = - hy; array[  2 ] = 0;
		array[  3 ] =   hx; array[  4 ] =   hy; array[  5 ] = 0;
		array[  6 ] = - hx; array[  7 ] =   hy; array[  8 ] = 0;

		// second face

		array[  9 ] = - hx; array[ 10 ] =   hy; array[ 11 ] = 0;
		array[ 12 ] = - hx; array[ 13 ] = - hy; array[ 14 ] = 0;
		array[ 15 ] =   hx; array[ 16 ] = - hy; array[ 17 ] = 0;

		position.needsUpdate = true;

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / https://github.com/Mugen87
 */

function HemisphereLightHelper( light, size ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	var geometry = new OctahedronBufferGeometry( size );
	geometry.rotateY( Math.PI * 0.5 );

	var material = new MeshBasicMaterial( { vertexColors: VertexColors, wireframe: true } );

	var position = geometry.getAttribute( 'position' );
	var colors = new Float32Array( position.count * 3 );

	geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );

	this.add( new Mesh( geometry, material ) );

	this.update();

}

HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;

HemisphereLightHelper.prototype.dispose = function () {

	this.children[ 0 ].geometry.dispose();
	this.children[ 0 ].material.dispose();

};

HemisphereLightHelper.prototype.update = function () {

	var vector = new Vector3();

	var color1 = new Color();
	var color2 = new Color();

	return function update() {

		var mesh = this.children[ 0 ];

		var colors = mesh.geometry.getAttribute( 'color' );

		color1.copy( this.light.color ).multiplyScalar( this.light.intensity );
		color2.copy( this.light.groundColor ).multiplyScalar( this.light.intensity );

		for ( var i = 0, l = colors.count; i < l; i ++ ) {

			var color = ( i < ( l / 2 ) ) ? color1 : color2;

			colors.setXYZ( i, color.r, color.g, color.b );

		}

		mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );

		colors.needsUpdate = true;

	};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function GridHelper( size, divisions, color1, color2 ) {

	size = size || 10;
	divisions = divisions || 10;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

	var center = divisions / 2;
	var step = ( size * 2 ) / divisions;
	var vertices = [], colors = [];

	for ( var i = 0, j = 0, k = - size; i <= divisions; i ++, k += step ) {

		vertices.push( - size, 0, k, size, 0, k );
		vertices.push( k, 0, - size, k, 0, size );

		var color = i === center ? color1 : color2;

		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;
		color.toArray( colors, j ); j += 3;

	}

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

	LineSegments.call( this, geometry, material );

}

GridHelper.prototype = Object.create( LineSegments.prototype );
GridHelper.prototype.constructor = GridHelper;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author Mugen87 / http://github.com/Mugen87
 * @author Hectate / http://www.github.com/Hectate
 */

function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {

	radius = radius || 10;
	radials = radials || 16;
	circles = circles || 8;
	divisions = divisions || 64;
	color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
	color2 = new Color( color2 !== undefined ? color2 : 0x888888 );

	var vertices = [];
	var colors = [];

	var x, z;
	var v, i, j, r, color;

	// create the radials

	for ( i = 0; i <= radials; i ++ ) {

		v = ( i / radials ) * ( Math.PI * 2 );

		x = Math.sin( v ) * radius;
		z = Math.cos( v ) * radius;

		vertices.push( 0, 0, 0 );
		vertices.push( x, 0, z );

		color = ( i & 1 ) ? color1 : color2;

		colors.push( color.r, color.g, color.b );
		colors.push( color.r, color.g, color.b );

	}

	// create the circles

	for ( i = 0; i <= circles; i ++ ) {

		color = ( i & 1 ) ? color1 : color2;

		r = radius - ( radius / circles * i );

		for ( j = 0; j < divisions; j ++ ) {

			// first vertex

			v = ( j / divisions ) * ( Math.PI * 2 );

			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;

			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );

			// second vertex

			v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );

			x = Math.sin( v ) * r;
			z = Math.cos( v ) * r;

			vertices.push( x, 0, z );
			colors.push( color.r, color.g, color.b );

		}

	}

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

	LineSegments.call( this, geometry, material );

}

PolarGridHelper.prototype = Object.create( LineSegments.prototype );
PolarGridHelper.prototype.constructor = PolarGridHelper;

/**
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
*/

function FaceNormalsHelper( object, size, hex, linewidth ) {

	// FaceNormalsHelper only supports THREE.Geometry

	this.object = object;

	this.size = ( size !== undefined ) ? size : 1;

	var color = ( hex !== undefined ) ? hex : 0xffff00;

	var width = ( linewidth !== undefined ) ? linewidth : 1;

	//

	var nNormals = 0;

	var objGeometry = this.object.geometry;

	if ( objGeometry && objGeometry.isGeometry ) {

		nNormals = objGeometry.faces.length;

	} else {

		console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );

	}

	//

	var geometry = new BufferGeometry();

	var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );

	geometry.addAttribute( 'position', positions );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );

	//

	this.matrixAutoUpdate = false;
	this.update();

}

FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;

FaceNormalsHelper.prototype.update = ( function () {

	var v1 = new Vector3();
	var v2 = new Vector3();
	var normalMatrix = new Matrix3();

	return function update() {

		this.object.updateMatrixWorld( true );

		normalMatrix.getNormalMatrix( this.object.matrixWorld );

		var matrixWorld = this.object.matrixWorld;

		var position = this.geometry.attributes.position;

		//

		var objGeometry = this.object.geometry;

		var vertices = objGeometry.vertices;

		var faces = objGeometry.faces;

		var idx = 0;

		for ( var i = 0, l = faces.length; i < l; i ++ ) {

			var face = faces[ i ];

			var normal = face.normal;

			v1.copy( vertices[ face.a ] )
				.add( vertices[ face.b ] )
				.add( vertices[ face.c ] )
				.divideScalar( 3 )
				.applyMatrix4( matrixWorld );

			v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );

			position.setXYZ( idx, v1.x, v1.y, v1.z );

			idx = idx + 1;

			position.setXYZ( idx, v2.x, v2.y, v2.z );

			idx = idx + 1;

		}

		position.needsUpdate = true;

		return this;

	};

}() );

/**
 * @author alteredq / http://alteredqualia.com/
 * @author mrdoob / http://mrdoob.com/
 * @author WestLangley / http://github.com/WestLangley
 */

function DirectionalLightHelper( light, size ) {

	Object3D.call( this );

	this.light = light;
	this.light.updateMatrixWorld();

	this.matrix = light.matrixWorld;
	this.matrixAutoUpdate = false;

	if ( size === undefined ) size = 1;

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( [
		- size,   size, 0,
		  size,   size, 0,
		  size, - size, 0,
		- size, - size, 0,
		- size,   size, 0
	], 3 ) );

	var material = new LineBasicMaterial( { fog: false } );

	this.add( new Line( geometry, material ) );

	geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );

	this.add( new Line( geometry, material ));

	this.update();

}

DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;

DirectionalLightHelper.prototype.dispose = function () {

	var lightPlane = this.children[ 0 ];
	var targetLine = this.children[ 1 ];

	lightPlane.geometry.dispose();
	lightPlane.material.dispose();
	targetLine.geometry.dispose();
	targetLine.material.dispose();

};

DirectionalLightHelper.prototype.update = function () {

	var v1 = new Vector3();
	var v2 = new Vector3();
	var v3 = new Vector3();

	return function update() {

		v1.setFromMatrixPosition( this.light.matrixWorld );
		v2.setFromMatrixPosition( this.light.target.matrixWorld );
		v3.subVectors( v2, v1 );

		var lightPlane = this.children[ 0 ];
		var targetLine = this.children[ 1 ];

		lightPlane.lookAt( v3 );
		lightPlane.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );

		targetLine.lookAt( v3 );
		targetLine.scale.z = v3.length();

	};

}();

/**
 * @author alteredq / http://alteredqualia.com/
 * @author Mugen87 / https://github.com/Mugen87
 *
 *	- shows frustum, line of sight and up of the camera
 *	- suitable for fast updates
 * 	- based on frustum visualization in lightgl.js shadowmap example
 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
 */

function CameraHelper( camera ) {

	var geometry = new BufferGeometry();
	var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );

	var vertices = [];
	var colors = [];

	var pointMap = {};

	// colors

	var colorFrustum = new Color( 0xffaa00 );
	var colorCone = new Color( 0xff0000 );
	var colorUp = new Color( 0x00aaff );
	var colorTarget = new Color( 0xffffff );
	var colorCross = new Color( 0x333333 );

	// near

	addLine( "n1", "n2", colorFrustum );
	addLine( "n2", "n4", colorFrustum );
	addLine( "n4", "n3", colorFrustum );
	addLine( "n3", "n1", colorFrustum );

	// far

	addLine( "f1", "f2", colorFrustum );
	addLine( "f2", "f4", colorFrustum );
	addLine( "f4", "f3", colorFrustum );
	addLine( "f3", "f1", colorFrustum );

	// sides

	addLine( "n1", "f1", colorFrustum );
	addLine( "n2", "f2", colorFrustum );
	addLine( "n3", "f3", colorFrustum );
	addLine( "n4", "f4", colorFrustum );

	// cone

	addLine( "p", "n1", colorCone );
	addLine( "p", "n2", colorCone );
	addLine( "p", "n3", colorCone );
	addLine( "p", "n4", colorCone );

	// up

	addLine( "u1", "u2", colorUp );
	addLine( "u2", "u3", colorUp );
	addLine( "u3", "u1", colorUp );

	// target

	addLine( "c", "t", colorTarget );
	addLine( "p", "c", colorCross );

	// cross

	addLine( "cn1", "cn2", colorCross );
	addLine( "cn3", "cn4", colorCross );

	addLine( "cf1", "cf2", colorCross );
	addLine( "cf3", "cf4", colorCross );

	function addLine( a, b, color ) {

		addPoint( a, color );
		addPoint( b, color );

	}

	function addPoint( id, color ) {

		vertices.push( 0, 0, 0 );
		colors.push( color.r, color.g, color.b );

		if ( pointMap[ id ] === undefined ) {

			pointMap[ id ] = [];

		}

		pointMap[ id ].push( ( vertices.length / 3 ) - 1 );

	}

	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	LineSegments.call( this, geometry, material );

	this.camera = camera;
	if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();

	this.matrix = camera.matrixWorld;
	this.matrixAutoUpdate = false;

	this.pointMap = pointMap;

	this.update();

}

CameraHelper.prototype = Object.create( LineSegments.prototype );
CameraHelper.prototype.constructor = CameraHelper;

CameraHelper.prototype.update = function () {

	var geometry, pointMap;

	var vector = new Vector3();
	var camera = new Camera();

	function setPoint( point, x, y, z ) {

		vector.set( x, y, z ).unproject( camera );

		var points = pointMap[ point ];

		if ( points !== undefined ) {

			var position = geometry.getAttribute( 'position' );

			for ( var i = 0, l = points.length; i < l; i ++ ) {

				position.setXYZ( points[ i ], vector.x, vector.y, vector.z );

			}

		}

	}

	return function update() {

		geometry = this.geometry;
		pointMap = this.pointMap;

		var w = 1, h = 1;

		// we need just camera projection matrix
		// world matrix must be identity

		camera.projectionMatrix.copy( this.camera.projectionMatrix );

		// center / target

		setPoint( "c", 0, 0, - 1 );
		setPoint( "t", 0, 0,  1 );

		// near

		setPoint( "n1", - w, - h, - 1 );
		setPoint( "n2",   w, - h, - 1 );
		setPoint( "n3", - w,   h, - 1 );
		setPoint( "n4",   w,   h, - 1 );

		// far

		setPoint( "f1", - w, - h, 1 );
		setPoint( "f2",   w, - h, 1 );
		setPoint( "f3", - w,   h, 1 );
		setPoint( "f4",   w,   h, 1 );

		// up

		setPoint( "u1",   w * 0.7, h * 1.1, - 1 );
		setPoint( "u2", - w * 0.7, h * 1.1, - 1 );
		setPoint( "u3",         0, h * 2,   - 1 );

		// cross

		setPoint( "cf1", - w,   0, 1 );
		setPoint( "cf2",   w,   0, 1 );
		setPoint( "cf3",   0, - h, 1 );
		setPoint( "cf4",   0,   h, 1 );

		setPoint( "cn1", - w,   0, - 1 );
		setPoint( "cn2",   w,   0, - 1 );
		setPoint( "cn3",   0, - h, - 1 );
		setPoint( "cn4",   0,   h, - 1 );

		geometry.getAttribute( 'position' ).needsUpdate = true;

	};

}();

/**
 * @author mrdoob / http://mrdoob.com/
 */

function BoxHelper( object, color ) {

	if ( color === undefined ) color = 0xffff00;

	var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	var positions = new Float32Array( 8 * 3 );

	var geometry = new BufferGeometry();
	geometry.setIndex( new BufferAttribute( indices, 1 ) );
	geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );

	LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );

	if ( object !== undefined ) {

		this.update( object );

	}

}

BoxHelper.prototype = Object.create( LineSegments.prototype );
BoxHelper.prototype.constructor = BoxHelper;

BoxHelper.prototype.update = ( function () {

	var box = new Box3();

	return function update( object ) {

		if ( object && object.isBox3 ) {

			box.copy( object );

		} else {

			box.setFromObject( object );

		}

		if ( box.isEmpty() ) return;

		var min = box.min;
		var max = box.max;

		/*
		  5____4
		1/___0/|
		| 6__|_7
		2/___3/

		0: max.x, max.y, max.z
		1: min.x, max.y, max.z
		2: min.x, min.y, max.z
		3: max.x, min.y, max.z
		4: max.x, max.y, min.z
		5: min.x, max.y, min.z
		6: min.x, min.y, min.z
		7: max.x, min.y, min.z
		*/

		var position = this.geometry.attributes.position;
		var array = position.array;

		array[  0 ] = max.x; array[  1 ] = max.y; array[  2 ] = max.z;
		array[  3 ] = min.x; array[  4 ] = max.y; array[  5 ] = max.z;
		array[  6 ] = min.x; array[  7 ] = min.y; array[  8 ] = max.z;
		array[  9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
		array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
		array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
		array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
		array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;

		position.needsUpdate = true;

		this.geometry.computeBoundingSphere();

	};

} )();

/**
 * @author WestLangley / http://github.com/WestLangley
 * @author zz85 / http://github.com/zz85
 * @author bhouston / http://clara.io
 *
 * Creates an arrow for visualizing directions
 *
 * Parameters:
 *  dir - Vector3
 *  origin - Vector3
 *  length - Number
 *  color - color in hex value
 *  headLength - Number
 *  headWidth - Number
 */

var lineGeometry = new BufferGeometry();
lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );

var coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
coneGeometry.translate( 0, - 0.5, 0 );

function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {

	// dir is assumed to be normalized

	Object3D.call( this );

	if ( color === undefined ) color = 0xffff00;
	if ( length === undefined ) length = 1;
	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.position.copy( origin );

	this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
	this.line.matrixAutoUpdate = false;
	this.add( this.line );

	this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
	this.cone.matrixAutoUpdate = false;
	this.add( this.cone );

	this.setDirection( dir );
	this.setLength( length, headLength, headWidth );

}

ArrowHelper.prototype = Object.create( Object3D.prototype );
ArrowHelper.prototype.constructor = ArrowHelper;

ArrowHelper.prototype.setDirection = ( function () {

	var axis = new Vector3();
	var radians;

	return function setDirection( dir ) {

		// dir is assumed to be normalized

		if ( dir.y > 0.99999 ) {

			this.quaternion.set( 0, 0, 0, 1 );

		} else if ( dir.y < - 0.99999 ) {

			this.quaternion.set( 1, 0, 0, 0 );

		} else {

			axis.set( dir.z, 0, - dir.x ).normalize();

			radians = Math.acos( dir.y );

			this.quaternion.setFromAxisAngle( axis, radians );

		}

	};

}() );

ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {

	if ( headLength === undefined ) headLength = 0.2 * length;
	if ( headWidth === undefined ) headWidth = 0.2 * headLength;

	this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
	this.line.updateMatrix();

	this.cone.scale.set( headWidth, headLength, headWidth );
	this.cone.position.y = length;
	this.cone.updateMatrix();

};

ArrowHelper.prototype.setColor = function ( color ) {

	this.line.material.color.copy( color );
	this.cone.material.color.copy( color );

};

/**
 * @author sroucheray / http://sroucheray.org/
 * @author mrdoob / http://mrdoob.com/
 */

function AxisHelper( size ) {

	size = size || 1;

	var vertices = [
		0, 0, 0,  size, 0, 0,
		0, 0, 0,  0, size, 0,
		0, 0, 0,  0, 0, size
	];

	var colors = [
		1, 0, 0,  1, 0.6, 0,
		0, 1, 0,  0.6, 1, 0,
		0, 0, 1,  0, 0.6, 1
	];

	var geometry = new BufferGeometry();
	geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );

	var material = new LineBasicMaterial( { vertexColors: VertexColors } );

	LineSegments.call( this, geometry, material );

}

AxisHelper.prototype = Object.create( LineSegments.prototype );
AxisHelper.prototype.constructor = AxisHelper;

/**
 * @author zz85 https://github.com/zz85
 *
 * Centripetal CatmullRom Curve - which is useful for avoiding
 * cusps and self-intersections in non-uniform catmull rom curves.
 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
 *
 * curve.type accepts centripetal(default), chordal and catmullrom
 * curve.tension is used for catmullrom which defaults to 0.5
 */

var CatmullRomCurve3 = ( function() {

	var
		tmp = new Vector3(),
		px = new CubicPoly(),
		py = new CubicPoly(),
		pz = new CubicPoly();

	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM

	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/

	function CubicPoly() {}

	/*
	 * Compute coefficients for a cubic polynomial
	 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
	 * such that
	 *   p(0) = x0, p(1) = x1
	 *  and
	 *   p'(0) = t0, p'(1) = t1.
	 */
	CubicPoly.prototype.init = function( x0, x1, t0, t1 ) {

		this.c0 = x0;
		this.c1 = t0;
		this.c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
		this.c3 = 2 * x0 - 2 * x1 + t0 + t1;

	};

	CubicPoly.prototype.initNonuniformCatmullRom = function( x0, x1, x2, x3, dt0, dt1, dt2 ) {

		// compute tangents when parameterized in [t1,t2]
		var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
		var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;

		// rescale tangents for parametrization in [0,1]
		t1 *= dt1;
		t2 *= dt1;

		// initCubicPoly
		this.init( x1, x2, t1, t2 );

	};

	// standard Catmull-Rom spline: interpolate between x1 and x2 with previous/following points x1/x4
	CubicPoly.prototype.initCatmullRom = function( x0, x1, x2, x3, tension ) {

		this.init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );

	};

	CubicPoly.prototype.calc = function( t ) {

		var t2 = t * t;
		var t3 = t2 * t;
		return this.c0 + this.c1 * t + this.c2 * t2 + this.c3 * t3;

	};

	// Subclass Three.js curve
	return Curve.create(

		function ( p /* array of Vector3 */ ) {

			this.points = p || [];
			this.closed = false;

		},

		function ( t ) {

			var points = this.points,
				point, intPoint, weight, l;

			l = points.length;

			if ( l < 2 ) console.log( 'duh, you need at least 2 points' );

			point = ( l - ( this.closed ? 0 : 1 ) ) * t;
			intPoint = Math.floor( point );
			weight = point - intPoint;

			if ( this.closed ) {

				intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / points.length ) + 1 ) * points.length;

			} else if ( weight === 0 && intPoint === l - 1 ) {

				intPoint = l - 2;
				weight = 1;

			}

			var p0, p1, p2, p3; // 4 points

			if ( this.closed || intPoint > 0 ) {

				p0 = points[ ( intPoint - 1 ) % l ];

			} else {

				// extrapolate first point
				tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
				p0 = tmp;

			}

			p1 = points[ intPoint % l ];
			p2 = points[ ( intPoint + 1 ) % l ];

			if ( this.closed || intPoint + 2 < l ) {

				p3 = points[ ( intPoint + 2 ) % l ];

			} else {

				// extrapolate last point
				tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
				p3 = tmp;

			}

			if ( this.type === undefined || this.type === 'centripetal' || this.type === 'chordal' ) {

				// init Centripetal / Chordal Catmull-Rom
				var pow = this.type === 'chordal' ? 0.5 : 0.25;
				var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
				var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
				var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );

				// safety check for repeated points
				if ( dt1 < 1e-4 ) dt1 = 1.0;
				if ( dt0 < 1e-4 ) dt0 = dt1;
				if ( dt2 < 1e-4 ) dt2 = dt1;

				px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
				py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
				pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );

			} else if ( this.type === 'catmullrom' ) {

				var tension = this.tension !== undefined ? this.tension : 0.5;
				px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, tension );
				py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, tension );
				pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, tension );

			}

			var v = new Vector3(
				px.calc( weight ),
				py.calc( weight ),
				pz.calc( weight )
			);

			return v;

		}

	);

} )();

/**************************************************************
 *	Spline 3D curve
 **************************************************************/


var SplineCurve3 = Curve.create(

	function ( points /* array of Vector3 */ ) {

		console.warn( 'THREE.SplineCurve3 will be deprecated. Please use THREE.CatmullRomCurve3' );
		this.points = ( points === undefined ) ? [] : points;

	},

	function ( t ) {

		var points = this.points;
		var point = ( points.length - 1 ) * t;

		var intPoint = Math.floor( point );
		var weight = point - intPoint;

		var point0 = points[ intPoint == 0 ? intPoint : intPoint - 1 ];
		var point1 = points[ intPoint ];
		var point2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var point3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];

		var interpolate = CurveUtils.interpolate;

		return new Vector3(
			interpolate( point0.x, point1.x, point2.x, point3.x, weight ),
			interpolate( point0.y, point1.y, point2.y, point3.y, weight ),
			interpolate( point0.z, point1.z, point2.z, point3.z, weight )
		);

	}

);

/**************************************************************
 *	Cubic Bezier 3D curve
 **************************************************************/

var CubicBezierCurve3 = Curve.create(

	function ( v0, v1, v2, v3 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;
		this.v3 = v3;

	},

	function ( t ) {

		var b3 = ShapeUtils.b3;

		return new Vector3(
			b3( t, this.v0.x, this.v1.x, this.v2.x, this.v3.x ),
			b3( t, this.v0.y, this.v1.y, this.v2.y, this.v3.y ),
			b3( t, this.v0.z, this.v1.z, this.v2.z, this.v3.z )
		);

	}

);

/**************************************************************
 *	Quadratic Bezier 3D curve
 **************************************************************/

var QuadraticBezierCurve3 = Curve.create(

	function ( v0, v1, v2 ) {

		this.v0 = v0;
		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		var b2 = ShapeUtils.b2;

		return new Vector3(
			b2( t, this.v0.x, this.v1.x, this.v2.x ),
			b2( t, this.v0.y, this.v1.y, this.v2.y ),
			b2( t, this.v0.z, this.v1.z, this.v2.z )
		);

	}

);

/**************************************************************
 *	Line3D
 **************************************************************/

var LineCurve3 = Curve.create(

	function ( v1, v2 ) {

		this.v1 = v1;
		this.v2 = v2;

	},

	function ( t ) {

		if ( t === 1 ) {

			return this.v2.clone();

		}

		var vector = new Vector3();

		vector.subVectors( this.v2, this.v1 ); // diff
		vector.multiplyScalar( t );
		vector.add( this.v1 );

		return vector;

	}

);

/**************************************************************
 *	Arc curve
 **************************************************************/

function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {

	EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );

}

ArcCurve.prototype = Object.create( EllipseCurve.prototype );
ArcCurve.prototype.constructor = ArcCurve;

/**
 * @author alteredq / http://alteredqualia.com/
 */

var SceneUtils = {

	createMultiMaterialObject: function ( geometry, materials ) {

		var group = new Group();

		for ( var i = 0, l = materials.length; i < l; i ++ ) {

			group.add( new Mesh( geometry, materials[ i ] ) );

		}

		return group;

	},

	detach: function ( child, parent, scene ) {

		child.applyMatrix( parent.matrixWorld );
		parent.remove( child );
		scene.add( child );

	},

	attach: function ( child, scene, parent ) {

		var matrixWorldInverse = new Matrix4();
		matrixWorldInverse.getInverse( parent.matrixWorld );
		child.applyMatrix( matrixWorldInverse );

		scene.remove( child );
		parent.add( child );

	}

};

/**
 * @author mrdoob / http://mrdoob.com/
 */

function Face4( a, b, c, d, normal, color, materialIndex ) {

	console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
	return new Face3( a, b, c, normal, color, materialIndex );

}

var LineStrip = 0;

var LinePieces = 1;

function MeshFaceMaterial( materials ) {

	console.warn( 'THREE.MeshFaceMaterial has been renamed to THREE.MultiMaterial.' );
	return new MultiMaterial( materials );

}

function PointCloud( geometry, material ) {

	console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function Particle( material ) {

	console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
	return new Sprite( material );

}

function ParticleSystem( geometry, material ) {

	console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
	return new Points( geometry, material );

}

function PointCloudMaterial( parameters ) {

	console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleBasicMaterial( parameters ) {

	console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function ParticleSystemMaterial( parameters ) {

	console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
	return new PointsMaterial( parameters );

}

function Vertex( x, y, z ) {

	console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
	return new Vector3( x, y, z );

}

//

function DynamicBufferAttribute( array, itemSize ) {

	console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
	return new BufferAttribute( array, itemSize ).setDynamic( true );

}

function Int8Attribute( array, itemSize ) {

	console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
	return new Int8BufferAttribute( array, itemSize );

}

function Uint8Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
	return new Uint8BufferAttribute( array, itemSize );

}

function Uint8ClampedAttribute( array, itemSize ) {

	console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
	return new Uint8ClampedBufferAttribute( array, itemSize );

}

function Int16Attribute( array, itemSize ) {

	console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
	return new Int16BufferAttribute( array, itemSize );

}

function Uint16Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
	return new Uint16BufferAttribute( array, itemSize );

}

function Int32Attribute( array, itemSize ) {

	console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
	return new Int32BufferAttribute( array, itemSize );

}

function Uint32Attribute( array, itemSize ) {

	console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
	return new Uint32BufferAttribute( array, itemSize );

}

function Float32Attribute( array, itemSize ) {

	console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
	return new Float32BufferAttribute( array, itemSize );

}

function Float64Attribute( array, itemSize ) {

	console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
	return new Float64BufferAttribute( array, itemSize );

}

//

function ClosedSplineCurve3( points ) {

	console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );

	CatmullRomCurve3.call( this, points );
	this.type = 'catmullrom';
	this.closed = true;

}

ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );


//
function BoundingBoxHelper( object, color ) {

	console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
	return new BoxHelper( object, color );

}

function EdgesHelper( object, hex ) {

	console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
	return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

GridHelper.prototype.setColors = function () {

	console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );

};

function WireframeHelper( object, hex ) {

	console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
	return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );

}

//

function XHRLoader( manager ) {

	console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
	return new FileLoader( manager );

}

//

Object.assign( Box2.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Object.assign( Box3.prototype, {

	center: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );

	},
	empty: function () {

		console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
		return this.isEmpty();

	},
	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	},
	size: function ( optionalTarget ) {

		console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
		return this.getSize( optionalTarget );

	}
} );

Line3.prototype.center = function ( optionalTarget ) {

	console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
	return this.getCenter( optionalTarget );

};

_Math.random16 = function () {

	console.warn( 'THREE.Math.random16() has been deprecated. Use Math.random() instead.' );
	return Math.random();

};

Object.assign( Matrix3.prototype, {

	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
		return vector.applyMatrix3( this );

	},
	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix3: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},
	applyToBuffer: function( buffer, offset, length ) {

		console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
		return this.applyToBufferAttribute( buffer );

	}

} );

Object.assign( Matrix4.prototype, {

	extractPosition: function ( m ) {

		console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
		return this.copyPosition( m );

	},
	flattenToArrayOffset: function ( array, offset ) {

		console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
		return this.toArray( array, offset );

	},
	getPosition: function () {

		var v1;

		return function getPosition() {

			if ( v1 === undefined ) v1 = new Vector3();
			console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
			return v1.setFromMatrixColumn( this, 3 );

		};

	}(),
	setRotationFromQuaternion: function ( q ) {

		console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
		return this.makeRotationFromQuaternion( q );

	},
	multiplyVector3: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) or vector.applyProjection( matrix ) instead.' );
		return vector.applyProjection( this );

	},
	multiplyVector4: function ( vector ) {

		console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	multiplyVector3Array: function ( a ) {

		console.warn( 'THREE.Matrix4: .multiplyVector3Array() has been renamed. Use matrix.applyToVector3Array( array ) instead.' );
		return this.applyToVector3Array( a );

	},
	rotateAxis: function ( v ) {

		console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
		v.transformDirection( this );

	},
	crossVector: function ( vector ) {

		console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
		return vector.applyMatrix4( this );

	},
	translate: function () {

		console.error( 'THREE.Matrix4: .translate() has been removed.' );

	},
	rotateX: function () {

		console.error( 'THREE.Matrix4: .rotateX() has been removed.' );

	},
	rotateY: function () {

		console.error( 'THREE.Matrix4: .rotateY() has been removed.' );

	},
	rotateZ: function () {

		console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );

	},
	rotateByAxis: function () {

		console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );

	},
	applyToBuffer: function( buffer, offset, length ) {

		console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
		return this.applyToBufferAttribute( buffer );

	}

} );

Plane.prototype.isIntersectionLine = function ( line ) {

	console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
	return this.intersectsLine( line );

};

Quaternion.prototype.multiplyVector3 = function ( vector ) {

	console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
	return vector.applyQuaternion( this );

};

Object.assign( Ray.prototype, {

	isIntersectionBox: function ( box ) {

		console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
		return this.intersectsBox( box );

	},
	isIntersectionPlane: function ( plane ) {

		console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
		return this.intersectsPlane( plane );

	},
	isIntersectionSphere: function ( sphere ) {

		console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
		return this.intersectsSphere( sphere );

	}

} );

Object.assign( Shape.prototype, {

	extrude: function ( options ) {

		console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
		return new ExtrudeGeometry( this, options );

	},
	makeGeometry: function ( options ) {

		console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
		return new ShapeGeometry( this, options );

	}

} );

Object.assign( Vector3.prototype, {

	setEulerFromRotationMatrix: function () {

		console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );

	},
	setEulerFromQuaternion: function () {

		console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );

	},
	getPositionFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
		return this.setFromMatrixPosition( m );

	},
	getScaleFromMatrix: function ( m ) {

		console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
		return this.setFromMatrixScale( m );

	},
	getColumnFromMatrix: function ( index, matrix ) {

		console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
		return this.setFromMatrixColumn( matrix, index );

	}

} );

//

Geometry.prototype.computeTangents = function () {

	console.warn( 'THREE.Geometry: .computeTangents() has been removed.' );

};

Object.assign( Object3D.prototype, {

	getChildByName: function ( name ) {

		console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
		return this.getObjectByName( name );

	},
	renderDepth: function () {

		console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );

	},
	translate: function ( distance, axis ) {

		console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
		return this.translateOnAxis( axis, distance );

	}

} );

Object.defineProperties( Object3D.prototype, {

	eulerOrder: {
		get: function () {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			return this.rotation.order;

		},
		set: function ( value ) {

			console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
			this.rotation.order = value;

		}
	},
	useQuaternion: {
		get: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		},
		set: function () {

			console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );

		}
	}

} );

Object.defineProperties( LOD.prototype, {

	objects: {
		get: function () {

			console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
			return this.levels;

		}
	}

} );

//

PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {

	console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
			"Use .setFocalLength and .filmGauge for a photographic setup." );

	if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
	this.setFocalLength( focalLength );

};

//

Object.defineProperties( Light.prototype, {
	onlyShadow: {
		set: function () {

			console.warn( 'THREE.Light: .onlyShadow has been removed.' );

		}
	},
	shadowCameraFov: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
			this.shadow.camera.fov = value;

		}
	},
	shadowCameraLeft: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
			this.shadow.camera.left = value;

		}
	},
	shadowCameraRight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
			this.shadow.camera.right = value;

		}
	},
	shadowCameraTop: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
			this.shadow.camera.top = value;

		}
	},
	shadowCameraBottom: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
			this.shadow.camera.bottom = value;

		}
	},
	shadowCameraNear: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
			this.shadow.camera.near = value;

		}
	},
	shadowCameraFar: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
			this.shadow.camera.far = value;

		}
	},
	shadowCameraVisible: {
		set: function () {

			console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );

		}
	},
	shadowBias: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
			this.shadow.bias = value;

		}
	},
	shadowDarkness: {
		set: function () {

			console.warn( 'THREE.Light: .shadowDarkness has been removed.' );

		}
	},
	shadowMapWidth: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
			this.shadow.mapSize.width = value;

		}
	},
	shadowMapHeight: {
		set: function ( value ) {

			console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
			this.shadow.mapSize.height = value;

		}
	}
} );

//

Object.defineProperties( BufferAttribute.prototype, {

	length: {
		get: function () {

			console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
			return this.array.length;

		}
	}

} );

Object.assign( BufferGeometry.prototype, {

	addIndex: function ( index ) {

		console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
		this.setIndex( index );

	},
	addDrawCall: function ( start, count, indexOffset ) {

		if ( indexOffset !== undefined ) {

			console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );

		}
		console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
		this.addGroup( start, count );

	},
	clearDrawCalls: function () {

		console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
		this.clearGroups();

	},
	computeTangents: function () {

		console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );

	},
	computeOffsets: function () {

		console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );

	}

} );

Object.defineProperties( BufferGeometry.prototype, {

	drawcalls: {
		get: function () {

			console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
			return this.groups;

		}
	},
	offsets: {
		get: function () {

			console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
			return this.groups;

		}
	}

} );

//

Object.defineProperties( Uniform.prototype, {

	dynamic: {
		set: function () {

			console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );

		}
	},
	onUpdate: {
		value: function () {

			console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
			return this;

		}
	}

} );

//

Object.defineProperties( Material.prototype, {

	wrapAround: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

		},
		set: function () {

			console.warn( 'THREE.' + this.type + ': .wrapAround has been removed.' );

		}
	},
	wrapRGB: {
		get: function () {

			console.warn( 'THREE.' + this.type + ': .wrapRGB has been removed.' );
			return new Color();

		}
	}

} );

Object.defineProperties( MeshPhongMaterial.prototype, {

	metal: {
		get: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
			return false;

		},
		set: function () {

			console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );

		}
	}

} );

Object.defineProperties( ShaderMaterial.prototype, {

	derivatives: {
		get: function () {

			console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			return this.extensions.derivatives;

		},
		set: function ( value ) {

			console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
			this.extensions.derivatives = value;

		}
	}

} );

//

EventDispatcher.prototype = Object.assign( Object.create( {

	// Note: Extra base ensures these properties are not 'assign'ed.

	constructor: EventDispatcher,

	apply: function ( target ) {

		console.warn( "THREE.EventDispatcher: .apply is deprecated, " +
				"just inherit or Object.assign the prototype to mix-in." );

		Object.assign( target, this );

	}

} ), EventDispatcher.prototype );

//

Object.assign( WebGLRenderer.prototype, {

	supportsFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
		return this.extensions.get( 'OES_texture_float' );

	},
	supportsHalfFloatTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
		return this.extensions.get( 'OES_texture_half_float' );

	},
	supportsStandardDerivatives: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
		return this.extensions.get( 'OES_standard_derivatives' );

	},
	supportsCompressedTextureS3TC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );

	},
	supportsCompressedTexturePVRTC: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
		return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );

	},
	supportsBlendMinMax: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
		return this.extensions.get( 'EXT_blend_minmax' );

	},
	supportsVertexTextures: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
		return this.capabilities.vertexTextures;

	},
	supportsInstancedArrays: function () {

		console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
		return this.extensions.get( 'ANGLE_instanced_arrays' );

	},
	enableScissorTest: function ( boolean ) {

		console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
		this.setScissorTest( boolean );

	},
	initMaterial: function () {

		console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );

	},
	addPrePlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );

	},
	addPostPlugin: function () {

		console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );

	},
	updateShadowMap: function () {

		console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );

	}

} );

Object.defineProperties( WebGLRenderer.prototype, {

	shadowMapEnabled: {
		get: function () {

			return this.shadowMap.enabled;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
			this.shadowMap.enabled = value;

		}
	},
	shadowMapType: {
		get: function () {

			return this.shadowMap.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
			this.shadowMap.type = value;

		}
	},
	shadowMapCullFace: {
		get: function () {

			return this.shadowMap.cullFace;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace is now .shadowMap.cullFace.' );
			this.shadowMap.cullFace = value;

		}
	}
} );

Object.defineProperties( WebGLShadowMap.prototype, {

	cullFace: {
		get: function () {

			return this.renderReverseSided ? CullFaceFront : CullFaceBack;

		},
		set: function ( cullFace ) {

			var value = ( cullFace !== CullFaceBack );
			console.warn( "WebGLRenderer: .shadowMap.cullFace is deprecated. Set .shadowMap.renderReverseSided to " + value + "." );
			this.renderReverseSided = value;

		}
	}

} );

//

Object.defineProperties( WebGLRenderTarget.prototype, {

	wrapS: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			return this.texture.wrapS;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
			this.texture.wrapS = value;

		}
	},
	wrapT: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			return this.texture.wrapT;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
			this.texture.wrapT = value;

		}
	},
	magFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			return this.texture.magFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
			this.texture.magFilter = value;

		}
	},
	minFilter: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			return this.texture.minFilter;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
			this.texture.minFilter = value;

		}
	},
	anisotropy: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			return this.texture.anisotropy;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
			this.texture.anisotropy = value;

		}
	},
	offset: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			return this.texture.offset;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
			this.texture.offset = value;

		}
	},
	repeat: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			return this.texture.repeat;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
			this.texture.repeat = value;

		}
	},
	format: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			return this.texture.format;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
			this.texture.format = value;

		}
	},
	type: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			return this.texture.type;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
			this.texture.type = value;

		}
	},
	generateMipmaps: {
		get: function () {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			return this.texture.generateMipmaps;

		},
		set: function ( value ) {

			console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
			this.texture.generateMipmaps = value;

		}
	}

} );

//

Audio.prototype.load = function ( file ) {

	console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
	var scope = this;
	var audioLoader = new AudioLoader();
	audioLoader.load( file, function ( buffer ) {

		scope.setBuffer( buffer );

	} );
	return this;

};

AudioAnalyser.prototype.getData = function () {

	console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
	return this.getFrequencyData();

};

//

var GeometryUtils = {

	merge: function ( geometry1, geometry2, materialIndexOffset ) {

		console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
		var matrix;

		if ( geometry2.isMesh ) {

			geometry2.matrixAutoUpdate && geometry2.updateMatrix();

			matrix = geometry2.matrix;
			geometry2 = geometry2.geometry;

		}

		geometry1.merge( geometry2, matrix, materialIndexOffset );

	},

	center: function ( geometry ) {

		console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
		return geometry.center();

	}

};

var ImageUtils = {

	crossOrigin: undefined,

	loadTexture: function ( url, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );

		var loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( url, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadTextureCube: function ( urls, mapping, onLoad, onError ) {

		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );

		var loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );

		var texture = loader.load( urls, onLoad, undefined, onError );

		if ( mapping ) texture.mapping = mapping;

		return texture;

	},

	loadCompressedTexture: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );

	},

	loadCompressedTextureCube: function () {

		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );

	}

};

//

function Projector() {

	console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );

	this.projectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
		vector.project( camera );

	};

	this.unprojectVector = function ( vector, camera ) {

		console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
		vector.unproject( camera );

	};

	this.pickingRay = function () {

		console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );

	};

}

//

function CanvasRenderer() {

	console.error( 'THREE.CanvasRenderer has been moved to /examples/js/renderers/CanvasRenderer.js' );

	this.domElement = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	this.clear = function () {};
	this.render = function () {};
	this.setClearColor = function () {};
	this.setSize = function () {};

}




/***/ },
/* 2 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-unused-variable */
var RuntimeEvents_1 = __webpack_require__(21);
var deepClone_1 = __webpack_require__(23);
var functions_1 = __webpack_require__(6);
var NodeObject_1 = __webpack_require__(9);
var classComposer_1 = __webpack_require__(39);
/** Events bound to the component object */
var selfEvents = [
    { event: 'startup', method: 'onStartupInternal', skippable: false },
    { event: 'shutdown', method: 'onShutdownInternal', skippable: false },
    { event: 'awake', method: 'onAwake', skippable: true },
    { event: 'attributesChanged', method: 'onAttributesChanged', skippable: true }
];
/** Events bound to the attached entity object */
var entityEvents = [
    { event: 'load', method: 'onEntityLoaded', testMethod: 'isLoaded', skippable: true },
    { event: 'loadBase', method: 'onEntityReady', testMethod: 'isBaseLoaded', skippable: true },
    { event: 'loadDependencies', method: 'onDependenciesLoaded', testMethod: 'isDependenciesLoaded', skippable: true }
];
/** Events bound to the attached engine object */
var engineEventMap = [
    { event: 'preUpdate', method: 'onPreUpdate', skippable: true },
    { event: 'update', method: 'onUpdate', skippable: true },
    { event: 'postUpdate', method: 'onPostUpdate', skippable: true },
    { event: 'preRender', method: 'onPreRender', skippable: true },
    { event: 'render', method: 'onRender', skippable: true },
    { event: 'postRender', method: 'onPostRender', skippable: true },
    { event: 'preRenderView', method: 'onPreRenderView', skippable: true },
    { event: 'postRenderView', method: 'onPostRenderView', skippable: true },
    { event: 'blur', method: 'onSuspend', skippable: true },
    { event: 'focus', method: 'onResume', skippable: true }
];
exports.baseComponentMixins = classComposer_1.default({}, [RuntimeEvents_1.default]);
/**
 * The base class for all components.
 */
var BaseComponent = (function (_super) {
    tslib_1.__extends(BaseComponent, _super);
    /**
     * Creates an instance of BaseComponent.
     */
    function BaseComponent() {
        var _this = _super.call(this) || this;
        /** Internal reference to input component, if it exists. */
        _this.input = undefined;
        _this.bindSelfEvents();
        return _this;
    }
    /**
     * Get the unique ID of this component
     * @returns The ID of this component
     */
    BaseComponent.prototype.getId = function () {
        return this.id;
    };
    /**
     * Get the index of this component in the entity's component list.
     * @returns The index of this component.
     */
    BaseComponent.prototype.getIndex = function () {
        return this.getEntity().components.indexOf(this);
    };
    /**
     * Get the name for this component
     * @returns The name of this component
     */
    BaseComponent.prototype.getName = function () {
        return this.name;
    };
    /**
     * Get the script asset for this component
     * @returns The script asset
     */
    BaseComponent.prototype.getScriptAsset = function () {
        return this.getEngine().getAssetById(this.getScriptId());
    };
    /**
     * Get the script name of this component
     * @returns The script name
     */
    BaseComponent.prototype.getScriptName = function () {
        return this.getScriptAsset().getName();
    };
    /**
     * Get the script id of this component.
     * @returns The script id
     */
    BaseComponent.prototype.getScriptId = function () {
        return this.scriptId;
    };
    /**
     * Return the complete set of attribute values for this component, including inherited values
     * (from a prefab) and default values, if not overridden.
     * @returns All attribute values.
     */
    BaseComponent.prototype.getAttributes = function () {
        var _this = this;
        var scriptAttributes = this.getScriptAsset().getProperty('attributes');
        return functions_1.map(scriptAttributes, function (_attr, name) { return _this.getAttribute(name); });
    };
    /**
     * Return the complete set of previous attribute values for this component, including
     * inherited values (from a prefab) and default values, if not overridden.
     * @returns All previous attribute values.
     */
    BaseComponent.prototype.getPreviousAttributes = function () {
        var _this = this;
        var scriptAttributes = this.getScriptAsset().getProperty('attributes');
        return functions_1.map(scriptAttributes, function (_attr, name) { return _this.getPreviousAttribute(name); });
    };
    /**
     * Set the specified attribute to the specified value.
     * @param attrib          The attribute name
     * @param value           The new value for the attribute.
     * @param [silent=false]  Suppress change event.
     */
    BaseComponent.prototype.setAttribute = function (attrib, value, _silent) {
        var changes = {
            attributes: (_a = {},
                _a[attrib] = deepClone_1.default(value),
                _a)
        };
        var dispatcher = this.getEngine().entityDispatcher;
        dispatcher.dispatchComponentChanged(this.entity.id, this.getIndex(), changes);
        var _a;
    };
    /**
     * Get the value of the specified attribute.
     * @param attribName  The attribute name
     * @returns           The saved attribute value.
     */
    BaseComponent.prototype.getAttribute = function (attribName) {
        // Look for the attribute in this component
        var entity = this.getEntity();
        var compDesc = entity.getComponentDescriptorById(this.getId());
        if (compDesc.attributes.hasOwnProperty(attribName)) {
            return compDesc.attributes[attribName];
        }
        else if (entity instanceof NodeObject_1.default) {
            // Otherwise, look in the entity's prefab for the attribute value.
            var prefabObj = entity.getPrefabObject();
            if (prefabObj) {
                var prefComp = prefabObj.getComponentById(this.getId());
                if (prefComp) {
                    return prefComp.getAttribute(attribName);
                }
            }
        }
        // If we didn't find an override value, return the default for this attribute.
        return this.getScriptAsset().getAttributeDefault(attribName);
    };
    /**
     * Get the previous value of the specified attribute.
     * @param attribName  The attribute name
     * @returns           The previous attribute value.
     */
    BaseComponent.prototype.getPreviousAttribute = function (attribName) {
        // Look for the attribute in this component
        var entity = this.getEntity();
        var compDesc = entity.getPreviousComponentDescriptorById(this.getId());
        if (compDesc && compDesc.attributes.hasOwnProperty(attribName)) {
            return compDesc.attributes[attribName];
        }
        else if (entity instanceof NodeObject_1.default) {
            // Otherwise, look in the entity's prefab for the attribute value.
            var prefabObj = entity.getPrefabObject();
            if (prefabObj) {
                var prefComp = prefabObj.getComponentById(this.getId());
                if (prefComp) {
                    return prefComp.getPreviousAttribute(attribName);
                }
            }
        }
        // If we didn't find an override value, return the default for this attribute.
        return this.getScriptAsset().getAttributeDefault(attribName);
    };
    /**
     * Returns the BaseEntity that the component is attached to
     * @returns The BaseEntity which this component is attached to.
     */
    BaseComponent.prototype.getEntity = function () {
        return this.entity;
    };
    /**
     * Returns the engine that the component is running in.
     * @returns The engine.
     */
    BaseComponent.prototype.getEngine = function () {
        return this.entity.engine;
    };
    /**
     * Enables the component. Fires an 'enable' event on the component and calls
     * the component's 'onEnable' function.
     */
    BaseComponent.prototype.enable = function () {
        if (!this.enabled) {
            this.enabled = true;
            this.onEnable();
            this.trigger('enable');
        }
    };
    /**
     * Disables the component. Fires a 'disable' event on the component and calls
     * the component's 'onDisable' function.
     */
    BaseComponent.prototype.disable = function () {
        if (this.enabled) {
            this.enabled = false;
            this.onDisable();
            this.trigger('disable');
        }
    };
    /**
     * Register a dependent entity on the entity that owns this component.
     * @param entity An entity that is required by this component.
     */
    BaseComponent.prototype.registerDependency = function (entity) {
        this.getEntity().registerDependency(entity);
    };
    /**
     * Unregister a dependent entity on the entity that owns this component.
     * @param entity The entity to unregister.
     */
    BaseComponent.prototype.unregisterDependency = function (entity) {
        this.getEntity().unregisterDependency(entity);
    };
    /**
     * Check whether the component is enabled or not.
     * @returns Whether the component is enabled or not.
     */
    BaseComponent.prototype.isEnabled = function () {
        return this.enabled;
    };
    /**
     * Check if runtimeData exists.
     * @returns Whether or not the runtimeData object exists.
     */
    BaseComponent.prototype.hasRuntimeData = function () {
        return !!(this.entity && this.entity.runtimeData);
    };
    /**
     * Returns the three.js data attached to the entity.
     * @returns The three.js data for the entity.
     */
    BaseComponent.prototype.getRuntimeData = function () {
        return this.entity.runtimeData;
    };
    /**
     * Returns the global event system.
     * @returns The global RuntimeEvents instance.
     */
    BaseComponent.prototype.getGlobalEvents = function () {
        return this.entity.engine.globalEvents;
    };
    /**
     * Returns the Box3D rendering component currently being used by the Box3D engine.
     * @returns The Renderer component.
     */
    BaseComponent.prototype.getRenderer = function () {
        return this.getEngine().getRenderer();
    };
    /**
     * Returns the WebGLRenderer currently being used by the Box3D engine.
     * @returns The THREE.WebGLRenderer object.
     */
    BaseComponent.prototype.getThreeRenderer = function () {
        var renderer = this.getEngine().getRenderer();
        if (renderer) {
            return renderer.threeRenderer;
        }
        return null;
    };
    /**
     * Returns the Input handler being used by the object's engine
     * @returns The input controller component
     */
    BaseComponent.prototype.getInput = function () {
        if (!this.input) {
            var application = this.getEngine().getApplication();
            this.input = application.getComponentByScriptName('Input Controller');
        }
        return this.input;
    };
    /**
     * Returns the NodeObject at the top of the hierarchy that this component's entity
     * is a part of. If this component's entity is a non-prefab asset, this will return null.
     * @returns the root object
     */
    BaseComponent.prototype.getRootObject = function () {
        if (this.entity instanceof NodeObject_1.default) {
            return this.entity.getRootObject();
        }
        return null;
    };
    /**
     * Returns the THREE.Object3D at the top of the hierarchy that this component's entity
     * is a part of. If this component's entity is a non-prefab asset, this will return null.
     * @returns the THREE.Object3D object
     */
    BaseComponent.prototype.getRootThreeObject = function () {
        if (this.entity instanceof NodeObject_1.default) {
            var rootObject = this.entity.getRootObject();
            return rootObject ? rootObject.runtimeData : null;
        }
        return null;
    };
    /** Forces the component to remove and re-add itself */
    BaseComponent.prototype.reload = function () {
        var scriptId = this.getScriptId();
        var attributes = this.getEntity()
            .getComponentDescriptor(function (component) { return component.scriptId === scriptId; }).attributes;
        var name = this.getName();
        this.getEntity().removeComponent(this);
        this.getEntity().addComponent(scriptId, attributes, name);
    };
    /**
     * Called when the component is first created.
     */
    BaseComponent.prototype.onAwake = function () {
        // nothing
    };
    /**
     * Called after the entity that this component is attached to starts to load.
     */
    BaseComponent.prototype.onStartup = function () {
        // nothing
    };
    /**
     * Called when the component or entity is unloaded
     */
    BaseComponent.prototype.onShutdown = function () {
        // nothing
    };
    /**
     * Called immediately before onUpdate.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onPreUpdate = function (delta) {
        // nothing
    };
    /**
     * Main update.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onUpdate = function (delta) {
        // nothing
    };
    /**
     * Called immediately after onUpdate.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onPostUpdate = function (delta) {
        // nothing
    };
    /**
     * Called just before rendering a frame.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onPreRender = function (delta) {
        // nothing
    };
    /**
     * Called at the time of rendering a frame.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onRender = function (delta) {
        // nothing
    };
    /**
     * Called immediately after rendering a frame.
     * @param delta The amount of time since the last call.
     */
    BaseComponent.prototype.onPostRender = function (delta) {
        // nothing
    };
    /**
     * Called just before rendering a view from each camera. Use this to run view-specific logic.
     * @param scene   The scene that is being rendered.
     * @param camera  The camera that is being rendered from.
     */
    BaseComponent.prototype.onPreRenderView = function (scene, camera) {
        // nothing
    };
    /**
     * Called just after rendering a view from each camera. Use this to run view-specific logic.
     * @param scene   The scene that is being rendered.
     * @param camera  The camera that is being rendered from.
     */
    BaseComponent.prototype.onPostRenderView = function (scene, camera) {
        // nothing
    };
    /** Called when the application loses focus */
    BaseComponent.prototype.onSuspend = function () {
        // nothing
    };
    /** Called when the application regains focus */
    BaseComponent.prototype.onResume = function () {
        // nothing
    };
    /**
     * Called when a component's attribute values change.
     * @param changes An array containing the names of all the attributes whose values
     *                have changed.
     */
    BaseComponent.prototype.onAttributesChanged = function (changes) {
        // nothing
    };
    /**
     * Called when the entity's runtime data (three.js data) is created and ready to use.
     * Note that all of the entity's children and dependencies (like materials, textures, etc.)
     * may not yet be loaded.
     */
    BaseComponent.prototype.onEntityReady = function () {
        // nothing
    };
    /** Called when the entity is completely loaded, including all of its dependencies. */
    BaseComponent.prototype.onEntityLoaded = function () {
        // nothing
    };
    /**
     * Called when all dependencies of the entity are loaded, including all of its children
     * and dependencies like textures, geometry, etc.
     */
    BaseComponent.prototype.onDependenciesLoaded = function () {
        // nothing
    };
    /** Called when component is enabled. */
    BaseComponent.prototype.onEnable = function () {
        // nothing
    };
    /** Called when component is disabled. */
    BaseComponent.prototype.onDisable = function () {
        // nothing
    };
    /** Internal startup, binds events and then calls user startup. */
    BaseComponent.prototype.onStartupInternal = function () {
        var _this = this;
        // Bind the component to engine events.
        engineEventMap.forEach(function (eventDef) {
            return _this.eventBindHelper(_this.getEngine(), eventDef);
        });
        // Bind the component to entity events.
        entityEvents.forEach(function (eventDef) {
            return _this.eventBindHelper(_this.getEntity(), eventDef);
        });
        this.onStartup();
        if (this.isEnabled()) {
            this.onEnable();
        }
    };
    /** Internal shutdown, unbind events and then calls user shutdown. */
    BaseComponent.prototype.onShutdownInternal = function () {
        // Unbind any events that we are listening to
        this.stopListening();
        this.onShutdown();
        // Re-bind to own events
        this.bindSelfEvents();
    };
    /**
     * A helper method for binding to events based on an event definition.
     * @param target    The target object
     * @param eventDef  The event binding definition
     */
    BaseComponent.prototype.eventBindHelper = function (target, eventDef) {
        if (typeof this[eventDef.method] !== 'function') {
            return;
        }
        if (eventDef.skippable && this[eventDef.method] === BaseComponent.prototype[eventDef.method]) {
            return;
        }
        this.listenTo(target, eventDef.event, this[eventDef.method]);
        // If the event should already have been triggered, immediately
        // call the callback function.
        if (eventDef.testMethod) {
            if (target[eventDef.testMethod]()) {
                this[eventDef.method]();
            }
        }
    };
    /** Bind to the events triggered on the component event system. */
    BaseComponent.prototype.bindSelfEvents = function () {
        var _this = this;
        selfEvents.forEach(function (eventDef) { return _this.eventBindHelper(_this, eventDef); });
    };
    return BaseComponent;
}(exports.baseComponentMixins));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseComponent;


/***/ },
/* 3 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var log = __webpack_require__(242);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = log;


/***/ },
/* 4 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var Ajv = __webpack_require__(213);
var functions_1 = __webpack_require__(6);
var Logger_1 = __webpack_require__(3);
// These are common pre-requisites for the larger schemas.
var refSchemas = [
    'accessor.json',
    'animationChannel.json',
    'animationClip.json',
    'animationLayer.json',
    'box3.json',
    'commonImageProperties.json',
    'imageRepresentation.json',
    'meshAttribute.json',
    'meshPrimitive.json',
    'representation.json',
    'shaderConditions.json',
    'shaderParameter.json',
    'vector3.json',
    'vector4.json',
    'videoRepresentation.json'
];
// Mapping of Entity Class -> schema file
var schemaMapping = {
    AnimationAsset: 'animationAssetProperties.json',
    ApplicationAsset: 'applicationAssetProperties.json',
    AudioAsset: 'audioAssetProperties.json',
    BufferAsset: 'bufferAssetProperties.json',
    DocumentAsset: 'documentAssetProperties.json',
    ImageAsset: 'imageAssetProperties.json',
    MaterialAsset: 'materialAssetProperties.json',
    MeshGeometryAsset: 'meshGeometryAssetProperties.json',
    PrefabAsset: 'prefabAssetProperties.json',
    PrimitiveGeometryAsset: 'primitiveGeometryAssetProperties.json',
    RenderTexture2DAsset: 'renderTexture2DAssetProperties.json',
    RenderTextureCubeAsset: 'renderTextureCubeAssetProperties.json',
    ScriptAsset: 'scriptAssetProperties.json',
    ShaderAsset: 'shaderAssetProperties.json',
    SkinAsset: 'skinAssetProperties.json',
    Texture2DAsset: 'texture2DAssetProperties.json',
    TextureCubeAsset: 'textureCubeAssetProperties.json',
    VideoAsset: 'videoAssetProperties.json',
    BoneObject: 'boneObjectProperties.json',
    CameraObject: 'cameraObjectProperties.json',
    LightObject: 'lightObjectProperties.json',
    MeshObject: 'meshObjectProperties.json',
    NodeObject: 'nodeObjectProperties.json',
    SceneObject: 'sceneObjectProperties.json'
};
var schemas = new Ajv({ useDefaults: true });
// Load and register the pre-requisite schemas.
functions_1.forEach(refSchemas, function (schemaName) {
    return schemas.addSchema(__webpack_require__(180)("./" + schemaName.replace('.json', '.ts')).default, schemaName);
});
// Load the per type schemas, caching in schemaSource by schema name.
var schemaSource = functions_1.values(schemaMapping).reduce(function (acc, schemaName) {
    acc[schemaName] = __webpack_require__(180)("./" + schemaName.replace('.json', '.ts')).default;
    return acc;
}, {});
// Register the loaded per type schemas.
functions_1.forEach(schemaSource, function (schema, schemaName) {
    schemas.addSchema(schema, schemaName);
});
/**
 * Gets the default properties for a specified schema.
 * @export
 * @param {string} schemaName
 * @returns {Object|Array}
 */
function getPropertyDefaultsForSchema(schemaName) {
    if (!schemaSource[schemaName] || !schemaSource[schemaName].properties) {
        throw new Error('Unknown schema: ' + schemaName);
    }
    var schema = schemas.getSchema(schemaName);
    var defaults = {};
    schema(defaults);
    return defaults;
}
exports.getPropertyDefaultsForSchema = getPropertyDefaultsForSchema;
/**
 * Gets separate, per-property validators for a given schema.
 * @export
 * @param {string} schemaName
 * @returns {Object}
 */
function getPropertyValidatorsForSchema(schemaName) {
    if (!schemaSource[schemaName] || !schemaSource[schemaName].properties) {
        throw new Error('Unknown schema: ' + schemaName);
    }
    return functions_1.map(schemaSource[schemaName].properties, function (schema, propertyName) {
        var computedName = schemaName + '-' + propertyName;
        var existingSchema = schemas.getSchema(computedName);
        if (!existingSchema) {
            schemas.addSchema(schema, computedName);
        }
        return existingSchema || schemas.getSchema(computedName);
    });
}
exports.getPropertyValidatorsForSchema = getPropertyValidatorsForSchema;
/**
 * Get the validator for a given schema.
 * @export
 * @param {string} schemaName
 * @returns {function}
 */
function getValidatorForSchema(schemaName) {
    return schemas.getSchema(schemaName);
}
exports.getValidatorForSchema = getValidatorForSchema;
/**
 * Attaches the validators and default properties to a given EntityConstructor.
 * @export
 * @param {string} name
 * @param {EntityConstructor<any>} constructor
 */
function addSchemas(name, constructor) {
    var schemaFile = schemaMapping[name];
    if (schemaFile) {
        constructor.validators = getPropertyValidatorsForSchema(schemaFile);
        constructor.defaults = getPropertyDefaultsForSchema(schemaFile);
    }
    else {
        Logger_1.default.warn("No schema file available for " + name);
        constructor.validators = {};
        constructor.defaults = {};
    }
}
exports.addSchemas = addSchemas;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = schemas;


/***/ },
/* 5 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseEntity_1 = __webpack_require__(32);
var baseAsset = tslib_1.__assign({}, baseEntity_1.default, { id: 'baseAsset', title: 'BaseAssetDef', properties: tslib_1.__assign({}, baseEntity_1.default.properties, { properties: {
            $ref: 'baseAssetProperties.json'
        }, representations: {
            type: 'array',
            description: 'Available representations for the asset.',
            items: {
                $ref: 'representation.json'
            }
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseAsset;


/***/ },
/* 6 */
/***/ function(module, exports) {

"use strict";
"use strict";
/**
 * Returns a new Object with each element (el) of 'object' filled with the return
 * value of fn(el). This preserves the shape of 'object'. i.e. the data type and number
 * of elements of the return value is the same as 'object'.
 * @param {Object} object The object to run the mapping on. Can be an array or POJO
 * @return {Object} The mapped object.
 */
exports.map = function (object, fn, context) {
    if (object === undefined || object === null) {
        return;
    }
    if (Array.isArray(object)) {
        return object.map(fn);
    }
    return Object.keys(object).reduce(function (newObj, key) {
        newObj[key] = (context ? fn.bind(context) : fn)(object[key], key);
        return newObj;
    }, {});
};
/**
 * Iterates over a collection running the provided function for each element.
 * @param {Mixed} object The object or array to iterate.
 * @param {Function} fn The function to be called for each element.
 * @param {Mixed} [context] The context to be used when calling `fn`.
 * @returns {Void}
 */
exports.forEach = function (object, fn, context) {
    if (object === undefined || object === null) {
        return;
    }
    if (Array.isArray(object)) {
        return object.forEach(fn, context);
    }
    return Object.keys(object).forEach(function (key) {
        (context ? fn.bind(context) : fn)(object[key], key);
    });
};
/**
 * Returns an array of values from an object, effectively converting an object
 * into an array while discarding the keys.
 * @param {Object} object The object from which to extract the values.
 * @returns {Array} The array of values
 */
exports.values = function (object) {
    if (object === undefined || object === null) {
        return;
    }
    if (Array.isArray(object)) {
        return object;
    }
    return Object.keys(object).reduce(function (arr, key) {
        arr.push(object[key]);
        return arr;
    }, []);
};


/***/ },
/* 7 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseEntity_1 = __webpack_require__(11);
/**
 * The base class asset.
 */
var BaseAsset = (function (_super) {
    tslib_1.__extends(BaseAsset, _super);
    function BaseAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    BaseAsset.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.on('triggerLoad', this.load, this);
    };
    /** @inheritdoc */
    BaseAsset.prototype.uninitialize = function () {
        this.off('triggerLoad', this.load, this);
        // Uninitialize this asset ( will force unload the asset and its children)
        _super.prototype.uninitialize.call(this);
    };
    /**
     * Returns the asset with the provided Id, if it exists.
     * @param assetId The ID of the asset
     * @returns       The asset or null if not found.
     */
    BaseAsset.prototype.getAssetById = function (assetId) {
        return this.engine.getAssetById(assetId);
    };
    /** @inheritdoc */
    BaseAsset.prototype.unload = function () {
        // abort xhr request associated with this
        this.abortRequests();
        _super.prototype.unload.call(this);
    };
    /** Destroys the asset and causes any instances of the asset to be removed. */
    BaseAsset.prototype.destroy = function () {
        this.engine.trigger(this.type + 'Deleted', this.id);
        this.engine.destroyAsset(this);
    };
    /** @inheritdoc */
    BaseAsset.prototype.clone = function (id) {
        var clonedAsset = _super.prototype.clone.call(this, id);
        clonedAsset.set('representations', this.get('representations'));
        return clonedAsset;
    };
    return BaseAsset;
}(BaseEntity_1.default));
/** @inheritdoc */
BaseAsset.events = {
    triggerLoad: {
        scope: 'local',
        params: [],
        action: true,
        category: 'Loading'
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseAsset;


/***/ },
/* 8 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseEntityProperties_1 = __webpack_require__(33);
var baseAssetProperties = tslib_1.__assign({}, baseEntityProperties_1.default, { id: 'baseAssetProperties', title: 'BaseAssetPropertiesDef' });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseAssetProperties;


/***/ },
/* 9 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-file-line-count */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseEntity_1 = __webpack_require__(11);
var Schemas_1 = __webpack_require__(4);
var NodeObject = (function (_super) {
    tslib_1.__extends(NodeObject, _super);
    function NodeObject() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    NodeObject.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.on('setVisible', this.setVisible, this);
        this.on('setInvisible', this.setInvisible, this);
        this.on('toggleVisibility', this.toggleVisibility, this);
        this.on('change:children', this.onChildrenChanged, this);
    };
    /** @inheritdoc */
    NodeObject.prototype.uninitialize = function () {
        this.off('setVisible', this.setVisible, this);
        this.off('setInvisible', this.setInvisible, this);
        this.off('toggleVisibility', this.toggleVisibility, this);
        this.off('change:children', this.onChildrenChanged, this);
        this.uninitPrefabBindings();
        _super.prototype.uninitialize.call(this);
    };
    /**
     * Returns the top-object (the root) of this object's hierarchy.
     * @returns The root object of this hierarchy.
     */
    NodeObject.prototype.getRootObject = function () {
        var parent = this.getParentObject();
        if (parent) {
            return parent.getRootObject();
        }
        return this;
    };
    /**
     * Reset the transform of the object from its internal data. i.e. If you have modified the Three.js
     * object data directly, you can call reset to return the transform to the state stored in the
     * Box3D entity.
     */
    NodeObject.prototype.reset = function () {
        if (this.runtimeData) {
            this.runtimeData.position.copy(this.getPosition());
            this.runtimeData.quaternion.copy(this.getQuaternion());
            this.runtimeData.scale.copy(this.getScale());
        }
    };
    /** @inheritdoc */
    NodeObject.prototype.createRuntimeData = function (callback) {
        // Default implementation creates a THREE.Object3D.
        this.runtimeData = new THREE.Object3D();
        this.runtimeData.name = this.getRuntimeName();
        callback();
    };
    /**
     * Clones the object.
     * @param id        The new ID for the clone.
     * @param recursive If true, clone will also clone the entire hierarchy under
     * this object.
     * @returns         The newly-created clone
     */
    NodeObject.prototype.clone = function (_id, recursive) {
        if (recursive === void 0) { recursive = true; }
        // FIXME, does id even get used???
        var clonedObject = _super.prototype.clone.call(this);
        clonedObject.set('parentId', null);
        clonedObject.set('prefabAssetId', this.get('prefabAssetId'));
        clonedObject.set('prefabObjectId', this.get('prefabObjectId'));
        if (recursive) {
            var children = this.getChildren();
            children.forEach(function (child) {
                var newChild = child.clone(undefined, recursive);
                clonedObject.addChild(newChild);
            });
            // Only copy the prefab links if the top-level of the instance is being copied
            // If the top-level is copied, set the flag so that recursive calls will copy links.
            if (this.isInstanceTop()) {
                clonedObject.set('prefabInstanceId', clonedObject.id);
                clonedObject.traverse(function (obj) {
                    obj.set('prefabInstanceId', clonedObject.id);
                });
            }
        }
        return clonedObject;
    };
    /**
     * Align an object relative to a position. This uses the object's bounding box.
     * @param newPosition The position to work relative to.
     * @param [alignment] An object of the form { x: x, y: y, z: z} where the
     *                    values for x, y and z are between -1 and +1 and specify
     *                    how the object is aligned to the edges of the model. e.g.
     *                    { x: 0, y: -1, z: 0 } will align the bottom, centre of the
     *                    object to the specified position.
     */
    NodeObject.prototype.alignToPosition = function (newPosition, alignment) {
        var position = new THREE.Vector3(newPosition.x || 0, newPosition.y || 0, newPosition.z || 0);
        var quaternion = this.getQuaternion();
        var scale = this.getScale();
        var center = this.getCenter();
        var rotation = new THREE.Quaternion(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
        var bounds = this.getBounds();
        var aabb = {};
        aabb.min = new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z);
        aabb.max = new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z);
        aabb.min.applyQuaternion(rotation);
        aabb.max.applyQuaternion(rotation);
        var offset = new THREE.Vector3(center.x, center.y, center.z);
        offset.applyQuaternion(rotation);
        aabb.min.multiply(scale);
        aabb.max.multiply(scale);
        offset.multiply(scale);
        if (alignment) {
            Object.keys(alignment).forEach(function (x) {
                var newMin = Math.min(aabb.min[x], aabb.max[x]);
                var newMax = Math.max(aabb.min[x], aabb.max[x]);
                var align = alignment[x] * 0.5 + 0.5;
                position[x] -= ((1.0 - align) * newMin + align * newMax);
            });
        }
        this.setProperty('position', tslib_1.__assign({}, position));
    };
    /**
     * Get the position of the object
     * @param [outVector] Optional vector to write the result to. Passing this in will
     *                    avoid another THREE.Vector3 from being created.
     * @returns           The position of the object
     */
    NodeObject.prototype.getPosition = function (outVector) {
        var returnVector = outVector || new THREE.Vector3();
        returnVector.copy(this.getProperty('position'));
        return returnVector;
    };
    /**
     * Set the position of the object
     * @param x X-axis position
     * @param y Y-axis position
     * @param z Z-axis position
     */
    NodeObject.prototype.setPosition = function (x, y, z) {
        if (z === undefined) {
            throw new Error('Calling setPosition with invalid arguments. Expected ' +
                'setPosition( x, y, z ).');
        }
        this.setProperty('position', { x: x, y: y, z: z });
    };
    /**
     * Get the quaternion for the object
     * @returns The object's quaternion
     */
    NodeObject.prototype.getQuaternion = function (outQuaternion) {
        var quaternion = outQuaternion || new THREE.Quaternion();
        quaternion.copy(this.getProperty('quaternion'));
        return quaternion;
    };
    /**
     * Set the quaternion for the object
     * @param x X-component
     * @param y Y-component
     * @param z Z-component
     * @param w W-component
     */
    NodeObject.prototype.setQuaternion = function (x, y, z, w) {
        if (w === undefined) {
            throw new Error('Calling setQuaternion with invalid arguments. Expected ' +
                'setQuaternion( x, y, z, w ).');
        }
        this.setProperty('quaternion', { x: x, y: y, z: z, w: w });
    };
    /**
     * Get the current scale of the object
     * @param [outVector] Optional vector to write the result to. Passing this in will
     *                    avoid another THREE.Vector3 from being created.
     * @returns           A vector with the scale along each axis.
     */
    NodeObject.prototype.getScale = function (outVector) {
        var returnVector = outVector || new THREE.Vector3();
        returnVector.copy(this.getProperty('scale'));
        return returnVector;
    };
    /**
     * Set the scale on each axis
     * @param x Value to scale the x axis
     * @param y Value to scale the y axis
     * @param z Value to scale the z axis
     */
    NodeObject.prototype.setScale = function (x, y, z) {
        if (z === undefined) {
            throw new Error('Calling setScale with invalid arguments. Expected setScale( x, y, z ).');
        }
        this.setProperty('scale', { x: x, y: y, z: z });
    };
    /**
     * Get the center point of the object
     * @param [outVector] Optional vector to write the result to. Passing this in will
     *                    avoid another THREE.Vector3 from being created.
     * @returns           The center point of the object. if the object has no center,
     *                    it uses the center of the bounding box
     */
    NodeObject.prototype.getCenter = function (outVector) {
        var returnVector = outVector || new THREE.Vector3();
        var bb = this.getBounds();
        returnVector.copy(bb.min);
        returnVector.add(bb.max);
        returnVector.multiplyScalar(0.5);
        return returnVector;
    };
    /**
     * Set this object as visible. Any rendered object in its hierarchy will become visible.
     */
    NodeObject.prototype.setVisible = function () {
        this.setProperty('visible', true);
        this.engine.needsRender = true;
    };
    /**
     * Set this object as invisible. Any rendered object in its hierarchy will become invisible.
     */
    NodeObject.prototype.setInvisible = function () {
        this.setProperty('visible', false);
        this.engine.needsRender = true;
    };
    /**
     * Toggle the object's visibility. If it was invisible, it will become visible, etc.
     */
    NodeObject.prototype.toggleVisibility = function () {
        var visible = this.getProperty('visible') ? false : true;
        this.setProperty('visible', visible);
        this.engine.needsRender = true;
    };
    /** @inheritdoc */
    NodeObject.prototype.loadBase = function (callback) {
        _super.prototype.loadBase.call(this, callback);
        // Start listening to prefab change events.
        if (this.isInstance()) {
            this.initPrefabBindings();
        }
    };
    /** @inheritdoc */
    NodeObject.prototype.reloadBase = function (callback) {
        var _this = this;
        // Stop listening to prefab change events.
        if (this.isInstance()) {
            this.uninitPrefabBindings();
        }
        // Remove the old runtimeData from its parent.
        var parent = this.runtimeData && this.runtimeData.parent;
        if (parent) {
            parent.remove(this.runtimeData);
        }
        // Save the children!
        var children = this.runtimeData && this.runtimeData.children;
        _super.prototype.reloadBase.call(this, function () {
            // Add the new runtimeData to the parent.
            if (parent) {
                parent.add(_this.runtimeData);
            }
            if (children) {
                // Add the old children to the new object.
                children.forEach(function (child) { return _this.runtimeData.add(child); });
            }
            if (typeof callback === 'function') {
                callback();
            }
        });
    };
    /**
     * Unload the object.
     * @param recursive Unload entire hierarchy of objects. False by default.
     */
    NodeObject.prototype.unload = function (recursive) {
        var _this = this;
        if (recursive === void 0) { recursive = false; }
        // Remove the object from its parent
        if (this.runtimeData && this.runtimeData.parent) {
            this.runtimeData.parent.remove(this.runtimeData);
        }
        // Unload children
        if (recursive) {
            var children = this.getChildIds();
            children.forEach(function (id) {
                var childObj = _this.engine.getObjectById(id);
                if (childObj) {
                    childObj.unload(recursive);
                }
            });
        }
        _super.prototype.unload.call(this);
    };
    /**
     * Destroy the object and remove it from any hierarchy that it is part of.
     * This does not automatically destroy any children of this object but it does
     * disconnect them from the hierarchy.
     */
    NodeObject.prototype.destroy = function () {
        this.engine.destroyObjectById(this.id);
    };
    /**
     * Traverse this entity's hierarchy and call the given function for each of them.
     * @param fn        The function to call for each object. The function will be passed
     *                  two parameters. The first is the object and the second is the parent.
     *                  If the function returns a truthy value, the traverse will immediately stop.
     * @param [context] The context in which to call the callback function.
     * @returns         True if the traverse short-circuited. False otherwise.
     */
    NodeObject.prototype.traverse = function (fn, context) {
        var cxt = context || this;
        var children = this.getChildren();
        return children.some(function (child) {
            return fn.call(cxt, child) || child.traverse(fn, cxt);
        });
    };
    /**
     * Return an array of each ancestor of this object, starting with its parent.
     * @param [predicate] A function which returns 'true' or 'false' and
     *                    is used to filter results.
     * @returns           The array of ancestor objects
     */
    NodeObject.prototype.getAncestors = function (predicate) {
        var parent = this.getParentObject();
        if (!parent) {
            return [];
        }
        if (predicate && !predicate(parent)) {
            return parent.getAncestors(predicate);
        }
        return [parent].concat(parent.getAncestors(predicate));
    };
    /**
     * Traverse this entity's hierarchy and return an array containing all of the entities
     * satisfying the predicate function
     * @param [predicate] A function which returns 'true' or 'false'
     * @return            The matching entities
     */
    NodeObject.prototype.getDescendants = function (predicate) {
        var results = [];
        var all = typeof predicate !== 'function';
        this.traverse(function (e) {
            if (all || predicate(e)) {
                results.push(e);
            }
        });
        return results;
    };
    /**
     * Traverse this entity's hierarchy and return the first entity satisfying
     * the predicate function
     * @param predicate A function which returns 'true' or 'false'
     * @returns         The matching entities
     */
    NodeObject.prototype.getDescendant = function (predicate) {
        var all = typeof predicate !== 'function';
        var entity;
        this.traverse(function (e) {
            if (!entity && (all || predicate(e))) {
                entity = e;
                return true;
            }
        });
        return entity;
    };
    /**
     * Returns the object with the provided Id, if it exists in this entity's hierarchy.
     * @param objectId  The ID of the object
     * @returns         The object or null if not found.
     */
    NodeObject.prototype.getDescendantById = function (objectId) {
        return this.getDescendant(function (e) { return e.id === objectId; });
    };
    /**
     * Returns the first object with the provided name that is found in this object's hierarchy.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @param objectName  The name of the object
     * @returns           The object, if found, or null if not found.
     */
    NodeObject.prototype.getDescendantByName = function (objectName) {
        return this.getDescendant(function (e) { return e.getName() === objectName; });
    };
    /**
     * Returns the first object with the provided type that is in this entity's hierarchy.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @param objectType  The type of the object
     * @returns           The object, if found, or null if not found.
     */
    NodeObject.prototype.getDescendantByType = function (objectType) {
        return this.getDescendant(function (e) { return e.type === objectType; });
    };
    /**
     * Returns all objects with the provided type that are in this entity's hierarchy.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @param objectType  The type of the object
     * @returns           An array of all objects with the given name.
     */
    NodeObject.prototype.getDescendantsByType = function (objectType) {
        return this.getDescendants(function (e) { return e.type === objectType; });
    };
    /**
     * Returns all objects with the provided name that are in this entity's hierarchy.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not build for high performance.
     * @param objectName  The name of the object
     * @returns           An array of all objects with the given name.
     */
    NodeObject.prototype.getDescendantsByName = function (objectName) {
        return this.getDescendants(function (e) { return e.getName() === objectName; });
    };
    /**
     * Returns the object if it is a direct child of this object.
     * @param objectId  The ID of the child to get
     * @returns         The child object, if it exists
     */
    NodeObject.prototype.getChildById = function (objectId) {
        if (this.sharedData.children.indexOf(objectId) !== -1) {
            return this.engine.getObjectById(objectId);
        }
        return null;
    };
    /**
     * Return the first direct child of this object that matches the given predicate function.
     * @param [predicate] A function which returns 'true' or 'false', used to determine
     *                    which entity to return.
     * @returns           The first matching object.
     */
    NodeObject.prototype.getChild = function (predicate) {
        var children = this.getChildren(predicate);
        return children.length ? children[0] : null;
    };
    /**
     * Return all direct children of this object that match the given predicate function.
     * @param [predicate] A function which returns 'true' or 'false', used to
     *                    determine which entities to return.
     * @returns           An array containing all the matching objects.
     */
    NodeObject.prototype.getChildren = function (predicate) {
        var _this = this;
        var children = this.getChildIds();
        var all = typeof predicate !== 'function';
        return children.filter(function (id) {
            var child = _this.getChildById(id);
            return child && (all || predicate(child));
        }).map(function (id) { return _this.engine.getObjectById(id); });
    };
    /**
     * Return all direct children of this object that match the given predicate function.
     * @param predicate A function which returns 'true' or 'false', used to
     *                  determine which entities to return.
     * @returns         An map from object ID's to all matching objects.
     */
    NodeObject.prototype.getChildrenMap = function (predicate) {
        var results = {};
        var children = this.getChildren(predicate);
        children.forEach(function (obj) {
            if (obj) {
                results[obj.id] = obj;
            }
        });
        return results;
    };
    /**
     * Returns the object that is the immediate parent of this one.
     * Returns null if this object doesn't have a parent. This will be
     * the case if the object is an asset or is orphaned.
     * @returns The parent object of this object.
     */
    NodeObject.prototype.getParentObject = function () {
        return this.engine.getObjectById(this.get('parentId'));
    };
    /**
     * Adds the specified object as a direct child of this object.
     * @param object    The object to add as a direct child of this object.
     * @param [silent]  Suppress change event. Defaults to false.
     */
    NodeObject.prototype.addChild = function (object, silent) {
        this.addChildById(object.id, silent);
    };
    /**
     * Adds the specified object as a direct child of this object.
     * @param objectId  The ID of the object to add as a direct child of this object.
     * @param silent    Suppress change event. Defaults to false.
     */
    NodeObject.prototype.addChildById = function (objectId, silent) {
        var object = this.engine.getObjectById(objectId);
        if (!object) {
            throw new Error("Can't find child object with id, " + objectId);
        }
        this.engine.entityDispatcher.dispatchChildAdded(this.id, objectId, silent);
    };
    /**
     * Removes the specified object as a direct child of this asset.
     * This does not delete (destroy) the object or unload it.
     * @param object    The object to add as a direct child of this object.
     * @param [silent]  Suppress change event. Defaults to false.
     */
    NodeObject.prototype.removeChild = function (object, silent) {
        this.removeChildById(object.id, silent);
    };
    /**
     * Removes the specified object as a direct child of this asset.
     * This does not delete (destroy) the object or unload it.
     * @param childId The ID of the child to be removed as a direct child of
     * this object.
     */
    NodeObject.prototype.removeChildById = function (childId, silent) {
        var child = this.getChildById(childId);
        if (!child) {
            throw new Error("Object, " + childId + ", is not a child of this object");
        }
        this.engine.entityDispatcher.dispatchChildRemoved(this.id, childId, silent);
    };
    /**
     * Return all ID's for the direct children of this object that match the given predicate
     * function.
     * @param [predicate] A function which returns 'true' or 'false', used to
     *                    determine which ID's to return.
     * @returns           An array containing all the matching child ID's.
     */
    NodeObject.prototype.getChildIds = function (predicate) {
        var all = typeof predicate !== 'function';
        if (all) {
            return this.sharedData.children.slice();
        }
        return this.sharedData.children.filter(function (id) { return predicate(id); });
    };
    /**
     * Set the entire set of children in one call.
     * @param newChildren Array of children ids to set.
     * @param silent      Suppress change event. Defaults to false.
     */
    NodeObject.prototype.setChildIds = function (newChildren, silent) {
        if (silent === void 0) { silent = false; }
        this.engine.entityDispatcher.dispatchChildChanged(this.id, newChildren, silent);
    };
    /**
     * Scale this object to a fixed size in the space of its parent. e.g. world space
     * @param size The size in units of the parent's space.
     */
    NodeObject.prototype.scaleToSize = function (size) {
        var aabb = {};
        var bb = this.getBounds();
        aabb.min = new THREE.Vector3(bb.min.x, bb.min.y, bb.min.z);
        aabb.max = new THREE.Vector3(bb.max.x, bb.max.y, bb.max.z);
        // Determine the mesh's scale and origin.
        var distance = aabb.min.distanceTo(aabb.max);
        var scale = size / distance;
        if (scale <= 0) {
            scale = 1.0;
        }
        this.setProperty('scale', {
            x: scale,
            y: scale,
            z: scale
        });
    };
    /**
     * Get the bounds for the hierarchy rooted at this object.
     * @param [outBounds] Optional Box3 to write the result to. Passing this in will
     *                    avoid another THREE.Box3 from being created.
     * @returns           The bounds of the hierarchy, in this object's local space.
     */
    NodeObject.prototype.getBounds = function (outBounds) {
        var bounds = this.getProperty('bounds');
        var returnBounds = outBounds || new THREE.Box3();
        if (bounds) {
            return returnBounds.set(bounds.min, bounds.max);
        }
        return this.computeBounds(returnBounds);
    };
    /**
     * Get the bounds of this object, but not its children.
     * @param [outBounds] Optional Box3 to write the result to. Passing this in will
     *                    avoid another THREE.Box3 from being created.
     * @returns           The bounds of this object.
     */
    NodeObject.prototype.getLocalBounds = function (outBounds) {
        var returnBounds = outBounds || new THREE.Box3();
        returnBounds.min.set(Infinity, Infinity, Infinity);
        returnBounds.max.set(-Infinity, -Infinity, -Infinity);
        return returnBounds;
    };
    /**
     * Compute the bounds for the hierarchy rooted at this object.
     * @param [outBounds] Optional Box3 to write the result to. Passing this in will
     *                    avoid another THREE.Box3 from being created.
     * @returns           The bounds of the hierarchy in this object's local space.
     */
    NodeObject.prototype.computeBounds = function (outBounds) {
        var children = this.getChildren();
        var box = this.getLocalBounds(outBounds || new THREE.Box3());
        var xform = new THREE.Matrix4();
        children.forEach(function (child) {
            var childBox = child.computeBounds();
            if (childBox.isEmpty()) {
                return;
            }
            // Transform the child's bounds into its parent's space.
            xform.compose(child.getPosition(), child.getQuaternion(), child.getScale());
            childBox.applyMatrix4(xform);
            // Combine the child box with the others.
            box.union(childBox);
        });
        this.setProperty('bounds', {
            min: { x: box.min.x, y: box.min.y, z: box.min.z },
            max: { x: box.max.x, y: box.max.y, z: box.max.z }
        });
        return box;
    };
    /**
     * Returns the previous value of the property specified by 'propertyName'
     * @param propertyName  The name of the property.
     * @returns             The property's previous value
     */
    NodeObject.prototype.getPreviousProperty = function (propertyName) {
        var value = this.sharedData.previousProperties[propertyName];
        if (value !== undefined) {
            return value;
        }
        var prefabObj = this.getPrefabObject();
        if (prefabObj) {
            return prefabObj.getProperty(propertyName);
        }
        return this.getDefaultProperty(propertyName);
    };
    /**
     * Returns the property value specified by 'propertyName'.
     * @param propertyName  The name of the property.
     * @returns             The property value
     */
    NodeObject.prototype.getProperty = function (propertyName) {
        var localProperty = this.getOwnProperty(propertyName);
        if (localProperty !== undefined) {
            return localProperty;
        }
        var prefabProperty = this.getPrefabProperty(propertyName);
        if (prefabProperty) {
            return prefabProperty;
        }
        return this.getDefaultProperty(propertyName);
    };
    /**
     * Returns all properties of the entity, including those inherited from
     * the entity's prefab.
     * @returns The properties
     */
    NodeObject.prototype.getProperties = function () {
        var myProperties = this.getOwnProperties();
        var prefabObj = this.getPrefabObject();
        var defaultProps = this.getDefaultProperties();
        // If this object has a prefab, inherit the prefab's properties in the returned
        // structure.
        if (prefabObj) {
            var prefabObjProperties = prefabObj.getOwnProperties();
            return Object.assign(defaultProps, prefabObjProperties, myProperties);
        }
        else {
            return Object.assign(defaultProps, myProperties);
        }
    };
    // ************ Prefabs ***********
    /**
     * If this object is a prefab instance, return the top-level of the instance.
     * @returns The top-level object of the prefab instance.
     */
    NodeObject.prototype.getInstanceTop = function () {
        var prefabInstanceId = this.get('prefabInstanceId');
        if (prefabInstanceId) {
            return this.engine.getObjectById(prefabInstanceId);
        }
        else {
            return null;
        }
    };
    /**
     * Returns the object that stores the source data for this object.
     * @returns The asset where the source data for this object is stored.
     */
    NodeObject.prototype.getPrefabObject = function () {
        return this.engine.getObjectById(this.get('prefabObjectId'));
    };
    /**
     * Returns the property given by 'propertyName' for this entity's
     * prefab (if any).
     * @param propertyName  The name of the property.
     * @returns             The property value
     */
    NodeObject.prototype.getPrefabProperty = function (propertyName) {
        var prefabObj = this.getPrefabObject();
        if (prefabObj) {
            return prefabObj.getProperty(propertyName);
        }
        return undefined;
    };
    /**
     * Returns true if the object is an instance of a prefab asset.
     * @returns True if the object is an instance of a prefab object. false otherwise.
     */
    NodeObject.prototype.isInstance = function () {
        return !!this.get('prefabObjectId');
    };
    /**
     * Returns true if the object is the top-level of a prefab instance tree.
     * @returns True if and only if the object is the top level of a prefab instance.
     */
    NodeObject.prototype.isInstanceTop = function () {
        return this.get('prefabInstanceId') === this.id;
    };
    /**
     * Unlink this entity from its prefab. This will prevent it from receiving prefab
     * updates. By default, the entity's hierarchy is also unlinked.
     * Passing in 'recursive' as 'false' will prevent this.
     * @param [recursive] Whether or not to traverse children
     */
    NodeObject.prototype.breakPrefabLink = function (recursive) {
        if (recursive === void 0) { recursive = true; }
        if (!this.isInstance()) {
            throw new Error('breakPrefabLink: Can\'t call this on an entity that isn\'t an instance.');
        }
        if (recursive) {
            this.getChildren().forEach(function (child) {
                child.breakPrefabLink(recursive);
            });
        }
        this.uninitPrefabBindings();
        this.mergeProperties(this.getPrefabObject());
        // FIXME, this doesn't exist
        // this.mergeComponents(this.getPrefabObject());
        var changes = {};
        changes.prefabInstanceId = undefined;
        changes.prefabObjectId = undefined;
        changes.prefabAssetId = undefined;
        // FIXME this isn't an acceptable syntax for set anymore.
        // this.set(changes);
    };
    /** @inheritdoc */
    NodeObject.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (changes.hasOwnProperty('static')) {
            var isStatic = this.getProperty('static');
            this.runtimeData.matrixAutoUpdate = !isStatic;
            this.runtimeData.rotationAutoUpdate = !isStatic;
            if (isStatic) {
                this.runtimeData.matrixWorldNeedsUpdate = true;
                this.runtimeData.updateMatrix();
            }
        }
        if (changes.hasOwnProperty('visible')) {
            this.runtimeData.visible = this.getProperty('visible');
        }
        if (changes.hasOwnProperty('castShadow')) {
            this.runtimeData.castShadow = this.getProperty('castShadow');
        }
        if (changes.hasOwnProperty('receiveShadow')) {
            this.runtimeData.receiveShadow = this.getProperty('receiveShadow');
        }
        if (changes.hasOwnProperty('frustumCulled')) {
            this.runtimeData.frustumCulled = this.getProperty('frustumCulled');
        }
        // Transform updates
        if (changes.hasOwnProperty('position')) {
            var position = this.getPosition();
            this.runtimeData.position.set(position.x, position.y, position.z);
        }
        if (changes.hasOwnProperty('quaternion')) {
            var quaternion = this.getQuaternion();
            this.runtimeData.quaternion.set(quaternion.x, quaternion.y, quaternion.z, quaternion.w);
        }
        if (changes.hasOwnProperty('scale')) {
            var scale = this.getScale();
            this.runtimeData.scale.set(scale.x, scale.y, scale.z);
        }
    };
    /**
     * Get the name that should be assigned to the runtime object (i.e., this.runtimeData).
     * @returns The runtime name.
     */
    NodeObject.prototype.getRuntimeName = function () {
        return this.engine.getRuntimeName(this.getSid());
    };
    /**
     * If this object is an instance of another, we'll hook up the entity events
     * so that we can listen to changes to the source asset.
     */
    NodeObject.prototype.initPrefabBindings = function () {
        var prefabObject = this.getPrefabObject();
        if (prefabObject) {
            prefabObject.on('propertyChanges', this.onPrefabEntityChanged, this);
        }
    };
    /**
     * Disconnect this instance object from listening to changes on the source asset.
     */
    NodeObject.prototype.uninitPrefabBindings = function () {
        var prefabObject = this.getPrefabObject();
        if (prefabObject) {
            prefabObject.off('propertyChanges', this.onPrefabEntityChanged, this);
        }
    };
    /**
     * Called when the prefab object for this object instance has changed.
     */
    NodeObject.prototype.onPrefabEntityChanged = function () {
        Logger_1.default.warn('TODO - re-implement updating from prefab changes');
    };
    /**
     * Bound to the loadBase event for each child. This allows us to add the child
     * when it's loaded. We do this rather than using listenToOnce so that we can
     * handle cases of reloading.
     * @param child The child that has just loaded.
     */
    NodeObject.prototype.onChildLoaded = function (child) {
        var _this = this;
        this.when('loadBase', function () {
            _this.runtimeData.add(child.runtimeData);
            _this.engine.needsRender = true;
        });
    };
    /**
     * Called when the entity's children list changes. Handles linking
     * and unlinking children after changes made.
     * @param addedChildren   An array of newly-added child objects.
     * @param removedChildren An array of newly-removed child objects.
     */
    NodeObject.prototype.onChildrenChanged = function (addedChildren, removedChildren) {
        var _this = this;
        // Remove the children specified
        removedChildren.forEach(function (child) {
            if (!child) {
                return;
            }
            child.set('parentId', null);
            _this.unregisterDependency(child);
            _this.stopListening(child, 'loadBase', _this.onChildLoaded);
            // Handle case where the three.js child is already attached.
            if (_this.isBaseLoaded() && child.isBaseLoaded()) {
                _this.runtimeData.remove(child.runtimeData);
                _this.engine.needsRender = true;
            }
        });
        // Now, add children that should be added.
        addedChildren.forEach(function (child) {
            var oldParent = child.getParentObject();
            // If the object has a parent already, remove it from that parent.
            if (oldParent && oldParent.id !== _this.id) {
                // Remove the object from previous parent
                oldParent.removeChildById(child.id, true);
            }
            // Setting the parent id because this might not exist yet.
            child.set('parentId', _this.id);
            // Listen for when the child loads so that we can attach the three.js child.
            // Note that we don't listen for unload because the unloading code handles the
            // removal of the child.
            _this.listenTo(child, 'loadBase', _this.onChildLoaded);
            // Handle the cases where the three.js child can already be attached.
            if (child.isBaseLoaded()) {
                if (_this.isBaseLoaded()) {
                    _this.runtimeData.add(child.runtimeData);
                    _this.engine.needsRender = true;
                }
                else {
                    // We need to handle this case separately because, if the child is already loaded,
                    // it won't trigger 'onChildLoaded' again.
                    _this.when('loadBase', function () {
                        _this.runtimeData.add(child.runtimeData);
                        _this.engine.needsRender = true;
                    });
                }
            }
            _this.registerDependency(child);
        });
    };
    return NodeObject;
}(BaseEntity_1.default));
/** @inheritdoc */
NodeObject.events = {
    toggleVisibility: {
        params: [],
        action: true,
        category: 'Rendering'
    },
    setVisible: {
        params: [],
        action: true,
        category: 'Rendering'
    },
    setInvisible: {
        params: [],
        action: true,
        category: 'Rendering'
    }
};
Schemas_1.addSchemas('NodeObject', NodeObject);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = NodeObject;


/***/ },
/* 10 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(7);
var Logger_1 = __webpack_require__(3);
/**
 * Available layouts for an image or texture.
 */
var ImageLayout;
(function (ImageLayout) {
    /** normal, the default. */
    ImageLayout[ImageLayout["Normal"] = 101] = "Normal";
    /** above-below */
    ImageLayout[ImageLayout["Stereo2dOverUnder"] = 102] = "Stereo2dOverUnder";
    /** below-above */
    ImageLayout[ImageLayout["Stereo2dUnderOver"] = 103] = "Stereo2dUnderOver";
    /** parallel-eyed */
    ImageLayout[ImageLayout["Stereo2dLeftRight"] = 104] = "Stereo2dLeftRight";
    /** cross-eyed */
    ImageLayout[ImageLayout["Stereo2dRightLeft"] = 105] = "Stereo2dRightLeft";
    ImageLayout[ImageLayout["StereoCubeHorizontal"] = 106] = "StereoCubeHorizontal";
})(ImageLayout = exports.ImageLayout || (exports.ImageLayout = {}));
/**
 * The base class for all image asset subtypes.
 */
var BaseImageAsset = (function (_super) {
    tslib_1.__extends(BaseImageAsset, _super);
    function BaseImageAsset() {
        var _this = _super.apply(this, arguments) || this;
        /**
         * Current number of loaded bytes
         * @type {number}
         */
        _this.loadedBytes = 0;
        return _this;
    }
    /**
     * Converts a format string into a THREE.PixelFormat.
     * @param format One of 'alpha', 'rgb', 'rgba', 'luminance', or 'luminanceAlpha'
     * @returns The mapped THREE.js constant.
     */
    BaseImageAsset.getThreeImageFormat = function (format) {
        switch (format) {
            case 'alpha': return THREE.AlphaFormat;
            case 'rgb': return THREE.RGBFormat;
            case 'rgba': return THREE.RGBAFormat;
            case 'luminance': return THREE.LuminanceFormat;
            case 'luminanceAlpha': return THREE.LuminanceAlphaFormat;
            default:
                Logger_1.default.warn("Unexpected format: " + format + ", defaulting to THREE.RGBFormat");
                return THREE.RGBFormat;
        }
    };
    /**
     * Converts an encoding string into a THREE.TextureEncoding or THREE.DepthPackingStrategies.
     * @param encoding One of 'linear', 'srgb', 'gamma', 'rgbe', 'logLuv', 'rgbm7', 'rgbm16',
     *                 'rgbd', 'depth' or 'rgbDepth'
     * @returns The mapped THREE.js constant.
     */
    BaseImageAsset.getThreeImageEncoding = function (encoding) {
        switch (encoding) {
            case 'linear': return THREE.LinearEncoding;
            case 'srgb': return THREE.sRGBEncoding;
            case 'gamma': return THREE.GammaEncoding;
            case 'rgbe': return THREE.RGBEEncoding;
            case 'logLuv': return THREE.LogLuvEncoding;
            case 'rgbm7': return THREE.RGBM7Encoding;
            case 'rgbm16': return THREE.RGBM16Encoding;
            case 'rgbd': return THREE.RGBDEncoding;
            // Depth packing strategies
            case 'depth': return THREE.BasicDepthPacking;
            case 'rgbaDepth': return THREE.RGBADepthPacking;
            default:
                Logger_1.default.warn("Unexpected format: " + encoding + ", defaulting to THREE.sRGBEncoding");
                return THREE.sRGBEncoding;
        }
    };
    /**
     * Converts a type string into a THREE.TextureDataType or THREE.PixelType.
     * @param type One of 'uByte', 'byte', 'short', 'uShort', 'int', 'uInt', 'float',
     *             'halfFloat', 'uShort4444', 'uShort5551' or 'uShort565'
     * @returns The mapped THREE.js constant.
     */
    BaseImageAsset.getThreeImageType = function (type) {
        switch (type) {
            case 'uByte': return THREE.UnsignedByteType;
            case 'byte': return THREE.ByteType;
            case 'short': return THREE.ShortType;
            case 'uShort': return THREE.UnsignedShortType;
            case 'int': return THREE.IntType;
            case 'uInt': return THREE.UnsignedIntType;
            case 'float': return THREE.FloatType;
            case 'halfFloat': return THREE.HalfFloatType;
            case 'uShort4444': return THREE.UnsignedShort4444Type;
            case 'uShort5551': return THREE.UnsignedShort5551Type;
            case 'uShort565': return THREE.UnsignedShort565Type;
            default:
                Logger_1.default.warn("Unexpected format: " + type + ", defaulting to THREE.UnsignedByteType");
                return THREE.UnsignedByteType;
        }
    };
    /**
     * Given an image format and type, calculate the number of bytes per pixel that it will
     * occupy in memory. Note that this only works for uncompressed images in memory.
     * @static
     * @public
     * @param {ImageFormatKey} format
     * @param {ImageTypeKey} dataType
     * @returns {number}
     * @memberOf BaseImageAsset
     */
    BaseImageAsset.getBytesPerPixel = function (format, dataType) {
        var channelSize = 0;
        switch (dataType) {
            case 'float':
            case 'uInt':
            case 'int':
                channelSize = 4;
                break;
            case 'halfFloat':
            case 'short':
            case 'uShort':
                channelSize = 2;
                break;
            case 'uByte':
            case 'byte':
                channelSize = 1;
                break;
            // The following types dictate the bpp directly.
            case 'uShort4444':
            case 'uShort5551':
            case 'uShort565':
                return 2;
            default:
                break;
        }
        return BaseImageAsset.getChannelCount(format) * channelSize;
    };
    /**
     * Given an image format, return the number of channels per pixel.
     * @public
     * @static
     * @param {ImageFormatKey} format
     * @returns {number}
     * @memberOf BaseImageAsset
     */
    BaseImageAsset.getChannelCount = function (format) {
        switch (format) {
            case 'alpha':
            case 'luminance':
                return 1;
            case 'luminanceAlpha':
                return 2;
            case 'rgb':
                return 3;
            case 'rgba':
                return 4;
            default:
                return 0;
        }
    };
    /** @inheritdoc */
    BaseImageAsset.prototype.unload = function () {
        this.loadedBytes = 0;
        _super.prototype.unload.call(this);
    };
    /**
     * Return the currently selected representation based on the image's properties.
     * @public
     * @returns {Representation}
     * @memberOf BaseImageAsset
     */
    BaseImageAsset.prototype.getChosenRepresentation = function () {
        return this.chosenRepresentation;
    };
    /**
     * Return the number of bytes loaded directly by this entity (not by a dependency) so far.
     * @method getDataSizeDownloadSelf
     * @protected
     * @returns {number} The number of bytes downloaded by this entity so far
     */
    BaseImageAsset.prototype.getDataSizeLoadedSelf = function () {
        return this.loadedBytes;
    };
    /** @inheritdoc */
    BaseImageAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        this.engine.trigger('imageChanged', this.id, changes);
    };
    /**
     * Return the number of color or luminance channels in the texture. An optional override lets
     * you query the value for a different pixel format.
     * @method getChannelCount
     * @public
     * @param {ImageFormatKey} overrideFormat Query the number of channels for a different pixel format
     * by specifying a format here.
     * @return {number} Returns the number of color or luminance channels in the texture.
     */
    BaseImageAsset.prototype.getChannelCount = function (overrideFormat) {
        var format = overrideFormat || this.getFormat();
        return BaseImageAsset.getChannelCount(format);
    };
    /**
     * Return the bytes per pixel of the final, uncompressed image.
     * Note that for in-memory-compressed images, this is not the same as the
     * amount of memory that the pixel consumes.
     * @param {ImageFormatKey} [overrideFormat] Query the bpp with a different image format.
     * @param {ImageTypeKey} [overrideType] Query the bpp with a different image type.
     * @returns {number}
     *
     * @memberOf ImageAsset
     */
    BaseImageAsset.prototype.getBytesPerPixel = function () {
        return BaseImageAsset.getBytesPerPixel(this.getFormat(), this.getDataType());
    };
    /**
     * Returns the pixel format of the image. e.g. THREE.RGBAFormat, THREE.LuminanceFormat, etc.
     * @method getFormat
     * @public
     * @return {ImageFormatKey} The image pixel format.
     */
    BaseImageAsset.prototype.getFormat = function () {
        return this.getProperty('format');
    };
    /**
     * Returns the data type of the texture. e.g. THREE.UnsignedByteType, THREE.FloatType, etc.
     * @method getDataType
     * @public
     * @return {ImageTypeKey} The texture pixel type.
     */
    BaseImageAsset.prototype.getDataType = function () {
        return this.getSupportedType(this.getProperty('type'));
    };
    /**
     * Returns the download size of this image using the current representation.
     * @method getDataSizeDownloadSelf
     * @return {number} The number of bytes of data.
     */
    BaseImageAsset.prototype.getDataSizeDownloadSelf = function () {
        if (this.chosenRepresentation) {
            return this.chosenRepresentation.contentLength;
        }
        // Return a non-zero value for now so that loading progress can go from 0 to 100%
        return 1;
    };
    /**
     * Given a data type for an image, check if it's supported by the current hardware
     * and modify and return the type as necessary. If the type is supported, the returned
     * value is the same as the type passed in.
     * @method getSupportedType
     * @public
     * @param  {String} type The data type that we want to check for support
     * @return {ImageTypeKey}      The data type closest to the one passed in that is supported
     * by the current hardware.
     */
    BaseImageAsset.prototype.getSupportedType = function (type) {
        var returnType = type;
        var renderer = this.engine.getThreeRenderer();
        var extensions = renderer.extensions;
        switch (type) {
            case 'float':
                if (extensions.get('OES_texture_float')) {
                    returnType = 'float';
                    break;
                }
            /* falls through */
            case 'halfFloat':
                if (extensions.get('OES_texture_half_float')) {
                    returnType = 'halfFloat';
                }
                else {
                    returnType = 'uByte';
                }
                break;
            default:
                returnType = type;
        }
        return returnType;
    };
    /**
     * Returns the anticipated number of mips that the loaded image should have, based on its size.
     * If mipmapping is disabled for this image, this method still returns the number of mips in the
     * full mip chain.
     * @method getMipCount
     * @public
     * @return {number} Returns the total number of mip levels used by this texture.
     */
    BaseImageAsset.prototype.getMipCount = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        var max = Math.max(width, height);
        return Math.floor(Math.log2(Math.max(max, 1))) + 1;
    };
    /**
     * Return whether the anticipated dimensions of the loaded image are powers of two
     * (e.g. 2^10 == 1024).
     * @method isPowerOfTwo
     * @public
     * @return {Boolean} True if the anticipated dimensions of the loaded image are powers of two.
     */
    BaseImageAsset.prototype.isPowerOfTwo = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        return THREE.Math.isPowerOfTwo(width) && THREE.Math.isPowerOfTwo(height);
    };
    /**
     * Returns the anticipated width of the loaded image.
     * @method getWidth
     * @public
     * @return {number} The image width.
     */
    BaseImageAsset.prototype.getWidth = function () {
        var width = this.getMaxRepresentationWidth();
        var maxSize = this.getMaxTextureSize();
        return Math.max(1, Math.min(maxSize, width));
    };
    /**
     * Returns the anticipated height of the loaded image.
     * @method getHeight
     * @public
     * @return {number} The image height.
     */
    BaseImageAsset.prototype.getHeight = function () {
        var height = this.getMaxRepresentationHeight();
        var maxSize = this.getMaxTextureSize();
        return Math.max(1, Math.min(maxSize, height));
    };
    /**
     * Get the largest width found for any representation of this image.
     * @protected
     * @returns {number}
     * @memberOf BaseImageAsset
     */
    BaseImageAsset.prototype.getMaxRepresentationWidth = function () {
        return 0;
    };
    /**
     * Get the largest height found for any representation of this image.
     * @protected
     * @returns {number}
     * @memberOf BaseImageAsset
     */
    BaseImageAsset.prototype.getMaxRepresentationHeight = function () {
        return 0;
    };
    /**
     * Returns the original width of the image.
     * @method getOriginalWidth
     * @public
     * @return {number} The original image width.
     */
    BaseImageAsset.prototype.getOriginalWidth = function () {
        return 0;
    };
    /**
     * Returns the original height of the image.
     * @method getOriginalHeight
     * @public
     * @return {number} The original image height.
     */
    BaseImageAsset.prototype.getOriginalHeight = function () {
        return 0;
    };
    /**
     * Returns the maximum texture size, taking into account the image type (e.g., 2D, cube, etc.).
     * @method getMaxTextureSize
     * @private
     * @return {number} The maximum texture size.
     */
    BaseImageAsset.prototype.getMaxTextureSize = function () {
        return Number.MAX_VALUE;
    };
    return BaseImageAsset;
}(BaseAsset_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseImageAsset;


/***/ },
/* 11 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-bitwise */
/* tslint:disable prefer-for-of */
/* tslint:disable max-file-line-count */
var uuid_1 = __webpack_require__(17);
var Logger_1 = __webpack_require__(3);
var RuntimeEvents_1 = __webpack_require__(21);
var DependencyRegistry_1 = __webpack_require__(190);
var ComponentRegistry_1 = __webpack_require__(188);
var ResourceLifecycle_1 = __webpack_require__(205);
var classComposer_1 = __webpack_require__(39);
var deepClone_1 = __webpack_require__(23);
exports.baseEntityMixins = classComposer_1.default({}, [
    ComponentRegistry_1.default,
    DependencyRegistry_1.default,
    RuntimeEvents_1.default,
    ResourceLifecycle_1.default
]);
var State;
(function (State) {
    State[State["Destroyed"] = 1] = "Destroyed";
    State[State["Pending"] = 2] = "Pending";
    State[State["InProgress"] = 4] = "InProgress";
    State[State["Partial"] = 8] = "Partial";
    State[State["Succeeded"] = 16] = "Succeeded";
    State[State["Aborted"] = 32] = "Aborted";
    State[State["Failed"] = 64] = "Failed";
})(State = exports.State || (exports.State = {}));
var StateType;
(function (StateType) {
    StateType[StateType["Base"] = 0] = "Base";
    StateType[StateType["Dependencies"] = 1] = "Dependencies";
})(StateType = exports.StateType || (exports.StateType = {}));
/**
 * The base class for all objects and assets in the engine.
 */
var BaseEntity = (function (_super) {
    tslib_1.__extends(BaseEntity, _super);
    /**
     * Creates an instance of BaseEntity.
     * @param jsonDesc  The json descriptor the this entity.
     * @param runtime   The engine instance that this entity belongs to.
     */
    function BaseEntity(jsonDesc, engine) {
        var _this = _super.call(this) || this;
        /** Events added to this entity by attached components. */
        _this.events = {};
        _this.engine = engine;
        // StateType.BASE, StateType.DEPENDENCIES
        _this.state = [State.Pending, State.Pending];
        _this.runtimeData = undefined;
        _this.sharedData = undefined;
        // TODO - id and type should be defined as getters that grab the value from
        // internal, private data.
        _this.id = jsonDesc.id;
        _this.type = jsonDesc.type;
        _this.sharedData = jsonDesc;
        return _this;
    }
    /**
     * Returns true if the given state indicates that loading is complete,
     * regardless of whether the load was successful or not.
     * @param state A state value to check against
     * @returns     True if the state indicates that loading is finished.
     */
    BaseEntity.checkLoadFinished = function (state) {
        var finishedState = State.Succeeded | State.Failed
            | State.Aborted;
        return !!(finishedState & state);
    };
    /**
     * Marks the loading state of the entity and updates any other entity's state if appropriate.
     * e.g. If an entity is loaded, the parent entity may need its children state set to loaded.
     * @param stateType The state type to mark. Values are from StateType.
     * @param state     The state to set. Values are from State.
     */
    BaseEntity.prototype.setState = function (stateType, state) {
        if (!state) {
            return;
        }
        this.state[stateType] = state;
        switch (state) {
            case State.Pending:
                if (this.isUnloaded()) {
                    this.trigger('unload', this);
                }
                if (stateType === StateType.Dependencies) {
                    this.trigger('loadStateChange', this);
                }
                break;
            case State.InProgress:
            case State.Partial:
                if (stateType === StateType.Dependencies) {
                    this.trigger('loadStateChange', this);
                }
                break;
            case State.Succeeded:
            case State.Failed:
            case State.Aborted:
                // Fire the appropriate load event
                switch (stateType) {
                    case StateType.Base:
                        this.trigger('loadBase', this);
                        break;
                    case StateType.Dependencies:
                        this.trigger('loadDependencies', this);
                        break;
                    default:
                }
                this.trigger('loadStateChange', this);
                // If this entity isn't finished loading then it won't affect the parent's state.
                if (!this.isLoaded()) {
                    return;
                }
                this.trigger('load', this);
                break;
            default:
                throw Error("Unknown state " + state);
        }
    };
    /**
     * After entity creation and registration, initialize is called to setup event
     * bindings as well as create components and register dependencies. The reason
     * that 'initialize' is separate from creation is that dependencies (including
     * scripts) may not be created and registered at the time when the entity is.
     */
    BaseEntity.prototype.initialize = function () {
        this.on('change:properties', this.propertyChanged, this);
        this.on('startTimer', this.startTimer, this);
        this.initializeProperties();
        this.initializeComponents();
    };
    /**
     * Unbind events, unregister dependencies, cleanup components, etc.
     * Note that this is different than destroying an entity. Destroying an entity
     * is a public function and removes the entity from all engines. 'uninitialize'
     * should not be called outside of the engine.
     */
    BaseEntity.prototype.uninitialize = function () {
        // Stop listening to events bound with this.listenToOnce, this.listenTo, etc.
        this.stopListening();
        this.off('startTimer', this.startTimer, this);
        this.off('change:properties', this.propertyChanged, this);
        this.unregisterDependencies();
        this.unload();
        for (var i = 0; i < this.state.length; i++) {
            this.state[i] = State.Destroyed;
        }
        this.runtimeData = null;
    };
    /**
     * Called when an entity is initialized. This ensures that an event is triggered
     * for all the initial properties being set.
     */
    BaseEntity.prototype.initializeProperties = function () {
        var _this = this;
        var properties = this.getProperties();
        Object.keys(properties).forEach(function (key) {
            var value = properties[key];
            if (!_this.verifyProperty(key, value)) {
                Logger_1.default.warn("Property \"" + key + "\" on \"" + _this.constructor.name + "\" does not exist or has an " +
                    ("invalid value of \"" + JSON.stringify(value, null, 2) + "\"."));
            }
        });
        this.applyPropertiesUnloaded(properties);
    };
    /**
     * Get the name of the entity
     * @returns {String} The entity's name
     */
    BaseEntity.prototype.getName = function () {
        return this.getProperty('name');
    };
    /**
     * Get the "Scoped" ID for the entity. The sid is usually used for name references that must be
     * unique within the scope of a particular hierarchy. e.g. animations referencing bones by name,
     * etc. The scoped ID may not be unique across an entire asset (e.g. with more than one animating
     * character in a scene).
     * @returns {String} The entity's sId
     */
    BaseEntity.prototype.getSid = function () {
        return this.get('sid');
    };
    /**
     * Set the name of the entity
     * @param newName         The entity's new name
     * @param [silent=false]  Supress change event.
     */
    BaseEntity.prototype.setName = function (newName, silent) {
        this.setProperty('name', newName, silent);
    };
    /**
     * Set the "Scoped" ID for the entity. The sid is usually used for name references that must be
     * unique within the scope of a particular hierarchy. e.g. animations referencing bones by name,
     * etc. The scoped ID may not be unique across an entire asset (e.g. with more than one animating
     * character in a scene).
     * @param newId           The entity's new scoped ID
     * @param [silent=false]  Supress change event.
     */
    BaseEntity.prototype.setSid = function (newId, silent) {
        this.set('sid', newId, silent);
    };
    /**
     * Get an attribute value for the entity.
     * @param attrib  The name of the attribute
     * @returns       The attribute's value
     */
    BaseEntity.prototype.get = function (attrib) {
        return this.sharedData[attrib];
    };
    /**
     * Set an attribute value for the entity.
     * @param attrib  The name of the attribute
     * @param value   Value of attribute
     */
    BaseEntity.prototype.set = function (attrib, value, _silent) {
        this.engine.entityDispatcher.dispatchAttributeChanged(this.id, attrib, value);
    };
    /**
     * Delete an attribute value for the entity.
     * @param attrib          The name of the attribute
     * @param [silent=false]  Supress change event.
     */
    BaseEntity.prototype.unset = function (attrib, _silent) {
        if (this.sharedData.hasOwnProperty(attrib)) {
            delete this.sharedData[attrib];
        }
        this.engine.entityDispatcher.dispatchAttributeChanged(this.id, attrib, undefined);
    };
    /**
     * Verifies a given property by name with the given value against the schema.
     * @param propertyName  The property name
     * @param value         The property value
     * @returns             Whether or not the property is valid
     */
    BaseEntity.prototype.verifyProperty = function (propertyName, value) {
        if (!this.constructor.validators[propertyName]) {
            Logger_1.default.warn("No validator available for property: " + propertyName);
            return false;
        }
        var validator = (this.constructor.validators[propertyName]);
        var result = validator(value);
        if (!result) {
            Logger_1.default.warn("Verification failed for value \"" + JSON.stringify(value) + "\" " +
                ("for property \"" + propertyName + "\""));
            var errors = validator.errors;
            if (errors && errors instanceof Array) {
                Logger_1.default.warn(errors && errors[0]);
            }
        }
        return result;
    };
    /**
     * Set a new or existing property for this object.
     * @param propertyName    Name of the property to set.
     * @param value           Value of the property.
     * @param [silent=false]  Supress change event.
     */
    BaseEntity.prototype.setProperty = function (propertyName, value, silent) {
        if (this.verifyProperty(propertyName, value)) {
            // Dispatch change event
            this.engine.entityDispatcher.dispatchPropertyChanged(this.id, propertyName, value, silent);
        }
    };
    /**
     * Remove an existing property from this object.
     * @param propertyName    Name of the property to remove.
     * @param [silent=false]  Supress change event.
     */
    BaseEntity.prototype.unsetProperty = function (propertyName, silent) {
        this.engine.entityDispatcher
            .dispatchPropertyChanged(this.id, propertyName, undefined, silent);
    };
    /**
     * Set multiple new or existing properties for this object at once. This merges with
     * existing properties
     * @param properties      Key-value pairs of properties.
     * @param [silent=false]  Supress change event.
     */
    BaseEntity.prototype.setProperties = function (properties, silent) {
        // TODO - verify  property values against schema.
        this.engine.entityDispatcher.dispatchPropertiesChanged(this.id, properties, silent);
    };
    /**
     * Returns the property of the object given by 'propertyName'.
     * This function only looks on the local entity and won't return
     * inherited values.
     * @method getOwnProperty
     * @param propertyName  The name of the property.
     * @returns             The property value
     */
    BaseEntity.prototype.getOwnProperty = function (propertyName) {
        return this.sharedData.properties[propertyName];
    };
    /**
     * Returns the previous value of the property specified by 'propertyName'
     * @param propertyName  The name of the property.
     * @returns             The property's previous value
     */
    BaseEntity.prototype.getPreviousProperty = function (propertyName) {
        var value = this.sharedData.previousProperties[propertyName];
        if (value !== undefined) {
            return value;
        }
        return this.getDefaultProperty(propertyName);
    };
    /**
     * Returns all properties of the entity. This function only looks on the
     * local entity and won't return inherited values.
     * @returns The properties
     */
    BaseEntity.prototype.getOwnProperties = function () {
        return this.sharedData.properties;
    };
    /**
     * Copy the properties of the given object to this object, overwriting
     * any of the same name.
     * @param object          The object to copy properties from.
     * @param [silent=false]  Supress change event.
     */
    BaseEntity.prototype.copyProperties = function (object, silent) {
        this.setProperties(object.getOwnProperties(), silent);
    };
    /**
     * Copy the properties of the given object to this object, leaving
     * any of the same name unmodified.
     * @param object          The object to copy properties from.
     * @param [silent=false]  Supress change event.
     */
    BaseEntity.prototype.mergeProperties = function (object, silent) {
        this.setProperties(tslib_1.__assign({}, object.getOwnProperties(), this.sharedData.properties), silent);
    };
    /**
     * Returns the default property of the object given by 'propertyName'
     * @param propertyName  The name of the property.
     * @returns             The property value
     */
    BaseEntity.prototype.getDefaultProperty = function (propertyName) {
        return deepClone_1.default(this.constructor.defaults[propertyName]);
    };
    /**
     * Returns the default properties of the object given by 'propertyName'
     * @returns List of default values, keyed by property name.
     */
    BaseEntity.prototype.getDefaultProperties = function () {
        return deepClone_1.default(this.constructor.defaults);
    };
    /**
     * Returns the property value specified by 'propertyName'.
     * @param propertyName  The name of the property.
     * @returns             The property value
     */
    BaseEntity.prototype.getProperty = function (propertyName) {
        var localProperty = this.getOwnProperty(propertyName);
        if (localProperty !== undefined) {
            return localProperty;
        }
        return this.getDefaultProperty(propertyName);
    };
    /**
     * Revert the property to its default value.
     * @param propertyName Name of the property to revert to default.
     */
    BaseEntity.prototype.revertProperty = function (propertyName) {
        this.unsetProperty(propertyName);
    };
    /**
     * Returns all properties of the entity, including those inherrited from
     * the entity's prefab.
     * @returns The properties
     */
    BaseEntity.prototype.getProperties = function () {
        var myProperties = this.getOwnProperties();
        var propertiesObj = this.getDefaultProperties();
        return Object.assign(propertiesObj, myProperties);
    };
    /**
     * Clones the entity.
     * @param [id]  The new ID for the clone.
     * @returns     The newly-created clone
     */
    BaseEntity.prototype.clone = function (id) {
        var clonedEntity = this.engine.createEntityByType(this.getType(), this.getOwnProperties(), id || uuid_1.v4());
        clonedEntity.set('sid', this.get('sid'));
        clonedEntity.setComponents(this.getComponentDescriptors());
        return clonedEntity;
    };
    /**
     * get the three data associated with this entity
     * @returns The Three.JS data attached to this BaseEntity. Can be things
     *          like THREE.Material, THREE.Object3D, THREE.PointLight, etc.
     *          See threejs.org/docs/
     */
    BaseEntity.prototype.getRuntimeData = function () {
        if (!this.runtimeData) {
            this.load();
        }
        return this.runtimeData;
    };
    /**
     * If the condition for specified event is met, immediately calls the callback. Otherwise,
     * listens for the event to be fired and then calls it. Useful for more concise code.
     * @param eventName The name of the event to listen for
     * @param callback  The callback function to call when the event occurs
     * @param [context] The context that the callback will be called in. This needs
     *                  to be another BaseEntity or something that inherits from
     *                  RuntimeEvents.
     */
    BaseEntity.prototype.when = function (eventName, callback, context) {
        if (typeof callback === 'function') {
            if (eventName === 'load' && this.isLoaded() ||
                eventName === 'loadBase' && this.isBaseLoaded() ||
                eventName === 'loadDependencies' && this.isDependenciesLoaded()) {
                callback.call(context, this);
            }
            else {
                if (context) {
                    context.listenToOnce(this, eventName, callback);
                }
                else {
                    this.once(eventName, callback, context);
                }
            }
        }
    };
    /**
     * Loads the Three.JS data for this entity and all of its dependencies. The following events
     * will be fired during this process:
     * 'load' - fired when the entity is loaded and all dependencies are either loaded
     * or have encountered an error.
     * 'loadBase' - fired when the data for just the base entity is loaded, not including any
     * dependencies (materials, textures, etc.).
     * 'loadDependencies' - fired when all the dependencies (objects, animations, textures, etc.)
     * for an entity have been loaded.
     * @param [callback] This function gets called when the final 'load' event is
     * triggered.
     */
    BaseEntity.prototype.load = function (callback) {
        var _this = this;
        this.when('load', function () {
            if (typeof callback === 'function') {
                callback(_this);
            }
        }, this);
        // Load this object
        this.loadBase();
        this.loadDependencies();
        if (this.checkIfOwnDependenciesLoaded()) {
            this.setState(StateType.Dependencies, State.Succeeded);
        }
    };
    /**
     * Resets the entity back to a default state.
     */
    BaseEntity.prototype.reset = function () {
        // nothing
    };
    /**
     * Total up this entity's current downloaded data size. Includes all dependencies of this entity.
     * Specify a class of entity to filter the dependencies that are considered.
     * @param [entityType]  The class of entity that you want to filter by.
     * @returns             The number of bytes currently loaded for this entity.
     */
    BaseEntity.prototype.getDataSizeLoaded = function (entityType) {
        return this.getDataSize('getDataSizeLoadedSelf', entityType);
    };
    /**
     * Total up the number of bytes that need to be downloaded when loading this entity.
     * This includes all dependencies of this entity.
     * Specify a class of entity to filter the dependencies that are considered.
     * @param [entityType]  The class of entity that you want to filter by.
     * @returns             The number of total bytes that will need to be
     *                      downloaded for this entity.
     */
    BaseEntity.prototype.getDataSizeDownload = function (entityType) {
        return this.getDataSize('getDataSizeDownloadSelf', entityType);
    };
    /**
     * Total up the amount of memory that this entity will need when loaded. Includes all dependencies of this entity.
     * Specify a class of entity to filter the dependencies that are considered.
     * @param [entityType]  The class of entity that you want to filter by.
     * @returns             The number of bytes of memory needed for this entity.
     */
    BaseEntity.prototype.getDataSizeInMemory = function (entityType) {
        return this.getDataSize('getDataSizeInMemorySelf', entityType);
    };
    /**
     * Return the number of bytes that will be downloaded directly by this entity
     * (not by a dependency) when loading.
     * @returns The number of bytes that need to be downloaded by this entity.
     */
    BaseEntity.prototype.getDataSizeDownloadSelf = function () {
        return 0;
    };
    /**
     * Return the number of bytes of memory needed directly by this entity
     * (not by a dependency) after loading.
     * @returns The number of bytes of memory needed by this entity.
     */
    BaseEntity.prototype.getDataSizeInMemorySelf = function () {
        return 0;
    };
    /**
     * Return the number of bytes loaded directly by this entity (not by a dependency) so far.
     * @returns The number of bytes downloaded by this entity so far.
     */
    BaseEntity.prototype.getDataSizeLoadedSelf = function () {
        return 0;
    };
    /**
     * Load runtime data for this entity alone, not child entities or
     * dependencies. This method triggers 'loadBase' when complete.
     * Calling this method after loading is complete causes the
     * method to trigger 'loadBase' again.
     * @param [callback] Called when loading is complete
     */
    BaseEntity.prototype.loadBase = function (callback) {
        var _this = this;
        if (this.isBaseLoaded()) {
            this.trigger('loadBase', this);
            if (typeof callback === 'function') {
                callback(this);
            }
        }
        else if (this.isBaseUnloaded()) {
            this.once('loadBase', callback, this);
            this.setState(StateType.Base, State.InProgress);
            this.startComponents();
            this.createRuntimeData(function () {
                if (_this.isDestroyed()) {
                    return;
                }
                // Apply the initial set of properties.
                _this.applyPropertiesLoaded(_this.getProperties(), 'init');
                if (_this.state[StateType.Base] <= State.Succeeded) {
                    _this.setState(StateType.Base, State.Succeeded);
                }
            });
        }
    };
    /**
     * Reload runtime data for this entity. This should be called by
     * subclasses when they wish to change the runtimeData reference.
     * This method invokes loadBase() to reload runtime data, so
     * 'loadBase' is triggered upon completion.
     * @param [callback] Called when loading is complete
     */
    BaseEntity.prototype.reloadBase = function (callback) {
        this.stopComponents();
        this.setState(StateType.Base, State.Pending);
        this.loadBase(function () {
            if (typeof callback === 'function') {
                callback();
            }
        });
    };
    /**
     * Returns the percentage of data that has already been loaded by this object and its
     * hierarchy.
     * @returns The number of bytes of data.
     */
    BaseEntity.prototype.getLoadingProgress = function () {
        // If the entity is marked as loaded, always return 100%
        if (this.isLoaded()) {
            return 1.0;
        }
        // Otherwise, calculate the progress.
        var loaded = this.getDataSizeLoaded();
        var total = this.getDataSizeDownload();
        if (total) {
            // The load hasn't been flagged as finished so clamp the return at 99.99%
            return Math.min(loaded / total, 0.999999);
        }
        // For entities that are loading but have no download size, just return
        // their progress as 99%.
        return this.isUnloaded() ? 0.0 : 0.99;
    };
    /**
     * Unload the entity.
     */
    BaseEntity.prototype.unload = function () {
        this.stopComponents();
        this.setState(StateType.Base, State.Pending);
        this.setState(StateType.Dependencies, State.Pending);
        this.runtimeData = null;
    };
    /**
     * Returns true iff the entity is unloaded (ignoring dependencies).
     * @returns True iff the entity is unloaded.
     */
    BaseEntity.prototype.isUnloaded = function () {
        return State.Pending === (State.Pending & this.state[StateType.Base]);
    };
    /**
     * Returns true if the three.js data is finished loading, including
     * all dependencies in this entity's hierarchy. Note that
     * a true value only means that the load is finished, not that it was
     * necessarily completely successful.
     * @returns True, if loading is finished
     */
    BaseEntity.prototype.isLoaded = function () {
        var finishedState = State.Succeeded | State.Failed | State.Aborted;
        for (var i = 0; i < this.state.length; i++) {
            if (!(finishedState & this.state[i])) {
                return false;
            }
        }
        return true;
    };
    /**
     * Returns true if any part of the loading of this entity failed. Note that
     * failure is distinct from abortion. For example, if an asset is unloaded or
     * destroyed during the load, the load is considered to be aborted, not failed.
     * @returns Whether the load failed or not.
     */
    BaseEntity.prototype.isLoadFailed = function () {
        for (var i = 0; i < this.state.length; i++) {
            if (State.Failed & this.state[i]) {
                return true;
            }
        }
        return false;
    };
    /**
     * Returns true if the three.js data is in the process of loading, including all dependencies
     * in this entity's hierarchy.
     * @returns True, if loaded
     */
    BaseEntity.prototype.isLoading = function () {
        var combinedState = 0;
        for (var i = 0; i < this.state.length; i++) {
            combinedState |= this.state[i];
        }
        return combinedState & State.InProgress ? true : false;
    };
    /**
     * Returns true if the three.js data for this entity is loaded. This does not include
     * any dependencies (like materials, textures, etc.) in this entity's hierarchy.
     * @returns True, if the base three.js object is loaded
     */
    BaseEntity.prototype.isBaseLoaded = function () {
        return BaseEntity.checkLoadFinished(this.state[StateType.Base]);
    };
    /**
     * Returns true if the three.js data for this entity is unloaded. This does not include
     * any dependencies (like materials, textures, etc.) in this entity's hierarchy.
     * @returns True, if the base three.js object is unloaded
     */
    BaseEntity.prototype.isBaseUnloaded = function () {
        return this.state[StateType.Base] === State.Pending;
    };
    /**
     * Returns true if this entity has been destroyed.
     * @returns True, if the entity has been destroyed
     */
    BaseEntity.prototype.isDestroyed = function () {
        return this.state[StateType.Base] === State.Destroyed;
    };
    /**
     * Returns true if the three.js data for all assets referenced by this entity are loaded.
     * i.e. materials, textures, animations, etc.
     * @returns True, if the dependencies are all loaded
     */
    BaseEntity.prototype.isDependenciesLoaded = function () {
        return BaseEntity.checkLoadFinished(this.state[StateType.Dependencies]);
    };
    /**
     * Returns true if the three.js data for all assets referenced by this entity are unloaded.
     * i.e. materials, textures, animations, etc.
     * @returns True, if the dependencies are all unloaded
     */
    BaseEntity.prototype.isDependenciesUnloaded = function () {
        return State.Pending === this.state[StateType.Dependencies];
    };
    /**
     * Update runtime data based on property changes. This method is called in
     * two situations: during initialization (just before 'loadBase' is
     * triggered), and for property changes that occur between 'loadBase' and
     * 'unload'. When called during initialization, *all* properties will be
     * listed in the changes parameter. When overriding this method, always call
     * the super implementation first.
     * @param changes The names of properties that have changed
     * @param reason  One of: 'init' or 'propertyChanged'
     */
    BaseEntity.prototype.applyPropertiesLoaded = function (_changes, _reason) {
        // nothing
    };
    /**
     * Update the settings for the object that don't require the Three.JS data to exist.
     * This method is called after loading an object and whenever there is a change event fired.
     * @param changes The names of properties that have changed
     */
    BaseEntity.prototype.applyPropertiesUnloaded = function (_changes) {
        // nothing
    };
    /**
     * Get the type of the entity
     * @returns The entity's type
     */
    BaseEntity.prototype.getType = function () {
        return this.get('type');
    };
    /**
     * Get the description of the entity
     * @returns The entity's description
     */
    BaseEntity.prototype.getDescription = function () {
        return this.get('description');
    };
    /**
     * Set the description of the entity
     * @param newDescription  The entity's new description
     */
    BaseEntity.prototype.setDescription = function (newDescription) {
        return this.set('description', newDescription);
    };
    /**
     * Registers a component event.
     * @param name        The name of the event.
     * @param parameters  An array of parameters for the event.
     * @param scope       The scope of the event.
     * @param boolean     Whether or not this is considered an "Action"
     * @param string      The Category for this event.
     * @param filter      A list of types that this event is applicable for.
     */
    BaseEntity.prototype.registerComponentEvent = function (name, parameters, scope, action, category, filter) {
        if (scope === 'other') {
            if (filter && filter.length) {
                for (var i = 0; i < filter.length; i++) {
                    var type = filter[i];
                    var typeClass = this.engine.getEntityClass(type);
                    typeClass.events[name] = {
                        params: parameters,
                        action: action,
                        category: category
                    };
                }
            }
            else {
                BaseEntity.events[name] = {
                    params: parameters,
                    action: action,
                    category: category
                };
            }
        }
        else {
            this.events[name] = {
                params: parameters,
                action: action,
                category: category
            };
        }
    };
    /**
     * Removes a component event.
     * @param name  The name of the event.
     * @param scope The scope of the event.
     */
    BaseEntity.prototype.removeComponentEvent = function (name, scope) {
        if (scope === 'other') {
            var nodeObjectClass = this.engine.getEntityClass('node');
            if (nodeObjectClass.prototype.events[name]) {
                delete nodeObjectClass.prototype.events[name];
            }
        }
        else {
            if (this.events[name]) {
                delete this.events[name];
            }
        }
    };
    /**
     * Get a list of all events avaialble on this entity.
     * @returns All of the available events.
     */
    BaseEntity.prototype.getEvents = function () {
        var events = {};
        Object.assign(events, events, this.events);
        var proto = Object.getPrototypeOf(this);
        while (proto) {
            if (proto.hasOwnProperty('events')) {
                Object.assign(events, events, proto.events);
            }
            proto = Object.getPrototypeOf(proto);
        }
        return events;
    };
    /**
     * Create runtime data for this entity. Upon successful completion,
     * call getRuntimeData() to retrieve the runtime data. Sub-classes should
     * override this method to initialize their runtime data.
     * @param [callback] Called when the runtime data is available
     */
    BaseEntity.prototype.createRuntimeData = function (callback) {
        // Default implementation invokes the callback.
        callback();
    };
    /**
     * Run through this entity's dependencies and total up the return value from the provided
     * function. This is used to calculate the data size of an entity and is called from the
     * specific public data size functions.
     * @param fnName        The name of the function to call on each entity.
     * @param [entityType]  The class of entity that you want to filter by.
     */
    BaseEntity.prototype.getDataSize = function (fnName, entityType) {
        // Get all dependencies
        var dependencies = this.getDependencies();
        return dependencies.reduce(function (total, dep) {
            if (entityType && !(dep instanceof entityType)) {
                return total;
            }
            return total + dep[fnName]();
        }, this[fnName]());
    };
    /**
     * Called when the entity's properties change and the object needs to be
     * updated to reflect the changes.
     * @param properties An object containing changed properties
     */
    BaseEntity.prototype.propertyChanged = function (properties) {
        if (BaseEntity.checkLoadFinished(this.state[StateType.Base])) {
            this.applyPropertiesLoaded(properties, 'propertyChanged');
        }
        this.applyPropertiesUnloaded(properties);
    };
    /**
     * Starts the timer.
     * @param time The amount of time until the endTimer event will be triggered.
     */
    BaseEntity.prototype.startTimer = function (time) {
        var _this = this;
        var elapsedTime = 0.0;
        var updateTimer = function (delta) {
            elapsedTime += delta;
            if (elapsedTime >= time) {
                _this.engine.off('update', updateTimer, _this);
                _this.trigger('endTimer');
            }
        };
        this.engine.on('update', updateTimer, this);
    };
    return BaseEntity;
}(exports.baseEntityMixins));
/** A mapping of event name to event descriptor of supported events by this entity type. */
BaseEntity.events = {
    load: {
        params: [],
        action: false,
        category: 'Loading'
    },
    loadBase: {
        params: [],
        action: false,
        category: 'Loading'
    },
    loadDependencies: {
        params: [],
        action: false,
        category: 'Loading'
    },
    startTimer: {
        params: [{
                name: 'time',
                description: 'The time (in seconds) that will elapse before the \'endTimer\' event ' +
                    'will be fired.',
                type: 'f',
                default: 5.0
            }],
        action: true,
        category: 'General'
    },
    endTimer: {
        params: [],
        action: false,
        category: 'General'
    }
};
/** A mapping of property names to validator functions */
BaseEntity.validators = {};
/** A mapping of property name to default value for properties on this entity type. */
BaseEntity.defaults = {};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseEntity;


/***/ },
/* 12 */
/***/ function(module, exports) {

"use strict";
"use strict";
var LoadingEvent = {
    LOAD: 'load',
    STATE_CHANGE: 'state_change',
    CANCEL: 'cancel',
    ERROR: 'error',
    PROGRESS: 'progress',
    DONE: 'done'
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LoadingEvent;


/***/ },
/* 13 */
/***/ function(module, exports) {

"use strict";
"use strict";
/**
 * Gets a simplified representation of the UserAgent eg: "Chrome 52".
 * @method
 * @return {String} The name of the browser and the version
 */
var getBrowser = function (ua) {
    if (ua === 'node') {
        return ua;
    }
    var EdgeM = ua.match(/(edge(?=\/))\/?\s*(\d+)/i) || [];
    var tem;
    var M = ua.match(/(opera|chrome|safari|firefox|msie|trident(?=\/))\/?\s*(\d+)/i) || [];
    if (EdgeM.length) {
        M = EdgeM;
    }
    if (/trident/i.test(M[1])) {
        tem = /\brv[ :]+(\d+)/g.exec(ua) || [];
        return 'IE ' + (tem[1] || '');
    }
    if (M[1] === 'Chrome') {
        tem = ua.match(/\bOPR\/(\d+)/);
        if (tem != null) {
            return 'Opera ' + tem[1];
        }
    }
    M = M[2] ? [M[1], M[2]] : [navigator.appName, navigator.appVersion, '-?'];
    tem = ua.match(/version\/(\d+)/i);
    if (tem != null) {
        M.splice(1, 1, tem[1]);
    }
    return M.join(' ');
};
var userAgent = typeof navigator !== 'undefined' ? navigator.userAgent : 'node';
var browserName = getBrowser(userAgent);
// Pre-test all of the conditions and cache the results.
var browser = {
    isMobile: /iphone|ipad|ipod|android|blackberry|bb10|mini|windows\sce|palm/i
        .test(userAgent),
    isIOS: /iphone|ipad|ipod/i.test(userAgent),
    isAndroid: /android/i.test(userAgent),
    isMac: /mac/i.test(userAgent),
    isLinux: /linux/i.test(userAgent),
    isUnix: /x11/i.test(userAgent),
    isWindows: /windows/i.test(userAgent),
    isChrome: /chrome/i.test(userAgent),
    isFirefox: /firefox/i.test(userAgent),
    isSafari: /safari/i.test(userAgent),
    isOpera: /opera/i.test(userAgent),
    isEdge: /edge/i.test(userAgent),
    isIpad: /ipad/i.test(userAgent),
    isNode: userAgent === 'node'
};
browser.isIE = /ie/i.test(browserName);
browser.isIE11 = /ie 11/i.test(browserName);
browser.isAndroidTablet = browser.isAndroid && !/mobile/i.test(userAgent);
browser.isTablet = browser.isIpad || browser.isAndroidTablet;
/**
 * Determines if the browser is mobile.
 * @method
 * @return {Boolean}
 */
exports.isMobile = function () { return browser.isMobile; };
/**
 * Determines if the browser is iOS.
 * @method
 * @return {Boolean}
 */
exports.isIOS = function () { return browser.isIOS; };
/**
 * Determines if the browser is Android.
 * @method
 * @return {Boolean}
 */
exports.isAndroid = function () { return browser.isAndroid; };
/**
 * Determines if the browser is Mac.
 * @method
 * @return {Boolean}
 */
exports.isMac = function () { return browser.isMac; };
/**
 * Determines if the browser is Linux.
 * @method
 * @return {Boolean}
 */
exports.isLinux = function () { return browser.isLinux; };
/**
 * Determines if the browser is Unix.
 * @method
 * @return {Boolean}
 */
exports.isUnix = function () { return browser.isUnix; };
/**
 * Determines if the browser is Windows.
 * @method
 * @return {Boolean}
 */
exports.isWindows = function () { return browser.isWindows; };
/**
 * Determines if the browser is Chrome.
 * @method
 * @return {Boolean}
 */
exports.isChrome = function () { return browser.isChrome; };
/**
 * Determines if the browser is Firefox.
 * @method
 * @return {Boolean}
 */
exports.isFirefox = function () { return browser.isFirefox; };
/**
 * Determines if the browser is Safari.
 * @method
 * @return {Boolean}
 */
exports.isSafari = function () { return browser.isSafari; };
/**
 * Determines if the browser is Opera.
 * @method
 * @return {Boolean}
 */
exports.isOpera = function () { return browser.isOpera; };
/**
 * Determines if the browser is Microsoft Edge.
 * @method
 * @return {Boolean}
 */
exports.isEdge = function () { return browser.isEdge; };
/**
 * Determines if the browser is an Android tablet.
 * @method
 * @return {Boolean}
 */
exports.isAndroidTablet = function () { return browser.isAndroidTablet; };
/**
 * Determines if the browser is an iPad.
 * @method
 * @return {Boolean}
 */
exports.isIpad = function () { return browser.isIpad; };
/**
 * Determines if the browser is a tablet.
 * @method
 * @return {Boolean}
 */
exports.isTablet = function () { return browser.isTablet; };
/**
 * Determines if the browser is Internet Explorer.
 * @method
 * @return {Boolean}
 */
exports.isIE = function () { return browser.isIE; };
/**
 * Determines if the browser is Internet Explorer 11.
 * @method
 * @return {Boolean}
 */
exports.isIE11 = function () { return browser.isIE11; };
/**
 * Determins if the environment is Node.js.
 * @method
 * @return {Boolean}
 */
exports.isNode = function () { return browser.isNode; };


/***/ },
/* 14 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-bitwise */
/* tslint:disable max-file-line-count */
/* tslint:disable no-string-literal */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(7);
var functions_1 = __webpack_require__(6);
var Schemas_1 = __webpack_require__(4);
var convertToDefine_1 = __webpack_require__(208);
/**
 * Stand-in texture substituted while a real texture loads so that
 * the material can properly render in the meantime.
 */
var StandInTexture;
(function (StandInTexture) {
    StandInTexture[StandInTexture["STANDIN_TEXTURE_WHITE"] = 0] = "STANDIN_TEXTURE_WHITE";
    StandInTexture[StandInTexture["STANDIN_TEXTURE_WHITE_CUBE"] = 1] = "STANDIN_TEXTURE_WHITE_CUBE";
    StandInTexture[StandInTexture["STANDIN_TEXTURE_BLACK"] = 2] = "STANDIN_TEXTURE_BLACK";
    StandInTexture[StandInTexture["STANDIN_TEXTURE_BLACK_CUBE"] = 3] = "STANDIN_TEXTURE_BLACK_CUBE";
    StandInTexture[StandInTexture["STANDIN_TEXTURE_NORMAL"] = 4] = "STANDIN_TEXTURE_NORMAL";
})(StandInTexture = exports.StandInTexture || (exports.StandInTexture = {}));
/**
 * Converts a integer color value into a ColorRGB vector.
 * @param hex   The input color number
 * @param obj   An optional ColorRGB object which will have the result
 *              assigned to it, otherwise a new object will be created.
 * @returns     The converted color as ColorRGB
 */
function hexColorToVector(hex, obj) {
    var color = Math.floor(hex);
    var converted = obj ? obj : {
        r: (color >> 16 & 255) / 255,
        g: (color >> 8 & 255) / 255,
        b: (color & 255) / 255
    };
    return converted;
}
/**
 * An asset that holds geometry.
 */
var MaterialAsset = (function (_super) {
    tslib_1.__extends(MaterialAsset, _super);
    function MaterialAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    MaterialAsset.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.listenTo(this.engine, 'textureDeleted', this.onTextureDeleted);
    };
    /** @inheritdoc */
    MaterialAsset.prototype.uninitialize = function () {
        _super.prototype.uninitialize.call(this);
        this.stopListening(this.engine, 'textureDeleted', this.onTextureDeleted);
    };
    /** @inheritdoc */
    MaterialAsset.prototype.getProperty = function (propName) {
        var value = _super.prototype.getProperty.call(this, propName);
        if (value === undefined) {
            var shaderParams = this.getShader().getProperty('parameters');
            if (shaderParams[propName]) {
                value = shaderParams[propName].default;
            }
        }
        return value;
    };
    /** @inheritdoc */
    MaterialAsset.prototype.getDefaultProperties = function () {
        var values = _super.prototype.getDefaultProperties.call(this);
        var shaderParams = this.getShader().getProperty('parameters');
        Object.keys(shaderParams).forEach(function (paramName) {
            values[paramName] = shaderParams[paramName].default;
        });
        return values;
    };
    /** @inheritdoc */
    MaterialAsset.prototype.verifyProperty = function (propertyName, value) {
        if (propertyName === 'shader' || propertyName === 'enabledFeatures') {
            return _super.prototype.verifyProperty.call(this, propertyName, value);
        }
        return true;
    };
    /** @inheritdoc */
    MaterialAsset.prototype.setProperty = function (propertyName, value, silent) {
        if (propertyName === 'shader' || propertyName === 'enabledFeatures') {
            return _super.prototype.setProperty.call(this, propertyName, value, silent);
        }
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        if (shaderParams[propertyName]) {
            var type = shaderParams[propertyName].type;
            var newValue = void 0;
            // Handle scalar values
            if (type === 't' && (typeof value === 'string' || value === null) ||
                type === 'f' && typeof value === 'number' ||
                type === 'b' && typeof value === 'boolean' ||
                type === 'i' && typeof value === 'number' && Math.round(value) === value ||
                type === 'opt' && shaderParams[propertyName].options.hasOwnProperty(value)) {
                newValue = value;
            }
            else if (type === 'c') {
                if (this.sharedData.properties.hasOwnProperty(propertyName) &&
                    typeof this.sharedData.properties[propertyName] === 'object') {
                    newValue = this.sharedData.properties[propertyName];
                }
                else {
                    newValue = { r: 0.0, g: 0.0, b: 0.0 };
                }
                if (typeof value === 'string') {
                    var hexValue = value;
                    if (hexValue.slice(0, 2) !== '0x') {
                        hexValue = String(parseInt(hexValue, 10));
                        hexValue = '0x' + hexValue.toString();
                    }
                    hexColorToVector(parseInt(hexValue, 16), newValue);
                }
                else if (typeof value === 'number') {
                    var clampedVal = Math.max(0, Math.max(0xffffff, value));
                    hexColorToVector(clampedVal, newValue);
                }
                else if (value && typeof value.r === 'number' && typeof value.g === 'number' &&
                    typeof value.b === 'number') {
                    newValue.r = value.r;
                    newValue.g = value.g;
                    newValue.b = value.b;
                    var min = shaderParams[propertyName].min;
                    var max = shaderParams[propertyName].max;
                    if (min !== undefined) {
                        newValue.r = Math.max(newValue.r, min);
                        newValue.g = Math.max(newValue.g, min);
                        newValue.b = Math.max(newValue.b, min);
                    }
                    if (max !== undefined) {
                        newValue.r = Math.min(newValue.r, max);
                        newValue.g = Math.min(newValue.g, max);
                        newValue.b = Math.min(newValue.b, max);
                    }
                }
            }
            else if (type.charAt(0) === 'v' && typeof value.x === 'number' &&
                typeof value.y === 'number') {
                if (this.sharedData.properties.hasOwnProperty(propertyName)) {
                    newValue = this.sharedData.properties[propertyName];
                }
                else {
                    newValue = {};
                }
                newValue.x = value.x;
                newValue.y = value.y;
                if (type === 'v3' && typeof value.z === 'number') {
                    newValue.z = value.z;
                }
                else if (type === 'v4' && typeof value.z === 'number' &&
                    typeof value.w === 'number') {
                    newValue.z = value.z;
                    newValue.w = value.w;
                }
            }
            else if (typeof value === 'undefined') {
                newValue = undefined;
            }
            else {
                Logger_1.default.error('Wrong type specified for ' + propertyName);
            }
            // Dispatch change event
            this.engine.entityDispatcher.dispatchPropertyChanged(this.id, propertyName, newValue, silent);
        }
    };
    /**
     * Return a list of texture assets that this material currently uses.
     * This takes enabled/disabled features into account as well as conditional
     * logic for the individual parameter.
     * @returns The list of texture assets that this material currently uses.
     */
    MaterialAsset.prototype.getReferencedAssetsList = function (allowDuplicates) {
        var _this = this;
        var refTextures = [];
        var refTextureMap = {};
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var shaderUniforms = shaderAsset.getProperty('uniforms');
        var shaderFeatures = shaderAsset.getProperty('features');
        // For each enabled feature for this material, go through
        // the parameters and see what textures are being used.
        functions_1.forEach(shaderFeatures, function (feature, featureName) {
            if (_this.isFeatureEnabled(featureName)) {
                functions_1.forEach(feature.parameters, function (param) {
                    var textureId;
                    var textureAsset;
                    if (shaderParams[param].type === 't') {
                        if (_this.isParameterUsed(param)) {
                            textureId = _this.getProperty(param);
                        }
                        if (textureId) {
                            textureAsset = _this.engine.getAssetById(textureId);
                            if (!refTextureMap[textureId]) {
                                refTextureMap[textureId] = textureAsset;
                                refTextures.push(textureAsset);
                            }
                            else if (allowDuplicates) {
                                refTextures.push(textureAsset);
                            }
                        }
                    }
                });
            }
        });
        functions_1.forEach(shaderUniforms, function (uniform) {
            if (uniform.type === 't' && uniform.default) {
                if (_this.getAssetById(uniform.default)) {
                    if (!refTextureMap[uniform.default]) {
                        refTextureMap[uniform.default] = _this.engine.getAssetById(uniform.default);
                        refTextures.push(_this.engine.getAssetById(uniform.default));
                    }
                    else if (allowDuplicates) {
                        refTextures.push(_this.engine.getAssetById(uniform.default));
                    }
                }
            }
        });
        return refTextures;
    };
    /**
     * Get shader returns the shader asset associated with this material. This will return a default
     * shader if either the shader isn't specified in the material properties OR the specified shader
     * doesn't exist.
     * @returns The shader asset used to build this material asset.
     */
    MaterialAsset.prototype.getShader = function () {
        // Calling super to avoid an infinite loop because Material.getProperty will fallback to looking
        // in the shader for default property values.
        var shaderId = _super.prototype.getProperty.call(this, 'shader');
        // If the shader asset doesn't exist, get the default shader asset.
        if (!this.engine.getAssetById(shaderId)) {
            shaderId = this.getDefaultProperty('shader');
        }
        return this.engine.getAssetById(shaderId);
    };
    /**
     * Determines whether or not a parameter is editable.
     * @param name  The name of the parameter.
     * @returns     Whether or not the parameter is editable.
     */
    MaterialAsset.prototype.isParameterEditable = function (name) {
        var _this = this;
        var shader = this.getShader();
        var result = false;
        if (shader) {
            var shaderParams_1 = shader.getProperty('parameters');
            var shaderFeatures = shader.getProperty('features');
            if (shaderParams_1[name]) {
                functions_1.forEach(shaderFeatures, function (feature, featureName) {
                    // If the param is part of this feature and this feature is enabled
                    if (feature.parameters.indexOf(name) !== -1 && _this.isFeatureEnabled(featureName)) {
                        // If there are additional conditions for this parameter, test them.
                        if (shaderParams_1[name].displayWhen) {
                            result = _this.testParameterConditions(shaderParams_1[name].displayWhen);
                        }
                        else {
                            result = true;
                        }
                    }
                });
            }
        }
        return result;
    };
    /**
     * The an appropriate three.js texture to substitute for the given texture
     * and usage.
     * @param textureParamName  Name of the material param that the texture is assigned to.
     * @param textureUsage      Use for the texture. 'normal', 'bump' or anything else.
     * @returns                 The three.js texture object
     */
    MaterialAsset.prototype.getStandInTexture = function (textureParamName, textureUsage) {
        var texture = this.engine.getAssetById(this.getProperty(textureParamName));
        if (!texture) {
            return;
        }
        var standInTex;
        if (!textureUsage) {
            standInTex = texture.isCubeMap()
                ? StandInTexture.STANDIN_TEXTURE_WHITE_CUBE
                : StandInTexture.STANDIN_TEXTURE_WHITE;
        }
        else if (textureUsage === 'normal') {
            standInTex = StandInTexture.STANDIN_TEXTURE_NORMAL;
        }
        else if (textureUsage === 'bump') {
            standInTex = texture.isCubeMap()
                ? StandInTexture.STANDIN_TEXTURE_BLACK
                : StandInTexture.STANDIN_TEXTURE_BLACK_CUBE;
        }
        return this.engine.materialUtilities.getStandInTexture(standInTex);
    };
    /**
     * Programmatically turn a material feature on or off. Changing a material feature
     * requires a material compilation so a slight pause will accompany a call to this
     * function.
     * @param featureName Name of the primary feature to toggle.
     * @param [on=false]  Are we turning the feature on or off.
     */
    MaterialAsset.prototype.enableFeature = function (featureName, on) {
        if (on === void 0) { on = false; }
        var shaderAsset = this.getShader();
        var enabledFeatures = this.getProperty('enabledFeatures');
        var features = shaderAsset.getProperty('features');
        var newFeatures = tslib_1.__assign({}, enabledFeatures);
        if (typeof features[featureName] === 'undefined') {
            return;
        }
        newFeatures[featureName] = on;
        this.setProperty('enabledFeatures', newFeatures);
    };
    /** @inheritdoc */
    MaterialAsset.prototype.unload = function () {
        var _this = this;
        // Stop listening to texture load events
        this.getDependencies().forEach(function (texture) { return _this.stopListening(texture, 'load'); });
        if (this.runtimeData) {
            this.engine.trigger('materialUnloaded', this.id);
            Logger_1.default.info(this.engine.getName() + ' - Unloading material, '
                + this.getName());
            for (var x in this.runtimeData) {
                if (this.runtimeData.hasOwnProperty(x)) {
                    this.runtimeData[x].dispose();
                    delete this.runtimeData[x];
                }
            }
            this.runtimeData = null;
            _super.prototype.unload.call(this);
        }
    };
    /**
     * Returns whether the specified feature is currently enabled.
     * @param featureName The name of the material feature
     * @returns           True if the feature is enabled.
     */
    MaterialAsset.prototype.isFeatureEnabled = function (featureName) {
        var shaderAsset = this.getShader();
        var enabledFeatures = this.getProperty('enabledFeatures');
        var features = shaderAsset.getProperty('features');
        if (typeof features[featureName] === 'undefined') {
            return false;
        }
        if (enabledFeatures && enabledFeatures[featureName] !== undefined) {
            return enabledFeatures[featureName];
        }
        return features[featureName].defaultEnabled || features[featureName].alwaysEnabled;
    };
    /** @inheritdoc */
    MaterialAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        var _this = this;
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (changes.hasOwnProperty('shader')) {
            // TODO - we could store and compare previously-enabled features so that
            // we can maintain state for the user after switching shaders. This, of course,
            // assumes that there would be overlapping features between shaders...
            var shaderAsset_1 = this.getShader();
            shaderAsset_1.when('load', function () {
                for (var x in MaterialAsset.materialObjectTypes) {
                    if (_this.runtimeData.hasOwnProperty(x)) {
                        var material = _this.runtimeData[x];
                        material.fragmentShader = shaderAsset_1.runtimeData.fragmentShader;
                        material.vertexShader = shaderAsset_1.runtimeData.vertexShader;
                        material.uniforms = THREE.UniformsUtils.clone(shaderAsset_1.runtimeData.uniforms);
                        _this.addSharedUniforms(material.uniforms);
                        for (var key in shaderAsset_1.runtimeData.renderParams) {
                            if (_this.runtimeData[x].hasOwnProperty(key)) {
                                if (_this.isParameterUsed(key)) {
                                    _this.runtimeData[x][key] = shaderAsset_1.runtimeData.renderParams[key];
                                }
                                else {
                                    delete _this.runtimeData[x][key];
                                }
                            }
                        }
                        _this.runtimeData[x].needsUpdate = true;
                        _this.updateMaterialDefines();
                        _this.updateShaderParameters(_this.getProperties());
                        _this.updateTransparency();
                        _this.updateDerivatives();
                        _this.engine.needsRender = true;
                    }
                }
            });
            if (shaderAsset_1.isUnloaded()) {
                shaderAsset_1.load();
            }
        }
        else if (changes.hasOwnProperty('enabledFeatures')) {
            this.updateMaterialDefines();
            this.updateShaderParameters(this.getProperties());
            this.updateTransparency();
            this.updateDerivatives();
            this.engine.needsRender = true;
        }
        else {
            var shaderAsset = this.getShader();
            var shaderParams = shaderAsset.getProperty('parameters');
            var transparencyNeedsUpdate = false;
            var derivativesNeedsUpdate = false;
            var definesNeedUpdate = false;
            for (var p in changes) {
                if (changes.hasOwnProperty(p)) {
                    if (shaderParams[p]) {
                        if (shaderParams[p].transparency) {
                            transparencyNeedsUpdate = true;
                        }
                        if (typeof shaderParams[p].derivatives !== 'undefined') {
                            derivativesNeedsUpdate = true;
                        }
                        // If there are any parameters that are dependent on the value
                        // of this one, we'll need to break out and rebuild preprocessor
                        // defines.
                        if (shaderAsset.getDependentParameters(p).length || shaderParams[p].forceUpdate) {
                            definesNeedUpdate = true;
                            break;
                        }
                        this.updateShaderParameter(p);
                    }
                }
            }
            if (definesNeedUpdate) {
                this.updateMaterialDefines();
                this.updateShaderParameters(this.getProperties());
                // Merge defines with existing set and force materials to update.
                transparencyNeedsUpdate = true;
                derivativesNeedsUpdate = true;
            }
            if (transparencyNeedsUpdate) {
                this.updateTransparency();
            }
            if (derivativesNeedsUpdate) {
                this.updateDerivatives();
            }
            this.engine.needsRender = true;
        }
    };
    /** @inheritdoc */
    MaterialAsset.prototype.applyPropertiesUnloaded = function (changes) {
        var _this = this;
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var value;
        var prevValue;
        var dependenciesNeedUpdate = false;
        if (changes) {
            functions_1.forEach(changes, function (_param, key) {
                if (shaderParams[key]) {
                    // If a texture has changed, update the size of all objects that rely on this material.
                    if (shaderParams[key].type === 't') {
                        value = _this.getProperty(key);
                        prevValue = _this.getPreviousProperty(key);
                        // Only register the dependency if the parameter is actually being used.
                        if (_this.isParameterUsed(key)) {
                            if (prevValue !== value) {
                                _this.registerDependencyById(value);
                                _this.unregisterDependencyById(prevValue);
                            }
                        }
                        else if (prevValue !== value) {
                            dependenciesNeedUpdate = true;
                        }
                    }
                    // If there are any parameters that are dependent on the value
                    // of this one, we'll need to rebuild dependencies
                    if (shaderAsset.getDependentParameters(key).length || shaderParams[key].forceUpdate) {
                        dependenciesNeedUpdate = true;
                    }
                }
            });
            if (changes.enabledFeatures || dependenciesNeedUpdate) {
                this.resetDependencies();
            }
        }
    };
    /** @inheritdoc */
    MaterialAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        var shaderAsset = this.getShader();
        shaderAsset.when('load', function () {
            _this.runtimeData = {};
            Object.keys(MaterialAsset.materialObjectTypes).forEach(function (typeName) {
                var matParams = {};
                matParams.vertexShader = shaderAsset.runtimeData.vertexShader;
                matParams.fragmentShader = shaderAsset.runtimeData.fragmentShader;
                // Copy the uniforms from the source shader
                matParams.uniforms = THREE.UniformsUtils.clone(shaderAsset.runtimeData.uniforms);
                // Add the uniforms that are shared between all materials
                _this.addSharedUniforms(matParams.uniforms);
                _this.runtimeData[typeName] = new THREE.ShaderMaterial(matParams);
                _this.runtimeData[typeName].name = _this.getName();
                // Assign default renderParams for shader.
                for (var key in shaderAsset.runtimeData.renderParams) {
                    if (_this.runtimeData[typeName].hasOwnProperty(key)) {
                        if (_this.isParameterUsed(key)) {
                            _this.runtimeData[typeName][key] = shaderAsset.runtimeData.renderParams[key];
                        }
                        else {
                            delete _this.runtimeData[typeName][key];
                        }
                    }
                }
                var type = MaterialAsset.materialObjectTypes[typeName];
                // Assign override renderParams from material object type.
                functions_1.forEach(type, function (value, key) {
                    if (_this.runtimeData[typeName].hasOwnProperty(key)) {
                        _this.runtimeData[typeName][key] = value;
                    }
                });
            });
            // Rebuild list of preprocessor defines for each material type
            _this.updateMaterialDefines();
            // Done.
            callback();
        }, this);
        shaderAsset.load();
    };
    /**
     * Test whether the conditions specified for a parameter are satisfied or not. Performs
     * a logical AND on all properties in the given object
     * @param param       The parameter to test
     * @param conditions  Json object structure specifying the AND conditional
     * @returns           True if the result of the test is true
     */
    MaterialAsset.prototype.testParameterCondition = function (param, condition) {
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        if (!shaderParams[param]) {
            return false;
        }
        var value = this.getProperty(param);
        // If this parameter is a texture and is assigned a texture that no longer
        // exists, consider its value as null.
        if (shaderParams[param].type === 't') {
            if (!this.engine.getAssetById(value)) {
                value = null;
            }
        }
        for (var i in condition) {
            if (condition.hasOwnProperty(i)) {
                switch (i) {
                    case 'equals':
                        if (value !== condition[i]) {
                            return false;
                        }
                        break;
                    case 'notEquals':
                        if (value === condition[i]) {
                            return false;
                        }
                        break;
                    case 'equalsDefault':
                        if (value !== shaderParams[param].default) {
                            return false;
                        }
                        break;
                    case 'notEqualsDefault':
                        if (value === shaderParams[param].default) {
                            return false;
                        }
                        break;
                    default:
                        return false;
                }
            }
        }
        return true;
    };
    /**
     * Test whether the conditions specified for a parameter are satisfied or not. Performs
     * a logic AND on all properties in the given object
     * @param conditions  Json object structure specifying the AND conditional
     * @returns           True if the result of the test is true
     */
    MaterialAsset.prototype.testParameterConditions = function (conditions) {
        var result = true;
        // Loop through and test each conditional
        for (var i in conditions) {
            if (conditions.hasOwnProperty(i)) {
                if (i === 'or') {
                    if (!this.testParameterConditionsOr(conditions[i])) {
                        result = false;
                        break;
                    }
                }
                else if (!this.testParameterCondition(i, conditions[i])) {
                    result = false;
                    break;
                }
            }
        }
        return result;
    };
    /**
     * Test whether the conditions specified for a parameter are satisfied or not. Performs
     * a logic OR on all properties in the given object.
     * @param conditions  An array of shader conditions.
     * @returns           Whether or not the conditions are satisfied.
     */
    MaterialAsset.prototype.testParameterConditionsOr = function (conditions) {
        var result = false;
        // Loop through and test each conditional
        for (var _i = 0, conditions_1 = conditions; _i < conditions_1.length; _i++) {
            var i = conditions_1[_i];
            if (this.testParameterConditions(i)) {
                result = true;
                break;
            }
        }
        return result;
    };
    /**
     * Calculate and return all of the defines for this material based
     * on the features enabled and the conditions for each parameter.
     * @returns The defines for this material.
     */
    MaterialAsset.prototype.getPreprocessorDefines = function () {
        var _this = this;
        var shaderAsset = this.getShader();
        var shaderFeatures = shaderAsset.getProperty('features');
        var shaderParams = shaderAsset.getProperty('parameters');
        var defines = {};
        functions_1.forEach(shaderFeatures, function (feature, featureName) {
            // If the feature is enabled, go through each parameter and
            // build a list of defines
            if (_this.isFeatureEnabled(featureName)) {
                // Add a define for the feature itself.
                defines[convertToDefine_1.default(featureName)] = 0;
                // Add defines for each enabled parameter.
                functions_1.forEach(feature.parameters, function (paramName) {
                    var useDefines = false;
                    if (shaderParams[paramName].enabledWhen) {
                        // Handle conditional logic
                        if (_this.testParameterConditions(shaderParams[paramName].enabledWhen)) {
                            useDefines = true;
                        }
                    }
                    else if (!shaderParams[paramName].isRenderParam) {
                        useDefines = true;
                    }
                    if (useDefines) {
                        var defineName = convertToDefine_1.default(paramName);
                        defines[defineName] = 0;
                        if (shaderParams[paramName].type === 'opt') {
                            defines[defineName] = shaderParams[paramName].options[_this.getProperty(paramName)];
                        }
                        else if (shaderParams[paramName].type === 't') {
                            var texId = _this.getProperty(paramName);
                            var texture = _this.engine.getAssetById(texId);
                            var mipsDefine = defineName + '_NUM_MIPS';
                            if (texture) {
                                defines[mipsDefine] = texture.getMipCount();
                            }
                            else {
                                defines[mipsDefine] = 0;
                            }
                            if (texture) {
                                var modeDefine = defineName + '_MODE_' +
                                    convertToDefine_1.default(texture.getProperty('projectionMode'));
                                defines[modeDefine] = 0;
                                var typeDefine = defineName + '_TYPE_' +
                                    convertToDefine_1.default(texture.getProperty('mappingType'));
                                defines[typeDefine] = 0;
                                var encodingDefine = defineName + '_ENCODING_' +
                                    convertToDefine_1.default(texture.getProperty('encoding'));
                                defines[encodingDefine] = 0;
                            }
                        }
                        if (shaderParams[paramName].defines) {
                            Object.assign(defines, shaderParams[paramName].defines);
                        }
                    }
                });
            }
        });
        return defines;
    };
    /**
     * Update the preprocessor defines for each three.js material object based on the
     * current material settings.
     */
    MaterialAsset.prototype.updateMaterialDefines = function () {
        var _this = this;
        var defines = this.getPreprocessorDefines();
        var matTypes = MaterialAsset.materialObjectTypes;
        Object.keys(matTypes).forEach(function (typeName) {
            var matDefines = tslib_1.__assign({}, defines);
            var matType = matTypes[typeName];
            if (matType.defines) {
                var defineNames = Object.keys(matType.defines);
                defineNames.forEach(function (name) {
                    matDefines[name] = matType.defines[name];
                });
            }
            _this.runtimeData[typeName].defines = matDefines;
            _this.runtimeData[typeName].needsUpdate = true;
        });
    };
    /**
     * Link up a uniform that is shared between materials
     * For now, just hardcode this for the 'time' uniform...
     * @param uniforms The shared uniforms object.
     */
    MaterialAsset.prototype.addSharedUniforms = function (uniforms) {
        uniforms['time'] = MaterialAsset.sharedUniforms['time'];
        uniforms['screenDimensions'] = MaterialAsset.sharedUniforms['screenDimensions'];
    };
    /**
     * Update the material state based on the provided parameter changes
     * @param changes Parameter values keyed by parameter name.
     */
    MaterialAsset.prototype.updateShaderParameters = function (changes) {
        var _this = this;
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        functions_1.forEach(changes, function (_value, key) {
            if (shaderParams[key]) {
                _this.updateShaderParameter(key);
            }
        });
    };
    /**
     * Rebuild a fresh list of dependencies for this material and re-register them.
     */
    MaterialAsset.prototype.resetDependencies = function () {
        var _this = this;
        this.unregisterDependencies();
        // Register fresh list of dependencies
        var textures = this.getReferencedAssetsList(true);
        textures.forEach(function (texAsset) { return _this.registerDependency(texAsset); });
    };
    /**
     * Determine whether or not to use derivatives and enable or disable the extension.
     */
    MaterialAsset.prototype.updateDerivatives = function () {
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var useDerivatives = false;
        for (var paramName in shaderParams) {
            if (shaderParams.hasOwnProperty(paramName)) {
                if (shaderParams[paramName].derivatives && this.isParameterUsed(paramName)) {
                    useDerivatives = true;
                    break;
                }
            }
        }
        this.setExtension('derivatives', useDerivatives);
    };
    /**
     * Go through all the properties of the material that affect transparency and make
     * sure the 'transparent' flag in Three.JS is appropriately set.
     */
    MaterialAsset.prototype.updateTransparency = function () {
        var _this = this;
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var transparencyOn = false;
        for (var paramName in shaderParams) {
            if (shaderParams.hasOwnProperty(paramName)) {
                transparencyOn = this.testParameterTransparency(paramName);
                if (transparencyOn) {
                    break;
                }
            }
        }
        if (this.runtimeData) {
            Object.keys(MaterialAsset.materialObjectTypes).forEach(function (matObjType) {
                _this.runtimeData[matObjType].transparent = transparencyOn;
            });
        }
    };
    /**
     * Test whether transparency should be enabled based on the conditions
     * specified for the given parameter.
     * @param paramName The name of the parameter to check.
     * @returns         True if the value of the parameter should result in this
     *                  material being transparent (assuming that this parameter is
     *                  currently being used.)
     */
    MaterialAsset.prototype.testParameterTransparency = function (paramName) {
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var transparencyCondition;
        if (shaderParams.hasOwnProperty(paramName)) {
            transparencyCondition = shaderParams[paramName].transparency;
            if (transparencyCondition && this.isParameterUsed(paramName)) {
                if (transparencyCondition === 'LessThanOne') {
                    if (this.getProperty(paramName) < 1.0) {
                        return true;
                    }
                }
                else if (transparencyCondition === 'GreaterThanOne') {
                    if (this.getProperty(paramName) > 1.0) {
                        return true;
                    }
                }
            }
        }
        return false;
    };
    /**
     * Given a parameter name, determine whether it is currently being used
     * for this material, taking into account enabled features and conditional
     * logic for the parameter.
     * @param  {String}  name Parameter name
     * @returns {Boolean}     True if the parameter is being used in the current material.
     */
    MaterialAsset.prototype.isParameterUsed = function (name) {
        var _this = this;
        var shader = this.getShader();
        var shaderParams;
        var shaderFeatures;
        var result = false;
        if (shader) {
            shaderParams = shader.getProperty('parameters');
            shaderFeatures = shader.getProperty('features');
            if (shaderParams[name]) {
                functions_1.forEach(shaderFeatures, function (feature, featureName) {
                    // If the param is part of this feature and this feature is enabled
                    if (feature.parameters.indexOf(name) !== -1 && _this.isFeatureEnabled(featureName)) {
                        // If there are additional conditions for this parameter, test them.
                        if (shaderParams[name].enabledWhen) {
                            result = _this.testParameterConditions(shaderParams[name].enabledWhen);
                        }
                        else {
                            result = true;
                        }
                    }
                });
            }
        }
        return result;
    };
    /**
     * Called when a texture asset referenced by this material is loaded. This function
     * assigns the texture to the materials uniforms list so that it's ready to use.
     * @param textureAsset The loaded texture asset.
     */
    MaterialAsset.prototype.onTextureLoaded = function (textureAsset) {
        var _this = this;
        // If the texture failed to load, the runtimeData will be empty
        // and we don't want to overwrite the stand-in texture assigned already.
        if (textureAsset.isLoadFailed()) {
            return;
        }
        var texture = textureAsset.getThreeTexture();
        if (!texture) {
            return;
        }
        // Go through list of params and find where this texture should be applied.
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        // Filter out only texture parameters that are in use by the material.
        var texParams = Object.keys(shaderParams).filter(function (paramName) {
            return shaderParams[paramName].type === 't'
                && _this.isParameterUsed(paramName)
                && _this.getProperty(paramName) === textureAsset.id;
        });
        // Set the uniform/renderParam for each texture.
        texParams.forEach(function (paramName) {
            _this.setThreeValue(paramName, texture);
        });
        // If the parameter changing always requires a shader recompile, do it.
        var forceUpdate = texParams.some(function (paramName) {
            return shaderParams[paramName].forceUpdate;
        });
        if (forceUpdate) {
            Object.keys(MaterialAsset.materialObjectTypes).forEach(function (matObjType) {
                _this.runtimeData[matObjType].needsUpdate = true;
            });
        }
        this.engine.needsRender = true;
    };
    /**
     * Update a uniform (or other type of parameter) for the Three.JS material from a key and
     * value pair. The key is checked against the material definition for the given type.
     * @param key Name of material param
     */
    MaterialAsset.prototype.updateShaderParameter = function (key) {
        var _this = this;
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var param = shaderParams[key];
        if (!param) {
            return;
        }
        var valueNeedsSetting = true;
        var value = this.getProperty(key);
        switch (param.type.charAt(0)) {
            case 't':
                {
                    var tex = this.engine.getAssetById(value);
                    if (tex && this.isParameterUsed(key)) {
                        // Don't set the value immediately. Let callback on texture load do it.
                        var prevTexId = this.getPreviousProperty(key);
                        if (prevTexId !== this.getProperty(key)) {
                            var prevTex = this.engine.getEntityById(prevTexId);
                            if (prevTex) {
                                this.stopListening(prevTex, 'load', this.onTextureLoaded);
                            }
                        }
                        // Unbind before binding to catch cases where this texture is already bound.
                        // This probably shouldn't be needed but will require a bit of a refactor to avoid.
                        this.stopListening(tex, 'load', this.onTextureLoaded);
                        this.listenTo(tex, 'load', this.onTextureLoaded);
                        // Assign the missing texture so that this material can render cleanly until
                        // the real texture loads.
                        value = this.getStandInTexture(key, param.textureUsage);
                        this.engine.needsRender = true;
                        // If the texture is completely unloaded, load it.
                        if (tex.isUnloaded()) {
                            tex.load();
                        }
                        else if (tex.isLoaded()) {
                            this.onTextureLoaded.call(this, tex);
                        }
                        // If the texture is already loaded, we don't want to set the stand-in texture.
                        if (tex.isLoaded()) {
                            valueNeedsSetting = false;
                        }
                    }
                    else {
                        value = null;
                    }
                }
                break;
            case 'b':
                if (param.animation && value) {
                    MaterialAsset.timeValueInUse = true;
                }
                value = value ? 1 : 0;
                break;
            case 'v':
                if (param.animation && (value.x || value.y || value.z || value.w)) {
                    MaterialAsset.timeValueInUse = true;
                }
                break;
            case 'o':
                value = param.options[value];
                break;
            default:
        }
        if (valueNeedsSetting) {
            this.setThreeValue(key, value);
        }
        // If the parameter changing always requires a material update, do it.
        if (param.forceUpdate) {
            Object.keys(MaterialAsset.materialObjectTypes).forEach(function (matObjType) {
                _this.runtimeData[matObjType].needsUpdate = true;
            });
        }
    };
    /**
     * Return the three.js material parameter/uniform value for the given shader
     * parameter and object type.
     * @param key         The name of the shader parameter
     * @param matObjType  The material object type to return the value from (e.g.
     *                    'static', 'skinned', etc.)
     * @returns           The value of the uniform/material parameter
     */
    MaterialAsset.prototype.getThreeValue = function (key, matObjType) {
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var param = shaderParams[key];
        var paramName = param.uniformName || key;
        var currentValue;
        if (param.isRenderParam) {
            currentValue = this.runtimeData[matObjType][paramName];
        }
        else if (param.isUniform) {
            var uniform = this.runtimeData[matObjType].uniforms[paramName];
            currentValue = uniform ? uniform.value : null;
        }
        if (param.type === 'c') {
            if (!currentValue) {
                currentValue = new THREE.Color(param.default.r, param.default.g, param.default.b);
            }
        }
        else if (param.type.charAt(0) === 'v') {
            if (!currentValue) {
                var defValue = param.default;
                switch (param.type.charAt(1)) {
                    case '4':
                        currentValue = new THREE.Vector4(defValue.x, defValue.y, defValue.z, defValue.w);
                        break;
                    case '3':
                        currentValue = new THREE.Vector3(defValue.x, defValue.y, defValue.z);
                        break;
                    case '2':
                        currentValue = new THREE.Vector2(defValue.x, defValue.y);
                        break;
                    default:
                }
            }
        }
        return currentValue;
    };
    /**
     * Set the uniform or material parameter on Three.js material objects
     * @param key   The name of the shader parameter
     * @param value The new value of the uniform/material parameter
     */
    MaterialAsset.prototype.setThreeValue = function (key, value) {
        var _this = this;
        if (!this.runtimeData) {
            return;
        }
        var shaderAsset = this.getShader();
        var shaderParams = shaderAsset.getProperty('parameters');
        var param = shaderParams[key];
        var paramName = param.uniformName || key;
        Object.keys(MaterialAsset.materialObjectTypes).forEach(function (matObjType) {
            var currentValue = _this.getThreeValue(key, matObjType);
            if (param.type === 'c') {
                currentValue.setRGB(value.r, value.g, value.b);
            }
            else if (param.type.charAt(0) === 'v') {
                switch (param.type.charAt(1)) {
                    case '4':
                        currentValue.w = value.w;
                    /* falls through */
                    case '3':
                        currentValue.z = value.z;
                    /* falls through */
                    case '2':
                        currentValue.x = value.x;
                        currentValue.y = value.y;
                    /* falls through */
                    default:
                }
            }
            else if (param.type === 't') {
                // If the texture has changed substantially enough, we'll need to recompile the material.
                // Encoding type and mapping type result in different shader code.
                if (!currentValue || !value ||
                    currentValue.encoding !== value.encoding ||
                    currentValue.mapping !== value.mapping) {
                    _this.runtimeData[matObjType].needsUpdate = true;
                }
                currentValue = value;
            }
            else {
                currentValue = value;
            }
            if (param.isUniform) {
                var uniform = _this.runtimeData[matObjType].uniforms[paramName];
                if (!uniform) {
                    throw new Error("Trying to set non-existent uniform " + paramName);
                }
                uniform.value = currentValue;
            }
            if (param.isRenderParam) {
                _this.runtimeData[matObjType][paramName] = currentValue;
            }
        });
    };
    /**
     * Enable or disable the use of an extension.
     * @param key   The name of the extension eg: `derivatives`
     * @param value Whether or not to use this extension
     */
    MaterialAsset.prototype.setExtension = function (key, value) {
        var _this = this;
        if (this.runtimeData) {
            Object.keys(MaterialAsset.materialObjectTypes).forEach(function (matObjType) {
                if (_this.runtimeData[matObjType].extensions.hasOwnProperty(key)) {
                    _this.runtimeData[matObjType].extensions[key] = value;
                }
            });
        }
    };
    /**
     * Handle a texture being deleted/unregistered. If the texture is assigned to
     * any property, set that property to null.
     * @param textureId The ID of the texture that was just deleted.
     */
    MaterialAsset.prototype.onTextureDeleted = function (textureId) {
        var _this = this;
        var properties = this.getOwnProperties();
        var assignedProps = Object.keys(properties).filter(function (propName) {
            return (properties[propName] === textureId);
        });
        assignedProps.forEach(function (propName) {
            _this.setProperty(propName, null);
        });
    };
    return MaterialAsset;
}(BaseAsset_1.default));
/** A mapping of string ids to MaterialAssetDef for built in materials. */
MaterialAsset.builtInAssetDescriptors = {
    missingMaterial: {
        id: 'missingMaterial',
        type: 'material',
        properties: {
            name: 'Missing Material',
            albedoColor: { r: 0.8275, g: 0.8275, b: 0.8275 }
        }
    }
};
/**
 * Definitions for each different three.js material that will be created for
 * each MaterialAsset. This includes things like materials with and without
 * skinning support to support being applied to different types of objects.
 */
MaterialAsset.materialObjectTypes = {
    static: {
        lights: true,
        fog: true,
        skinning: false
    },
    skinned: {
        lights: true,
        fog: true,
        skinning: true
    },
    staticTangents: {
        lights: true,
        fog: true,
        skinning: false,
        defines: {
            USE_TANGENTS: true
        }
    },
    skinnedTangents: {
        lights: true,
        fog: true,
        skinning: true,
        defines: {
            USE_TANGENTS: true
        }
    },
    depthStatic: {
        lights: false,
        fog: false,
        vertexColors: THREE.NoColors,
        skinning: false,
        defines: {
            DEPTH_PASS: true
        }
    },
    depthSkinned: {
        lights: false,
        fog: false,
        vertexColors: THREE.NoColors,
        skinning: true,
        defines: {
            DEPTH_PASS: true
        }
    }
};
/**
 * Definitions for uniforms that are used in all (or some) materials. Rather
 * that update the values of each copy of the uniform separately, these are
 * just shared between materials.
 */
MaterialAsset.sharedUniforms = {
    time: {
        type: 'f',
        value: 0.0
    },
    screenDimensions: {
        type: 'v4',
        value: new THREE.Vector4()
    }
};
/**
 * Boolean to track whether materials are animating (and thus need the time
 * uniform to be updated). If true, the engine is set to update the render
 * every frame.
 */
MaterialAsset.timeValueInUse = false;
Schemas_1.addSchemas('MaterialAsset', MaterialAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MaterialAsset;


/***/ },
/* 15 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseEntity_1 = __webpack_require__(32);
var nodeObject = tslib_1.__assign({}, baseEntity_1.default, { id: 'nodeObject', title: 'NodeObjectDef', properties: tslib_1.__assign({}, baseEntity_1.default.properties, { type: {
            enum: ['node']
        }, parentId: {
            type: 'string',
            description: 'The ID of the entity\'s parent.'
        }, prefabAssetId: {
            type: 'string'
        }, prefabObjectId: {
            type: 'string'
        }, prefabInstanceId: {
            type: 'string'
        }, children: {
            type: 'array',
            items: {
                type: 'string'
            },
            default: [],
            description: 'The IDs of this entity\'s children.'
        }, properties: {
            $ref: 'nodeObjectProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = nodeObject;


/***/ },
/* 16 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseEntityProperties_1 = __webpack_require__(33);
var nodeObjectProperties = tslib_1.__assign({}, baseEntityProperties_1.default, { id: 'nodeObjectProperties', title: 'NodeObjectPropertiesDef', properties: tslib_1.__assign({}, baseEntityProperties_1.default.properties, { position: {
            $ref: 'vector3.json',
            default: { x: 0, y: 0, z: 0 }
        }, quaternion: {
            $ref: 'vector4.json',
            default: { x: 0, y: 0, z: 0, w: 1 }
        }, scale: {
            $ref: 'vector3.json',
            default: { x: 1, y: 1, z: 1 }
        }, castShadow: {
            type: 'boolean',
            default: true
        }, receiveShadow: {
            type: 'boolean',
            default: true
        }, visible: {
            type: 'boolean',
            default: true
        }, bounds: {
            $ref: 'box3.json'
        } }), required: ['position', 'scale', 'quaternion'] });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = nodeObjectProperties;


/***/ },
/* 17 */
/***/ function(module, exports, __webpack_require__) {

var v1 = __webpack_require__(246);
var v4 = __webpack_require__(247);

var uuid = v4;
uuid.v1 = v1;
uuid.v4 = v4;

module.exports = uuid;


/***/ },
/* 18 */
/***/ function(module, exports) {

"use strict";
"use strict";
var LoadingType;
(function (LoadingType) {
    LoadingType[LoadingType["BUFFER"] = 1] = "BUFFER";
    LoadingType[LoadingType["IMAGE"] = 2] = "IMAGE";
    LoadingType[LoadingType["VIDEO"] = 3] = "VIDEO";
    LoadingType[LoadingType["ENTITIES"] = 4] = "ENTITIES";
})(LoadingType || (LoadingType = {}));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LoadingType;


/***/ },
/* 19 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var commonImageProperties_1 = __webpack_require__(51);
var baseTextureAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, commonImageProperties_1.default, { id: 'baseTextureAssetProperties', title: 'BaseTextureAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, commonImageProperties_1.default.properties, { uMapping: {
            type: 'string',
            description: '',
            default: 'wrap'
        }, vMapping: {
            type: 'string',
            description: '',
            default: 'wrap'
        }, 
        // This value is temporarily here for compatibility with three.js
        // Remove it when adding a separate transform object to textures.
        mappingType: {
            type: 'string',
            default: 'equirec'
        }, 
        // This value is temporarily here for compatibility with three.js
        // It really doesn't belong anywhere near the texture...
        projectionMode: {
            type: 'string',
            default: 'reflection'
        }, minFilter: {
            type: 'string',
            description: '',
            default: 'linearWithLinearMipmap'
        }, magFilter: {
            type: 'string',
            description: '',
            default: 'linear'
        }, anisotropy: {
            type: 'number',
            description: '',
            default: 8.0
        }, generateMipmaps: {
            type: 'boolean',
            description: '',
            default: true
        }, imageId: {
            type: ['string', 'null'],
            default: null
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseTextureAssetProperties;


/***/ },
/* 20 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-bitwise */
/* tslint:disable max-file-line-count */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseEntity_1 = __webpack_require__(11);
var BaseAsset_1 = __webpack_require__(7);
var BaseImageAsset_1 = __webpack_require__(10);
var ImageAsset_1 = __webpack_require__(29);
var BaseImageAsset_2 = __webpack_require__(10);
var BaseTextureAsset = (function (_super) {
    tslib_1.__extends(BaseTextureAsset, _super);
    function BaseTextureAsset() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * Create a 2D Three.js texture with the specified colour.
     * @param r   Red value (0-255)
     * @param g   Green value (0-255)
     * @param b   Blue value (0-255)
     * @param [a] Alpha value (0-255). If undefined, an RGB texture will be created.
     * @returns   A THREE.DataTexture
     */
    BaseTextureAsset.createColorTexture = function (r, g, b, a) {
        if (r === void 0) { r = 255; }
        if (g === void 0) { g = 255; }
        if (b === void 0) { b = 255; }
        var format = THREE.RGBFormat;
        var byteSize = a !== undefined ? 4 : 3;
        var data = new Uint8Array(byteSize);
        data[0] = r;
        data[1] = g;
        data[2] = b;
        if (byteSize === 4) {
            data[3] = a;
            format = THREE.RGBAFormat;
        }
        var texture = new THREE.DataTexture(data, 1, 1, format, undefined, undefined, undefined, undefined, undefined, undefined);
        texture.needsUpdate = true;
        return texture;
    };
    /**
     * Create a cubemap Three.js texture with the specified colour.
     * @param r   Red value (0-255)
     * @param g   Green value (0-255)
     * @param b   Blue value (0-255)
     * @param [a] Alpha value (0-255). If undefined, an RGB texture will be created.
     * @returns   A THREE.CubeTexture
     */
    BaseTextureAsset.createColorTextureCube = function (r, g, b, a) {
        if (r === void 0) { r = 255; }
        if (g === void 0) { g = 255; }
        if (b === void 0) { b = 255; }
        var sides = [0, 1, 2, 3, 4, 5].map(function (_s) {
            return BaseTextureAsset.createColorTexture(r, g, b, a);
        });
        var texture = new THREE.CubeTexture(sides);
        texture.generateMipmaps = false;
        texture.format = sides[0].format;
        texture.minFilter = THREE.NearestFilter;
        texture.magFilter = THREE.NearestFilter;
        texture.needsUpdate = true;
        return texture;
    };
    /**
     * Returns a 2D texture to be used in place of missing assets.
     * @returns The missing texture.
     */
    BaseTextureAsset.getMissingTexture = function () {
        if (!BaseTextureAsset.missingTexture2d) {
            BaseTextureAsset.missingTexture2d = BaseTextureAsset.createColorTexture();
        }
        return BaseTextureAsset.missingTexture2d;
    };
    /**
     * Returns a cube texture to be used in place of missing assets.
     * @returns THREE.CubeTexture
     */
    BaseTextureAsset.getMissingTextureCube = function () {
        if (!BaseTextureAsset.missingTextureCube) {
            BaseTextureAsset.missingTextureCube = BaseTextureAsset.createColorTextureCube();
        }
        return BaseTextureAsset.missingTextureCube;
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.initialize = function () {
        var _this = this;
        _super.prototype.initialize.call(this);
        this.listenTo(this.engine, 'imageUnloaded', function (imageId) {
            // If this texture is using the image, unload the texture so that entities
            // listening for texture unload can take action.
            if (_this.getProperty('imageId') === imageId) {
                _this.unload();
            }
        });
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        var handleImageFailure = function () {
            _this.runtimeData = BaseTextureAsset.getMissingTexture();
            _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
            _this.trigger('loadProgress', _this);
            if (typeof callback === 'function') {
                callback.call(_this);
            }
        };
        var imageAsset = this.getImage();
        if (imageAsset) {
            // Listen to 'load' event on the image. This can happen multiple times if
            // the image is streaming or a properties change force a new version
            // to be downloaded.
            var onImageLoad = function (image) {
                if (!image.runtimeData) {
                    handleImageFailure();
                    return;
                }
                _this.createTextureData(image.runtimeData);
                if (typeof callback === 'function') {
                    callback.call(_this);
                }
            };
            this.listenTo(imageAsset, 'load', onImageLoad);
            if (imageAsset.isLoaded()) {
                onImageLoad.call(this, imageAsset);
            }
            if (imageAsset.isUnloaded()) {
                imageAsset.load();
            }
        }
        else {
            handleImageFailure();
        }
    };
    /**
     * Create the three.js texture object using the loaded image
     * @param image The runtime data from the image asset
     */
    BaseTextureAsset.prototype.createTextureData = function (_image) {
        Logger_1.default.warn('Need to implement createTextureData in derrived class.');
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.unload = function () {
        // Stop listening to image load events when this texture is unloaded.
        var imageAsset = this.getImage();
        if (imageAsset) {
            this.stopListening(imageAsset, 'load');
        }
        if (this.runtimeData) {
            this.engine.trigger('textureUnloaded', this.id);
            Logger_1.default.info(this.engine.getName() + ' - Unloading texture, ' +
                this.getName());
            this.runtimeData.dispose();
        }
        _super.prototype.unload.call(this);
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        var texture = this.runtimeData instanceof THREE.WebGLRenderTarget ?
            this.runtimeData.texture : this.runtimeData;
        // Textures should always have flipY turned off because it can't be applied to all
        // texture types (e.g. hardware compressed textures). Our shaders will always do
        // the y-flip for us.
        texture.flipY = false;
        if (changes.hasOwnProperty('uMapping')) {
            texture.wrapS = this.getThreeAddressMode(this.getAddressModeU());
        }
        if (changes.hasOwnProperty('vMapping')) {
            texture.wrapT = this.getThreeAddressMode(this.getAddressModeV());
        }
        if (changes.hasOwnProperty('anisotropy')) {
            texture.anisotropy = this.getProperty('anisotropy');
        }
        if (changes.hasOwnProperty('minFilter')) {
            texture.minFilter = this.getThreeFilter(this.getMinFilter());
        }
        if (changes.hasOwnProperty('magFilter')) {
            texture.magFilter = this.getThreeFilter(this.getMagFilter());
        }
        if (changes.hasOwnProperty('generateMipmaps')) {
            texture.generateMipmaps = this.isMipmapsEnabled();
        }
        this.engine.needsRender = true;
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.hasOwnProperty('imageId')) {
            var prevImg = this.getPreviousProperty('imageId');
            if (prevImg) {
                this.unregisterDependencyById(prevImg);
            }
            if (changes.imageId) {
                this.registerDependencyById(this.getProperty('imageId'));
            }
        }
        this.engine.trigger('textureChanged', this.id, changes);
    };
    /**
     * Return the address mode (mapping) for the U axis, taking into account which modes are supported
     * for the image. For example, non power-of-two images must use the "clamp" mode.
     * @returns The best supported address mode.
     */
    BaseTextureAsset.prototype.getAddressModeU = function () {
        return this.getSupportedAddressMode(this.getProperty('uMapping'));
    };
    /**
     * Return the address mode (mapping) for the V axis, taking into account which modes are supported
     * for the image. For example, non power-of-two images must use the "clamp" mode.
     * @returns The best supported address mode.
     */
    BaseTextureAsset.prototype.getAddressModeV = function () {
        return this.getSupportedAddressMode(this.getProperty('vMapping'));
    };
    /**
     * Return the address mode (mapping), taking into account which modes are supported for the image.
     * For example, non power-of-two images must use the "clamp" mode.
     * @param mode  The desired address mode.
     * @returns     The closest supported address mode.
     */
    BaseTextureAsset.prototype.getSupportedAddressMode = function (mode) {
        var image = this.getImage();
        if (image && !image.isPowerOfTwo()) {
            return 'clamp';
        }
        return mode;
    };
    /**
     * Return the layout type of the texture. The different possibilities
     * are defined in BaseImageAsset.LAYOUT. This value comes from the image
     * asset used by this texture or, in the case of renderTextures, is a
     * property of the texture.
     * @returns The layout enum.
     */
    BaseTextureAsset.prototype.getLayout = function () {
        var myLayout = this.getProperty('layout');
        if (myLayout) {
            return myLayout;
        }
        var imageAsset = this.getImage();
        return imageAsset ? imageAsset.getProperty('layout') : BaseImageAsset_2.ImageLayout.Normal;
    };
    /**
     * Returns the width of the texture.
     * @returns The texture width.
     */
    BaseTextureAsset.prototype.getWidth = function () {
        var imageAsset = this.getImage();
        return imageAsset ? imageAsset.getWidth() : 1;
    };
    /**
     * Returns the height of the texture.
     * @returns The texture height.
     */
    BaseTextureAsset.prototype.getHeight = function () {
        var imageAsset = this.getImage();
        return imageAsset ? imageAsset.getHeight() : 1;
    };
    /**
     * Return the minification filter based on the texture's 'minFilter' property, taking into
     * account the capabilities of the current hardware and the texture's data type. e.g. if linear
     * filtering isn't supported for the current data type, this will return the 'nearest' filter.
     * @returns The best supported filter.
     */
    BaseTextureAsset.prototype.getMinFilter = function () {
        return this.getSupportedFilter(this.getProperty('minFilter'));
    };
    /**
     * Return the magnification filter based on the texture's 'magFilter' property, taking into
     * account the capabilities of the current hardware and the texture's data type. e.g. if linear
     * filtering isn't supported for the current data type, this will return the 'nearest' filter.
     * @returns The best supported filter.
     */
    BaseTextureAsset.prototype.getMagFilter = function () {
        return this.getSupportedFilter(this.getProperty('magFilter'));
    };
    /**
     * Given a texture filter, check if it's supported by the current hardware for the current
     * data type and modify and return the filter as necessary. If the filter is supported, the
     * returned value is the same as the filter passed in.
     * @param filter  The filter that we want to check for support
     * @returns       The filter closest to the one passed in that is supported
     * by the current hardware in combination with the current data type.
     */
    BaseTextureAsset.prototype.getSupportedFilter = function (filter) {
        // If we have a float type, check for a compatible filtering extension.
        var type = this.getDataType();
        if (!this.isLinearFilterAvailableForType(type)) {
            return 'nearest';
        }
        // Don't use mipmap filters when mipmapping is disabled.
        if (!this.isMipmapsEnabled()) {
            switch (filter) {
                default:
                case 'nearest':
                case 'nearestWithNearestMipmap':
                case 'nearestWithLinearMipmap':
                    return 'nearest';
                case 'linear':
                case 'linearWithNearestMipmap':
                case 'linearWithLinearMipmap':
                    return 'linear';
            }
        }
        return filter;
    };
    /**
     * Return the texture type of this asset (e.g. 'float', 'uByte', etc.). If the texture type is
     * not compatible with the current hardware, the closest type will be returned instead.
     * @returns The data type of the texture.
     */
    BaseTextureAsset.prototype.getDataType = function () {
        var type = this.getProperty('type');
        if (!type) {
            var image = this.getImage();
            if (image) {
                return image.getDataType();
            }
            return 'uByte';
        }
        var returnType = type;
        var renderer = this.engine.getThreeRenderer();
        var extensions = renderer.extensions;
        switch (type) {
            case 'float':
                if (extensions.get('OES_texture_float')) {
                    returnType = 'float';
                    break;
                }
            /* falls through */
            // (for fallback compatibility)
            case 'halfFloat':
                if (extensions.get('OES_texture_half_float')) {
                    returnType = 'halfFloat';
                }
                else {
                    returnType = 'uByte';
                }
                break;
            default:
                returnType = type;
        }
        return returnType;
    };
    /**
     * Get the format for this texture. 'rgb', 'rgba', etc.
     * @returns The image format as a string.
     */
    BaseTextureAsset.prototype.getFormat = function () {
        var format = this.getProperty('format');
        if (!format) {
            var image = this.getImage();
            if (image) {
                return image.getFormat();
            }
            return 'rgb';
        }
        return format;
    };
    /**
     * Returns the number of mip levels that this texture has, including the full-resolution version.
     * @returns The total number of mip levels used by this texture.
     */
    BaseTextureAsset.prototype.getMipCount = function () {
        if (!this.getProperty('generateMipmaps')) {
            return 1;
        }
        var imageAsset = this.getImage();
        return imageAsset ? imageAsset.getMipCount() : 1;
    };
    /**
     * Return the image asset that is used by this texture, if any.
     * @returns The image asset that is used by this texture, if any.
     */
    BaseTextureAsset.prototype.getImage = function () {
        return this.engine.getAssetById(this.getProperty('imageId'));
    };
    /** @inheritdoc */
    BaseTextureAsset.prototype.getDataSizeInMemorySelf = function () {
        var image = this.getImage();
        if (image instanceof ImageAsset_1.default) {
            var rep = image.getChosenRepresentation();
            if (!rep) {
                // TODO - video assets that use video tags dont' have representations. So, what should we do here?
                return image.getDataSizeInMemory();
            }
            if (rep.compression && rep.compression !== 'zip' && rep.compression !== 'jpeg') {
                return this.getDataSizeDownloadSelf();
            }
            if (this.getHdrPackingType(rep.channels)) {
                return this.getWidth() * this.getHeight() * BaseImageAsset_1.default.getBytesPerPixel('rgb', this.getDataType());
            }
        }
        return this.getWidth() * this.getHeight() * BaseImageAsset_1.default.getBytesPerPixel(this.getFormat(), this.getDataType());
    };
    /**
     * Returns true iff the texture is a cube texture.
     * @returns Returns true iff the texture is a cube texture.
     */
    BaseTextureAsset.prototype.isCubeMap = function () {
        return this.type === 'textureCube' || this.type === 'renderTextureCube';
    };
    /**
     * Returns true iff linear texture filtering is supported for the provided type
     * on the current hardware.
     * @param dataType  The dataType of the texture (e.g. 'float', 'halfFloat', 'uByte', etc.)
     * @returns         Returns the three.js type (e.g. THREE.FloatType)
     */
    BaseTextureAsset.prototype.isLinearFilterAvailableForType = function (dataType) {
        var renderer = this.engine.getThreeRenderer();
        var extensions = renderer.extensions;
        switch (dataType) {
            case 'halfFloat':
                return !!extensions.get('OES_texture_half_float_linear');
            case 'float':
                return !!extensions.get('OES_texture_float_linear');
            default:
                return true;
        }
    };
    /**
     * Return true if mipmaps are enabled and supported for the data type and image size; otherwise,
     * returns false. For example, non power-of-two images cannot have mipmaps.
     * @returns True if mipmaps are enabled; otherwise, false.
     */
    BaseTextureAsset.prototype.isMipmapsEnabled = function () {
        if (!this.isLinearFilterAvailableForType(this.getDataType())) {
            return false;
        }
        // TODO: isPowerOfTwo() is currently based on the dimensions of the *original* image, not the
        // *loaded* image, so this isn't quite correct. We need to re-evaluate the behaviour of
        // getWidth(), getHeight(), isPowerOfTwo(), etc..
        var image = this.getImage();
        if (image && !image.isPowerOfTwo()) {
            return false;
        }
        return this.getProperty('generateMipmaps');
    };
    /**
     * Return the packing format of the HDR texture. Returns null if either not HDR or
     * not a recognized packing type.
     * @param channels  The channels array for the image. e.g. ['red', 'green', 'blue']
     * @returns         The packing format of the HDR texture (e.g. 'rgbe')
     */
    BaseTextureAsset.prototype.getHdrPackingType = function (channels) {
        if (channels && channels.length === 4 && channels[3] === 'exponent') {
            return 'rgbe';
        }
        return null;
    };
    /**
     * Create DXT compressed texture from an array buffer containing the data.
     * @param buffer  The binary data representing the DXT image file.
     * @returns       The three.js compressed texture
     */
    BaseTextureAsset.prototype.createDxtTextureData = function (buffer) {
        var texture = new THREE.CompressedTexture(null, null, null);
        var dds = this.parseDDS(buffer, true);
        var iFace;
        var iMip;
        var nFaces;
        texture.format = dds.format;
        texture.generateMipmaps = false;
        if (dds.isCubemap) {
            texture.flipY = false;
            // FIXME: THREE.CompressedTexture doesn't seem to like this attribute
            // bypassing via cast as `any`. Is this a bug?
            var image = texture.image = [];
            nFaces = dds.mipmaps.length / dds.mipmapCount;
            for (iFace = 0; iFace < nFaces; iFace += 1) {
                image[iFace] = {
                    mipmaps: []
                };
                for (iMip = 0; iMip < dds.mipmapCount; iMip += 1) {
                    image[iFace].mipmaps.push(dds.mipmaps[iFace * dds.mipmapCount + iMip]);
                    image[iFace].format = dds.format;
                    image[iFace].width = dds.width;
                    image[iFace].height = dds.height;
                }
            }
        }
        else {
            texture.mipmaps = dds.mipmaps;
            texture.image.width = dds.width;
            texture.image.height = dds.height;
        }
        return texture;
    };
    /**
     * Get the three.js texture object for this texture. Note that if this is a render texture, this
     * function returns the texture object inside the render target object.
     * @returns The three.js texture object for this texture.
     */
    BaseTextureAsset.prototype.getThreeTexture = function () {
        if (this.runtimeData) {
            return this.runtimeData.texture ? this.runtimeData.texture : this.runtimeData;
        }
        return null;
    };
    /**
     * Converts a Box3D address mode string into a THREE.js Wrapping constant.
     * @param addressMode A string representing the wrapping mode.
     * @returns           The THREE.js wrapping constant.
     */
    BaseTextureAsset.prototype.getThreeAddressMode = function (addressMode) {
        switch (addressMode) {
            case 'wrap':
                return THREE.RepeatWrapping;
            case 'clamp':
                return THREE.ClampToEdgeWrapping;
            case 'mirror':
                return THREE.MirroredRepeatWrapping;
            default:
                Logger_1.default.warn("Unexpected address mode setting: " + addressMode + " defaulting to THREE.ClampToEdgeWrapping");
                return THREE.ClampToEdgeWrapping;
        }
    };
    /**
     * Converts a Box3D filter string into a THREE.js Texture Filter constant.
     * @param filter  A string representing the texture filter setting.
     * @returns       The THREE.js texture filter constant.
     */
    BaseTextureAsset.prototype.getThreeFilter = function (filter) {
        switch (filter) {
            case 'nearest':
                return THREE.NearestFilter;
            case 'nearestWithNearestMipmap':
                return THREE.NearestMipMapNearestFilter;
            case 'nearestWithLinearMipmap':
                return THREE.NearestMipMapLinearFilter;
            case 'linear':
                return THREE.LinearFilter;
            case 'linearWithNearestMipmap':
                return THREE.LinearMipMapNearestFilter;
            case 'linearWithLinearMipmap':
                return THREE.LinearMipMapLinearFilter;
            default:
                Logger_1.default.warn("Unexpected filter setting: " + filter + " defaulting to THREE.LinearFilter");
                return THREE.LinearFilter;
        }
    };
    /**
     * Parse the downloaded DDS file
     * @param buffer      The array buffer containing the downloaded DXT-compressed image
     * @param loadMipmaps True if we want to load mipmaps (if they exist in the data)
     * @returns           An object containing information about the DDS
     */
    BaseTextureAsset.prototype.parseDDS = function (buffer, loadMipmaps) {
        // Disabled  ext-variable-name due to adaptation from external code.
        /* tslint:disable ext-variable-name */
        // Adapted from @toji's DDS utils
        //  https://github.com/toji/webgl-texture-utils/blob/master/texture-util/dds.js
        // All values and structures referenced from:
        // http://msdn.microsoft.com/en-us/library/bb943991.aspx/
        /**
         * Converts a four character code into an 32 bit integer.
         * @param value The four character code.
         * @returns     The converted 32 bit integer.
         */
        function fourCCToInt32(value) {
            return value.charCodeAt(0) +
                (value.charCodeAt(1) << 8) +
                (value.charCodeAt(2) << 16) +
                (value.charCodeAt(3) << 24);
        }
        /**
         * Converts a 32 bit integer into a four character code.
         * @param value The 32 bit integer.
         * @returns     The four character code.
         */
        function int32ToFourCC(value) {
            return String.fromCharCode(value & 0xff, (value >> 8) & 0xff, (value >> 16) & 0xff, (value >> 24) & 0xff);
        }
        /**
         * Extracts a mip from the input buffer.
         * @param buf         The array buffer to load from.
         * @param dataOffset  The offset into the buffer for this mip.
         * @param width       The width of the mip.
         * @param height      The height of the mip.
         * @returns           An extracted unsigned 8 bit array.
         */
        function loadARGBMip(buf, dataOffset, width, height) {
            var dataLength = width * height * 4;
            var srcBuffer = new Uint8Array(buf, dataOffset, dataLength);
            var byteArray = new Uint8Array(dataLength);
            var dst = 0;
            var src = 0;
            var x;
            var y;
            var r;
            var g;
            var b;
            var a;
            for (y = 0; y < height; y += 1) {
                for (x = 0; x < width; x += 1) {
                    b = srcBuffer[src];
                    g = srcBuffer[src + 1];
                    r = srcBuffer[src + 2];
                    a = srcBuffer[src + 3];
                    byteArray[dst] = r; // r
                    byteArray[dst + 1] = g; // g
                    byteArray[dst + 2] = b; // b
                    byteArray[dst + 3] = a; // a
                    src += 4;
                    dst += 4;
                }
            }
            return byteArray;
        }
        var DDS_MAGIC = 0x20534444;
        // DDSD_CAPS = 0x1,
        // DDSD_HEIGHT = 0x2,
        // DDSD_WIDTH = 0x4,
        // DDSD_PITCH = 0x8,
        // DDSD_PIXELFORMAT = 0x1000,
        var DDSD_MIPMAPCOUNT = 0x20000;
        // DDSD_LINEARSIZE = 0x80000,
        // DDSD_DEPTH = 0x800000,
        // DDSCAPS_COMPLEX = 0x8,
        // DDSCAPS_MIPMAP = 0x400000,
        // DDSCAPS_TEXTURE = 0x1000,
        var DDSCAPS2_CUBEMAP = 0x200;
        // DDSCAPS2_CUBEMAP_POSITIVEX = 0x400,
        // DDSCAPS2_CUBEMAP_NEGATIVEX = 0x800,
        // DDSCAPS2_CUBEMAP_POSITIVEY = 0x1000,
        // DDSCAPS2_CUBEMAP_NEGATIVEY = 0x2000,
        // DDSCAPS2_CUBEMAP_POSITIVEZ = 0x4000,
        // DDSCAPS2_CUBEMAP_NEGATIVEZ = 0x8000,
        // DDSCAPS2_VOLUME = 0x200000,
        // DDPF_ALPHAPIXELS = 0x1,
        // DDPF_ALPHA = 0x2,
        var DDPF_FOURCC = 0x4;
        // DDPF_RGB = 0x40,
        // DDPF_YUV = 0x200,
        // DDPF_LUMINANCE = 0x20000,
        var FOURCC_DXT1 = fourCCToInt32('DXT1');
        var FOURCC_DXT3 = fourCCToInt32('DXT3');
        var FOURCC_DXT5 = fourCCToInt32('DXT5');
        var headerLengthInt = 31; // The header length in 32 bit ints
        // Offsets into the header array
        var off_magic = 0;
        var off_size = 1;
        var off_flags = 2;
        var off_height = 3;
        var off_width = 4;
        var off_mipmapCount = 7;
        var off_pfFlags = 20;
        var off_pfFourCC = 21;
        var off_RGBBitCount = 22;
        var off_RBitMask = 23;
        var off_GBitMask = 24;
        var off_BBitMask = 25;
        var off_ABitMask = 26;
        // off_caps = 27,
        var off_caps2 = 28;
        // off_caps3 = 29,
        // off_caps4 = 30,
        var header;
        var blockBytes;
        var fourCC;
        var isRGBAUncompressed;
        var dataOffset;
        var width;
        var height;
        var iFace;
        var nFaces;
        var iMip;
        var byteArray;
        var dataLength;
        var dds = {
            mipmaps: [],
            width: 0,
            height: 0,
            format: null,
            mipmapCount: 1
        };
        header = new Int32Array(buffer, 0, headerLengthInt);
        // Parse header
        if (header[off_magic] !== DDS_MAGIC) {
            Logger_1.default.error('THREE.DDSLoader.parse: Invalid magic number in DDS ' +
                'header.');
            return dds;
        }
        if (!(header[off_pfFlags] & DDPF_FOURCC)) {
            Logger_1.default.error('THREE.DDSLoader.parse: Unsupported format, must ' +
                'contain a FourCC code.');
            return dds;
        }
        fourCC = header[off_pfFourCC];
        isRGBAUncompressed = false;
        switch (fourCC) {
            case FOURCC_DXT1:
                blockBytes = 8;
                dds.format = THREE.RGB_S3TC_DXT1_Format;
                break;
            case FOURCC_DXT3:
                blockBytes = 16;
                dds.format = THREE.RGBA_S3TC_DXT3_Format;
                break;
            case FOURCC_DXT5:
                blockBytes = 16;
                dds.format = THREE.RGBA_S3TC_DXT5_Format;
                break;
            default:
                if (header[off_RGBBitCount] === 32 &&
                    header[off_RBitMask] & 0xff0000 &&
                    header[off_GBitMask] & 0xff00 &&
                    header[off_BBitMask] & 0xff &&
                    header[off_ABitMask] & 0xff000000) {
                    isRGBAUncompressed = true;
                    blockBytes = 64;
                    dds.format = THREE.RGBAFormat;
                }
                else {
                    Logger_1.default.error('THREE.DDSLoader.parse: Unsupported FourCC code ', int32ToFourCC(fourCC));
                    return dds;
                }
        }
        dds.mipmapCount = 1;
        if (header[off_flags] & DDSD_MIPMAPCOUNT && loadMipmaps !== false) {
            dds.mipmapCount = Math.max(1, header[off_mipmapCount]);
        }
        // TODO: Verify that all faces of the cubemap are present with
        // DDSCAPS2_CUBEMAP_POSITIVEX, etc.
        dds.isCubemap = header[off_caps2] & DDSCAPS2_CUBEMAP ? true : false;
        dds.width = header[off_width];
        dds.height = header[off_height];
        dataOffset = header[off_size] + 4;
        // Extract mipmaps buffers
        width = dds.width;
        height = dds.height;
        nFaces = dds.isCubemap ? 6 : 1;
        for (iFace = 0; iFace < nFaces; iFace += 1) {
            for (iMip = 0; iMip < dds.mipmapCount; iMip += 1) {
                if (isRGBAUncompressed) {
                    byteArray = loadARGBMip(buffer, dataOffset, width, height);
                    dataLength = byteArray.length;
                }
                else {
                    dataLength = Math.max(4, width) / 4 * Math.max(4, height) /
                        4 * blockBytes;
                    byteArray = new Uint8Array(buffer, dataOffset, dataLength);
                }
                dds.mipmaps.push({
                    data: byteArray,
                    width: width,
                    height: height
                });
                dataOffset += dataLength;
                width = Math.max(width * 0.5, 1);
                height = Math.max(height * 0.5, 1);
            }
            width = dds.width;
            height = dds.height;
        }
        return dds;
        /* tslint:enable ext-variable-name */
    };
    return BaseTextureAsset;
}(BaseAsset_1.default));
/** The texture to be used in place of a missing texture2d. */
BaseTextureAsset.missingTexture2d = null;
/** The texture to be used in place of a missing textureCube. */
BaseTextureAsset.missingTextureCube = null;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseTextureAsset;


/***/ },
/* 21 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* tslint:disable no-invalid-this */
// RuntimeEvents based on code adapted from Backbone.Events.
//
// Backbone.js:
//     (c) 2010-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Backbone may be freely distributed under the MIT license.
//     For all details and documentation:
//     http://backbonejs.org
//
"use strict";
var uuid_1 = __webpack_require__(17);
;
var triggerEvents = function (events, args) {
    var ev;
    var i = -1;
    var l = events.length;
    var a1 = args[0];
    var a2 = args[1];
    var a3 = args[2];
    switch (args.length) {
        case 0:
            while (++i < l) {
                (ev = events[i]).callback.call(ev.ctx);
            }
            break;
        case 1:
            while (++i < l) {
                (ev = events[i]).callback.call(ev.ctx, a1);
            }
            break;
        case 2:
            while (++i < l) {
                (ev = events[i]).callback.call(ev.ctx, a1, a2);
            }
            break;
        case 3:
            while (++i < l) {
                (ev = events[i]).callback.call(ev.ctx, a1, a2, a3);
            }
            break;
        default:
            while (++i < l) {
                (ev = events[i]).callback.apply(ev.ctx, args);
            }
            break;
    }
};
// Inversion-of-control versions of `on` and `once`. Tell *this* object to
// listen to an event in another object ... keeping track of what it's
// listening to.
var invertedListen = function (method) {
    return function (obj, name, callback) {
        var id = obj._listenId || (obj._listenId = uuid_1.v4());
        this._listeningTo[id] = obj;
        if (!callback && typeof name === 'object') {
            callback = this;
        }
        obj[method](name, callback, this);
        return this;
    };
};
var once = function (fn) {
    var _this = this;
    var called = false;
    return function () {
        var args = [];
        for (var _i = 0; _i < arguments.length; _i++) {
            args[_i] = arguments[_i];
        }
        if (!called) {
            called = true;
            fn.apply(_this, args);
        }
    };
};
var listenTo = invertedListen('on');
var listenToOnce = invertedListen('once');
var RuntimeEvents = (function () {
    function RuntimeEvents() {
        this._events = { all: [] };
        this._listeningTo = {};
        this._listenId = uuid_1.v4();
    }
    /**
     * Bind an event to a `callback` function.
     * @method on
     * @public
     * @param  {String}   name     The name of the event
     * @param  {Function} callback The function to call when the event occurs.
     * @param  {Object}   [context]  The context in which the callback will be called.
     */
    RuntimeEvents.prototype.on = function (name, callback, context) {
        var events = this._events[name] || (this._events[name] = []);
        events.push({ callback: callback, context: context, ctx: context || this });
        return this;
    };
    /**
     * Bind an event to only be triggered a single time. After the first time the callback
     * is invoked, it will be removed.
     * @method once
     * @public
     * @param  {String}   name      The name of the event
     * @param  {Function} callback  The function to call when the event occurs.
     * @param  {Object}   [context] The context in which the callback will be called.
     */
    RuntimeEvents.prototype.once = function (name, callback, context) {
        var _this = this;
        if (typeof callback !== 'function') {
            return;
        }
        var fn = once(function () {
            var args = [];
            for (var _i = 0; _i < arguments.length; _i++) {
                args[_i] = arguments[_i];
            }
            _this.off(name, once);
            callback.apply(context || _this, args);
        });
        return this.on(name, fn, context);
    };
    /**
     * Remove one or many callbacks. If `context` is null, removes all
     * callbacks with that function. If `callback` is null, removes all
     * callbacks for the event. If `name` is null, removes all bound
     * callbacks for all events.
     * @method off
     * @public
     * @param  {String}   [name]     The name of the event
     * @param  {Function} [callback] The function to call when the event occurs.
     * @param  {Object}   [context]  The context in which the callback will be called.
     */
    RuntimeEvents.prototype.off = function (name, callback, context) {
        var retain;
        var ev;
        var events;
        var names;
        if (!name && !callback && !context) {
            return this;
        }
        names = name ? [name] : Object.keys(this._events);
        /* tslint:disable one-variable-per-declaration */
        for (var i = 0, l = names.length; i < l; i++) {
            name = names[i];
            events = this._events[name];
            if (events) {
                this._events[name] = retain = [];
                if (callback || context) {
                    for (var j = 0, k = events.length; j < k; j++) {
                        ev = events[j];
                        if ((callback && callback !== ev.callback && callback !== ev.callback._callback) ||
                            (context && context !== ev.context)) {
                            retain.push(ev);
                        }
                    }
                }
                if (!retain.length) {
                    delete this._events[name];
                }
            }
        }
        /* tslint:enable one-variable-per-declaration */
        return this;
    };
    /**
     * Trigger one or many events, firing all bound callbacks. Callbacks are
     * passed the same arguments as `trigger` is, apart from the event name
     * (unless you're listening on `"all"`, which will cause your callback to
     * receive the true name of the event as the first argument).
     * @method trigger
     * @public
     * @param {String} name The name of the event
     */
    RuntimeEvents.prototype.trigger = function (name) {
        var args = [];
        for (var _i = 1; _i < arguments.length; _i++) {
            args[_i - 1] = arguments[_i];
        }
        if (!this._events) {
            return this;
        }
        var events = this._events[name];
        var allEvents = this._events.all;
        if (events) {
            triggerEvents(events, args);
        }
        args.unshift(name);
        if (allEvents) {
            triggerEvents(allEvents, args);
        }
        return this;
    };
    /**
     * Tell this object to stop listening to either specific events ... or
     * to every object it's currently listening to.
     * @method stopListening
     * @public
     * @param  {[type]}   [obj]      The object that the event is bound to
     * @param  {String}   [name]     The name of the event
     * @param  {Function} [callback] The function to call when the event occurs.
     */
    RuntimeEvents.prototype.stopListening = function (obj, name, callback) {
        var listeningTo = this._listeningTo;
        if (!listeningTo) {
            return this;
        }
        var remove = !name && !callback;
        if (!callback && typeof name === 'object') {
            callback = this;
        }
        if (obj) {
            (listeningTo = {})[obj._listenId] = obj;
        }
        for (var id in listeningTo) {
            if (listeningTo.hasOwnProperty(id)) {
                obj = listeningTo[id];
                obj.off(name, callback, this);
                if (remove || !obj._events) {
                    delete this._listeningTo[id];
                }
            }
        }
    };
    /**
     * Returns true if someone is listening to the specified event on this object.
     * @method isEventBound
     * @public
     * @param  {String}  name The name of the event.
     * @return {Boolean}      True if the event has a listener already. False otherwise.
     */
    RuntimeEvents.prototype.isEventBound = function (name) {
        return this._events[name] ? true : false;
    };
    /**
     * Inversion-of-control version of `on`.
     * @method listenTo
     * @public
     * @param  {Object}   obj      The object which emits the event.
     * @param  {String}   name     The name of the event
     * @param  {Function} [callback] The function to call when the event occurs.
     */
    RuntimeEvents.prototype.listenTo = function (obj, name, callback) {
        return listenTo.call(this, obj, name, callback);
    };
    /**
     * Inversion-of-control version of `once`.
     * @method listenTo
     * @public
     * @param  {Object}   obj      The object which emits the event.
     * @param  {String}   name     The name of the event
     * @param  {Function} [callback] The function to call when the event occurs.
     */
    RuntimeEvents.prototype.listenToOnce = function (obj, name, callback) {
        return listenToOnce.call(this, obj, name, callback);
    };
    return RuntimeEvents;
}());
;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RuntimeEvents;


/***/ },
/* 22 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var baseTextureAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'baseTextureAsset', title: 'BaseTextureAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { properties: {
            $ref: 'baseTextureAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseTextureAsset;


/***/ },
/* 23 */
/***/ function(module, exports) {

"use strict";
"use strict";
/**
 * Returns a deep clone of the given data. This method doesn't copy
 * functions and is intended for POJO's and primitive types.
 * @param {mixed} json The data to clone.
 * @return {mixed} The cloned data.
 */
var deepClone = function (data) {
    switch (typeof data) {
        case 'object':
            return JSON.parse(JSON.stringify(data));
        case 'function':
            return undefined;
        default:
            return data;
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = deepClone;


/***/ },
/* 24 */
/***/ function(module, exports) {

var core = module.exports = {version: '2.4.0'};
if(typeof __e == 'number')__e = core; // eslint-disable-line no-undef

/***/ },
/* 25 */
/***/ function(module, exports) {

// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028
var global = module.exports = typeof window != 'undefined' && window.Math == Math
  ? window : typeof self != 'undefined' && self.Math == Math ? self : Function('return this')();
if(typeof __g == 'number')__g = global; // eslint-disable-line no-undef

/***/ },
/* 26 */
/***/ function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;//     Underscore.js 1.6.0
//     http://underscorejs.org
//     (c) 2009-2014 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
//     Underscore may be freely distributed under the MIT license.

(function() {

  // Baseline setup
  // --------------

  // Establish the root object, `window` in the browser, or `exports` on the server.
  var root = this;

  // Save the previous value of the `_` variable.
  var previousUnderscore = root._;

  // Establish the object that gets returned to break out of a loop iteration.
  var breaker = {};

  // Save bytes in the minified (but not gzipped) version:
  var ArrayProto = Array.prototype, ObjProto = Object.prototype, FuncProto = Function.prototype;

  // Create quick reference variables for speed access to core prototypes.
  var
    push             = ArrayProto.push,
    slice            = ArrayProto.slice,
    concat           = ArrayProto.concat,
    toString         = ObjProto.toString,
    hasOwnProperty   = ObjProto.hasOwnProperty;

  // All **ECMAScript 5** native function implementations that we hope to use
  // are declared here.
  var
    nativeForEach      = ArrayProto.forEach,
    nativeMap          = ArrayProto.map,
    nativeReduce       = ArrayProto.reduce,
    nativeReduceRight  = ArrayProto.reduceRight,
    nativeFilter       = ArrayProto.filter,
    nativeEvery        = ArrayProto.every,
    nativeSome         = ArrayProto.some,
    nativeIndexOf      = ArrayProto.indexOf,
    nativeLastIndexOf  = ArrayProto.lastIndexOf,
    nativeIsArray      = Array.isArray,
    nativeKeys         = Object.keys,
    nativeBind         = FuncProto.bind;

  // Create a safe reference to the Underscore object for use below.
  var _ = function(obj) {
    if (obj instanceof _) return obj;
    if (!(this instanceof _)) return new _(obj);
    this._wrapped = obj;
  };

  // Export the Underscore object for **Node.js**, with
  // backwards-compatibility for the old `require()` API. If we're in
  // the browser, add `_` as a global object via a string identifier,
  // for Closure Compiler "advanced" mode.
  if (true) {
    if (typeof module !== 'undefined' && module.exports) {
      exports = module.exports = _;
    }
    exports._ = _;
  } else {
    root._ = _;
  }

  // Current version.
  _.VERSION = '1.6.0';

  // Collection Functions
  // --------------------

  // The cornerstone, an `each` implementation, aka `forEach`.
  // Handles objects with the built-in `forEach`, arrays, and raw objects.
  // Delegates to **ECMAScript 5**'s native `forEach` if available.
  var each = _.each = _.forEach = function(obj, iterator, context) {
    if (obj == null) return obj;
    if (nativeForEach && obj.forEach === nativeForEach) {
      obj.forEach(iterator, context);
    } else if (obj.length === +obj.length) {
      for (var i = 0, length = obj.length; i < length; i++) {
        if (iterator.call(context, obj[i], i, obj) === breaker) return;
      }
    } else {
      var keys = _.keys(obj);
      for (var i = 0, length = keys.length; i < length; i++) {
        if (iterator.call(context, obj[keys[i]], keys[i], obj) === breaker) return;
      }
    }
    return obj;
  };

  // Return the results of applying the iterator to each element.
  // Delegates to **ECMAScript 5**'s native `map` if available.
  _.map = _.collect = function(obj, iterator, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeMap && obj.map === nativeMap) return obj.map(iterator, context);
    each(obj, function(value, index, list) {
      results.push(iterator.call(context, value, index, list));
    });
    return results;
  };

  var reduceError = 'Reduce of empty array with no initial value';

  // **Reduce** builds up a single result from a list of values, aka `inject`,
  // or `foldl`. Delegates to **ECMAScript 5**'s native `reduce` if available.
  _.reduce = _.foldl = _.inject = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduce && obj.reduce === nativeReduce) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduce(iterator, memo) : obj.reduce(iterator);
    }
    each(obj, function(value, index, list) {
      if (!initial) {
        memo = value;
        initial = true;
      } else {
        memo = iterator.call(context, memo, value, index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // The right-associative version of reduce, also known as `foldr`.
  // Delegates to **ECMAScript 5**'s native `reduceRight` if available.
  _.reduceRight = _.foldr = function(obj, iterator, memo, context) {
    var initial = arguments.length > 2;
    if (obj == null) obj = [];
    if (nativeReduceRight && obj.reduceRight === nativeReduceRight) {
      if (context) iterator = _.bind(iterator, context);
      return initial ? obj.reduceRight(iterator, memo) : obj.reduceRight(iterator);
    }
    var length = obj.length;
    if (length !== +length) {
      var keys = _.keys(obj);
      length = keys.length;
    }
    each(obj, function(value, index, list) {
      index = keys ? keys[--length] : --length;
      if (!initial) {
        memo = obj[index];
        initial = true;
      } else {
        memo = iterator.call(context, memo, obj[index], index, list);
      }
    });
    if (!initial) throw new TypeError(reduceError);
    return memo;
  };

  // Return the first value which passes a truth test. Aliased as `detect`.
  _.find = _.detect = function(obj, predicate, context) {
    var result;
    any(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) {
        result = value;
        return true;
      }
    });
    return result;
  };

  // Return all the elements that pass a truth test.
  // Delegates to **ECMAScript 5**'s native `filter` if available.
  // Aliased as `select`.
  _.filter = _.select = function(obj, predicate, context) {
    var results = [];
    if (obj == null) return results;
    if (nativeFilter && obj.filter === nativeFilter) return obj.filter(predicate, context);
    each(obj, function(value, index, list) {
      if (predicate.call(context, value, index, list)) results.push(value);
    });
    return results;
  };

  // Return all the elements for which a truth test fails.
  _.reject = function(obj, predicate, context) {
    return _.filter(obj, function(value, index, list) {
      return !predicate.call(context, value, index, list);
    }, context);
  };

  // Determine whether all of the elements match a truth test.
  // Delegates to **ECMAScript 5**'s native `every` if available.
  // Aliased as `all`.
  _.every = _.all = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = true;
    if (obj == null) return result;
    if (nativeEvery && obj.every === nativeEvery) return obj.every(predicate, context);
    each(obj, function(value, index, list) {
      if (!(result = result && predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if at least one element in the object matches a truth test.
  // Delegates to **ECMAScript 5**'s native `some` if available.
  // Aliased as `any`.
  var any = _.some = _.any = function(obj, predicate, context) {
    predicate || (predicate = _.identity);
    var result = false;
    if (obj == null) return result;
    if (nativeSome && obj.some === nativeSome) return obj.some(predicate, context);
    each(obj, function(value, index, list) {
      if (result || (result = predicate.call(context, value, index, list))) return breaker;
    });
    return !!result;
  };

  // Determine if the array or object contains a given value (using `===`).
  // Aliased as `include`.
  _.contains = _.include = function(obj, target) {
    if (obj == null) return false;
    if (nativeIndexOf && obj.indexOf === nativeIndexOf) return obj.indexOf(target) != -1;
    return any(obj, function(value) {
      return value === target;
    });
  };

  // Invoke a method (with arguments) on every item in a collection.
  _.invoke = function(obj, method) {
    var args = slice.call(arguments, 2);
    var isFunc = _.isFunction(method);
    return _.map(obj, function(value) {
      return (isFunc ? method : value[method]).apply(value, args);
    });
  };

  // Convenience version of a common use case of `map`: fetching a property.
  _.pluck = function(obj, key) {
    return _.map(obj, _.property(key));
  };

  // Convenience version of a common use case of `filter`: selecting only objects
  // containing specific `key:value` pairs.
  _.where = function(obj, attrs) {
    return _.filter(obj, _.matches(attrs));
  };

  // Convenience version of a common use case of `find`: getting the first object
  // containing specific `key:value` pairs.
  _.findWhere = function(obj, attrs) {
    return _.find(obj, _.matches(attrs));
  };

  // Return the maximum element or (element-based computation).
  // Can't optimize arrays of integers longer than 65,535 elements.
  // See [WebKit Bug 80797](https://bugs.webkit.org/show_bug.cgi?id=80797)
  _.max = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.max.apply(Math, obj);
    }
    var result = -Infinity, lastComputed = -Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed > lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Return the minimum element (or element-based computation).
  _.min = function(obj, iterator, context) {
    if (!iterator && _.isArray(obj) && obj[0] === +obj[0] && obj.length < 65535) {
      return Math.min.apply(Math, obj);
    }
    var result = Infinity, lastComputed = Infinity;
    each(obj, function(value, index, list) {
      var computed = iterator ? iterator.call(context, value, index, list) : value;
      if (computed < lastComputed) {
        result = value;
        lastComputed = computed;
      }
    });
    return result;
  };

  // Shuffle an array, using the modern version of the
  // [Fisher-Yates shuffle](http://en.wikipedia.org/wiki/Fisher–Yates_shuffle).
  _.shuffle = function(obj) {
    var rand;
    var index = 0;
    var shuffled = [];
    each(obj, function(value) {
      rand = _.random(index++);
      shuffled[index - 1] = shuffled[rand];
      shuffled[rand] = value;
    });
    return shuffled;
  };

  // Sample **n** random values from a collection.
  // If **n** is not specified, returns a single random element.
  // The internal `guard` argument allows it to work with `map`.
  _.sample = function(obj, n, guard) {
    if (n == null || guard) {
      if (obj.length !== +obj.length) obj = _.values(obj);
      return obj[_.random(obj.length - 1)];
    }
    return _.shuffle(obj).slice(0, Math.max(0, n));
  };

  // An internal function to generate lookup iterators.
  var lookupIterator = function(value) {
    if (value == null) return _.identity;
    if (_.isFunction(value)) return value;
    return _.property(value);
  };

  // Sort the object's values by a criterion produced by an iterator.
  _.sortBy = function(obj, iterator, context) {
    iterator = lookupIterator(iterator);
    return _.pluck(_.map(obj, function(value, index, list) {
      return {
        value: value,
        index: index,
        criteria: iterator.call(context, value, index, list)
      };
    }).sort(function(left, right) {
      var a = left.criteria;
      var b = right.criteria;
      if (a !== b) {
        if (a > b || a === void 0) return 1;
        if (a < b || b === void 0) return -1;
      }
      return left.index - right.index;
    }), 'value');
  };

  // An internal function used for aggregate "group by" operations.
  var group = function(behavior) {
    return function(obj, iterator, context) {
      var result = {};
      iterator = lookupIterator(iterator);
      each(obj, function(value, index) {
        var key = iterator.call(context, value, index, obj);
        behavior(result, key, value);
      });
      return result;
    };
  };

  // Groups the object's values by a criterion. Pass either a string attribute
  // to group by, or a function that returns the criterion.
  _.groupBy = group(function(result, key, value) {
    _.has(result, key) ? result[key].push(value) : result[key] = [value];
  });

  // Indexes the object's values by a criterion, similar to `groupBy`, but for
  // when you know that your index values will be unique.
  _.indexBy = group(function(result, key, value) {
    result[key] = value;
  });

  // Counts instances of an object that group by a certain criterion. Pass
  // either a string attribute to count by, or a function that returns the
  // criterion.
  _.countBy = group(function(result, key) {
    _.has(result, key) ? result[key]++ : result[key] = 1;
  });

  // Use a comparator function to figure out the smallest index at which
  // an object should be inserted so as to maintain order. Uses binary search.
  _.sortedIndex = function(array, obj, iterator, context) {
    iterator = lookupIterator(iterator);
    var value = iterator.call(context, obj);
    var low = 0, high = array.length;
    while (low < high) {
      var mid = (low + high) >>> 1;
      iterator.call(context, array[mid]) < value ? low = mid + 1 : high = mid;
    }
    return low;
  };

  // Safely create a real, live array from anything iterable.
  _.toArray = function(obj) {
    if (!obj) return [];
    if (_.isArray(obj)) return slice.call(obj);
    if (obj.length === +obj.length) return _.map(obj, _.identity);
    return _.values(obj);
  };

  // Return the number of elements in an object.
  _.size = function(obj) {
    if (obj == null) return 0;
    return (obj.length === +obj.length) ? obj.length : _.keys(obj).length;
  };

  // Array Functions
  // ---------------

  // Get the first element of an array. Passing **n** will return the first N
  // values in the array. Aliased as `head` and `take`. The **guard** check
  // allows it to work with `_.map`.
  _.first = _.head = _.take = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[0];
    if (n < 0) return [];
    return slice.call(array, 0, n);
  };

  // Returns everything but the last entry of the array. Especially useful on
  // the arguments object. Passing **n** will return all the values in
  // the array, excluding the last N. The **guard** check allows it to work with
  // `_.map`.
  _.initial = function(array, n, guard) {
    return slice.call(array, 0, array.length - ((n == null) || guard ? 1 : n));
  };

  // Get the last element of an array. Passing **n** will return the last N
  // values in the array. The **guard** check allows it to work with `_.map`.
  _.last = function(array, n, guard) {
    if (array == null) return void 0;
    if ((n == null) || guard) return array[array.length - 1];
    return slice.call(array, Math.max(array.length - n, 0));
  };

  // Returns everything but the first entry of the array. Aliased as `tail` and `drop`.
  // Especially useful on the arguments object. Passing an **n** will return
  // the rest N values in the array. The **guard**
  // check allows it to work with `_.map`.
  _.rest = _.tail = _.drop = function(array, n, guard) {
    return slice.call(array, (n == null) || guard ? 1 : n);
  };

  // Trim out all falsy values from an array.
  _.compact = function(array) {
    return _.filter(array, _.identity);
  };

  // Internal implementation of a recursive `flatten` function.
  var flatten = function(input, shallow, output) {
    if (shallow && _.every(input, _.isArray)) {
      return concat.apply(output, input);
    }
    each(input, function(value) {
      if (_.isArray(value) || _.isArguments(value)) {
        shallow ? push.apply(output, value) : flatten(value, shallow, output);
      } else {
        output.push(value);
      }
    });
    return output;
  };

  // Flatten out an array, either recursively (by default), or just one level.
  _.flatten = function(array, shallow) {
    return flatten(array, shallow, []);
  };

  // Return a version of the array that does not contain the specified value(s).
  _.without = function(array) {
    return _.difference(array, slice.call(arguments, 1));
  };

  // Split an array into two arrays: one whose elements all satisfy the given
  // predicate, and one whose elements all do not satisfy the predicate.
  _.partition = function(array, predicate) {
    var pass = [], fail = [];
    each(array, function(elem) {
      (predicate(elem) ? pass : fail).push(elem);
    });
    return [pass, fail];
  };

  // Produce a duplicate-free version of the array. If the array has already
  // been sorted, you have the option of using a faster algorithm.
  // Aliased as `unique`.
  _.uniq = _.unique = function(array, isSorted, iterator, context) {
    if (_.isFunction(isSorted)) {
      context = iterator;
      iterator = isSorted;
      isSorted = false;
    }
    var initial = iterator ? _.map(array, iterator, context) : array;
    var results = [];
    var seen = [];
    each(initial, function(value, index) {
      if (isSorted ? (!index || seen[seen.length - 1] !== value) : !_.contains(seen, value)) {
        seen.push(value);
        results.push(array[index]);
      }
    });
    return results;
  };

  // Produce an array that contains the union: each distinct element from all of
  // the passed-in arrays.
  _.union = function() {
    return _.uniq(_.flatten(arguments, true));
  };

  // Produce an array that contains every item shared between all the
  // passed-in arrays.
  _.intersection = function(array) {
    var rest = slice.call(arguments, 1);
    return _.filter(_.uniq(array), function(item) {
      return _.every(rest, function(other) {
        return _.contains(other, item);
      });
    });
  };

  // Take the difference between one array and a number of other arrays.
  // Only the elements present in just the first array will remain.
  _.difference = function(array) {
    var rest = concat.apply(ArrayProto, slice.call(arguments, 1));
    return _.filter(array, function(value){ return !_.contains(rest, value); });
  };

  // Zip together multiple lists into a single array -- elements that share
  // an index go together.
  _.zip = function() {
    var length = _.max(_.pluck(arguments, 'length').concat(0));
    var results = new Array(length);
    for (var i = 0; i < length; i++) {
      results[i] = _.pluck(arguments, '' + i);
    }
    return results;
  };

  // Converts lists into objects. Pass either a single array of `[key, value]`
  // pairs, or two parallel arrays of the same length -- one of keys, and one of
  // the corresponding values.
  _.object = function(list, values) {
    if (list == null) return {};
    var result = {};
    for (var i = 0, length = list.length; i < length; i++) {
      if (values) {
        result[list[i]] = values[i];
      } else {
        result[list[i][0]] = list[i][1];
      }
    }
    return result;
  };

  // If the browser doesn't supply us with indexOf (I'm looking at you, **MSIE**),
  // we need this function. Return the position of the first occurrence of an
  // item in an array, or -1 if the item is not included in the array.
  // Delegates to **ECMAScript 5**'s native `indexOf` if available.
  // If the array is large and already in sort order, pass `true`
  // for **isSorted** to use binary search.
  _.indexOf = function(array, item, isSorted) {
    if (array == null) return -1;
    var i = 0, length = array.length;
    if (isSorted) {
      if (typeof isSorted == 'number') {
        i = (isSorted < 0 ? Math.max(0, length + isSorted) : isSorted);
      } else {
        i = _.sortedIndex(array, item);
        return array[i] === item ? i : -1;
      }
    }
    if (nativeIndexOf && array.indexOf === nativeIndexOf) return array.indexOf(item, isSorted);
    for (; i < length; i++) if (array[i] === item) return i;
    return -1;
  };

  // Delegates to **ECMAScript 5**'s native `lastIndexOf` if available.
  _.lastIndexOf = function(array, item, from) {
    if (array == null) return -1;
    var hasIndex = from != null;
    if (nativeLastIndexOf && array.lastIndexOf === nativeLastIndexOf) {
      return hasIndex ? array.lastIndexOf(item, from) : array.lastIndexOf(item);
    }
    var i = (hasIndex ? from : array.length);
    while (i--) if (array[i] === item) return i;
    return -1;
  };

  // Generate an integer Array containing an arithmetic progression. A port of
  // the native Python `range()` function. See
  // [the Python documentation](http://docs.python.org/library/functions.html#range).
  _.range = function(start, stop, step) {
    if (arguments.length <= 1) {
      stop = start || 0;
      start = 0;
    }
    step = arguments[2] || 1;

    var length = Math.max(Math.ceil((stop - start) / step), 0);
    var idx = 0;
    var range = new Array(length);

    while(idx < length) {
      range[idx++] = start;
      start += step;
    }

    return range;
  };

  // Function (ahem) Functions
  // ------------------

  // Reusable constructor function for prototype setting.
  var ctor = function(){};

  // Create a function bound to a given object (assigning `this`, and arguments,
  // optionally). Delegates to **ECMAScript 5**'s native `Function.bind` if
  // available.
  _.bind = function(func, context) {
    var args, bound;
    if (nativeBind && func.bind === nativeBind) return nativeBind.apply(func, slice.call(arguments, 1));
    if (!_.isFunction(func)) throw new TypeError;
    args = slice.call(arguments, 2);
    return bound = function() {
      if (!(this instanceof bound)) return func.apply(context, args.concat(slice.call(arguments)));
      ctor.prototype = func.prototype;
      var self = new ctor;
      ctor.prototype = null;
      var result = func.apply(self, args.concat(slice.call(arguments)));
      if (Object(result) === result) return result;
      return self;
    };
  };

  // Partially apply a function by creating a version that has had some of its
  // arguments pre-filled, without changing its dynamic `this` context. _ acts
  // as a placeholder, allowing any combination of arguments to be pre-filled.
  _.partial = function(func) {
    var boundArgs = slice.call(arguments, 1);
    return function() {
      var position = 0;
      var args = boundArgs.slice();
      for (var i = 0, length = args.length; i < length; i++) {
        if (args[i] === _) args[i] = arguments[position++];
      }
      while (position < arguments.length) args.push(arguments[position++]);
      return func.apply(this, args);
    };
  };

  // Bind a number of an object's methods to that object. Remaining arguments
  // are the method names to be bound. Useful for ensuring that all callbacks
  // defined on an object belong to it.
  _.bindAll = function(obj) {
    var funcs = slice.call(arguments, 1);
    if (funcs.length === 0) throw new Error('bindAll must be passed function names');
    each(funcs, function(f) { obj[f] = _.bind(obj[f], obj); });
    return obj;
  };

  // Memoize an expensive function by storing its results.
  _.memoize = function(func, hasher) {
    var memo = {};
    hasher || (hasher = _.identity);
    return function() {
      var key = hasher.apply(this, arguments);
      return _.has(memo, key) ? memo[key] : (memo[key] = func.apply(this, arguments));
    };
  };

  // Delays a function for the given number of milliseconds, and then calls
  // it with the arguments supplied.
  _.delay = function(func, wait) {
    var args = slice.call(arguments, 2);
    return setTimeout(function(){ return func.apply(null, args); }, wait);
  };

  // Defers a function, scheduling it to run after the current call stack has
  // cleared.
  _.defer = function(func) {
    return _.delay.apply(_, [func, 1].concat(slice.call(arguments, 1)));
  };

  // Returns a function, that, when invoked, will only be triggered at most once
  // during a given window of time. Normally, the throttled function will run
  // as much as it can, without ever going more than once per `wait` duration;
  // but if you'd like to disable the execution on the leading edge, pass
  // `{leading: false}`. To disable execution on the trailing edge, ditto.
  _.throttle = function(func, wait, options) {
    var context, args, result;
    var timeout = null;
    var previous = 0;
    options || (options = {});
    var later = function() {
      previous = options.leading === false ? 0 : _.now();
      timeout = null;
      result = func.apply(context, args);
      context = args = null;
    };
    return function() {
      var now = _.now();
      if (!previous && options.leading === false) previous = now;
      var remaining = wait - (now - previous);
      context = this;
      args = arguments;
      if (remaining <= 0) {
        clearTimeout(timeout);
        timeout = null;
        previous = now;
        result = func.apply(context, args);
        context = args = null;
      } else if (!timeout && options.trailing !== false) {
        timeout = setTimeout(later, remaining);
      }
      return result;
    };
  };

  // Returns a function, that, as long as it continues to be invoked, will not
  // be triggered. The function will be called after it stops being called for
  // N milliseconds. If `immediate` is passed, trigger the function on the
  // leading edge, instead of the trailing.
  _.debounce = function(func, wait, immediate) {
    var timeout, args, context, timestamp, result;

    var later = function() {
      var last = _.now() - timestamp;
      if (last < wait) {
        timeout = setTimeout(later, wait - last);
      } else {
        timeout = null;
        if (!immediate) {
          result = func.apply(context, args);
          context = args = null;
        }
      }
    };

    return function() {
      context = this;
      args = arguments;
      timestamp = _.now();
      var callNow = immediate && !timeout;
      if (!timeout) {
        timeout = setTimeout(later, wait);
      }
      if (callNow) {
        result = func.apply(context, args);
        context = args = null;
      }

      return result;
    };
  };

  // Returns a function that will be executed at most one time, no matter how
  // often you call it. Useful for lazy initialization.
  _.once = function(func) {
    var ran = false, memo;
    return function() {
      if (ran) return memo;
      ran = true;
      memo = func.apply(this, arguments);
      func = null;
      return memo;
    };
  };

  // Returns the first function passed as an argument to the second,
  // allowing you to adjust arguments, run code before and after, and
  // conditionally execute the original function.
  _.wrap = function(func, wrapper) {
    return _.partial(wrapper, func);
  };

  // Returns a function that is the composition of a list of functions, each
  // consuming the return value of the function that follows.
  _.compose = function() {
    var funcs = arguments;
    return function() {
      var args = arguments;
      for (var i = funcs.length - 1; i >= 0; i--) {
        args = [funcs[i].apply(this, args)];
      }
      return args[0];
    };
  };

  // Returns a function that will only be executed after being called N times.
  _.after = function(times, func) {
    return function() {
      if (--times < 1) {
        return func.apply(this, arguments);
      }
    };
  };

  // Object Functions
  // ----------------

  // Retrieve the names of an object's properties.
  // Delegates to **ECMAScript 5**'s native `Object.keys`
  _.keys = function(obj) {
    if (!_.isObject(obj)) return [];
    if (nativeKeys) return nativeKeys(obj);
    var keys = [];
    for (var key in obj) if (_.has(obj, key)) keys.push(key);
    return keys;
  };

  // Retrieve the values of an object's properties.
  _.values = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var values = new Array(length);
    for (var i = 0; i < length; i++) {
      values[i] = obj[keys[i]];
    }
    return values;
  };

  // Convert an object into a list of `[key, value]` pairs.
  _.pairs = function(obj) {
    var keys = _.keys(obj);
    var length = keys.length;
    var pairs = new Array(length);
    for (var i = 0; i < length; i++) {
      pairs[i] = [keys[i], obj[keys[i]]];
    }
    return pairs;
  };

  // Invert the keys and values of an object. The values must be serializable.
  _.invert = function(obj) {
    var result = {};
    var keys = _.keys(obj);
    for (var i = 0, length = keys.length; i < length; i++) {
      result[obj[keys[i]]] = keys[i];
    }
    return result;
  };

  // Return a sorted list of the function names available on the object.
  // Aliased as `methods`
  _.functions = _.methods = function(obj) {
    var names = [];
    for (var key in obj) {
      if (_.isFunction(obj[key])) names.push(key);
    }
    return names.sort();
  };

  // Extend a given object with all the properties in passed-in object(s).
  _.extend = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Return a copy of the object only containing the whitelisted properties.
  _.pick = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    each(keys, function(key) {
      if (key in obj) copy[key] = obj[key];
    });
    return copy;
  };

   // Return a copy of the object without the blacklisted properties.
  _.omit = function(obj) {
    var copy = {};
    var keys = concat.apply(ArrayProto, slice.call(arguments, 1));
    for (var key in obj) {
      if (!_.contains(keys, key)) copy[key] = obj[key];
    }
    return copy;
  };

  // Fill in a given object with default properties.
  _.defaults = function(obj) {
    each(slice.call(arguments, 1), function(source) {
      if (source) {
        for (var prop in source) {
          if (obj[prop] === void 0) obj[prop] = source[prop];
        }
      }
    });
    return obj;
  };

  // Create a (shallow-cloned) duplicate of an object.
  _.clone = function(obj) {
    if (!_.isObject(obj)) return obj;
    return _.isArray(obj) ? obj.slice() : _.extend({}, obj);
  };

  // Invokes interceptor with the obj, and then returns obj.
  // The primary purpose of this method is to "tap into" a method chain, in
  // order to perform operations on intermediate results within the chain.
  _.tap = function(obj, interceptor) {
    interceptor(obj);
    return obj;
  };

  // Internal recursive comparison function for `isEqual`.
  var eq = function(a, b, aStack, bStack) {
    // Identical objects are equal. `0 === -0`, but they aren't identical.
    // See the [Harmony `egal` proposal](http://wiki.ecmascript.org/doku.php?id=harmony:egal).
    if (a === b) return a !== 0 || 1 / a == 1 / b;
    // A strict comparison is necessary because `null == undefined`.
    if (a == null || b == null) return a === b;
    // Unwrap any wrapped objects.
    if (a instanceof _) a = a._wrapped;
    if (b instanceof _) b = b._wrapped;
    // Compare `[[Class]]` names.
    var className = toString.call(a);
    if (className != toString.call(b)) return false;
    switch (className) {
      // Strings, numbers, dates, and booleans are compared by value.
      case '[object String]':
        // Primitives and their corresponding object wrappers are equivalent; thus, `"5"` is
        // equivalent to `new String("5")`.
        return a == String(b);
      case '[object Number]':
        // `NaN`s are equivalent, but non-reflexive. An `egal` comparison is performed for
        // other numeric values.
        return a != +a ? b != +b : (a == 0 ? 1 / a == 1 / b : a == +b);
      case '[object Date]':
      case '[object Boolean]':
        // Coerce dates and booleans to numeric primitive values. Dates are compared by their
        // millisecond representations. Note that invalid dates with millisecond representations
        // of `NaN` are not equivalent.
        return +a == +b;
      // RegExps are compared by their source patterns and flags.
      case '[object RegExp]':
        return a.source == b.source &&
               a.global == b.global &&
               a.multiline == b.multiline &&
               a.ignoreCase == b.ignoreCase;
    }
    if (typeof a != 'object' || typeof b != 'object') return false;
    // Assume equality for cyclic structures. The algorithm for detecting cyclic
    // structures is adapted from ES 5.1 section 15.12.3, abstract operation `JO`.
    var length = aStack.length;
    while (length--) {
      // Linear search. Performance is inversely proportional to the number of
      // unique nested structures.
      if (aStack[length] == a) return bStack[length] == b;
    }
    // Objects with different constructors are not equivalent, but `Object`s
    // from different frames are.
    var aCtor = a.constructor, bCtor = b.constructor;
    if (aCtor !== bCtor && !(_.isFunction(aCtor) && (aCtor instanceof aCtor) &&
                             _.isFunction(bCtor) && (bCtor instanceof bCtor))
                        && ('constructor' in a && 'constructor' in b)) {
      return false;
    }
    // Add the first object to the stack of traversed objects.
    aStack.push(a);
    bStack.push(b);
    var size = 0, result = true;
    // Recursively compare objects and arrays.
    if (className == '[object Array]') {
      // Compare array lengths to determine if a deep comparison is necessary.
      size = a.length;
      result = size == b.length;
      if (result) {
        // Deep compare the contents, ignoring non-numeric properties.
        while (size--) {
          if (!(result = eq(a[size], b[size], aStack, bStack))) break;
        }
      }
    } else {
      // Deep compare objects.
      for (var key in a) {
        if (_.has(a, key)) {
          // Count the expected number of properties.
          size++;
          // Deep compare each member.
          if (!(result = _.has(b, key) && eq(a[key], b[key], aStack, bStack))) break;
        }
      }
      // Ensure that both objects contain the same number of properties.
      if (result) {
        for (key in b) {
          if (_.has(b, key) && !(size--)) break;
        }
        result = !size;
      }
    }
    // Remove the first object from the stack of traversed objects.
    aStack.pop();
    bStack.pop();
    return result;
  };

  // Perform a deep comparison to check if two objects are equal.
  _.isEqual = function(a, b) {
    return eq(a, b, [], []);
  };

  // Is a given array, string, or object empty?
  // An "empty" object has no enumerable own-properties.
  _.isEmpty = function(obj) {
    if (obj == null) return true;
    if (_.isArray(obj) || _.isString(obj)) return obj.length === 0;
    for (var key in obj) if (_.has(obj, key)) return false;
    return true;
  };

  // Is a given value a DOM element?
  _.isElement = function(obj) {
    return !!(obj && obj.nodeType === 1);
  };

  // Is a given value an array?
  // Delegates to ECMA5's native Array.isArray
  _.isArray = nativeIsArray || function(obj) {
    return toString.call(obj) == '[object Array]';
  };

  // Is a given variable an object?
  _.isObject = function(obj) {
    return obj === Object(obj);
  };

  // Add some isType methods: isArguments, isFunction, isString, isNumber, isDate, isRegExp.
  each(['Arguments', 'Function', 'String', 'Number', 'Date', 'RegExp'], function(name) {
    _['is' + name] = function(obj) {
      return toString.call(obj) == '[object ' + name + ']';
    };
  });

  // Define a fallback version of the method in browsers (ahem, IE), where
  // there isn't any inspectable "Arguments" type.
  if (!_.isArguments(arguments)) {
    _.isArguments = function(obj) {
      return !!(obj && _.has(obj, 'callee'));
    };
  }

  // Optimize `isFunction` if appropriate.
  if (true) {
    _.isFunction = function(obj) {
      return typeof obj === 'function';
    };
  }

  // Is a given object a finite number?
  _.isFinite = function(obj) {
    return isFinite(obj) && !isNaN(parseFloat(obj));
  };

  // Is the given value `NaN`? (NaN is the only number which does not equal itself).
  _.isNaN = function(obj) {
    return _.isNumber(obj) && obj != +obj;
  };

  // Is a given value a boolean?
  _.isBoolean = function(obj) {
    return obj === true || obj === false || toString.call(obj) == '[object Boolean]';
  };

  // Is a given value equal to null?
  _.isNull = function(obj) {
    return obj === null;
  };

  // Is a given variable undefined?
  _.isUndefined = function(obj) {
    return obj === void 0;
  };

  // Shortcut function for checking if an object has a given property directly
  // on itself (in other words, not on a prototype).
  _.has = function(obj, key) {
    return hasOwnProperty.call(obj, key);
  };

  // Utility Functions
  // -----------------

  // Run Underscore.js in *noConflict* mode, returning the `_` variable to its
  // previous owner. Returns a reference to the Underscore object.
  _.noConflict = function() {
    root._ = previousUnderscore;
    return this;
  };

  // Keep the identity function around for default iterators.
  _.identity = function(value) {
    return value;
  };

  _.constant = function(value) {
    return function () {
      return value;
    };
  };

  _.property = function(key) {
    return function(obj) {
      return obj[key];
    };
  };

  // Returns a predicate for checking whether an object has a given set of `key:value` pairs.
  _.matches = function(attrs) {
    return function(obj) {
      if (obj === attrs) return true; //avoid comparing an object to itself.
      for (var key in attrs) {
        if (attrs[key] !== obj[key])
          return false;
      }
      return true;
    }
  };

  // Run a function **n** times.
  _.times = function(n, iterator, context) {
    var accum = Array(Math.max(0, n));
    for (var i = 0; i < n; i++) accum[i] = iterator.call(context, i);
    return accum;
  };

  // Return a random integer between min and max (inclusive).
  _.random = function(min, max) {
    if (max == null) {
      max = min;
      min = 0;
    }
    return min + Math.floor(Math.random() * (max - min + 1));
  };

  // A (possibly faster) way to get the current timestamp as an integer.
  _.now = Date.now || function() { return new Date().getTime(); };

  // List of HTML entities for escaping.
  var entityMap = {
    escape: {
      '&': '&amp;',
      '<': '&lt;',
      '>': '&gt;',
      '"': '&quot;',
      "'": '&#x27;'
    }
  };
  entityMap.unescape = _.invert(entityMap.escape);

  // Regexes containing the keys and values listed immediately above.
  var entityRegexes = {
    escape:   new RegExp('[' + _.keys(entityMap.escape).join('') + ']', 'g'),
    unescape: new RegExp('(' + _.keys(entityMap.unescape).join('|') + ')', 'g')
  };

  // Functions for escaping and unescaping strings to/from HTML interpolation.
  _.each(['escape', 'unescape'], function(method) {
    _[method] = function(string) {
      if (string == null) return '';
      return ('' + string).replace(entityRegexes[method], function(match) {
        return entityMap[method][match];
      });
    };
  });

  // If the value of the named `property` is a function then invoke it with the
  // `object` as context; otherwise, return it.
  _.result = function(object, property) {
    if (object == null) return void 0;
    var value = object[property];
    return _.isFunction(value) ? value.call(object) : value;
  };

  // Add your own custom functions to the Underscore object.
  _.mixin = function(obj) {
    each(_.functions(obj), function(name) {
      var func = _[name] = obj[name];
      _.prototype[name] = function() {
        var args = [this._wrapped];
        push.apply(args, arguments);
        return result.call(this, func.apply(_, args));
      };
    });
  };

  // Generate a unique integer id (unique within the entire client session).
  // Useful for temporary DOM ids.
  var idCounter = 0;
  _.uniqueId = function(prefix) {
    var id = ++idCounter + '';
    return prefix ? prefix + id : id;
  };

  // By default, Underscore uses ERB-style template delimiters, change the
  // following template settings to use alternative delimiters.
  _.templateSettings = {
    evaluate    : /<%([\s\S]+?)%>/g,
    interpolate : /<%=([\s\S]+?)%>/g,
    escape      : /<%-([\s\S]+?)%>/g
  };

  // When customizing `templateSettings`, if you don't want to define an
  // interpolation, evaluation or escaping regex, we need one that is
  // guaranteed not to match.
  var noMatch = /(.)^/;

  // Certain characters need to be escaped so that they can be put into a
  // string literal.
  var escapes = {
    "'":      "'",
    '\\':     '\\',
    '\r':     'r',
    '\n':     'n',
    '\t':     't',
    '\u2028': 'u2028',
    '\u2029': 'u2029'
  };

  var escaper = /\\|'|\r|\n|\t|\u2028|\u2029/g;

  // JavaScript micro-templating, similar to John Resig's implementation.
  // Underscore templating handles arbitrary delimiters, preserves whitespace,
  // and correctly escapes quotes within interpolated code.
  _.template = function(text, data, settings) {
    var render;
    settings = _.defaults({}, settings, _.templateSettings);

    // Combine delimiters into one regular expression via alternation.
    var matcher = new RegExp([
      (settings.escape || noMatch).source,
      (settings.interpolate || noMatch).source,
      (settings.evaluate || noMatch).source
    ].join('|') + '|$', 'g');

    // Compile the template source, escaping string literals appropriately.
    var index = 0;
    var source = "__p+='";
    text.replace(matcher, function(match, escape, interpolate, evaluate, offset) {
      source += text.slice(index, offset)
        .replace(escaper, function(match) { return '\\' + escapes[match]; });

      if (escape) {
        source += "'+\n((__t=(" + escape + "))==null?'':_.escape(__t))+\n'";
      }
      if (interpolate) {
        source += "'+\n((__t=(" + interpolate + "))==null?'':__t)+\n'";
      }
      if (evaluate) {
        source += "';\n" + evaluate + "\n__p+='";
      }
      index = offset + match.length;
      return match;
    });
    source += "';\n";

    // If a variable is not specified, place data values in local scope.
    if (!settings.variable) source = 'with(obj||{}){\n' + source + '}\n';

    source = "var __t,__p='',__j=Array.prototype.join," +
      "print=function(){__p+=__j.call(arguments,'');};\n" +
      source + "return __p;\n";

    try {
      render = new Function(settings.variable || 'obj', '_', source);
    } catch (e) {
      e.source = source;
      throw e;
    }

    if (data) return render(data, _);
    var template = function(data) {
      return render.call(this, data, _);
    };

    // Provide the compiled function source as a convenience for precompilation.
    template.source = 'function(' + (settings.variable || 'obj') + '){\n' + source + '}';

    return template;
  };

  // Add a "chain" function, which will delegate to the wrapper.
  _.chain = function(obj) {
    return _(obj).chain();
  };

  // OOP
  // ---------------
  // If Underscore is called as a function, it returns a wrapped object that
  // can be used OO-style. This wrapper holds altered versions of all the
  // underscore functions. Wrapped objects may be chained.

  // Helper function to continue chaining intermediate results.
  var result = function(obj) {
    return this._chain ? _(obj).chain() : obj;
  };

  // Add all of the Underscore functions to the wrapper object.
  _.mixin(_);

  // Add all mutator Array functions to the wrapper.
  each(['pop', 'push', 'reverse', 'shift', 'sort', 'splice', 'unshift'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      var obj = this._wrapped;
      method.apply(obj, arguments);
      if ((name == 'shift' || name == 'splice') && obj.length === 0) delete obj[0];
      return result.call(this, obj);
    };
  });

  // Add all accessor Array functions to the wrapper.
  each(['concat', 'join', 'slice'], function(name) {
    var method = ArrayProto[name];
    _.prototype[name] = function() {
      return result.call(this, method.apply(this._wrapped, arguments));
    };
  });

  _.extend(_.prototype, {

    // Start chaining a wrapped Underscore object.
    chain: function() {
      this._chain = true;
      return this;
    },

    // Extracts the result from a wrapped and chained object.
    value: function() {
      return this._wrapped;
    }

  });

  // AMD registration happens at the end for compatibility with AMD loaders
  // that may not enforce next-turn semantics on modules. Even though general
  // practice for AMD registration is to be anonymous, underscore registers
  // as a named module because, like jQuery, it is a base library that is
  // popular enough to be bundled in a third party lib, but not be part of
  // an AMD load request. Those cases could generate an error when an
  // anonymous define() is called outside of a loader request.
  if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = function() {
      return _;
    }.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
  }
}).call(this);


/***/ },
/* 27 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(7);
var functions_1 = __webpack_require__(6);
/**
 * An abstract base class that holds geometry.
 * @class BaseGeometryAsset
 */
var BaseGeometryAsset = (function (_super) {
    tslib_1.__extends(BaseGeometryAsset, _super);
    /**
     * Create a BaseGeometryAsset.
     * @constructor
     * @protected
     */
    function BaseGeometryAsset(jsonDesc, runtime) {
        var _this = _super.call(this, jsonDesc, runtime) || this;
        /**
         * The loaded Three.js geometries for this asset.
         */
        _this.geometries = {};
        /**
         * The maximum index in the material array referenced by the geometry.
         */
        _this.maxMaterialIndices = {};
        functions_1.forEach(BaseGeometryAsset.primitiveType, function (type) {
            _this.maxMaterialIndices[type] = -1;
        });
        return _this;
    }
    /**
     * Calculates the highest material index referenced by a Three.js geometry object.
     * @method computeMaxMaterialIndex
     * @private
     * @param {THREE.Geometry|THREE.BufferGeometry} geometry The Three.js geometry.
     * @returns {number} The maximum material index.
     */
    BaseGeometryAsset.computeMaxMaterialIndex = function (geometry) {
        var groups = BaseGeometryAsset.getMaterialGroups(geometry);
        return groups.reduce(function (maxIndex, group) { return Math.max(maxIndex, group.materialIndex); }, -1);
    };
    /**
     * Map negative material indices, which indicate no material assignment, to positive ones. All
     * negative material indices are mapped to maxMaterialIndex + 1, where maxMaterialIndex is the
     * maximum material index as calculated by computeMaxMaterialIndex().
     * @method fixNegativeMaterialIndices
     * @private
     * @param {THREE.Geometry|THREE.BufferGeometry} geometry The Three.js geometry.
     * @returns {void}
     */
    BaseGeometryAsset.fixNegativeMaterialIndices = function (geometry) {
        var groups = this.getMaterialGroups(geometry);
        var negativeGroups = groups.filter(function (group) { return group.materialIndex < 0; });
        var maxMaterialIndex = BaseGeometryAsset.computeMaxMaterialIndex(geometry);
        negativeGroups.forEach(function (group) {
            group.materialIndex = maxMaterialIndex + 1;
        });
    };
    /**
     * Get an array of "groups", where each group has a material assignment (materialIndex). For a
     * THREE.BufferGeometry, this method returns the "groups" property. For a THREE.Geometry, this
     * method returns the "faces" property. If neither of these properties exist, this method returns
     * an empty array.
     * @method getMaterialGroups
     * @private
     * @param {THREE.Geometry|THREE.BufferGeometry} geometry The Three.js geometry.
     * @returns {Array} The array of material groups.
     */
    BaseGeometryAsset.getMaterialGroups = function (geometry) {
        if (geometry instanceof THREE.BufferGeometry && geometry.groups) {
            return geometry.groups;
        }
        if (geometry instanceof THREE.Geometry && geometry.faces) {
            return geometry.faces;
        }
        return [];
    };
    /** @inheritdoc */
    BaseGeometryAsset.prototype.unload = function () {
        Logger_1.default.info(this.engine.getName() +
            ' - BaseGeometryAsset: Unloading geometry, ' + this.getName() + ' - "' + this.id + '"');
        functions_1.forEach(this.geometries, function (geometry) {
            if (geometry) {
                geometry.dispose();
            }
        });
        this.geometries = {};
        _super.prototype.unload.call(this);
    };
    /**
     * Get the bounds of this geometry.
     * @param [outBounds] Optional Box3 to write the result to. Passing this in will
     * avoid another THREE.Box3 from being created.
     * @returns The bounds of this geometry.
     */
    BaseGeometryAsset.prototype.getBounds = function (outBounds) {
        var geometries = functions_1.values(this.geometries).filter(function (geometry) { return geometry; });
        return geometries.reduce(function (bounds, geometry) {
            return bounds.union(geometry.boundingBox);
        }, outBounds || new THREE.Box3());
    };
    /**
     * Returns an array of this asset's geometries (all PrimitiveTypes).
     * @method getGeometries
     * @public
     * @returns {Array} An array of THREE.Geometry and THREE.BufferGeometry objects.
     */
    BaseGeometryAsset.prototype.getGeometries = function () {
        return functions_1.values(this.geometries);
    };
    /**
     * Returns this asset's geometry of the specified type.
     * @method getGeometry
     * @public
     * @param {String} [type] One of BaseGeometryAsset.primitiveType (default is TRIANGLES).
     * @returns {THREE.Geometry|THREE.BufferGeometry} A Three.js geometry.
     */
    BaseGeometryAsset.prototype.getGeometry = function (type) {
        if (type === void 0) { type = BaseGeometryAsset.primitiveType.TRIANGLES; }
        return this.geometries[type];
    };
    /**
     * Returns this asset's maximum material index for the specified type.
     * @method getMaxMaterialIndex
     * @public
     * @param {String} [type] One of BaseGeometryAsset.primitiveType (default is TRIANGLES).
     * @returns {number} The maximum material index.
     */
    BaseGeometryAsset.prototype.getMaxMaterialIndex = function (type) {
        if (type === void 0) { type = BaseGeometryAsset.primitiveType.TRIANGLES; }
        return this.maxMaterialIndices[type];
    };
    /**
     * Called by subclasses to register a THREE.Geometry or THREE.BufferGeometry with this asset. The
     * geometry can then be fetched with getGeometry().
     * @protected
     * @param {String} type One of the BaseGeometryAsset.primitiveType.
     * @param {THREE.Geometry|THREE.BufferGeometry} geometry The Three.js geometry.
     * @returns {void}
     */
    BaseGeometryAsset.prototype.setGeometry = function (type, geometry) {
        if (geometry) {
            BaseGeometryAsset.fixNegativeMaterialIndices(geometry);
            // FIXME: does dynamic exist as a property anymore? casting as any to allow
            geometry.dynamic = this.getProperty('dynamic') || false;
        }
        this.geometries[type] = geometry;
        this.maxMaterialIndices[type] = geometry ?
            BaseGeometryAsset.computeMaxMaterialIndex(geometry) : -1;
    };
    return BaseGeometryAsset;
}(BaseAsset_1.default));
/**
 * The available types of primitives to render.
 */
BaseGeometryAsset.primitiveType = {
    POINTS: 'points',
    LINES: 'lines',
    TRIANGLES: 'triangles'
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseGeometryAsset;


/***/ },
/* 28 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseAsset_1 = __webpack_require__(7);
var functions_1 = __webpack_require__(6);
var LoadingEvent_1 = __webpack_require__(12);
var LoadingType_1 = __webpack_require__(18);
var Schemas_1 = __webpack_require__(4);
/**
 * An asset that holds binary data.
 * @class BufferAsset
 */
var BufferAsset = (function (_super) {
    tslib_1.__extends(BufferAsset, _super);
    function BufferAsset() {
        var _this = _super.apply(this, arguments) || this;
        /**
         * The number of loaded bytes.
         * @protected
         * @type {number}
         */
        _this.loadedBytes = 0;
        /**
         * The associated array buffer.
         * @private
         * @type {ArrayBuffer}
         */
        _this.buffer = null;
        /**
         * A mapping of accessor keys to extracted typed arrays.
         * @private
         * @type {ObjectMap<TypedArray>}
         */
        _this.arrays = {};
        return _this;
    }
    /**
     * Returns the size (in bytes) of the specified component type.
     * @method getComponentTypeSize
     * @public
     * @param {String} componentType One of: 'int8', 'int16', 'int32', 'float16',
     * 'float32', 'float64'.
     * @returns {number} The byte size of the specified component type.
     */
    BufferAsset.getComponentTypeSize = function (componentType) {
        if (!BufferAsset.componentTypeSizes.hasOwnProperty(componentType)) {
            throw new Error('Unknown component type, ' + componentType);
        }
        return BufferAsset.componentTypeSizes[componentType];
    };
    /**
     * Returns the size (in components) of the specified type.
     * @method getTypeSize
     * @public
     * @param {String} type One of: 'scalar', 'vec2', 'vec3', 'vec4', 'mat2',
     * 'mat3', 'mat4'.
     * @returns {number} The size of the specified type.
     */
    BufferAsset.getTypeSize = function (type) {
        if (!BufferAsset.typeSizes.hasOwnProperty(type)) {
            throw new Error('Unknown attribute value type, ' + type);
        }
        return BufferAsset.typeSizes[type];
    };
    /** @inheritdoc */
    BufferAsset.prototype.unload = function () {
        this.buffer = null;
        this.arrays = {};
        _super.prototype.unload.call(this);
    };
    /**
     * Returns the accessor with the specified name.
     * @method getAccessor
     * @public
     * @param {String} The name of the accessor.
     * @returns {Object|undefined} The accessor with the specified name, if it
     * exists; otherwise, undefined.
     */
    BufferAsset.prototype.getAccessor = function (name) {
        var accessors = this.getProperty('accessors');
        return accessors[name];
    };
    /**
     * Returns the typed-array for the accessor with the specified name.
     * @method getArray
     * @public
     * @param {String} name The name of the accessor.
     * @returns {TypedArray|undefined} The typed-array with the specified name, if
     * it exists; otherwise, undefined.
     */
    BufferAsset.prototype.getArray = function (name) {
        return this.arrays[name];
    };
    /** @inheritdoc */
    BufferAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        var resource = this.loadResource(this.getProperty('src'), LoadingType_1.default.BUFFER, callback, { size: 1, priority: 1 });
        resource.on(LoadingEvent_1.default.PROGRESS, function (progressObj) {
            _this.loadedBytes = _this.getDataSizeDownload() * progressObj.loaded / progressObj.total;
            _this.trigger('loadProgress', _this);
        });
        resource.on(LoadingEvent_1.default.LOAD, function (data) {
            _this.buffer = data;
            _this.createArrays();
            _this.loadedBytes = _this.getDataSizeDownload();
        });
    };
    /** @inheritdoc */
    BufferAsset.prototype.getDataSizeDownloadSelf = function () {
        // Loop through each accessor and total up the size of the data.
        var accessors = this.getProperty('accessors');
        return Object.keys(accessors).map(function (name) {
            var acc = accessors[name];
            return BufferAsset.getComponentTypeSize(acc.componentType) *
                BufferAsset.getTypeSize(acc.type) * acc.count;
        }).reduce(function (total, size) {
            return size + total;
        }, 0);
    };
    /** @inheritdoc */
    BufferAsset.prototype.getDataSizeLoadedSelf = function () {
        return this.loadedBytes;
    };
    /**
     * Returns the typed-array constructor for the specified component type.
     * @method getArrayType
     * @private
     * @param {String} componentType One of: 'int8', 'uint8', 'int16', 'uint16',
     * 'int32', 'uint32', 'float32', 'float64'.
     * @returns {Function} The typed-array constructor.
     */
    BufferAsset.prototype.getArrayType = function (componentType) {
        if (!BufferAsset.arrayTypes.hasOwnProperty(componentType)) {
            throw new Error('Unknown component type, ' + componentType);
        }
        return BufferAsset.arrayTypes[componentType];
    };
    /**
     * Create a typed-array for the specified accessor.
     * @method createArray
     * @private
     * @param {Object} accessor The accessor to create a typed-array for.
     * @returns {TypedArray} The typed-array for the accessor.
     */
    BufferAsset.prototype.createArray = function (accessor) {
        var type = this.getArrayType(accessor.componentType);
        var typeSize = BufferAsset.getTypeSize(accessor.type);
        return new type(this.buffer, accessor.byteOffset, accessor.count * typeSize);
    };
    /**
     * Create a typed-array for each accessor.
     * @method createArrays
     * @private
     * @returns {void}
     */
    BufferAsset.prototype.createArrays = function () {
        var _this = this;
        var accessors = this.getProperty('accessors');
        this.arrays = functions_1.map(accessors, function (accessor) {
            return _this.createArray(accessor);
        });
    };
    return BufferAsset;
}(BaseAsset_1.default));
/**
 * Maps array types to typed-array constructors.
 */
BufferAsset.arrayTypes = {
    int8: Int8Array,
    uint8: Uint8Array,
    int16: Int16Array,
    uint16: Uint16Array,
    int32: Int32Array,
    uint32: Uint32Array,
    float32: Float32Array,
    float64: Float64Array
};
/**
 * Maps accessor types to sizes (number of components per value).
 */
BufferAsset.typeSizes = {
    scalar: 1,
    vec2: 2,
    vec3: 3,
    vec4: 4,
    mat2: 4,
    mat3: 9,
    mat4: 16
};
/**
 * Maps component types to sizes (number of bytes per component).
 */
BufferAsset.componentTypeSizes = {
    int8: 1,
    uint8: 1,
    int16: 2,
    uint16: 2,
    int32: 4,
    uint32: 4,
    float16: 2,
    float32: 4,
    float64: 8
};
Schemas_1.addSchemas('BufferAsset', BufferAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BufferAsset;


/***/ },
/* 29 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var BaseEntity_1 = __webpack_require__(11);
var BaseImageAsset_1 = __webpack_require__(10);
var LoadingEvent_1 = __webpack_require__(12);
var LoadingType_1 = __webpack_require__(18);
var Schemas_1 = __webpack_require__(4);
var compressionType = {
    DXT: 'dxt',
    DXT1: 'dxt1',
    DXT5: 'dxt5',
    JPEG: 'jpeg',
    ZIP: 'zip'
};
var defaultChannels = ['red', 'green', 'blue'];
var maxImageSize = 16384;
/**
 * Class that represents all static image data to be loaded by the engine.
 */
var ImageAsset = (function (_super) {
    tslib_1.__extends(ImageAsset, _super);
    function ImageAsset() {
        var _this = _super.apply(this, arguments) || this;
        /**
         * The current loading priority of this asset. Changes based on
         * streaming state and settings.
         */
        _this.loadPriority = 2;
        return _this;
    }
    /** @inheritdoc */
    ImageAsset.prototype.unload = function () {
        if (this.runtimeData) {
            this.engine.trigger('imageUnloaded', this.id);
            Logger_1.default.info(this.engine.getName() + ' - Unloading image, ' +
                this.getName());
            _super.prototype.unload.call(this);
        }
    };
    /**
     * Get the chosen image representation definition.
     * @returns {ImageRepresentationDef}
     */
    ImageAsset.prototype.getChosenRepresentation = function () {
        return this.chosenRepresentation;
    };
    /**
     * Returns true iff the loaded image is using hardware compression. If not loaded, returns true
     * iff the image as flagged to load a hardware compressed version.
     * @method isCompressed
     * @public
     * @return {Boolean} True iff the texture is using a hardware compression format.
     */
    ImageAsset.prototype.isCompressed = function () {
        if (this.runtimeData) {
            return this.runtimeData.compression !== 'jpeg' && this.runtimeData.compression !== 'zip';
        }
        return this.getProperty('useCompression');
    };
    /**
     * Returns the preferred texture compression format for the device.
     * @method getCompressionFormat
     * @public
     * @return {String} 'atc', 'dxt', 'pvrtc' (or, for non-hardware compressed formats, 'jpg' or 'zip')
     */
    ImageAsset.prototype.getCompressionFormat = function () {
        var compression = this.getFormat() === 'rgb' ? 'jpeg' : 'zip';
        // If a compressed format is preferred, get one based on the device caps.
        if (this.getProperty('useCompression')) {
            var renderer = this.engine.getThreeRenderer();
            var extensions = renderer.extensions;
            if (extensions.get('WEBGL_compressed_texture_s3tc')) {
                compression = 'dxt';
            }
            else if (extensions.get('WEBGL_compressed_texture_pvrtc')) {
                compression = 'pvrtc';
            }
        }
        return compression;
    };
    /** @inheritdoc */
    ImageAsset.prototype.getOriginalWidth = function () {
        return this.getProperty('width') || 0;
    };
    /** @inheritdoc */
    ImageAsset.prototype.getOriginalHeight = function () {
        return this.getProperty('height') || 0;
    };
    /** @inheritdoc */
    ImageAsset.prototype.getMaxRepresentationWidth = function () {
        var representations = this.get('representations');
        if (!representations) {
            return 0;
        }
        return representations.reduce(function (maxWidth, rep) {
            return rep.width > maxWidth ? rep.width : maxWidth;
        }, 0);
    };
    /** @inheritdoc */
    ImageAsset.prototype.getMaxRepresentationHeight = function () {
        var representations = this.get('representations');
        if (!representations) {
            return 0;
        }
        return representations.reduce(function (maxHeight, rep) {
            return rep.height > maxHeight ? rep.height : maxHeight;
        }, 0);
    };
    /** @inheritdoc */
    ImageAsset.prototype.getMaxTextureSize = function () {
        var renderer = this.engine.getRenderer();
        return renderer ? renderer.getMaxTextureSize2d() : _super.prototype.getMaxTextureSize.call(this);
    };
    /**
     * Given a compression type for a representation (e.g. 'jpeg', 'dxt', etc.),
     * return the response type that is expected (e.g. 'blob' or 'arraybuffer').
     * @method getImageResponseType
     * @public
     * @param {String} compression The compression type for the representation ('jpeg', 'dxt', etc.).
     * @returns {String} Either 'blob' or 'arraybuffer'.
     */
    ImageAsset.prototype.getImageResponseType = function (compression) {
        switch (compression) {
            case compressionType.DXT:
            case compressionType.DXT1:
            case compressionType.DXT5:
                return 'arraybuffer';
            default:
                return 'blob';
        }
    };
    /** @inheritdoc */
    ImageAsset.prototype.applyPropertiesUnloaded = function (_changes) {
        var imageParams = {
            maxSize: Math.max(this.getWidth(), this.getHeight()),
            compression: this.getCompressionFormat()
        };
        var rep = this.findRepresentation(imageParams);
        if (!rep) {
            throw new Error('No representation found for ' +
                (imageParams.maxSize + ":" + this.getCompressionFormat()));
        }
        this.chosenRepresentation = rep;
    };
    /** @inheritdoc */
    ImageAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        this.loadLowResImage(callback)
            .then(function () { return _this.loadHighResImage(callback); })
            .catch(this.onImageLoadError.bind(this));
    };
    /**
     * Loads the low resolution version of the image.
     * @method loadLowResImage
     * @private
     * @param {Function} callback A function which will be called on completion
     *                            regardless of success/failure.
     * @return {Promise} A promise which will resolve when the image finishes loading.
     */
    ImageAsset.prototype.loadLowResImage = function (callback) {
        var _this = this;
        this.loadPriority = 2;
        // This image is not to be streamed, so this promise is a NOOP.
        if (!this.getProperty('stream')) {
            return Promise.resolve();
        }
        // FIXME - The hardcoded maxSize should probably be replaced by a global (or per-image) value
        var textureParams = {
            maxSize: 64,
            compression: this.getCompressionFormat()
        };
        var rep = this.findRepresentation(textureParams);
        if (!rep) {
            // We don't have an acceptable low-res image for streaming so just return
            // and let the high res image load.
            return Promise.resolve();
        }
        // If this image is set to be streamed, load the low-res image first
        return new Promise(function (resolve, reject) {
            var resource = _this.loadResource(rep.src, LoadingType_1.default.IMAGE, callback, {
                priority: _this.loadPriority,
                responseType: _this.getImageResponseType(rep.compression),
                isExternal: rep.isExternal
            });
            resource.once(LoadingEvent_1.default.LOAD, function (data) {
                _this.onImageLoad(data, rep);
                _this.loadPriority = 8;
                resolve();
            });
            resource.once(LoadingEvent_1.default.CANCEL, function () {
                reject(new Error('Failed to load low res texture'));
            });
            resource.once(LoadingEvent_1.default.ERROR, reject);
        });
    };
    /**
     * Loads the high resolution version of the image. Typically called after the
     * low resolution version has already been loaded.
     * @method loadHighResImage
     * @private
     * @param {Function} callback A function which will be called on completion
     *                            regardless of success/failure.
     * @return {Promise} A promise which will resolve when the image finishes loading.
     */
    ImageAsset.prototype.loadHighResImage = function (callback) {
        var _this = this;
        if (this.isDestroyed()) {
            return;
        }
        // Now load the high-res version of the image.
        return new Promise(function (_resolve, reject) {
            var onImageLoadProgress = function (progressObj) {
                if (_this.isDestroyed()) {
                    return;
                }
                _this.loadedBytes = _this.getDataSizeDownload() * progressObj.loaded / progressObj.total;
                _this.trigger('loadProgress', _this);
            };
            _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.InProgress);
            var rep = _this.chosenRepresentation;
            var resource = _this.loadResource(rep.src, LoadingType_1.default.IMAGE, callback, {
                responseType: _this.getImageResponseType(rep.compression),
                isExternal: rep.isExternal,
                priority: _this.loadPriority
            });
            resource.once(LoadingEvent_1.default.PROGRESS, onImageLoadProgress);
            resource.once(LoadingEvent_1.default.LOAD, function (data) {
                _this.onImageLoad(data, rep);
            });
            resource.once(LoadingEvent_1.default.ERROR, reject);
        });
    };
    /**
     * Called when image is finished loading
     * @method onImageLoad
     * @private
     * @param  {Object} data Loaded data
     * @returns {void}
     */
    ImageAsset.prototype.onImageLoad = function (data, representation) {
        if (!this.runtimeData) {
            this.runtimeData = {};
        }
        this.runtimeData.compression = representation.compression;
        this.runtimeData.channels = representation.channels || defaultChannels;
        this.runtimeData.width = representation.width;
        this.runtimeData.height = representation.height;
        if (data instanceof ArrayBuffer || data instanceof Image) {
            this.runtimeData.imageData = data;
            this.loadedBytes = this.getDataSizeDownload();
            this.trigger('loadProgress', this);
        }
        else {
            throw new Error('Uknown container type for image data!');
        }
    };
    /**
     * Called when something unexpected happened during image load.
     * @method onImageLoadError
     * @private
     * @param  {Error} err Error object
     * @returns {void}
     */
    ImageAsset.prototype.onImageLoadError = function (err) {
        if (this.isDestroyed()) {
            return;
        }
        Logger_1.default.error('There was an error loading the image, ' + this.getName(), err);
        this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
        this.loadedBytes = this.getDataSizeDownload();
        this.trigger('loadProgress', this);
    };
    /**
     * Find the image representation that best matches the specified criteria.
     * @method findRepresentation
     * @private
     * @param {Object} options Loading options (@see XhrResourceLoader.prototype.load()).
     * @returns {Object} the representation that best matches the search criteria or null if none were
     * found.
     */
    ImageAsset.prototype.findRepresentation = function (options) {
        if (options === void 0) { options = {}; }
        var representations = this.get('representations');
        if (!representations || representations.length === 0) {
            return null;
        }
        var optionsEx = Object.assign({ maxSize: maxImageSize }, options);
        // Get closest match for compression param. Compression will either match exactly or fall back
        // to 'none'.
        var compressionMatches = representations.filter(function (image) {
            if (image.compression === optionsEx.compression) {
                return true;
            }
            switch (image.compression) {
                case compressionType.ZIP:
                case compressionType.JPEG:
                    return !optionsEx.compression;
                case compressionType.DXT:
                case compressionType.DXT1:
                case compressionType.DXT5:
                    return optionsEx.compression === compressionType.DXT;
                default:
            }
            return false;
        });
        // If no matches for the supplied compression exist, try to find the regular images (png or
        // jpg).
        if (compressionMatches.length === 0) {
            compressionMatches = representations.filter(function (image) {
                return image.compression === compressionType.ZIP ||
                    image.compression === compressionType.JPEG;
            });
        }
        var formatMatches = compressionMatches.filter(function (image) {
            var channels = image.channels || defaultChannels;
            return !optionsEx.channels || channels.toString() === optionsEx.channels.toString();
        });
        if (formatMatches.length === 0) {
            formatMatches = compressionMatches;
        }
        // For each match, compute the difference between its size and the max size.
        var sizeDiffs = formatMatches.map(function (image) {
            return optionsEx.maxSize - Math.max(image.width || 1, image.height || 1);
        });
        // Find the index of the minimum, *positive* “diff”. This is equivalent to the largest image
        // that is less than or equal to the max specified.
        var bestIdx = sizeDiffs.reduce(function (currentBestIdx, currentDiff, currentIdx) {
            var bestDiff = currentBestIdx >= 0 ? sizeDiffs[currentBestIdx] : Number.MAX_VALUE;
            return currentDiff >= 0 && currentDiff < bestDiff ? currentIdx : currentBestIdx;
        }, -1);
        // Locate the match.
        return bestIdx >= 0 ? formatMatches[bestIdx] : null;
    };
    return ImageAsset;
}(BaseImageAsset_1.default));
Schemas_1.addSchemas('ImageAsset', ImageAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ImageAsset;


/***/ },
/* 30 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseImageAsset_1 = __webpack_require__(10);
var LoadingType_1 = __webpack_require__(18);
var LoadingEvent_1 = __webpack_require__(12);
var Schemas_1 = __webpack_require__(4);
var MAX_VIDEO_HEIGHT = 1080;
/**
 * @class VideoAsset
 * @constructor
 */
var VideoAsset = (function (_super) {
    tslib_1.__extends(VideoAsset, _super);
    function VideoAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    VideoAsset.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.engine.on('update', this.onUpdate, this);
        this.on('pause', this.pause, this);
        this.on('play', this.play, this);
        this.on('stop', this.stop, this);
        this.on('toggle', this.toggle, this);
    };
    /** @inheritdoc */
    VideoAsset.prototype.uninitialize = function () {
        this.engine.off('update', this.onUpdate, this);
        this.off('pause', this.pause, this);
        this.off('play', this.play, this);
        this.off('stop', this.stop, this);
        this.off('toggle', this.toggle, this);
        if (this.runtimeData && this.runtimeData.image) {
            // TODO: should we be doing more here?
            this.runtimeData.image.pause();
        }
        _super.prototype.uninitialize.call(this);
    };
    /** @inheritdoc */
    VideoAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        var onVideoReady = function (videoEl) {
            if (videoEl) {
                videoEl.style.display = 'none';
                videoEl.loop = _this.getProperty('loop');
                videoEl.autoplay = _this.getProperty('autoPlay');
                if (!_this.runtimeData) {
                    _this.runtimeData = {};
                }
                _this.runtimeData.imageData = videoEl;
                _this.runtimeData.width = videoEl.width;
                _this.runtimeData.height = videoEl.height;
                _this.loadedBytes = _this.getDataSizeDownload();
                _this.trigger('loadProgress', _this);
            }
        };
        var parentEl = this.engine.getRenderer().getCanvas().parentElement;
        var cssSelector = this.getProperty('querySelector');
        if (cssSelector) {
            var videoEl = parentEl.querySelector(cssSelector);
            onVideoReady(videoEl);
            callback();
        }
        else {
            var rep = this.findRepresentation();
            if (rep) {
                var resource = this.loadResource(rep.src, LoadingType_1.default.VIDEO, callback);
                resource.on(LoadingEvent_1.default.PROGRESS, function (progressObj) {
                    _this.loadedBytes = _this.getDataSizeDownload() * progressObj.loaded / progressObj.total;
                    _this.trigger('loadProgress', _this);
                });
                resource.once(LoadingEvent_1.default.LOAD, function (data) {
                    parentEl.appendChild(data);
                    onVideoReady(data);
                });
            }
        }
    };
    /** @inheritdoc */
    VideoAsset.prototype.applyPropertiesUnloaded = function (_changes) {
        var rep = this.findRepresentation();
        // Don't need to check for existing representation here because it's okay to not have any.
        // The video might be coming from a video tag.
        this.chosenRepresentation = rep;
    };
    /** @inheritdoc */
    VideoAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (!this.runtimeData || !this.runtimeData.imageData) {
            return;
        }
        var videoEl = this.runtimeData.imageData;
        if (changes.hasOwnProperty('loop')) {
            videoEl.loop = this.getProperty('loop');
        }
        if (changes.hasOwnProperty('autoPlay')) {
            videoEl.autoplay = this.getProperty('autoPlay');
        }
    };
    /** @inheritdoc */
    VideoAsset.prototype.getMaxRepresentationWidth = function () {
        var representations = this.get('representations');
        if (!representations) {
            return 0;
        }
        return representations.reduce(function (maxWidth, rep) {
            return rep.video && rep.video.width > maxWidth ? rep.video.width : maxWidth;
        }, 0);
    };
    /** @inheritdoc */
    VideoAsset.prototype.getMaxRepresentationHeight = function () {
        var representations = this.get('representations');
        if (!representations) {
            return 0;
        }
        return representations.reduce(function (maxHeight, rep) {
            return rep.video && rep.video.height > maxHeight ? rep.video.height : maxHeight;
        }, 0);
    };
    VideoAsset.prototype.onUpdate = function () {
        if (this.runtimeData) {
            var videoEl = this.runtimeData.imageData;
            if (videoEl && !videoEl.paused && !videoEl.error &&
                videoEl.readyState >= videoEl.HAVE_CURRENT_DATA) {
                this.engine.needsRender = true;
            }
        }
    };
    VideoAsset.prototype.pause = function () {
        if (this.runtimeData) {
            this.runtimeData.image.pause();
        }
    };
    VideoAsset.prototype.play = function (seek, seekTime) {
        if (this.runtimeData) {
            if (seek) {
                this.runtimeData.imageData.currentTime = seekTime;
            }
            this.runtimeData.imageData.play();
        }
    };
    VideoAsset.prototype.stop = function () {
        if (this.runtimeData) {
            this.runtimeData.imageData.pause();
            this.runtimeData.imageData.currentTime = 0;
        }
    };
    VideoAsset.prototype.toggle = function () {
        if (this.runtimeData) {
            if (this.runtimeData.imageData.paused) {
                this.play();
            }
            else {
                this.pause();
            }
        }
    };
    /** @inheritdoc */
    VideoAsset.prototype.getOriginalWidth = function () {
        var streams = this.getProperty('streams') || [];
        return streams.reduce(function (max, stream) {
            return Math.max(stream.width || 0, max);
        }, 0);
    };
    /** @inheritdoc */
    VideoAsset.prototype.getOriginalHeight = function () {
        var streams = this.getProperty('streams') || [];
        return streams.reduce(function (max, stream) {
            return Math.max(stream.height || 0, max);
        }, 0);
    };
    /** @inheritdoc */
    VideoAsset.prototype.getMaxTextureSize = function () {
        var renderer = this.engine.getRenderer();
        return renderer ? renderer.getMaxTextureSize2d() : _super.prototype.getMaxTextureSize.call(this);
    };
    /**
     * Find the video representation that best matches the specified criteria.
     * @method findRepresentation
     * @private
     * @param {BaseAsset} asset The video asset.
     * @param {Object} options Loading options (@see XhrResourceLoader.prototype.load()).
     * @returns {Object} the representation that best matches the search criteria or null if none were
     * found.
     */
    VideoAsset.prototype.findRepresentation = function (options) {
        if (options === void 0) { options = {}; }
        var representations = this.get('representations');
        if (!representations || representations.length === 0) {
            return null;
        }
        var optionsEx = Object.assign({ maxHeight: MAX_VIDEO_HEIGHT }, options);
        // For each representation, compute the difference between its height and the max height.
        var sizeDiffs = representations.map(function (representation) {
            return optionsEx.maxHeight - (representation.video || {}).height || 0;
        });
        // Find the index of the minimum, *positive* “diff”. This is equivalent to the largest video
        // that is less than or equal to the max specified.
        var foundIdx = sizeDiffs.reduce(function (bestIdx, currentDiff, currentIdx) {
            var bestDiff = bestIdx >= 0 ? sizeDiffs[bestIdx] : Number.MAX_VALUE;
            return currentDiff >= 0 && currentDiff < bestDiff ? currentIdx : bestIdx;
        }, -1);
        // Locate the match.
        return foundIdx >= 0 ? representations[foundIdx] : null;
    };
    return VideoAsset;
}(BaseImageAsset_1.default));
VideoAsset.events = {
    pause: {
        params: [],
        action: true,
        category: ''
    },
    play: {
        params: [{
                name: 'seek',
                type: 'b',
                description: '',
                default: false
            }, {
                name: 'seekTime',
                type: 'f',
                description: '',
                default: 0
            }],
        action: true,
        category: ''
    },
    stop: {
        params: [],
        action: true,
        category: ''
    },
    toggle: {
        params: [],
        action: true,
        category: ''
    }
};
Schemas_1.addSchemas('VideoAsset', VideoAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = VideoAsset;


/***/ },
/* 31 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var LoadingEvent_1 = __webpack_require__(12);
/**
 * Configures an XMLHttpRequest object and adds it to a LoadableResource.
 * @function makeXhr
 * @param {Function} configureXhr     The function used to generate / configureXhr
 *                                    the XMLHttpRequest object, should return a
 *                                    promise to resolve with an XHR.
 * @param {LoadableResource} resource The loadable resource which contains the
 *                                    XMLHttpRequest object.
 * @return {Promise}                  Promise that will resolve with the same
 *                                    LoadableResource for purposes of continuation.
 */
exports.makeXhr = function (configureXhr) {
    return function (resource) {
        return configureXhr(resource.path, resource.params)
            .then(function (xhr) {
            resource.loaderData.xhr = xhr;
            return Promise.resolve(resource);
        });
    };
};
/**
 * Loads an XMLHttpRequest object.
 * @function loadXhr
 * @param {LoadableResource} resource The loadable resource which contains the
 *                                    XMLHttpRequest object.
 * @return {Promise}                  Promise that will resolve with the
 *                                    same LoadableResource for purposes of
 *                                    continuation.
 */
exports.loadXhr = function (resource) {
    return new Promise(function (resolve, reject) {
        resource.setLoading();
        var getContentLength = function (xhr) {
            return parseInt(xhr.getResponseHeader('Content-Length'), 10);
        };
        var getLoadStatus = function (ev) {
            return {
                total: (ev.lengthComputable && ev.target) ? getContentLength(ev.target) : 0,
                loaded: ev.loaded
            };
        };
        var cancel = function () {
            resource.loaderData.xhr.abort();
            resolve(resource);
            resource.off(LoadingEvent_1.default.CANCEL, cancel);
        };
        var complete = function () {
            resource.off(LoadingEvent_1.default.CANCEL, cancel);
            resolve(resource);
        };
        var error = function (err) {
            resource.off(LoadingEvent_1.default.CANCEL, cancel);
            reject(err);
        };
        resource.on(LoadingEvent_1.default.CANCEL, cancel);
        resource.loaderData.xhr.send();
        resource.loaderData.xhr.addEventListener('load', complete);
        resource.loaderData.xhr.addEventListener('error', error);
        resource.loaderData.xhr.addEventListener('progress', function (ev) {
            return resource.trigger(LoadingEvent_1.default.PROGRESS, getLoadStatus(ev));
        });
    });
};
/**
 * Uses predicate function to determine whether the status code constitutes
 * success or failure.
 * @function requireStatus
 * @param {Function} predicate A function which takes a status code and
 *                             returns a Boolean.
 * @param {Resource} resource  A LoadableResource instance.
 * @return {Promise}           Promise that will resolve with the same
 *                             LoadableResource for purposes of continuation.
 */
exports.requireStatus = function (predicate) {
    return function (resource) {
        return predicate(resource.loaderData.xhr.status) ?
            Promise.resolve(resource) :
            Promise.reject(new Error("Failed to load: " + resource.path + " status: " + resource.loaderData.xhr.status));
    };
};
/**
 * Sets the repsonseType on the XMLHttpRequest object.
 * @function setResponseType
 * @param {String}           defaultType A default type to use in the situation which one
 * @param {LoadableResource} resource A LoadableResource instance.
 * @return {Function}        Promise that will resolve with the same
 *                           LoadableResource for purposes of continuation.
 */
exports.setResponseType = function (defaultType) { return function (resource) {
    resource.loaderData.xhr.responseType = resource.params.responseType || defaultType;
    return Promise.resolve(resource);
}; };
/**
 * Handles an error condition by setting the LoadableResource error and then
 * returning the error down the promise chain.
 * @function handleError
 * @param {LoadableResource} resource A LoadableResource instance.
 * @param {Error} err                 An Error object.
 * @return {Promise}                  Promise that will resolve with the same
 *                                    LoadableResource for purposes of continuation.
 */
exports.handleError = function (resource) { return function (err) {
    resource.setError(err);
    return Promise.reject(err);
}; };
/**
 * A wrapper for a promise which first checks if the LoadableResource was
 * cancelled before executing the wrapped promise. In the case where the
 * LoadableResource was cancelled, the continuation will continue with the next
 * Promise in the chain.
 * @function unlessCancelled
 * @param {Promise} promise            The Promise to wrap.
 * @param {LoadableResource} resource  A LoadableResource object.
 * @return {Promise}                   Promise that will resolve with the same
 *                                     LoadableResource for purposes of
 *                                     continuation.
 */
exports.unlessCancelled = function (promise) { return function (resource) {
    return resource.isCancelled() ? Promise.resolve(resource) : promise(resource);
}; };


/***/ },
/* 32 */
/***/ function(module, exports) {

"use strict";
"use strict";
var baseEntity = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'baseEntity',
    title: 'BaseEntityDef',
    type: 'object',
    description: 'Base hierarchical type for assets and objects.',
    properties: {
        type: {
            type: 'string',
            description: 'The entity\'s type.'
        },
        sid: {
            type: 'string',
            description: 'The entity\'s scoped ID.'
        },
        id: {
            type: 'string',
            description: 'The entity\'s unique ID.'
        },
        properties: {
            $ref: 'baseEntityProperties.json'
        },
        previousProperties: {
            $ref: 'baseEntityProperties.json'
        },
        components: {
            type: 'array',
            items: {
                $ref: 'component.json'
            },
            default: []
        },
        previousComponents: {
            type: 'array',
            items: {
                $ref: 'component.json'
            },
            default: []
        }
    },
    additionalProperties: false,
    required: ['id']
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseEntity;


/***/ },
/* 33 */
/***/ function(module, exports) {

"use strict";
"use strict";
var baseEntityProperties = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'baseEntityProperties',
    title: 'BaseEntityPropertiesDef',
    type: 'object',
    description: 'Holds type-specific properties.',
    properties: {
        name: {
            type: 'string',
            description: 'The entity\'s name.',
            default: 'unnamed'
        }
    },
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseEntityProperties;


/***/ },
/* 34 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var baseGeometryAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'baseGeometryAsset', title: 'BaseGeometryAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { properties: {
            $ref: 'baseGeometryAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseGeometryAsset;


/***/ },
/* 35 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var baseGeometryAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'baseGeometryAssetProperties', title: 'BaseGeometryAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { bounds: {
            description: 'The bounds of the geometry.',
            $ref: 'box3.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseGeometryAssetProperties;


/***/ },
/* 36 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseTextureAsset_1 = __webpack_require__(22);
var baseRenderTextureAsset = tslib_1.__assign({}, baseTextureAsset_1.default, { id: 'baseRenderTextureAsset', title: 'BaseRenderTextureAssetDef', properties: tslib_1.__assign({}, baseTextureAsset_1.default.properties, { properties: {
            $ref: 'baseRenderTextureAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseRenderTextureAsset;


/***/ },
/* 37 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseTextureAssetProperties_1 = __webpack_require__(19);
var baseRenderTextureAssetProperties = tslib_1.__assign({}, baseTextureAssetProperties_1.default, { id: 'baseRenderTextureAssetProperties', title: 'BaseRenderTextureAssetPropertiesDef', properties: tslib_1.__assign({}, baseTextureAssetProperties_1.default.properties, { stencilBuffer: {
            type: 'boolean',
            default: false
        }, depthBuffer: {
            type: 'boolean',
            default: false
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseRenderTextureAssetProperties;


/***/ },
/* 38 */
/***/ function(module, exports) {

"use strict";
"use strict";
var representation = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'representation',
    title: 'RepresentationDef',
    type: 'object',
    properties: {
        src: {
            type: 'string'
        },
        contentLength: {
            type: 'number'
        }
    },
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = representation;


/***/ },
/* 39 */
/***/ function(module, exports) {

"use strict";
"use strict";
/* tslint:disable no-invalid-this */
/**
 * Copy properties of source object to target object excluding constructor.
 * If a property with the same exists on the target it is NOT overwritten.
 *
 * @param target
 * @param source
 */
function extend(target, source) {
    Object.getOwnPropertyNames(source).forEach(function (name) {
        if (name !== 'constructor' && !target.hasOwnProperty(name)) {
            Object.defineProperty(target, name, Object.getOwnPropertyDescriptor(source, name));
        }
    });
}
/**
 * Create a constructor function for a class implementing the given mixins.
 *
 * @param defaultOptions options that will be used if some options are missing at construction time
 * @param mixins array of classes to be mixed together. The constructor of those classes will receive the options given
 *               to the constructor of the composed object
 * @returns {{new(any): {}}} a constructor function
 */
function classComposer(defaultOptions, mixins) {
    // our constructor function that will be called every time a new composed object is created
    var ctor = function (options) {
        var _this = this;
        var o = {};
        // clone options given to the constructor
        if (options) {
            extend(o, options);
        }
        // complete with the defaultOptions
        if (defaultOptions) {
            extend(o, defaultOptions);
        }
        // call the constructor function of all the mixins
        mixins.forEach(function (mixin) {
            mixin.call(_this, o);
        });
    };
    // add all mixins properties and methods to the constructor prototype for all
    // created objects to have them
    mixins.forEach(function (mixin) {
        extend(ctor.prototype, mixin.prototype);
    });
    return ctor;
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = classComposer;


/***/ },
/* 40 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var RuntimeEvents_1 = __webpack_require__(21);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = new RuntimeEvents_1.default();


/***/ },
/* 41 */
/***/ function(module, exports) {

module.exports = function(it){
  return typeof it === 'object' ? it !== null : typeof it === 'function';
};

/***/ },
/* 42 */
/***/ function(module, exports) {

var g;

// This works in non-strict mode
g = (function() { return this; })();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1,eval)("this");
} catch(e) {
	// This works if the window reference is available
	if(typeof window === "object")
		g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;


/***/ },
/* 43 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseTextureAsset_1 = __webpack_require__(20);
var ImageAsset_1 = __webpack_require__(29);
var BaseImageAsset_1 = __webpack_require__(10);
/**
 * An asset that holds geometry.
 * @class BaseRenderTextureAsset
 * @constructor
 */
var BaseRenderTextureAsset = (function (_super) {
    tslib_1.__extends(BaseRenderTextureAsset, _super);
    function BaseRenderTextureAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.createRuntimeData = function (callback) {
        this.createRTImageData();
        this.trigger('loadProgress', this); // TODO: do we need this?
        callback();
    };
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.getLayout = function () {
        return this.getProperty('layout');
    };
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.getWidth = function () {
        return this.getProperty('width');
    };
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.getHeight = function () {
        return this.getProperty('height');
    };
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.getMipCount = function () {
        return ImageAsset_1.default.prototype.getMipCount.call(this);
    };
    /** @inheritdoc */
    BaseRenderTextureAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        // If something changed that necessitates the texture being recreated, do so.
        if (changes.hasOwnProperty('format') ||
            changes.hasOwnProperty('type') ||
            changes.hasOwnProperty('width') ||
            changes.hasOwnProperty('height')) {
            if (this.runtimeData.__webglFramebuffer) {
                this.runtimeData.dispose();
                delete this.runtimeData.__webglFramebuffer;
            }
            this.runtimeData.texture.format = BaseImageAsset_1.default.getThreeImageFormat(this.getProperty('format'));
            this.runtimeData.texture.type = BaseImageAsset_1.default.getThreeImageType(this.getDataType());
            this.runtimeData.texture.height = this.getHeight();
            this.runtimeData.texture.width = this.getWidth();
        }
        this.runtimeData.texture.encoding = BaseImageAsset_1.default.getThreeImageEncoding(this.getProperty('encoding'));
    };
    return BaseRenderTextureAsset;
}(BaseTextureAsset_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BaseRenderTextureAsset;


/***/ },
/* 44 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(7);
var Box3DShaderPBR_1 = __webpack_require__(194);
var functions_1 = __webpack_require__(6);
var Schemas_1 = __webpack_require__(4);
var ShaderAsset = (function (_super) {
    tslib_1.__extends(ShaderAsset, _super);
    function ShaderAsset() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * Return a list of all parameters that are dependent on the specified one.
     * @param paramName The name of the dependency to check for.
     * @returns         An array of parameters that are dependent on the
     *                  given one.
     */
    ShaderAsset.prototype.getDependentParameters = function (paramName) {
        if (this.paramDependencyMap[paramName]) {
            return this.paramDependencyMap[paramName];
        }
    };
    /**
     * Get a list of all parameters that the given parameter is dependent on.
     * @param paramName The name of the parameter to get dependencies for.
     * @returns         An array of parameter names.
     */
    ShaderAsset.prototype.getParameterDependencies = function (paramName) {
        /**
         * Gets a list of dependency names for a logical and condition.
         * @param conditions  The shader conditions object.
         * @param deps        A reference to the current array of dependencies.
         * @returns           An array of dependent parameter names.
         */
        function getLogicalAndDependencies(conditions, deps) {
            if (deps === void 0) { deps = []; }
            var dependencies = deps;
            functions_1.forEach(conditions, function (cond, key) {
                if (key === 'or') {
                    dependencies = getLogicalOrDependencies(cond, dependencies);
                }
                else if (dependencies.indexOf(key) === -1) {
                    dependencies = dependencies.concat([key]);
                }
            });
            return dependencies;
        }
        /**
         * Gets a list of dependency names for a logical or condition.
         * @param conditions  An array of shader conditions objects.
         * @param deps        A reference to the current array of dependencies.
         * @returns           An array of dependent parameter names.
         */
        function getLogicalOrDependencies(conditions, deps) {
            if (deps === void 0) { deps = []; }
            var dependencies = deps;
            functions_1.forEach(conditions, function (cond) {
                dependencies = getLogicalAndDependencies(cond, dependencies);
            });
            return dependencies;
        }
        var parameters = this.getProperty('parameters');
        if (parameters[paramName] && parameters[paramName].enabledWhen) {
            return getLogicalAndDependencies(parameters[paramName].enabledWhen, []);
        }
        else {
            return [];
        }
    };
    /** @inheritdoc */
    ShaderAsset.prototype.createRuntimeData = function (callback) {
        this.runtimeData = {};
        this.runtimeData.vertexShader = this.getProperty('vertexShader');
        this.runtimeData.fragmentShader = this.getProperty('fragmentShader');
        this.filterUnusedParameters();
        this.buildUniformList();
        this.buildRenderParamList();
        callback();
    };
    /** @inheritdoc */
    ShaderAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        this.buildParamDependencies();
    };
    /**
     * Filter out the parameters that may be in the list but not actually referenced by
     * the features list.
     */
    ShaderAsset.prototype.filterUnusedParameters = function () {
        var parameters = this.getProperty('parameters');
        var features = this.getProperty('features');
        var newParameters = {};
        Object.keys(parameters).forEach(function (key) {
            var found = Object.keys(features).some(function (featureName) {
                return features[featureName].parameters.indexOf(key) !== -1;
            });
            if (found) {
                newParameters[key] = parameters[key];
            }
        });
        this.setProperty('parameters', newParameters);
    };
    /**
     * Builds the uniform list runtime data.
     */
    ShaderAsset.prototype.buildUniformList = function () {
        var _this = this;
        var parameters = this.getProperty('parameters');
        var uniforms = this.getProperty('uniforms');
        var uniform;
        this.runtimeData.uniforms = THREE.UniformsUtils.clone(uniforms);
        functions_1.forEach(parameters, function (param, paramName) {
            uniform = {};
            if (!param || param.isRenderParam || !param.isUniform) {
                return;
            }
            switch (param.type) {
                case 'opt':
                    uniform.type = 'i';
                    uniform.value = param.default;
                    break;
                case 'b':
                    uniform.type = 'i';
                    uniform.value = param.default ? 1 : 0;
                    break;
                case 't':
                    uniform.type = 't';
                    uniform.value = param.default;
                    break;
                case 'c':
                    uniform.type = param.type;
                    uniform.value = new THREE.Color(param.default);
                    uniform.value.copyGammaToLinear(uniform.value);
                    break;
                case 'v2':
                    uniform.type = param.type;
                    uniform.value = new THREE.Vector2();
                    uniform.value.set(param.default.x, param.default.y);
                    break;
                case 'v3':
                    uniform.type = param.type;
                    uniform.value = new THREE.Vector3();
                    uniform.value.set(param.default.x, param.default.y, param.default.z);
                    break;
                case 'v4':
                    uniform.type = param.type;
                    uniform.value = new THREE.Vector4();
                    uniform.value.set(param.default.x, param.default.y, param.default.z, param.default.w);
                    break;
                default:
                    uniform.type = param.type;
                    uniform.value = param.default;
            }
            var uniformName = param.uniformName || paramName;
            _this.runtimeData.uniforms[uniformName] = uniform;
        });
    };
    /**
     * Builds the render parameter list runtime data.
     */
    ShaderAsset.prototype.buildRenderParamList = function () {
        var _this = this;
        var parameters = this.getProperty('parameters');
        var renderParams = this.getProperty('renderParams');
        this.runtimeData.renderParams = renderParams || {};
        functions_1.forEach(parameters, function (param, paramName) {
            if (!param || param.isUniform || !param.isRenderParam) {
                return;
            }
            switch (param.type) {
                case 'b':
                    _this.runtimeData.renderParams[paramName] = !!param.default;
                    break;
                default:
                    _this.runtimeData.renderParams[paramName] = param.default;
            }
        });
    };
    /**
     * Build a mapping from a parameter name to a list of all parameters
     * that are dependent on it.
     */
    ShaderAsset.prototype.buildParamDependencies = function () {
        var _this = this;
        var parameters = this.getProperty('parameters');
        this.paramDependencyMap = {};
        functions_1.forEach(parameters, function (_param, name) {
            // Add this param to the list for each dependency that it has.
            var deps = _this.getParameterDependencies(name);
            functions_1.forEach(deps, function (paramName) {
                if (!_this.paramDependencyMap[paramName]) {
                    _this.paramDependencyMap[paramName] = [];
                }
                if (_this.paramDependencyMap[paramName].indexOf(name) === -1) {
                    _this.paramDependencyMap[paramName].push(name);
                }
            });
            // Make sure that there is at least an empty array for each param.
            if (!_this.paramDependencyMap[name]) {
                _this.paramDependencyMap[name] = [];
            }
        });
    };
    return ShaderAsset;
}(BaseAsset_1.default));
/**
 * A mapping of string to entity descriptors for built in shaders.
 */
ShaderAsset.builtInAssetDescriptors = {
    PBR: Box3DShaderPBR_1.default
};
Schemas_1.addSchemas('ShaderAsset', ShaderAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ShaderAsset;


/***/ },
/* 45 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @class RenderView
 * @vid render_view_component
 * @vname Render View
 * @vfilter camera
 * @vcategory Rendering
 */
var RenderView = (function (_super) {
    tslib_1.__extends(RenderView, _super);
    function RenderView() {
        var _this = _super.apply(this, arguments) || this;
        // tslint:disable max-line-length */
        /**
         * Run pre-render functions with this view. These include things like real-time reflections,
         * which need to be rendered for each view separately.
         * @vattr Boolean enablePreRenderFunctions {
         *   description: 'Run pre-render functions with this view. These include things like real-time reflections, which need to be rendered for each view separately.',
         *   default : true,
         *   advanced: true
         * }
         */
        // tslint:enable max-line-length */
        _this.enablePreRenderFunctions = true;
        /**
         * Render shadows for this view.
         * @vattr Boolean enableShadows {
         *   description: 'Render shadows for this view.',
         *   default : true,
         *   advanced: true
         * }
         */
        _this.enableShadows = true;
        /**
         * The render event name to listen to.
         */
        _this.renderEventName = 'render';
        /**
         * The opacity value to use while rendering.
         */
        _this.opacity = 1.0;
        /**
         * The current render context if overridden.
         */
        _this.currentRenderContext = _this;
        return _this;
    }
    /** @inheritdoc */
    RenderView.prototype.onStartup = function () {
        var _this = this;
        var renderEvent = parseInt(String(this.renderGroup), 10);
        if (renderEvent) {
            this.renderEventName += 'Group' + renderEvent;
        }
        this.getEngine().on(this.renderEventName, this.renderView, this);
        this.getEngine().on('resize', this.resize, this);
        this.getEntity().when('loadBase', function () {
            _this.resize();
        });
        this.listenTo(this.getEntity(), 'enableRenderView', this.enableRenderView);
        this.listenTo(this.getEntity(), 'disableRenderView', this.disableRenderView);
        this.listenTo(this.getEntity(), 'toggleRenderView', this.toggleRenderView);
        this.listenTo(this.getEntity(), 'setViewport', this.setViewport);
    };
    /** @inheritdoc */
    RenderView.prototype.onShutdown = function () {
        this.getEngine().off(this.renderEventName, this.renderView, this);
        this.getEngine().off('resize', this.resize, this);
        this.stopListening();
    };
    /**
     * Overrides the default render function and render context.
     * @param fn      The render function to override with.
     * @param context The context to use.
     */
    RenderView.prototype.setRenderOverride = function (fn, context) {
        // Unbind existing render function
        if (this.renderViewOverride) {
            this.getEngine().off(this.renderEventName, this.renderViewOverride, this.currentRenderContext);
        }
        else {
            this.getEngine().off(this.renderEventName, this.renderView, this);
        }
        // Bind new render function
        if (fn) {
            this.getEngine().on(this.renderEventName, fn, context);
            this.currentRenderContext = context;
            this.renderViewOverride = fn;
        }
        else {
            this.getEngine().on(this.renderEventName, this.renderView, this);
            this.renderViewOverride = null;
        }
    };
    /**
     * Sets the render effect.
     * @param effect The three.js effect to apply
     */
    RenderView.prototype.setEffect = function (effect) {
        this.effect = effect;
    };
    /** @inheritDoc */
    RenderView.prototype.onEnable = function () {
        if (this.renderTarget && this.renderTarget.isUnloaded()) {
            this.renderTarget.load();
        }
    };
    /**
     * The default renderView implementation. Can be overridden via setRenderOverride().
     * @param delta The current frame delta.
     */
    RenderView.prototype.renderView = function (delta) {
        if (!this.isEnabled() || !this.hasRuntimeData()) {
            return;
        }
        var scene = this.getRootObject();
        if (!scene.runtimeData) {
            return;
        }
        // Adjust the opacity of this render view over time for fade effects
        if (this.fadeInTime) {
            this.getEngine().needsRender = true;
            this.opacityTime += delta;
            this.opacity = this.opacityTime * this.opacityTime / this.fadeInTime;
            if (this.opacity > 1.0) {
                this.opacity = 1.0;
                this.fadeInTime = 0.0;
                this.opacityTime = 0.0;
            }
        }
        else if (this.fadeOutTime) {
            this.getEngine().needsRender = true;
            if (this.opacityTime === -1.0) {
                this.disable();
                this.opacity = 0;
                this.fadeOutTime = 0.0;
                this.opacityTime = 0.0;
                this.disable();
            }
            else {
                this.opacityTime -= delta;
                if (this.opacityTime <= 0.0) {
                    this.opacity = 0.0001;
                    this.opacityTime = -1.0;
                }
                else {
                    this.opacity = this.opacityTime / this.fadeOutTime;
                }
            }
        }
        // Animate the size of the viewport over time
        if (this.animationTotalTime > 0) {
            this.getEngine().needsRender = true;
            this.animationTime += delta;
            var animationProgress = this.animationTime / this.animationTotalTime;
            if (animationProgress >= 1.0) {
                this.animationTotalTime = 0;
                animationProgress = 1.0;
            }
            this.x = (1.0 - animationProgress) * this.oldX + animationProgress * this.targetX;
            this.y = (1.0 - animationProgress) * this.oldY + animationProgress * this.targetY;
            this.width = (1.0 - animationProgress) * this.oldWidth +
                animationProgress * this.targetWidth;
            this.height = (1.0 - animationProgress) * this.oldHeight +
                animationProgress * this.targetHeight;
            this.updateCameraProjection();
        }
        // Render the view
        this.getRuntimeData().layers.set(this.renderLayer);
        this.getRenderer().renderView(scene.runtimeData, this.getRuntimeData(), {
            viewPort: {
                x: this.x,
                y: this.y,
                width: this.width,
                height: this.height
            },
            enablePreRenderFunctions: this.enablePreRenderFunctions,
            enableShadows: this.enableShadows,
            clearColor: this.clearColor,
            clearDepth: this.clearDepth,
            delta: delta,
            opacity: this.opacity,
            renderTarget: this.renderTarget,
            effect: this.effect
        });
    };
    /**
     * Sets the viewport, handled on event trigger. See @vevent descriptor below.
     * @param x             The x position.
     * @param y             The y position.
     * @param width         The width.
     * @param height        The height.
     * @param animationTime The amount of time to animate the change in viewport.
     */
    RenderView.prototype.setViewport = function (x, y, width, height, animationTime) {
        this.viewportLeft = x.toString();
        this.viewportBottom = y.toString();
        this.viewportWidth = width.toString();
        this.viewportHeight = height.toString();
        if (!animationTime) {
            this.resize();
            this.animationTotalTime = 0;
        }
        else {
            this.animationTotalTime = animationTime;
            this.animationTime = 0;
            this.oldX = this.x;
            this.oldY = this.y;
            this.oldWidth = this.width;
            this.oldHeight = this.height;
            this.updateViewport();
            this.targetX = this.x;
            this.targetY = this.y;
            this.targetWidth = this.width;
            this.targetHeight = this.height;
            this.x = this.oldX;
            this.y = this.oldY;
            this.width = this.oldWidth;
            this.height = this.oldHeight;
        }
    };
    /** Updates the viewport */
    RenderView.prototype.updateViewport = function () {
        var cWidth = this.getEngine().getRenderer().getWidth();
        var cHeight = this.getEngine().getRenderer().getHeight();
        var percent;
        if (this.viewportBottom.slice(-1) === '%') {
            percent = parseFloat(this.viewportBottom.slice(0, -1)) * 0.01;
            this.y = percent * cHeight;
        }
        else {
            this.y = parseInt(this.viewportBottom, 10);
        }
        if (this.viewportLeft.slice(-1) === '%') {
            percent = parseFloat(this.viewportLeft.slice(0, -1)) * 0.01;
            this.x = percent * cWidth;
        }
        else {
            this.x = parseInt(this.viewportLeft, 10);
        }
        if (this.viewportWidth.slice(-1) === '%') {
            percent = parseFloat(this.viewportWidth.slice(0, -1)) * 0.01;
            this.width = percent * cWidth;
        }
        else {
            this.width = parseInt(this.viewportWidth, 10);
        }
        this.width = Math.min(this.width, cWidth - this.x);
        if (this.viewportHeight.slice(-1) === '%') {
            percent = parseFloat(this.viewportHeight.slice(0, -1)) * 0.01;
            this.height = percent * cHeight;
        }
        else {
            this.height = parseInt(this.viewportHeight, 10);
        }
        this.height = Math.min(this.height, cHeight - this.y);
        if (this.x < 0) {
            this.x += cWidth;
        }
        if (this.y < 0) {
            this.y += cHeight;
        }
    };
    /**
     * Handles the enable render view event (see @vevent enableRenderView).
     * @param fade How long to fade the render view in. By default, the
     * view will immediately be visible.
     */
    RenderView.prototype.enableRenderView = function (fade) {
        this.enable();
        if (fade) {
            this.fadeOutTime = 0.0;
            this.fadeInTime = fade;
            this.opacityTime = 0.0;
            this.opacity = 0.0;
        }
        else {
            this.opacity = 1.0;
        }
    };
    /**
     * Handles the disable render view event (see @vevent disableRenderView).
     * @param fade How long to fade the render view out. By default, the
     * view will immediately be hidden.
     */
    RenderView.prototype.disableRenderView = function (fade) {
        if (fade) {
            this.fadeInTime = 0.0;
            this.opacityTime = fade;
            this.fadeOutTime = fade;
            this.opacity = 1.0;
        }
        else {
            this.disable();
            this.opacity = 0.0;
        }
    };
    /**
     * Handles the toggle render view event (see @vevent toggleRenderView).
     * @param fade How long to fade the render view in/out. By default, the
     * view will immediately be toggled.
     */
    RenderView.prototype.toggleRenderView = function (fade) {
        if (this.isEnabled()) {
            this.disableRenderView(fade);
        }
        else {
            this.enableRenderView(fade);
        }
    };
    /** Updates the camera projection matrix. */
    RenderView.prototype.updateCameraProjection = function () {
        var camera = this.getRuntimeData();
        var aspect;
        if (camera) {
            aspect = this.width / this.height;
            if (camera instanceof THREE.PerspectiveCamera) {
                camera.aspect = aspect;
            }
            else {
                camera.left = camera.bottom * aspect;
                camera.right = camera.top * aspect;
            }
            camera.updateProjectionMatrix();
        }
    };
    /** Handles the resize event. */
    RenderView.prototype.resize = function () {
        this.updateViewport();
        this.updateCameraProjection();
    };
    return RenderView;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Event definitions:
 *
 * @vevent local enableRenderView {
 *   'category': 'Rendering',
 *   'parameters': [{'name': 'fade', 'type': 'f', 'description': 'Defined in seconds',
 *   'default': 0.0}]
 * }
 *
 * @vevent local setViewport {
 *   'category': 'Rendering',
 *   'parameters': [
 *     {'name': 'viewportLeft', 'description': 'Left position of the viewport to be rendered by this camera.',
 *        'type': 's', 'default' : '0px' },
 *     {'name': 'viewportBottom', 'description': 'Bottom position of the viewport to be rendered by this camera.',
 *        'type': 's', 'default' : '0px' },
 *     {'name': 'viewportWidth', 'description': 'Width of the viewport to be rendered by this camera.',
 *        'type': 's', 'default' : '100%' },
 *     {'name': 'viewportHeight', 'description': 'Height of the viewport to be rendered by this camera.',
 *        'type': 's', 'default' : '100%' },
 *     {'name': 'animationTime', 'type': 'f', 'description': 'Animate the change in viewport over this many seconds.',
 *        'default': 0.0}
 *   ]
 * }
 *
 * @vevent local disableRenderView {
 *   'category': 'Rendering',
 *   'parameters': [{'name': 'fade', 'type': 'f', 'description': 'Defined in seconds', 'default': 0.0}]
 * }
 *
 * @vevent local toggleRenderView {
 *   'category': 'Rendering',
 *   'parameters': [{'name': 'fade', 'type': 'f', 'description': 'Defined in seconds', 'default': 0.0}]
 * }
 */
exports.default = RenderView;


/***/ },
/* 46 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var Handedness;
(function (Handedness) {
    Handedness[Handedness["LeftOrRight"] = 0] = "LeftOrRight";
    Handedness[Handedness["Left"] = 1] = "Left";
    Handedness[Handedness["Right"] = 2] = "Right";
    Handedness[Handedness["Any"] = 3] = "Any";
    Handedness[Handedness["None"] = 4] = "None";
})(Handedness = exports.Handedness || (exports.Handedness = {}));
/**
 * @vid vr_hand_controller
 * @vname VR Hand Controller
 * @vfilter object
 * @vcategory Input
 */
var VrHandController = (function (_super) {
    tslib_1.__extends(VrHandController, _super);
    function VrHandController() {
        var _this = _super.apply(this, arguments) || this;
        /**
         * The preference for the handedness of this controller.
         * @vattr integer handPreference { 'default': 0 }
         */
        _this.handPreference = Handedness.LeftOrRight;
        /** Internal value for to store standing matrix from device */
        _this.standingMatrix = new THREE.Matrix4();
        /**
         * The scale of the scene FIXME: this should be set via some global scale value so that all
         * VR can abide by it.
         */
        _this.scale = 1.0;
        /** Internal boolean for tracking when a matching gamepad has been found for the first time. */
        _this.foundGamepadOnce = false;
        return _this;
    }
    /**
     * Return the gamepad that matches the settings on this component.
     * @returns The found gamepad, if any.
     */
    VrHandController.prototype.getGamepad = function () {
        var engine = this.getEngine();
        var vrDisplay = engine.getVrDisplay();
        return this.findGamepad(vrDisplay ? vrDisplay.displayId : undefined);
    };
    /**
     * Call the provided callback
     * @param callback Function to call when the first controller is found that
     * can be used by this component.
     */
    VrHandController.prototype.whenControllerFound = function (callback) {
        if (this.foundGamepadOnce) {
            callback(this.findGamepad());
            return;
        }
        this.listenToOnce(this, 'foundFirstController', callback);
    };
    /** @inheritDoc */
    VrHandController.prototype.onShutdown = function () {
        var _this = this;
        // Mark any gamepad in use by this component as available.
        var idx = VrHandController.assignedControllers.findIndex(function (controller) { return controller === _this; });
        if (idx > -1) {
            VrHandController.assignedControllers[idx] = null;
        }
    };
    /** @inheritDoc */
    VrHandController.prototype.onPreUpdate = function (_delta) {
        if (!this.isEnabled()) {
            return;
        }
        var engine = this.getEngine();
        var vrDisplay = engine.getVrDisplay();
        if (!vrDisplay) {
            return;
        }
        var gamepad = this.findGamepad(vrDisplay.displayId);
        if (gamepad && gamepad.pose) {
            if (!this.foundGamepadOnce) {
                this.foundGamepadOnce = true;
                this.trigger('foundFirstController', gamepad);
            }
            var pose = gamepad.pose;
            var object = this.getRuntimeData();
            var entity = this.getEntity();
            if (pose.position) {
                entity.setPosition(pose.position[0], pose.position[1], pose.position[2]);
            }
            if (pose.orientation) {
                entity.setQuaternion(pose.orientation[0], pose.orientation[1], pose.orientation[2], pose.orientation[3]);
            }
            object.updateMatrix();
            this.standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
            object.applyMatrix(this.standingMatrix);
            entity.setQuaternion(object.quaternion.x, object.quaternion.y, object.quaternion.z, object.quaternion.w);
            object.position.multiplyScalar(this.scale);
            entity.setPosition(object.position.x, object.position.y, object.position.z);
            engine.needsRender = true;
        }
    };
    /**
     * Find an appropriate gamepad in the list of the ones available.
     * @param [_displayId=0]  Only match gamepads with the given displayId.
     * @returns               The found gamepad, if any.
     */
    VrHandController.prototype.findGamepad = function (_displayId) {
        if (_displayId === void 0) { _displayId = 0; }
        var gamepads = navigator.getGamepads();
        // getGamepads() doesn't return an array in Chrome so we need to iterate
        // with a regular for loop. Firefox does.
        /* tslint:disable prefer-for-of */
        for (var i = 0; i < gamepads.length; i++) {
            if (!gamepads[i]) {
                VrHandController.assignedControllers[i] = null;
                continue;
            }
            // If the controller is in use by another component, skip it.
            if (VrHandController.assignedControllers[i] &&
                VrHandController.assignedControllers[i] !== this) {
                continue;
            }
            VrHandController.assignedControllers[i] = this;
            // FIXME - Currently, Chromium doesn't report matching displayId's for headsets and
            // controllers so we can't actually do this test yet.
            // if (gamepads[i].displayId !== displayId) {
            //   continue;
            // }
            switch (this.handPreference) {
                case Handedness.Left:
                    if (gamepads[i].hand === 'left') {
                        return gamepads[i];
                    }
                    break;
                case Handedness.Right:
                    if (gamepads[i].hand === 'right') {
                        return gamepads[i];
                    }
                    break;
                case Handedness.LeftOrRight:
                    if (gamepads[i].hand === 'left' || gamepads[i].hand === 'right') {
                        return gamepads[i];
                    }
                    break;
                case Handedness.None:
                    if (gamepads[i].hand === '') {
                        return gamepads[i];
                    }
                    break;
                default:
                    return gamepads[i];
            }
            VrHandController.assignedControllers[i] = null;
        }
        /* tslint:enable prefer-for-of */
    };
    return VrHandController;
}(BaseComponent_1.default));
/** Structure to track which gamepads are already in use by other instances of VrHandController */
VrHandController.assignedControllers = [];
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = VrHandController;


/***/ },
/* 47 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-file-line-count */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var NodeObject_1 = __webpack_require__(9);
var MaterialAsset_1 = __webpack_require__(14);
var BaseGeometryAsset_1 = __webpack_require__(27);
var Schemas_1 = __webpack_require__(4);
/**
 * @class MeshObject
 * @constructor
 */
var MeshObject = (function (_super) {
    tslib_1.__extends(MeshObject, _super);
    function MeshObject() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    MeshObject.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.engine.on('materialDeleted', this.onMaterialDeleted, this);
        this.on('setMaterial', this.setMaterial, this);
        this.on('castShadowsEnable', this.castShadowsEnable, this);
        this.on('castShadowsDisable', this.castShadowsDisable, this);
        this.on('castShadowsToggle', this.castShadowsToggle, this);
    };
    /** @inheritdoc */
    MeshObject.prototype.uninitialize = function () {
        this.off('setMaterial', this.setMaterial, this);
        this.off('castShadowsEnable', this.castShadowsEnable, this);
        this.off('castShadowsDisable', this.castShadowsDisable, this);
        this.off('castShadowsToggle', this.castShadowsToggle, this);
        this.engine.off('materialDeleted', this.onMaterialDeleted, this);
        _super.prototype.uninitialize.call(this);
    };
    /** @inheritdoc */
    MeshObject.prototype.unload = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        if (this.runtimeData) {
            // TODO: is this line needed?
            this.runtimeData.material = null;
            // TODO: is this line needed?
            this.runtimeData.geometry = null;
        }
        _super.prototype.unload.call(this, recursive);
    };
    /**
     * Disable shadow casting.
     * @method castShadowsDisable
     * @public
     * @returns {void}
     */
    MeshObject.prototype.castShadowsDisable = function () {
        this.setProperty('castShadow', false);
        this.engine.needsRender = true;
    };
    /**
     * Enable shadow casting.
     * @method castShadowsEnable
     * @public
     * @returns {void}
     */
    MeshObject.prototype.castShadowsEnable = function () {
        this.setProperty('castShadow', true);
        this.engine.needsRender = true;
    };
    /**
     * Toggle shadow casting.
     * @method castShadowsToggle
     * @public
     * @returns {void}
     */
    MeshObject.prototype.castShadowsToggle = function () {
        var castShadow = this.getProperty('castShadow') ? false : true;
        this.setProperty('castShadow', castShadow);
        this.engine.needsRender = true;
    };
    /** @inheritdoc */
    MeshObject.prototype.createRuntimeData = function (callback) {
        var _this = this;
        var geometryId = this.getProperty('geometryId');
        var skinId = this.getProperty('skinId');
        var missingMaterial = this.engine.materialUtilities.getMissingMaterial();
        var missingMaterialId = missingMaterial ? missingMaterial.id : null;
        Promise.all([
            this.loadAsset(missingMaterialId),
            this.loadAsset(geometryId),
            this.loadAsset(skinId)
        ])
            .then(function () {
            _this.createMeshLoaded();
            callback();
        })
            .catch(function (err) {
            if (_this.isDestroyed()) {
                return;
            }
            Logger_1.default.error(_this.engine.getName() + ' - MeshObject: ' + err.toString());
            _this.createDefaultMesh();
            if (typeof callback === 'function') {
                callback();
            }
        });
    };
    /**
     * Return the Three.js geometry object.
     * @method getGeometry
     * @public
     * @returns {THREE.BufferGeometry|THREE.Geometry|null} The Three.js geometry object if it exists;
     * otherwise, null.
     */
    MeshObject.prototype.getGeometry = function () {
        var geometryAsset = this.getGeometryAsset();
        if (geometryAsset) {
            return geometryAsset.getGeometry(BaseGeometryAsset_1.default.primitiveType.TRIANGLES);
        }
        return null;
    };
    /**
     * Get the geometry asset assigned to this mesh.
     * @method getGeometryAsset
     * @public
     * @returns {BaseGeometryAsset|null} The geometry asset if it exists; otherwise, null.
     */
    MeshObject.prototype.getGeometryAsset = function () {
        var geometryId = this.getProperty('geometryId');
        return geometryId ? this.engine.getAssetById(geometryId) : null;
    };
    /** @inheritDoc */
    MeshObject.prototype.getLocalBounds = function (outBounds) {
        var geometryAsset = this.getGeometryAsset();
        if (geometryAsset) {
            return geometryAsset.getBounds(outBounds);
        }
        if (outBounds) {
            return outBounds.set(MeshObject.defaultLocalBounds.min, MeshObject.defaultLocalBounds.max);
        }
        return MeshObject.defaultLocalBounds;
    };
    /**
     * Get the material asset assigned to this mesh at the specified index.
     * @method getMaterial
     * @public
     * @param {number} [index] The material index (default is 0).
     * @param {Boolean} [placeholder] Return a placeholder material if the material is missing
     * (default is true).
     * @returns {MaterialAsset|null} The material if it exists; otherwise, null.
     */
    MeshObject.prototype.getMaterial = function (index, placeholder) {
        if (index === void 0) { index = 0; }
        if (placeholder === void 0) { placeholder = true; }
        // Validate the index parameter.
        if (index < 0 || index >= this.getMaterialCount()) {
            throw new Error('Invalid index parameter');
        }
        var materialId = this.getMaterialIds()[index];
        if (materialId) {
            var asset = this.engine.getAssetById(materialId);
            if (asset) {
                return asset;
            }
        }
        if (placeholder) {
            return this.engine.materialUtilities.getMissingMaterial();
        }
        return null;
    };
    /**
     * Get the material asset previously assigned to this mesh at the specified index.
     * @method getPreviousMaterial
     * @public
     * @param {number} [index] The material index (default is 0).
     * @param {Boolean} [placeholder] Return a placeholder material if the material is missing
     * (default is true).
     * @returns {MaterialAsset|null} The material if it exists; otherwise, null.
     */
    MeshObject.prototype.getPreviousMaterial = function (index, placeholder) {
        if (index === void 0) { index = 0; }
        if (placeholder === void 0) { placeholder = true; }
        // Validate the index parameter.
        if (index < 0 || index >= this.getMaterialCount()) {
            throw new Error('Invalid index parameter');
        }
        var materialId = this.getPreviousMaterialIds()[index];
        if (materialId) {
            var asset = this.engine.getAssetById(materialId);
            if (asset) {
                return asset;
            }
        }
        if (placeholder) {
            return this.engine.materialUtilities.getMissingMaterial();
        }
        return null;
    };
    /**
     * Get the number of material slots that this mesh has.
     * @method getMaterialCount
     * @public
     * @returns {number} The number of material slots that this mesh has.
     */
    MeshObject.prototype.getMaterialCount = function () {
        return this.getMaterialIds().length;
    };
    /**
     * Get an array of material assets that are assigned to this mesh.
     * @method getMaterials
     * @public
     * @param {Boolean} [placeholder] Substitute a placeholder for missing materials (default is
     * true).
     * @returns {MaterialAsset[]} An array of assets.
     */
    MeshObject.prototype.getMaterials = function (placeholder) {
        if (placeholder === void 0) { placeholder = true; }
        var materials = [];
        var nMaterials = this.getMaterialCount();
        for (var i = 0; i < nMaterials; ++i) {
            materials.push(this.getMaterial(i, placeholder));
        }
        return materials;
    };
    /**
     * Get the skin asset assigned to this mesh.
     * @method getSkinAsset
     * @public
     * @returns {SkinAsset|null} The skin asset if it exists; otherwise, null.
     */
    MeshObject.prototype.getSkinAsset = function () {
        var skinId = this.getProperty('skinId');
        return skinId ? this.engine.getAssetById(skinId) : null;
    };
    /**
     * Indicates whether or not this mesh is skinned.
     * @method isSkinned
     * @public
     * @returns {Boolean} true if this mesh is skinned; otherwise, false.
     */
    MeshObject.prototype.isSkinned = function () {
        return this.getSkinAsset() !== null;
    };
    /** @inheritdoc */
    MeshObject.prototype.applyPropertiesLoaded = function (changes, reason) {
        var _this = this;
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (changes.hasOwnProperty('geometryId')) {
            var prevGeometryId = this.getPreviousProperty('geometryId');
            var newGeometryId = this.getProperty('geometryId');
            // Stop listening to the old geometry, start listening to the new one.
            this.registerChangeListener(prevGeometryId, this.onGeometryChanged, false);
            this.registerChangeListener(newGeometryId, this.onGeometryChanged, true);
            // Reload the runtime data.
            if (reason !== 'init') {
                this.reloadBase();
                return;
            }
        }
        if (changes.hasOwnProperty('materials')) {
            // Stop listening for changes to the previous materials.
            var prevMaterialIds = this.getPreviousMaterialIds();
            prevMaterialIds.forEach(function (materialId) {
                _this.registerChangeListener(materialId, _this.onMaterialChanged, false);
            });
            // Allocate the MultiMaterial (container for other materials).
            if (!(this.runtimeData.material instanceof THREE.MultiMaterial)) {
                this.runtimeData.material = new THREE.MultiMaterial();
            }
            // Reset the MultiMaterial's material list.
            this.runtimeData.material.materials = [];
            // Assign the new materials and listen for changes.
            var materialType_1 = this.getMaterialType();
            var newMaterialIds = this.getMaterialIds();
            // Extend newMaterialIds to cover all of the material slots that the geometry references.
            var geometryAsset = this.getGeometryAsset();
            var maxMaterialIndex = geometryAsset ? geometryAsset.getMaxMaterialIndex('triangles') : 0;
            while (newMaterialIds.length <= maxMaterialIndex) {
                newMaterialIds.push(null);
            }
            newMaterialIds.forEach(function (materialId, index) {
                _this.registerChangeListener(materialId, _this.onMaterialChanged, true);
                _this.loadAndAssignMaterial(_this.runtimeData.material.materials, index, materialId, materialType_1);
            });
        }
        if (changes.hasOwnProperty('customDepthMaterial')) {
            var prevDepthMaterialId = this.getPreviousProperty('customDepthMaterial');
            var newDepthMaterialId = this.getProperty('customDepthMaterial');
            // Stop listening to the old material, start listening to the new one.
            this.registerChangeListener(prevDepthMaterialId, this.onMaterialChanged, false);
            this.registerChangeListener(newDepthMaterialId, this.onMaterialChanged, true);
            // Assign the new depth material.
            this.loadAndAssignMaterial(this.runtimeData, 'customDepthMaterial', newDepthMaterialId, this.getDepthMaterialType());
        }
    };
    /**
     * Load the asset with the specified ID.
     * @method loadAsset
     * @private
     * @param {String} assetId The ID of the asset to load.
     * @returns {Promise} A promise that resolves with the loaded asset or an error, if one occurs.
     * If assetId is null, the promise resolves with null.
     */
    MeshObject.prototype.loadAsset = function (assetId) {
        if (!assetId) {
            return Promise.resolve(null);
        }
        var asset = this.engine.getAssetById(assetId);
        if (!asset) {
            return Promise.reject(new Error("Asset \"" + assetId + "\" not found"));
        }
        return new Promise(function (resolve, reject) {
            asset.when('load', function () {
                if (asset.isLoadFailed()) {
                    reject(new Error("Asset \"" + assetId + "\" failed to load"));
                    return;
                }
                resolve(asset);
            });
            if (!asset.isLoaded()) {
                asset.load();
            }
        });
    };
    /**
     * Called in response to GeometryAsset property changes.
     * @method onGeometryChanged
     * @public
     * @returns {void}
     */
    MeshObject.prototype.onGeometryChanged = function () {
        this.createRuntimeData();
    };
    /**
     * Called in response to MaterialAsset property changes.
     * @method onMaterialChanged
     * @public
     * @returns {void}
     */
    MeshObject.prototype.onMaterialChanged = function () {
        // TODO: Update runtimeData.customDepthMaterial.
        return;
    };
    /**
     * Called when a MaterialAsset is deleted.
     * @method onMaterialDeleted
     * @public
     * @param {String} unloadedMaterialId The ID of the material being unloaded.
     * @returns {void}
     */
    MeshObject.prototype.onMaterialDeleted = function (unloadedMaterialId) {
        var materialIds = this.getMaterialIds();
        var removed = false;
        // Remove the unloaded material from the list of materials.
        materialIds.forEach(function (materialId, index) {
            if (materialId === unloadedMaterialId) {
                // Note: we assign null (no material) rather than undefined (use prefab material).
                materialIds[index] = null;
                removed = true;
            }
        });
        // If the material was in-use, remove it from the material list.
        if (removed) {
            this.setProperty('materials', materialIds);
        }
    };
    /**
     * Revert the material assignment at the specified index. This will cause the material at that
     * index to be inherited from the prefab object, if one is set.
     * @method revertMaterial
     * @public
     * @param {number} [index] The material index (default is 0).
     * @returns {void}
     */
    MeshObject.prototype.revertMaterial = function (index) {
        if (index === void 0) { index = 0; }
        // Note: we pass undefined, which unassigns the material and causes the prefab material at the
        // same index to be used. Passing null would override the prefab's material with an empty
        // material slot.
        this.setMaterial(undefined, index);
    };
    /**
     * Assign the specified material to the mesh at the specified index.
     * @method setMaterial
     * @public
     * @param {String|MaterialAsset} material The MaterialAsset, its ID or null/undefined.
     * @param {number} [index] The material index (default is 0).
     * @returns {void}
     */
    MeshObject.prototype.setMaterial = function (material, index) {
        if (index === void 0) { index = 0; }
        // Validate the index parameter.
        if (index < 0 || index >= this.getMaterialCount()) {
            throw new Error('Invalid index parameter');
        }
        // If material is a MaterialAsset, get the ID.
        var materialId = material instanceof MaterialAsset_1.default ? material.id : material;
        // Assign the material to the index.
        var materialIds = (this.getOwnProperty('materials') || []).slice();
        if (materialIds[index] !== materialId) {
            materialIds[index] = materialId;
            this.setProperty('materials', materialIds);
        }
    };
    /**
     * Get an array of material asset IDs that are assigned to this mesh.
     * @method getMaterialIds
     * @public
     * @returns {Array} An array of BaseAsset IDs.
     */
    MeshObject.prototype.getMaterialIds = function () {
        var materialIds = this.getProperty('materials');
        var prefab = this.getPrefabObject();
        var prefabMaterialIds = prefab ? prefab.getProperty('materials') : [];
        var merged = [];
        var length = Math.max(materialIds.length, prefabMaterialIds.length);
        for (var i = 0; i < length; ++i) {
            // Note: if the material ID is null, we interpret that as "no material" rather than falling
            // back to the prefab's material ID, which we do when material ID is undefined.
            merged.push(materialIds[i] !== undefined ? materialIds[i] : prefabMaterialIds[i]);
        }
        return merged;
    };
    /** @inheritdoc */
    MeshObject.prototype.applyPropertiesUnloaded = function (changes) {
        var _this = this;
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.hasOwnProperty('materials')) {
            // Unregister previous materials.
            this.getPreviousMaterials().forEach(function (material) { return _this.unregisterDependency(material); });
            // Register new materials.
            this.getMaterials().forEach(function (material) { return _this.registerDependency(material); });
        }
        if (changes.hasOwnProperty('customDepthMaterial')) {
            // Unregister previous material.
            var prevDepthMaterialId = this.getPreviousProperty('customDepthMaterial');
            if (prevDepthMaterialId) {
                this.unregisterDependencyById(prevDepthMaterialId);
            }
            // Register new material.
            var newDepthMaterialId = this.getProperty('customDepthMaterial');
            if (newDepthMaterialId) {
                this.registerDependencyById(newDepthMaterialId);
            }
        }
        if (changes.hasOwnProperty('geometryId')) {
            // Unregister previous geometry.
            var prevGeometryId = this.getPreviousProperty('geometryId');
            if (prevGeometryId) {
                this.unregisterDependencyById(prevGeometryId);
            }
            // Register new geometry.
            var newGeometryId = this.getProperty('geometryId');
            if (newGeometryId) {
                this.registerDependencyById(newGeometryId);
            }
        }
    };
    /**
     * Bind this mesh to a skeleton using the assigned skin. An error will be thrown if:
     *   * This mesh is not part of a prefab instance
     *   * No skin asset is assigned
     *   * The skin asset is not loaded
     *   * The mesh's runtime data is not loaded
     * @method bindToHierarchy
     * @private
     * @returns {void}
     * @throws Error
     */
    MeshObject.prototype.bindToHierarchy = function () {
        var _this = this;
        var root = this.getInstanceTop();
        if (!root) {
            throw new Error('Cannot bind mesh to hierarchy because it is not part of a prefab instance');
        }
        var skinAsset = this.getSkinAsset();
        if (!skinAsset) {
            throw new Error('Cannot bind mesh to hierarchy because it does not have a skin asset');
        }
        if (!skinAsset.isLoaded()) {
            throw new Error('Cannot bind mesh to hierarchy because the skin asset is not loaded');
        }
        var mesh = this.runtimeData;
        if (!mesh) {
            throw new Error('Cannot bind mesh to hierarchy because the mesh is not loaded');
        }
        root.when('loadDependencies', function () {
            var entities = root ? root.getDescendants() : [];
            var objects = entities.map(function (entity) { return entity.getRuntimeData(); });
            var objectsByName = objects.reduce(function (curr, obj) {
                curr[obj.name] = obj;
                return curr;
            }, {});
            var joints = skinAsset.getJointNames().map(function (jointName) {
                var runtimeName = _this.engine.getRuntimeName(jointName);
                return objectsByName[runtimeName];
            });
            var skeleton = new THREE.Skeleton(joints, skinAsset.getInverseBindMatrices());
            mesh.bind(skeleton, skinAsset.getBindShapeMatrix());
        });
        if (!root.isUnloaded()) {
            root.load();
        }
    };
    /**
     * Create a default three.js mesh using default geometry. Used when problems
     * loading this meshes assigned geometry occur.
     */
    MeshObject.prototype.createDefaultMesh = function () {
        var defaultGeometry = this.engine.geometryUtilities.getDefaultGeometry();
        this.createMesh(defaultGeometry);
    };
    /**
     * Create three.js mesh using the given geometry.
     * @param geometry The Three.js geometry to create the mesh from.
     */
    MeshObject.prototype.createMesh = function (geometry) {
        if (!this.runtimeData) {
            var meshType = this.isSkinned() ? THREE.SkinnedMesh : THREE.Mesh;
            var mesh = new meshType(geometry);
            mesh.name = this.getRuntimeName();
            mesh.castShadow = true;
            mesh.receiveShadow = true;
            mesh.material = null;
            this.runtimeData = mesh;
        }
        else {
            this.runtimeData.geometry = geometry;
        }
    };
    /**
     * Create the runtime mesh (i.e., a THREE.Mesh or THREEE.SkinnedMesh).
     * @method createMesh
     * @private
     * @returns {void}
     * @throws Error
     */
    MeshObject.prototype.createMeshLoaded = function () {
        var geometryAsset = this.getGeometryAsset();
        if (!geometryAsset.isLoaded()) {
            throw new Error('Cannot create mesh because geometry asset is not loaded');
        }
        var skinAsset = this.getSkinAsset();
        if (skinAsset && !skinAsset.isLoaded()) {
            throw new Error('Cannot create mesh because skin asset is not loaded');
        }
        var primitiveType = BaseGeometryAsset_1.default.primitiveType.TRIANGLES;
        var geometry = geometryAsset ? geometryAsset.getGeometry(primitiveType) : undefined;
        this.createMesh(geometry);
        if (skinAsset) {
            this.bindToHierarchy();
        }
    };
    /**
     * Get the depth material type.
     * @method getDepthMaterialType
     * @private
     * @returns {String} Either 'depthSkinned' or 'depthStatic'.
     */
    MeshObject.prototype.getDepthMaterialType = function () {
        var materialType = this.getMaterialType();
        if (MaterialAsset_1.default.materialObjectTypes[materialType].skinning) {
            return 'depthSkinned';
        }
        return 'depthStatic';
    };
    /**
     * Get an array of material assets that were previously assigned to this mesh.
     * @method getPreviousMaterials
     * @public
     * @param {Boolean} [placeholder] Substitute a placeholder for missing materials (default is
     * true).
     * @returns {MaterialAsset[]} An array of assets.
     */
    MeshObject.prototype.getPreviousMaterials = function (placeholder) {
        if (placeholder === void 0) { placeholder = true; }
        var materials = [];
        var nMaterials = this.getMaterialCount();
        for (var i = 0; i < nMaterials; ++i) {
            materials.push(this.getPreviousMaterial(i, placeholder));
        }
        return materials;
    };
    /**
     * Get the material type.
     * @method getMaterialType
     * @private
     * @returns {String} One of 'static', 'staticTangents', 'skinned', or 'skinnedTangents'.
     */
    MeshObject.prototype.getMaterialType = function () {
        var geometry = this.getGeometry();
        // FIXME does hasTangents exist anymore? I can't find it with a grep in three.js
        var hasTangents = geometry && geometry.hasTangents;
        if (this.isSkinned()) {
            return hasTangents ? 'skinnedTangents' : 'skinned';
        }
        return hasTangents ? 'staticTangents' : 'static';
    };
    /**
     * Get an array of material asset IDs that were previously assigned to this mesh.
     * @method getPreviousMaterialIds
     * @private
     * @returns {Array} an array of BaseAsset IDs.
     */
    MeshObject.prototype.getPreviousMaterialIds = function () {
        var materialIds = this.getPreviousProperty('materials');
        var prefab = this.getPrefabObject();
        var prefabMaterialIds = prefab ? prefab.getPreviousProperty('materials') : [];
        var merged = [];
        var length = Math.max(materialIds.length, prefabMaterialIds.length);
        for (var i = 0; i < length; ++i) {
            // Note: if the material ID is null, we interpret that as "no material" rather than falling
            // back to the prefab's material ID, which we do when material ID is undefined.
            merged.push(materialIds[i] !== undefined ? materialIds[i] : prefabMaterialIds[i]);
        }
        return merged;
    };
    /**
     * Load a material asset and assign its runtime data to the specified property.
     * @method loadAndAssignMaterial
     * @private
     * @param {Object} obj The object that receives the material assignment.
     * @param {String} property The property that receives the material assignment.
     * @param {String} materialId The ID of the material asset.
     * @param {String} materialType The type of material to use.
     * @returns {void}
     */
    MeshObject.prototype.loadAndAssignMaterial = function (obj, property, materialId, materialType) {
        // Assign the missing material while the real material loads.
        var missingMaterial = this.engine.materialUtilities.getMissingMaterial();
        if (missingMaterial && missingMaterial.getRuntimeData()) {
            obj[property] = missingMaterial.getRuntimeData()[materialType];
        }
        else {
            Logger_1.default.error(this.engine.getName() +
                ' - MeshObject: "Missing" material needed, but can\'t be found or isn\'t loaded.');
        }
        // Load and assign the real material.
        if (materialId) {
            var materialAsset_1 = this.engine.getAssetById(materialId);
            if (materialAsset_1) {
                materialAsset_1.when('loadBase', function () {
                    obj[property] = materialAsset_1.getRuntimeData()[materialType];
                });
                if (!materialAsset_1.isLoaded()) {
                    materialAsset_1.load();
                }
            }
        }
    };
    /**
     * Start or stop listening for changes to a BaseAsset.
     * @method registerChangeListener
     * @private
     * @param {String} assetId The ID of the BaseAsset to listen to.
     * @param {Function} callback The function to be called when properties change.
     * @param {Boolean} enabled Indicates whether to start or stop listening.
     * @returns {void}
     */
    MeshObject.prototype.registerChangeListener = function (assetId, callback, enabled) {
        // TODO: move this functionality into BaseEntity.
        if (!assetId) {
            return;
        }
        var asset = this.engine.getAssetById(assetId);
        if (!asset) {
            return;
        }
        if (enabled) {
            asset.on('propertyChanges', callback, this);
        }
        else {
            asset.off('propertyChanges', callback, this);
        }
    };
    return MeshObject;
}(NodeObject_1.default));
/** @inheritdoc */
MeshObject.events = {
    setMaterial: {
        scope: 'local',
        action: true,
        category: 'Materials',
        params: [
            {
                name: 'material',
                type: 'asset',
                filter: {
                    material: true
                }
            },
            {
                name: 'index',
                type: 'i',
                description: 'Optional - the index of the material (default is 0).',
                default: 0
            }
        ]
    },
    castShadowsEnable: {
        params: [],
        action: true,
        category: 'Rendering'
    },
    castShadowsDisable: {
        params: [],
        action: true,
        category: 'Rendering'
    },
    castShadowsToggle: {
        params: [],
        action: true,
        category: 'Rendering'
    }
};
/**
 * Default value for mesh bounds.
 */
MeshObject.defaultLocalBounds = new THREE.Box3();
Schemas_1.addSchemas('MeshObject', MeshObject);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MeshObject;


/***/ },
/* 48 */
/***/ function(module, exports) {

"use strict";
"use strict";
var LoadingState;
(function (LoadingState) {
    LoadingState[LoadingState["STARTING"] = 0] = "STARTING";
    LoadingState[LoadingState["LOADING"] = 1] = "LOADING";
    LoadingState[LoadingState["PROCESSING"] = 2] = "PROCESSING";
    LoadingState[LoadingState["COMPLETE"] = 3] = "COMPLETE";
    LoadingState[LoadingState["CANCELLED"] = 4] = "CANCELLED";
    LoadingState[LoadingState["ERROR"] = 5] = "ERROR";
})(LoadingState || (LoadingState = {}));
;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LoadingState;


/***/ },
/* 49 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var baseImageAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'baseImageAsset', title: 'BaseImageAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { properties: {
            $ref: 'baseImageAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseImageAsset;


/***/ },
/* 50 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var baseImageAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'baseImageAssetProperties', title: 'BaseImageAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { premultiplyAlpha: {
            type: 'boolean',
            default: false
        }, stream: {
            type: 'boolean',
            description: 'True if a low-resolution image should be loaded before the full-size image.',
            default: true
        }, filename: {
            type: 'string',
            description: 'The filename of the original image.',
            default: ''
        }, compression: {
            type: 'string',
            description: 'The type of compression used for the original image file.',
            default: 'zip'
        }, depth: {
            type: 'integer',
            description: 'The bit-depth of each channel in the original image file.',
            default: 8
        }, sequenceLength: {
            type: 'integer',
            description: 'The number of images contained in the original image file.',
            default: 1
        }, channels: {
            type: 'array',
            item: {
                type: 'string'
            },
            description: 'The distinct channels found in the original image file.',
            default: ['red', 'green', 'blue']
        }, format: {
            type: 'string',
            description: '',
            default: 'rgb'
        }, type: {
            type: 'string',
            description: '',
            default: 'uByte'
        }, layout: {
            type: 'string',
            description: '',
            default: 'normal'
        }, width: {
            type: 'integer',
            description: 'The width, in pixels, of the original image file.',
            default: undefined
        }, height: {
            type: 'integer',
            description: 'The height, in pixels, of the original image file.',
            default: undefined
        }, encoding: {
            type: 'string',
            default: 'srgb'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = baseImageAssetProperties;


/***/ },
/* 51 */
/***/ function(module, exports) {

"use strict";
"use strict";
var commonImageProperties = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'commonImageProperties',
    title: 'CommonImagePropertiesDef',
    type: 'object',
    properties: {
        width: {
            type: 'integer',
            description: 'The width, in pixels, of the original image file.'
        },
        height: {
            type: 'integer',
            description: 'The height, in pixels, of the original image file.'
        },
        format: {
            type: 'string',
            default: 'rgb'
        },
        type: {
            type: 'string',
            default: 'uByte'
        },
        encoding: {
            type: 'string',
            default: 'srgb'
        },
        layout: {
            type: 'string',
            default: 'normal'
        }
    },
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = commonImageProperties;


/***/ },
/* 52 */
/***/ function(module, exports, __webpack_require__) {

// Thank's IE8 for his funny defineProperty
module.exports = !__webpack_require__(175)(function(){
  return Object.defineProperty({}, 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ },
/* 53 */
/***/ function(module, exports, __webpack_require__) {

var global    = __webpack_require__(25)
  , core      = __webpack_require__(24)
  , hide      = __webpack_require__(54)
  , redefine  = __webpack_require__(233)
  , ctx       = __webpack_require__(174)
  , PROTOTYPE = 'prototype';

var $export = function(type, name, source){
  var IS_FORCED = type & $export.F
    , IS_GLOBAL = type & $export.G
    , IS_STATIC = type & $export.S
    , IS_PROTO  = type & $export.P
    , IS_BIND   = type & $export.B
    , target    = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE]
    , exports   = IS_GLOBAL ? core : core[name] || (core[name] = {})
    , expProto  = exports[PROTOTYPE] || (exports[PROTOTYPE] = {})
    , key, own, out, exp;
  if(IS_GLOBAL)source = name;
  for(key in source){
    // contains in native
    own = !IS_FORCED && target && target[key] !== undefined;
    // export native or passed
    out = (own ? target : source)[key];
    // bind timers to global for call from export context
    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;
    // extend global
    if(target)redefine(target, key, out, type & $export.U);
    // export
    if(exports[key] != out)hide(exports, key, exp);
    if(IS_PROTO && expProto[key] != out)expProto[key] = out;
  }
};
global.core = core;
// type bitmap
$export.F = 1;   // forced
$export.G = 2;   // global
$export.S = 4;   // static
$export.P = 8;   // proto
$export.B = 16;  // bind
$export.W = 32;  // wrap
$export.U = 64;  // safe
$export.R = 128; // real proto method for `library` 
module.exports = $export;

/***/ },
/* 54 */
/***/ function(module, exports, __webpack_require__) {

var dP         = __webpack_require__(231)
  , createDesc = __webpack_require__(232);
module.exports = __webpack_require__(52) ? function(object, key, value){
  return dP.f(object, key, createDesc(1, value));
} : function(object, key, value){
  object[key] = value;
  return object;
};

/***/ },
/* 55 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(7);
var BufferAsset_1 = __webpack_require__(28);
var functions_1 = __webpack_require__(6);
var Schemas_1 = __webpack_require__(4);
/**
 * An asset that holds animation data: clips, layers and channels.
 * @class AnimationAsset
 * @constructor
 */
var AnimationAsset = (function (_super) {
    tslib_1.__extends(AnimationAsset, _super);
    function AnimationAsset() {
        var _this = _super.apply(this, arguments) || this;
        /**
         * A mapping of ids to THREE.AnimationClips
         * @private
         * @type {ObjectMap<THREE.AnimationClip>}
         */
        _this.clips = {};
        return _this;
    }
    /**
     * Get the THREE.AnimationClip for the clip with the specified ID.
     * @method getAnimationClip
     * @param {String} id The clip ID.
     * @returns {THREE.AnimationClip} A THREE.AnimationClip.
     */
    AnimationAsset.prototype.getAnimationClip = function (id) {
        return this.clips[id];
    };
    /**
     * Get the channel with the specified ID.
     * @method getChannel
     * @public
     * @param {String} id The channel ID.
     * @returns {Object|undefined} The channel or undefined if the channel does not exist.
     */
    AnimationAsset.prototype.getChannel = function (id) {
        return this.getProperty('channels')[id];
    };
    /**
     * Get the IDs of all the channels.
     * @method getChannelIds
     * @public
     * @returns {Array} An array of channel IDs.
     */
    AnimationAsset.prototype.getChannelIds = function () {
        return Object.keys(this.getProperty('channels'));
    };
    /**
     * Get all channels.
     * @method getChannels
     * @public
     * @returns {Array} An array of channels.
     */
    AnimationAsset.prototype.getChannels = function () {
        return functions_1.values(this.getProperty('channels'));
    };
    /**
     * Get the clip with the specified ID.
     * @method getClip
     * @public
     * @param {String} id The clip ID.
     * @returns {Object} The clip or undefined if the clip does not exist.
     */
    AnimationAsset.prototype.getClip = function (id) {
        return this.getProperty('clips')[id];
    };
    /**
     * Get IDs of all the clips.
     * @method getClipIds
     * @public
     * @returns {Array} An array of clip IDs.
     */
    AnimationAsset.prototype.getClipIds = function () {
        return Object.keys(this.getProperty('clips'));
    };
    /**
     * Get all clips.
     * @method getClips
     * @public
     * @returns {Array} An array of clips.
     */
    AnimationAsset.prototype.getClips = function () {
        return functions_1.values(this.getProperty('clips'));
    };
    /**
     * Get the layer with the specified ID.
     * @method getLayer
     * @public
     * @param {String} id The layer ID.
     * @returns {Object|undefined} The layer or undefined if the layer does not exist.
     */
    AnimationAsset.prototype.getLayer = function (id) {
        return this.getProperty('layers')[id];
    };
    /**
     * Get IDs of all the layers.
     * @method getLayerIds
     * @public
     * @returns {Array} An array of layer IDs.
     */
    AnimationAsset.prototype.getLayerIds = function () {
        return Object.keys(this.getProperty('layers'));
    };
    /**
     * Get all layers.
     * @method getLayers
     * @public
     * @returns {Array} An array of layers.
     */
    AnimationAsset.prototype.getLayers = function () {
        return functions_1.values(this.getProperty('layers'));
    };
    /** @inheritdoc */
    AnimationAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        this.when('loadDependencies', function () {
            if (_this.isDestroyed()) {
                return;
            }
            var dependencies = _this.getDependencies();
            var loadFailed = dependencies.some(function (asset) { return asset.isLoadFailed(); });
            if (!loadFailed) {
                _this.createClips();
            }
            callback();
        }, this);
    };
    /** @inheritdoc */
    AnimationAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.hasOwnProperty('channels')) {
            this.registerBufferDependency();
        }
    };
    /**
     * Register the buffer asset as a dependency.
     * @method registerBufferDependency
     * @private
     * @return {void}
     */
    AnimationAsset.prototype.registerBufferDependency = function () {
        var _this = this;
        var channels = this.getChannels();
        var accessorIds = [];
        channels.forEach(function (channel) {
            accessorIds.push(channel.times);
            accessorIds.push(channel.values);
        });
        accessorIds.forEach(function (accessorId) {
            var tokens = accessorId.split('#');
            if (tokens.length !== 2) {
                throw new Error(_this.engine.getName() +
                    ' - AnimationAsset: Invalid accessorId, ' + accessorId);
            }
            _this.registerDependencyById(tokens[0]);
        });
    };
    /**
     * Create a THREE.AnimationClip for each clip.
     * @method createClips
     * @private
     * @returns {void}
     */
    AnimationAsset.prototype.createClips = function () {
        var _this = this;
        var clipIds = this.getClipIds();
        clipIds.forEach(function (clipId) {
            _this.clips[clipId] = _this.createClip(clipId);
        });
    };
    /**
     * Create a THREE.AnimationClip for a clip.
     * @method createClip
     * @private
     * @param {String} clipId The clip ID.
     * @returns {THREE.AnimationClip} A THREE.AnimationClip.
     */
    AnimationAsset.prototype.createClip = function (clipId) {
        var _this = this;
        var clip = this.getClip(clipId);
        if (!clip) {
            throw new Error("Invalid argument: clip \"" + clipId + "\" not found");
        }
        if (clip.layers.length > 1) {
            Logger_1.default.warn("Clip \"" + clipId + "\" contains multiple layers, but " +
                'AnimationAsset.prototype.createAnimation() only supports a single layer.');
        }
        // Get channels that belong to the first layer.
        var layer = this.getLayer(clip.layers[0]);
        var channels = layer ?
            layer.channels.map(function (channelId) { return _this.getChannel(channelId); }) : [];
        // Create a keyframe track for each channel.
        var tracks = channels.map(function (channel) {
            return _this.createKeyframeTrack(channel, clip.start, clip.stop);
        });
        return new THREE.AnimationClip(clip.name, clip.stop - clip.start, tracks);
    };
    /**
     * Create a THREE.KeyframeTrack for the specified channel.
     * @method createKeyframeTrack
     * @private
     * @param {Object} channel The channel object (@see getChannel()).
     * @param {number} startTime The track's start time (in seconds).
     * @param {number} stopTime The track's stop time (in seconds).
     * @returns {THREE.KeyframeTrack} A THREE.KeyframeTrack.
     */
    AnimationAsset.prototype.createKeyframeTrack = function (channel, startTime, stopTime) {
        var _this = this;
        var timeTokens = channel.times.split('#');
        var timeBufferId = timeTokens[0];
        var timeAccessorName = timeTokens[1];
        var timeBuffer = this.engine.getEntityById(timeBufferId);
        if (!timeBuffer) {
            throw new Error(this.engine.getName() +
                ' - AnimationAsset: BufferAsset not found, ' + timeBufferId);
        }
        var timeAccessor = timeBuffer.getAccessor(timeAccessorName);
        var times = timeBuffer.getArray(timeAccessorName);
        if (!timeAccessor || !times) {
            throw new Error(this.engine.getName() +
                ' - AnimationAsset: Accessor not found, ' + timeAccessorName);
        }
        var valueTokens = channel.values.split('#');
        var valueBufferId = valueTokens[0];
        var valueAccessorName = valueTokens[1];
        var valueBuffer = this.engine.getEntityById(valueBufferId);
        if (!valueBuffer) {
            throw new Error(this.engine.getName() +
                ' - AnimationAsset: BufferAsset not found, ' + valueBufferId);
        }
        var valueAccessor = valueBuffer.getAccessor(valueAccessorName);
        var values = valueBuffer.getArray(valueAccessorName);
        if (!valueAccessor || !values) {
            throw new Error(this.engine.getName() +
                ' - AnimationAsset: Accessor not found, ' + valueAccessorName);
        }
        var runtimeNames = channel.targetObject.map(function (sid) { return _this.engine.getRuntimeName(sid); });
        var target = runtimeNames.join('/') + '.' + channel.targetProperty;
        var trackType = channel.targetProperty === 'quaternion' ?
            THREE.QuaternionKeyframeTrack : THREE.VectorKeyframeTrack;
        // Crop the time and value arrays by [startTime, stopTime] so that only the keyframes in that
        // time range are included in the track.
        var _a = times.reduce(function (result, time, idx) {
            if (!result.hasOwnProperty('firstTimeNo') && time >= startTime) {
                result.firstTimeNo = idx;
            }
            if (time <= stopTime) {
                result.lastTimeNo = idx;
            }
            return result;
        }, {}), firstTimeNo = _a.firstTimeNo, lastTimeNo = _a.lastTimeNo;
        var begin = firstTimeNo >= 0 ? firstTimeNo : 0;
        var end = lastTimeNo >= 0 ? lastTimeNo + 1 : times.length;
        var valueSize = BufferAsset_1.default.getTypeSize(valueAccessor.type);
        var croppedTimes = times.subarray(begin, end);
        var croppedValues = values.subarray(begin * valueSize, end * valueSize);
        var shiftedTimes = (startTime === 0)
            ? croppedTimes
            : croppedTimes.slice().map(function (n) { return n - startTime; });
        return new trackType(target, shiftedTimes, croppedValues, null);
    };
    return AnimationAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('AnimationAsset', AnimationAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = AnimationAsset;


/***/ },
/* 56 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseAsset_1 = __webpack_require__(7);
var Schemas_1 = __webpack_require__(4);
var ApplicationAsset = (function (_super) {
    tslib_1.__extends(ApplicationAsset, _super);
    function ApplicationAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    ApplicationAsset.prototype.createRuntimeData = function (callback) {
        this.engine.setCurrentApp(this.id);
        var scene = this.engine.getEntityById(this.getProperty('startupSceneId'));
        if (scene) {
            scene.load();
        }
        callback();
    };
    return ApplicationAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('ApplicationAsset', ApplicationAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ApplicationAsset;


/***/ },
/* 57 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseAsset_1 = __webpack_require__(7);
var Schemas_1 = __webpack_require__(4);
// import JSONLoader from '../Util/JSONLoader';
/**
 * An asset that loads entities from an external document and adds them to the
 * runtime.
 * @class DocumentAsset
 * @constructor
 */
var DocumentAsset = (function (_super) {
    tslib_1.__extends(DocumentAsset, _super);
    function DocumentAsset() {
        return _super.apply(this, arguments) || this;
    }
    // public loadedBytes: number = 0;
    /** @inheritdoc */
    DocumentAsset.prototype.createRuntimeData = function (callback) {
        return callback();
        // FIXME: Outdated!
        // const loadFromJson = (response) => {
        //   const loader = new JSONLoader(this.engine);
        //   return loader.loadFromJson(response.data);
        // };
        // const onDocumentLoadError = (err) => {
        //   log.error(this.engine.engineName +
        //     ' - DocumentAsset: Error loading document, ' +
        //     this.getName(), err);
        //   callback();
        // };
        // const onDocumentProgress = (progressObj) => {
        //   this.loadedBytes = progressObj.loaded / progressObj.total;
        //   this.trigger('loadProgress', this);
        // };
        // const onDocumentLoaded = (entities) => {
        //   // Reference entities by SID.
        //   this.runtimeData = {
        //     entityIds: {}
        //   };
        //   entities.forEach(function(entity) {
        //     this.runtimeData.entityIds[entity.sid] = entity.id;
        //   }, this);
        //   callback();
        // };
        // this.engine.resourceLoader
        //   .load(this, { xhrKey: this.id }, onDocumentProgress)
        //   .then(loadFromJson)
        //   .then(onDocumentLoaded)
        //   .catch(onDocumentLoadError);
    };
    /**
     * Return the ID of the entity with the specified SID.
     * @method getEntityId
     * @public
     * @param {String} sid - the SID of the entity
     * @returns {String|undefined} the ID of the entity or undefined
     */
    DocumentAsset.prototype.getEntityId = function (sid) {
        return this.runtimeData ? this.runtimeData.entityIds[sid] : undefined;
    };
    return DocumentAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('DocumentAsset', DocumentAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DocumentAsset;


/***/ },
/* 58 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseGeometryAsset_1 = __webpack_require__(27);
var BaseEntity_1 = __webpack_require__(11);
var BufferAsset_1 = __webpack_require__(28);
var functions_1 = __webpack_require__(6);
var Schemas_1 = __webpack_require__(4);
/**
 * A concrete subclass of BaseGeometryAsset that holds mesh geometry.
 */
var MeshGeometryAsset = (function (_super) {
    tslib_1.__extends(MeshGeometryAsset, _super);
    function MeshGeometryAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    MeshGeometryAsset.prototype.getBounds = function (outBounds) {
        var bounds = this.getProperty('bounds');
        var returnBounds = outBounds || new THREE.Box3();
        return returnBounds.set(bounds.min, bounds.max);
    };
    /** @inheritdoc */
    MeshGeometryAsset.prototype.getDataSizeInMemorySelf = function () {
        var _this = this;
        // Loop through each attribute and total up the size of the data.
        var attributes = this.getProperty('attributes');
        return Object.keys(attributes).map(function (name) {
            var attribute = attributes[name];
            var accessor = _this.getBufferAccessor(attribute.accessorId);
            return BufferAsset_1.default.getComponentTypeSize(accessor.componentType) *
                BufferAsset_1.default.getTypeSize(accessor.type) * accessor.count;
        }).reduce(function (total, size) { return size + total; }, 0);
    };
    /** @inheritdoc */
    MeshGeometryAsset.prototype.applyPropertiesUnloaded = function (changes) {
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.attributes || changes.indices) {
            this.registerBufferDependency();
        }
    };
    /** @inheritdoc */
    MeshGeometryAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        this.when('loadDependencies', function () {
            var dependencies = _this.getDependencies();
            var loadFailed = dependencies.some(function (asset) { return asset.isLoadFailed(); });
            if (_this.isDestroyed()) {
                return;
            }
            if (!loadFailed) {
                try {
                    _this.createBufferGeometry();
                }
                catch (err) {
                    Logger_1.default.error(err.toString());
                    _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
                }
            }
            else {
                _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
            }
            callback();
        });
    };
    /**
     * Adds required attributes to the specified geometry.
     * @param geometry The Three.js geometry.
     */
    MeshGeometryAsset.prototype.addMissingAttributes = function (geometry) {
        // Create an empty position array if it doesn't exist.
        if (geometry.attributes.position === undefined) {
            Logger_1.default.warn(this.engine.getName() +
                ' - MeshGeometryAsset: Mesh is missing "position" attribute.');
            geometry.addAttribute('position', new THREE.BufferAttribute(new Float32Array(0), 3));
        }
        // Compute vertex normals if they don't exist.
        if (geometry.attributes.normal === undefined) {
            Logger_1.default.warn(this.engine.getName() +
                ' - MeshGeometryAsset: Mesh is missing "normal" attribute.');
            geometry.computeVertexNormals();
        }
    };
    /**
     * Create a collection of THREE.BufferAttributes for this mesh.
     * @param typeSizes The desired value-size of each attribute.
     * @returns         A collection of THREE.BufferAttributes.
     * @throws Error    (@see createBufferAttribute)
     */
    MeshGeometryAsset.prototype.createAttributes = function (typeSizes) {
        var _this = this;
        var nameMap = {
            indices: 'index',
            positions: 'position',
            normals: 'normal',
            tangents: 'tangent',
            colors: 'color',
            uvs1: 'uv',
            uvs2: 'uv2',
            skinIndices: 'skinIndex',
            skinWeights: 'skinWeight'
        };
        // Add indices to the list of attributes.
        var attributes = Object.assign({
            indices: {
                accessorId: this.getProperty('indices')
            }
        }, this.getProperty('attributes'));
        var bufferAttributes = {};
        functions_1.forEach(nameMap, function (newName, oldName) {
            if (attributes.hasOwnProperty(oldName)) {
                var accessorId = attributes[oldName].accessorId;
                bufferAttributes[newName] = _this.createBufferAttribute(accessorId, typeSizes[newName]);
            }
        });
        return bufferAttributes;
    };
    /**
     * Create a THREE.BufferAttribute for the specified attribute. The underlying typed-array will be
     * resized if necessary. This method will throw an error if the accessorId is invalid because:
     *   * it is not of the form <buffer-id>#<accessor-name>
     *   * the referenced buffer asset does not exist
     *   * the buffer failed to load
     *   * the buffer does not contain the referenced accessor
     * @param accessorId  The ID of the accessor.
     * @param newTypeSize The desired number of components in each value.
     * @returns           A THREE.BufferAttribute.
     * @throws Error
     */
    MeshGeometryAsset.prototype.createBufferAttribute = function (accessorId, newTypeSize) {
        var accessor = this.getBufferAccessor(accessorId);
        var array = this.getBufferArray(accessorId);
        var oldTypeSize = BufferAsset_1.default.getTypeSize(accessor.type);
        if (newTypeSize === undefined || oldTypeSize === newTypeSize) {
            return new THREE.BufferAttribute(array, oldTypeSize);
        }
        // The attribute size needs to be adjusted.
        var dstArray = new array.constructor(accessor.count * newTypeSize);
        var minSize = Math.min(oldTypeSize, newTypeSize);
        for (var iValue = 0; iValue < accessor.count; iValue += 1) {
            var iComponent = 0;
            for (; iComponent < minSize; iComponent += 1) {
                dstArray[iValue * newTypeSize + iComponent] = array[iValue * oldTypeSize + iComponent];
            }
            while (iComponent < newTypeSize) {
                dstArray[iValue * newTypeSize + iComponent] = 0;
                iComponent += 1;
            }
        }
        return new THREE.BufferAttribute(dstArray, newTypeSize);
    };
    /**
     * Create THREE.BufferGeometry objects for this mesh.
     * @throws Error (@see createAttributes)
     */
    MeshGeometryAsset.prototype.createBufferGeometry = function () {
        var _this = this;
        // Create vertex attributes.
        var attributes = this.createAttributes({
            index: 1,
            position: 3,
            normal: 3,
            tangent: 4,
            color: 4,
            uv: 2,
            uv2: 2,
            skinIndex: 4,
            skinWeight: 4
        });
        var bounds = this.getProperty('bounds');
        var boundsMin = new THREE.Vector3(bounds.min.x, bounds.min.y, bounds.min.z);
        var boundsMax = new THREE.Vector3(bounds.max.x, bounds.max.y, bounds.max.z);
        var primitivesByType = this.getProperty('primitives')
            .reduce(function (grouped, primitive) {
            grouped[primitive.primitive] = grouped[primitive.primitive] || [];
            grouped[primitive.primitive].push(primitive);
            return grouped;
        }, {});
        functions_1.forEach(primitivesByType, function (primitives, type) {
            var geometry = new THREE.BufferGeometry();
            // Add groups to the BufferGeometry.
            primitives.forEach(function (primitive) {
                geometry.addGroup(primitive.start, primitive.count, primitive.materialIndex);
            });
            // Add attributes to the BufferGeometry.
            functions_1.forEach(attributes, function (attribute, name) {
                if (name === 'index') {
                    geometry.setIndex(attribute);
                }
                else {
                    geometry.addAttribute(name, attribute);
                }
            });
            // Add missing attributes.
            _this.addMissingAttributes(geometry);
            // Calculate the geometry bounds.
            geometry.boundingBox = new THREE.Box3(boundsMin, boundsMax);
            geometry.computeBoundingSphere();
            // Register the geometry.
            _this.setGeometry(type, geometry);
        });
    };
    /**
     * Given an accessor ID for the geometry's buffer, return the accessor.
     * @private
     * @param {string} accessorId
     * @returns {AccessorDef}
     * @memberOf MeshGeometryAsset
     */
    MeshGeometryAsset.prototype.getBufferAccessor = function (accessorId) {
        var tokens = accessorId.split('#');
        if (tokens.length !== 2) {
            throw new Error(this.engine.getName() +
                ' - MeshGeometryAsset: Invalid accessorId, ' + accessorId);
        }
        var bufferId = tokens[0];
        var accessorName = tokens[1];
        var bufferAsset = this.engine.getEntityById(bufferId);
        if (!bufferAsset) {
            throw new Error(this.engine.getName() +
                ' - MeshGeometryAsset: BufferAsset not found, ' + bufferId);
        }
        var accessor = bufferAsset.getAccessor(accessorName);
        if (!accessor) {
            throw new Error(this.engine.getName() +
                ' - MeshGeometryAsset: Accessor not found, ' + accessorName);
        }
        return accessor;
    };
    /**
     * Given an accessor ID for the geometry's buffer, return the buffer data.
     * @param accessorId The ID of the accessor.
     * @returns The buffer associated with the specified ID.
     */
    MeshGeometryAsset.prototype.getBufferArray = function (accessorId) {
        var tokens = accessorId.split('#');
        if (tokens.length !== 2) {
            throw new Error(this.engine.getName() +
                ' - MeshGeometryAsset: Invalid accessorId, ' + accessorId);
        }
        var bufferId = tokens[0];
        var accessorName = tokens[1];
        var bufferAsset = this.engine.getEntityById(bufferId);
        if (!bufferAsset) {
            throw new Error(this.engine.getName() +
                ' - MeshGeometryAsset: BufferAsset not found, ' + bufferId);
        }
        var array = bufferAsset.getArray(accessorName);
        if (!array) {
            throw new Error(this.engine.getName() +
                ' - MeshGeometryAsset: Accessor not found, ' + accessorName);
        }
        return array;
    };
    /**
     * Register the buffer asset as a dependency.
     */
    MeshGeometryAsset.prototype.registerBufferDependency = function () {
        var _this = this;
        var attributes = this.getProperty('attributes');
        var indices = this.getProperty('indices');
        var accessorIds = [indices];
        Object.keys(attributes).forEach(function (name) {
            accessorIds.push(attributes[name].accessorId);
        });
        var bufferIds = {};
        accessorIds.forEach(function (accessorId) {
            var tokens = accessorId.split('#');
            if (tokens.length !== 2) {
                throw new Error(_this.engine.getName() +
                    ' - MeshGeometryAsset: Invalid accessorId, ' + accessorId);
            }
            bufferIds[tokens[0]] = true;
        });
        Object.keys(bufferIds).forEach(function (bufferId) {
            _this.registerDependencyById(bufferId);
        });
    };
    return MeshGeometryAsset;
}(BaseGeometryAsset_1.default));
Schemas_1.addSchemas('MeshGeometryAsset', MeshGeometryAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MeshGeometryAsset;


/***/ },
/* 59 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseAsset_1 = __webpack_require__(7);
var uuid_1 = __webpack_require__(17);
var functions_1 = __webpack_require__(6);
var Schemas_1 = __webpack_require__(4);
/**
 * @class PrefabAsset
 * @constructor
 */
var PrefabAsset = (function (_super) {
    tslib_1.__extends(PrefabAsset, _super);
    function PrefabAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    PrefabAsset.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.engine.on('prefabDeleted', this.onPrefabDeleted, this);
        this.on('load', this.onPrefabLoaded, this);
    };
    /** @inheritdoc */
    PrefabAsset.prototype.uninitialize = function () {
        var _this = this;
        this.engine.off('prefabDeleted', this.onPrefabDeleted, this);
        this.off('load', this.onPrefabLoaded, this);
        var root = this.getRootObject();
        if (root) {
            // We call unregister here because we don't know the context of why uninitialize
            // is being called. It could be that the prefab is being destroyed or it could be
            // that the engine is shutting down. Either way, we want to remove the child objects from
            // this runtime only.
            root.getDescendants().forEach(function (obj) { return _this.engine.unregisterEntity(obj); });
        }
        _super.prototype.uninitialize.call(this);
    };
    /**
     * Returns the NodeObject that is the root of this asset's object hierarchy, if any.
     * @returns The NodeObject root, if it exists, or null otherwise
     */
    PrefabAsset.prototype.getRootObject = function () {
        return this.engine.getObjectById(this.getProperty('rootObjectId'));
    };
    /**
     * Set the NodeObject that will be the root of this asset's object hierarchy.
     * @param rootObjectId The ID of the NodeObject to set as the root.
     */
    PrefabAsset.prototype.setRootObjectById = function (rootObjectId) {
        return this.setProperty('rootObjectId', rootObjectId);
    };
    /**
     * Set the NodeObject that will be the root of this asset's object hierarchy.
     * @param rootObject The NodeObject to set as the root.
     */
    PrefabAsset.prototype.setRootObject = function (rootObject) {
        return this.setProperty('rootObjectId', rootObject.id);
    };
    /** @inheritdoc */
    PrefabAsset.prototype.unload = function () {
        var root = this.getRootObject();
        if (root) {
            root.unload(true);
        }
        _super.prototype.unload.call(this);
    };
    /**
     * Create and return an instance of this prefab's object hierarchy.
     * @param [id]  An ID for the new instance. If the one specified is not unique or
     *              not given, a new one will be generated.
     * @returns     The new instance object
     */
    PrefabAsset.prototype.createInstance = function (id) {
        var _this = this;
        var rootObject = this.getRootObject();
        if (!rootObject) {
            throw new Error('No object hierarchy inside of this prefab so can\'t create an instance');
        }
        var newTopObjectId = id || uuid_1.v4();
        var topInstanceDesc = {
            id: newTopObjectId,
            sid: rootObject.get('sid'),
            prefabObjectId: rootObject.id,
            prefabAssetId: this.id,
            prefabInstanceId: newTopObjectId,
            type: rootObject.type,
            components: rootObject.getComponentDescriptors()
        };
        // Create the top-level instance object
        var topInst = this.engine.createEntity(topInstanceDesc);
        var instanceMap = {};
        instanceMap[rootObject.id] = topInst;
        // Create child instance objects
        var prefabObjects = rootObject.getDescendants();
        prefabObjects.forEach(function (prefabObject) {
            var instanceDesc = {
                sid: prefabObject.get('sid'),
                prefabObjectId: prefabObject.id,
                prefabAssetId: _this.id,
                prefabInstanceId: newTopObjectId,
                type: prefabObject.type,
                properties: {},
                components: prefabObject.getComponentDescriptors()
            };
            var inst = _this.engine.createEntity(instanceDesc);
            instanceMap[prefabObject.id] = inst;
        });
        // For each object, set 'parentId' and 'children' on the instance using
        // the mapping created above.
        prefabObjects.forEach(function (prefabObject) {
            var instChildren = [];
            var childIds = prefabObject.getChildIds();
            var instance = instanceMap[prefabObject.id];
            functions_1.forEach(childIds, function (childId) {
                if (instanceMap[childId]) {
                    instChildren.push(instanceMap[childId].id);
                    instanceMap[childId].set('parentId', instance.id);
                }
            });
            instance.setChildIds(instChildren);
            // Re-link component entity refs.
            _this.relinkComponentRefs(instance, instanceMap);
        });
        this.relinkComponentRefs(topInst, instanceMap);
        // Add top-level instance children
        var instChildren = [];
        var childIds = rootObject.getChildIds();
        functions_1.forEach(childIds, function (childId) {
            if (instanceMap[childId]) {
                instChildren.push(instanceMap[childId].id);
                instanceMap[childId].set('parentId', topInst.id);
            }
        });
        topInst.setChildIds(instChildren);
        return topInst;
    };
    /** @inheritdoc */
    PrefabAsset.prototype.clone = function (id) {
        var clonedAsset = _super.prototype.clone.call(this, id);
        var rootObject = this.getRootObject();
        if (rootObject) {
            clonedAsset.setRootObject(rootObject.clone());
        }
        return clonedAsset;
    };
    /** @inheritdoc */
    PrefabAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.hasOwnProperty('rootObjectId')) {
            var prevRoot = this.getPreviousProperty('rootObjectId');
            if (prevRoot) {
                this.unregisterDependencyById(prevRoot);
            }
            var rootObj = this.getProperty('rootObjectId');
            if (rootObj) {
                this.registerDependencyById(rootObj);
            }
        }
    };
    /**
     * Look at the given instance object and check to see if its components contain any
     * references to objects within the prefab's hierarchy. If so, remap these references
     * to the appropriate object in its own hierarchy.
     * @param instance    The object to modify.
     * @param instanceMap A map from prefab object ID's to instance objects.
     */
    PrefabAsset.prototype.relinkComponentRefs = function (instance, instanceMap) {
        instance.getComponents().forEach(function (comp) {
            var attrDefs = comp.getScriptAsset().getAttributes();
            functions_1.forEach(comp.getAttributes(), function (attr, name) {
                // Relink if the attribute is either an array of objects...
                if (attrDefs[name].type === 'a' && attrDefs[name].subType.type === 'object') {
                    var objects_1 = [];
                    attr.forEach(function (objId) {
                        if (instanceMap[objId]) {
                            objects_1.push(instanceMap[objId].id);
                        }
                        else {
                            objects_1.push(objId);
                        }
                    });
                    comp.setAttribute(name, objects_1);
                }
                else if (attrDefs[name].type === 'object') {
                    var objId = attr;
                    if (objId && instanceMap[objId]) {
                        comp.setAttribute(name, instanceMap[objId].id);
                    }
                }
            });
        });
    };
    /**
     * Called when a PrefabAsset has been deleted. This goes through this asset and deletes any
     * instances of that prefab within this asset.
     * @param prefabId The ID of the prefab asset that was deleted
     */
    PrefabAsset.prototype.onPrefabDeleted = function (prefabId) {
        if (!this.runtimeData) {
            return;
        }
        var rootObj = this.getRootObject();
        if (!rootObj) {
            return;
        }
        rootObj.traverse(function (obj) {
            if (obj.get('prefabObjectId') === prefabId) {
                obj.breakPrefabLink();
            }
        });
    };
    /**
     * When this prefab loads, this function handles ensuring that the renderer re-renders
     * the final scene.
     */
    PrefabAsset.prototype.onPrefabLoaded = function () {
        this.engine.needsRender = true;
    };
    return PrefabAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('PrefabAsset', PrefabAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PrefabAsset;


/***/ },
/* 60 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseGeometryAsset_1 = __webpack_require__(27);
var Schemas_1 = __webpack_require__(4);
/**
 * A concreate subclass of BaseGeometryAsset that holds primitive geometry.
 * @class PrimitiveGeometryAsset
 */
var PrimitiveGeometryAsset = (function (_super) {
    tslib_1.__extends(PrimitiveGeometryAsset, _super);
    function PrimitiveGeometryAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    PrimitiveGeometryAsset.prototype.getDataSizeInMemorySelf = function () {
        // TODO: Primitive geometry should report in-memory size even before data is loaded.
        return 0;
    };
    /** @inheritdoc */
    PrimitiveGeometryAsset.prototype.createRuntimeData = function (callback) {
        this.createPrimitiveGeometry();
        this.trigger('geometryChanged', this); // TODO: do we need this?
        callback();
    };
    /** @inheritdoc */
    PrimitiveGeometryAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (reason !== 'init') {
            // Currently, any property changes cause the runtimeData to be re-created.
            this.reloadBase();
            // Keeping the return here in case we add additional property handling below.
            return;
        }
    };
    /**
     * Create and register a THREE.Geometry with the base class.
     * @method createPrimitiveGeometry
     * @private
     * @returns {void}
     */
    PrimitiveGeometryAsset.prototype.createPrimitiveGeometry = function () {
        var type = this.getProperty('type');
        var geometry;
        switch (type) {
            case 'box':
                geometry = new THREE.BoxGeometry(this.getProperty('sizeX'), this.getProperty('sizeY'), this.getProperty('sizeZ'), this.getProperty('segmentsX'), this.getProperty('segmentsY'), this.getProperty('segmentsZ'));
                break;
            case 'cylinder':
                geometry = new THREE.CylinderGeometry(this.getProperty('radiusTop'), this.getProperty('radiusBottom'), this.getProperty('height'), this.getProperty('segmentsV'), this.getProperty('segmentsU'), this.getProperty('open'));
                break;
            case 'plane':
                geometry = new THREE.PlaneGeometry(this.getProperty('sizeX'), this.getProperty('sizeY'), this.getProperty('segmentsX'), this.getProperty('segmentsY'));
                geometry.applyMatrix(new THREE.Matrix4().makeRotationX(-Math.PI / 2));
                break;
            case 'sphere':
                geometry = new THREE.SphereGeometry(this.getProperty('radius'), this.getProperty('segmentsU'), this.getProperty('segmentsV'));
                break;
            case 'torus':
                geometry = new THREE.TorusGeometry(this.getProperty('radius'), 2 * this.getProperty('tubeRadius'), this.getProperty('segmentsV'), this.getProperty('segmentsU'), this.getProperty('arcAngle'));
                break;
            default:
                Logger_1.default.error(this.engine.getName() +
                    ' - PrimitiveGeometryAsset: Unrecognized geometry type, "' +
                    type + '"');
                break;
        }
        if (geometry) {
            geometry.groupsNeedUpdate = true;
            geometry.computeBoundingBox();
            geometry.computeBoundingSphere();
            this.setGeometry(BaseGeometryAsset_1.default.primitiveType.TRIANGLES, geometry);
        }
    };
    return PrimitiveGeometryAsset;
}(BaseGeometryAsset_1.default));
Schemas_1.addSchemas('PrimitiveGeometryAsset', PrimitiveGeometryAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PrimitiveGeometryAsset;


/***/ },
/* 61 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseImageAsset_1 = __webpack_require__(10);
var BaseRenderTextureAsset_1 = __webpack_require__(43);
var Schemas_1 = __webpack_require__(4);
/**
 * An asset that holds geometry.
 * @class RenderTexture2DAsset
 * @constructor
 */
var RenderTexture2DAsset = (function (_super) {
    tslib_1.__extends(RenderTexture2DAsset, _super);
    function RenderTexture2DAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    RenderTexture2DAsset.prototype.createRTImageData = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        this.runtimeData = new THREE.WebGLRenderTarget(width, height, {
            wrapS: this.getThreeAddressMode(this.getProperty('uMapping')),
            wrapT: this.getThreeAddressMode(this.getProperty('vMapping')),
            minFilter: THREE.LinearFilter,
            magFilter: THREE.LinearFilter,
            format: BaseImageAsset_1.default.getThreeImageFormat(this.getProperty('format')),
            type: BaseImageAsset_1.default.getThreeImageType(this.getDataType()),
            stencilBuffer: this.getProperty('stencilBuffer')
        });
    };
    return RenderTexture2DAsset;
}(BaseRenderTextureAsset_1.default));
Schemas_1.addSchemas('RenderTexture2DAsset', RenderTexture2DAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RenderTexture2DAsset;


/***/ },
/* 62 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseImageAsset_1 = __webpack_require__(10);
var BaseRenderTextureAsset_1 = __webpack_require__(43);
var Schemas_1 = __webpack_require__(4);
/**
 * @class RenderTextureCubeAsset
 * @constructor
 */
var RenderTextureCubeAsset = (function (_super) {
    tslib_1.__extends(RenderTextureCubeAsset, _super);
    function RenderTextureCubeAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    RenderTextureCubeAsset.prototype.createRTImageData = function () {
        var width = this.getWidth();
        var height = this.getHeight();
        this.runtimeData = new THREE.WebGLRenderTargetCube(width, height, {
            wrapS: this.getThreeAddressMode(this.getProperty('uMapping')),
            wrapT: this.getThreeAddressMode(this.getProperty('vMapping')),
            minFilter: this.getThreeFilter(this.getMinFilter()),
            magFilter: this.getThreeFilter(this.getMagFilter()),
            format: BaseImageAsset_1.default.getThreeImageFormat(this.getProperty('format')),
            type: BaseImageAsset_1.default.getThreeImageType(this.getDataType()),
            stencilBuffer: this.getProperty('stencilBuffer')
        });
    };
    /** @inheritdoc */
    RenderTextureCubeAsset.prototype.getDataSizeInMemorySelf = function () {
        var oneFaceSize = _super.prototype.getDataSizeInMemorySelf.call(this);
        return oneFaceSize * 6;
    };
    return RenderTextureCubeAsset;
}(BaseRenderTextureAsset_1.default));
Schemas_1.addSchemas('RenderTextureCubeAsset', RenderTextureCubeAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RenderTextureCubeAsset;


/***/ },
/* 63 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseEntity_1 = __webpack_require__(11);
var BaseAsset_1 = __webpack_require__(7);
var functions_1 = __webpack_require__(6);
var Schemas_1 = __webpack_require__(4);
var ScriptAsset = (function (_super) {
    tslib_1.__extends(ScriptAsset, _super);
    function ScriptAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    ScriptAsset.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        var category = this.getProperty('category');
        if (!category) {
            this.setProperty('category', 'User Defined');
        }
        this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Succeeded);
    };
    /**
     * Return the attribute descriptions for this script.
     * @method getAttributes
     * @public
     * @return {Object} Object containing attribute descriptions, keyed by attribute name.
     */
    ScriptAsset.prototype.getAttributes = function () {
        return this.getProperty('attributes');
    };
    /**
     * Return the default values of all attributes.
     * @method getAttributeDefaults
     * @public
     * @return {Object} Object containing default attribute values, keyed by attribute name.
     */
    ScriptAsset.prototype.getAttributeDefaults = function () {
        var _this = this;
        var scriptAttributes = this.getProperty('attributes');
        return functions_1.map(scriptAttributes, function (_attr, attrName) {
            return _this.getAttributeDefault(attrName);
        });
    };
    /**
     * Return the default value of the specified attribute.
     * @method getAttributeDefault
     * @public
     * @param {string} attribName The name of the attribute.
     * @return {mixed} The default attribute value.
     */
    ScriptAsset.prototype.getAttributeDefault = function (attribName) {
        var scriptAttributes = this.getProperty('attributes');
        if (!scriptAttributes[attribName]) {
            return;
        }
        var attribute = scriptAttributes[attribName];
        if (attribute.hasOwnProperty('default')) {
            return (attribute.default);
        }
        else if (attribute.type === 'custom') {
            return functions_1.map(attribute.attributes, function (attr) { return attr.default; });
        }
        else if (attribute.type === 'a') {
            return [attribute.subType.default];
        }
    };
    return ScriptAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('ScriptAsset', ScriptAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ScriptAsset;


/***/ },
/* 64 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/*
* NAMING CONVENTION FOR EVENTS
* play  <-- to start an event, is an action
* pause <-- to pause an event, is an action
* stop  <-- to stop an event, is an action
*
* enable  <-- , is an action
* disable <-- , is an action
* toggle  <-- , is an action
*
* begin  <-- triggered when event started, not an action
* end    <-- triggered when event complete, not an action
*
* Naming convention goes as follows
* <one of the above or one of your own><describing the event>
*
* Examples:
* playAnimateAlongCurve <-- start the curve animation
* stopKeyframeAnimation <-- stop a keyframe animation from playing
* pauseAudio            <-- pause a sound
* enableFreeCameraController   <-- turn on the free camera controller
* disableOrbitCameraController <-- turn off the orbit camera controller
* toggleVisibility             <-- toggle the visibility of an object
* beginShot                    <-- a shot has begun
* endExplode                   <-- the exploder has finished animating
*
* hideAnnotationPin    <-- hides just the pin for the annotation
* setViewport
*/
"use strict";
var tslib_1 = __webpack_require__(0);
var components_builtin_1 = __webpack_require__(210);
var scriptsInitialized = false;
var scripts = {};
/**
 * All ScriptAssets are manged by this registry.
 */
var ScriptRegistry = (function () {
    /**
     * Creates an instance of ScriptRegistry.
     */
    function ScriptRegistry(engine) {
        this.engine = engine;
        if (!scriptsInitialized) {
            scriptsInitialized = true;
            ScriptRegistry.registerScripts(components_builtin_1.default);
        }
        this.initBuiltInScripts();
    }
    /**
     * Registers a script globally for use by all engines which initialize after
     * this call.
     * @param scriptAssetDef  The script asset definition
     * @param constructor     The constructor function
     */
    ScriptRegistry.registerScript = function (scriptAssetDef, constructor) {
        if (!scriptAssetDef.id) {
            throw new Error('Component definition is lacking an id attribute!');
        }
        if (!constructor) {
            throw new Error('A constructor must be provided!');
        }
        scripts[scriptAssetDef.id] = {
            def: scriptAssetDef,
            constructor: constructor
        };
    };
    /**
     * @param scripts
     */
    ScriptRegistry.registerScripts = function (scriptPairs) {
        scriptPairs.forEach(function (_a) {
            var scriptAssetDef = _a[0], constructor = _a[1];
            return ScriptRegistry.registerScript(scriptAssetDef, constructor);
        });
    };
    /**
     * Initializes all ot the built in scripts, making them available for use in the engine.
     */
    ScriptRegistry.prototype.initBuiltInScripts = function () {
        var _this = this;
        Object.keys(scripts).forEach(function (scriptId) {
            var script = scripts[scriptId];
            var scriptAsset = _this.engine.createEntity(tslib_1.__assign({}, script.def, { type: 'script' }));
            var constructor = script.constructor;
            scriptAsset.sharedData.classConstructor = constructor;
        });
    };
    return ScriptRegistry;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ScriptRegistry;


/***/ },
/* 65 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseAsset_1 = __webpack_require__(7);
var Schemas_1 = __webpack_require__(4);
/**
 * An asset that holds skinning data.
 */
var SkinAsset = (function (_super) {
    tslib_1.__extends(SkinAsset, _super);
    function SkinAsset() {
        var _this = _super.apply(this, arguments) || this;
        /** The bind-shape matrix, which is the world-space transform of the mesh. */
        _this.bindShapeMatrix = new THREE.Matrix4();
        /** The inverse bind matrices for all joints. */
        _this.inverseBindMatrices = [];
        return _this;
    }
    /** @inheritdoc */
    SkinAsset.prototype.createRuntimeData = function (callback) {
        var _this = this;
        this.when('loadDependencies', function () {
            if (_this.isDestroyed()) {
                return;
            }
            var dependencies = _this.getDependencies();
            var loadFailed = dependencies.some(function (asset) { return asset.isLoadFailed(); });
            if (!loadFailed) {
                _this.createMatrices();
            }
            callback();
        }, this);
    };
    /**
     * Get the bind-shape matrix, which is the world-space transform of the mesh.
     * @returns The bind-shape matrix.
     */
    SkinAsset.prototype.getBindShapeMatrix = function () {
        return this.bindShapeMatrix;
    };
    /**
     * Get the inverse bind matrices for all joints (@see getInverseBindMatrix).
     * @returns An array of THREE.Matrix4 instances.
     */
    SkinAsset.prototype.getInverseBindMatrices = function () {
        return this.inverseBindMatrices;
    };
    /**
     * Get the inverse bind matrix for the joint with the specified index. The
     * inverse bind matrix is the inverse, world-space transform of the joint at
     * bind-time.
     * @param index The joint index.
     * @returns     The inverse bind matrix.
     */
    SkinAsset.prototype.getInverseBindMatrix = function (index) {
        return this.inverseBindMatrices[index];
    };
    /**
     * Get the number of joints.
     * @returns The number of joints.
     */
    SkinAsset.prototype.getJointCount = function () {
        return this.getJointNames().length;
    };
    /**
     * Get the name of the joint with the specified index.
     * @param index The joint index.
     * @returns     The name of the joint.
     */
    SkinAsset.prototype.getJointName = function (index) {
        return this.getJointNames()[index];
    };
    /**
     * Get all of the joint names.
     * @returns An array of joint names.
     */
    SkinAsset.prototype.getJointNames = function () {
        return this.getProperty('jointNames');
    };
    /** @inheritdoc */
    SkinAsset.prototype.applyPropertiesUnloaded = function (changes) {
        if (changes === void 0) { changes = {}; }
        _super.prototype.applyPropertiesUnloaded.call(this, changes);
        if (changes.inverseBindMatrices) {
            var previousAccessorId = this.getPreviousProperty('inverseBindMatrices');
            var accessorId = this.getProperty('inverseBindMatrices');
            if (previousAccessorId && previousAccessorId !== accessorId) {
                var prevTokens = accessorId.split('#');
                if (prevTokens.length === 2) {
                    this.unregisterDependencyById(prevTokens[0]);
                }
            }
            var tokens = accessorId.split('#');
            if (tokens.length !== 2) {
                throw new Error(this.engine.getName() +
                    ' - SkinAsset: Invalid accessorId, ' + accessorId);
            }
            this.registerDependencyById(tokens[0]);
        }
    };
    /**
     * Create a THREE.Matrix4 instance for the bind-shape matrix and each inverse bind matrix.
     */
    SkinAsset.prototype.createMatrices = function () {
        // Initialize the bind-shape matrix.
        this.bindShapeMatrix.fromArray(this.getProperty('bindShapeMatrix'));
        // Get the inverse bind matrix array.
        var accessorId = this.getProperty('inverseBindMatrices');
        var tokens = accessorId.split('#');
        if (tokens.length !== 2) {
            throw new Error(this.engine.getName() +
                ' - SkinAsset: Invalid accessorId, ' + accessorId);
        }
        var bufferId = tokens[0];
        var buffer = this.engine.getAssetById(bufferId);
        if (!buffer) {
            throw new Error(this.engine.getName() +
                ' - SkinAsset: Invalid accessorId, ' + accessorId);
        }
        var accessorName = tokens[1];
        var accessor = buffer.getAccessor(accessorName);
        var array = buffer.getArray(accessorName);
        if (!accessor || !array) {
            throw new Error(this.engine.getName() +
                ' - SkinAsset: Invalid accessorId, ' + accessorId);
        }
        // Create THREE.Matrix4 instances for each inverse bind matrix.
        var nJoints = this.getJointCount();
        this.inverseBindMatrices = [];
        for (var i = 0; i < nJoints; ++i) {
            var subArray = array.subarray(i * 16, (i + 1) * 16);
            var transform = new THREE.Matrix4().fromArray(subArray);
            this.inverseBindMatrices.push(transform);
        }
    };
    return SkinAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('SkinAsset', SkinAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SkinAsset;


/***/ },
/* 66 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var UnpackHDRShader_1 = __webpack_require__(199);
var ShaderPass_1 = __webpack_require__(198);
var BaseTextureAsset_1 = __webpack_require__(20);
var BaseImageAsset_1 = __webpack_require__(10);
var VideoAsset_1 = __webpack_require__(30);
var Schemas_1 = __webpack_require__(4);
/**
 * @class Texture2DAsset
 * @constructor
 */
var Texture2DAsset = (function (_super) {
    tslib_1.__extends(Texture2DAsset, _super);
    function Texture2DAsset() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * Unpack this texture into a 16-bit floating point colour texture.
     * @method unpackHdrTextureData
     * @public
     * @param {Object} imageData Descriptor object for the raw image data.
     * @return {void}
     */
    Texture2DAsset.prototype.unpackHdrTextureData = function (imageData) {
        if (this.hdrSource) {
            this.hdrSource.dispose();
        }
        this.hdrSource = this.runtimeData;
        this.runtimeData = new THREE.WebGLRenderTarget(imageData.width, imageData.height, {
            // The filter settings will be overridden later by the usual method
            minFilter: this.getThreeFilter(this.getMinFilter()),
            magFilter: this.getThreeFilter(this.getMagFilter()),
            format: THREE.RGBAFormat,
            type: BaseImageAsset_1.default.getThreeImageType(this.getDataType()),
            depthBuffer: false,
            stencilBuffer: false
        });
        var packingDefines = {};
        switch (this.getHdrPackingType(imageData.channels)) {
            case 'rgbe':
                packingDefines.HDR_RGBE = 0;
                packingDefines.FLIP_Y = 0;
                break;
            default:
                packingDefines.HDR_RGBE = 0;
                packingDefines.FLIP_Y = 0;
                break;
        }
        var renderer = this.engine.getThreeRenderer();
        if (!this.hdrSource) {
            Logger_1.default.warn('Unable to unpack HDR texture because the source data is missing.');
            return;
        }
        this.hdrSource.minFilter = THREE.NearestFilter;
        this.hdrSource.magFilter = THREE.NearestFilter;
        this.hdrSource.generateMipmaps = false;
        var texture = this.getThreeTexture();
        if (!this.isLinearFilterAvailableForType(this.getDataType())) {
            texture.minFilter = THREE.NearestFilter;
            texture.magFilter = THREE.NearestFilter;
            texture.generateMipmaps = false;
        }
        if (!this.unpackHdrPass) {
            this.unpackHdrPass = new ShaderPass_1.default(UnpackHDRShader_1.default);
        }
        this.unpackHdrPass.material.defines = packingDefines;
        this.unpackHdrPass.render(renderer, this.runtimeData, this.hdrSource);
    };
    /** @inheritdoc */
    Texture2DAsset.prototype.unload = function () {
        if (this.hdrSource) {
            this.hdrSource.dispose();
            this.hdrSource = undefined;
        }
        _super.prototype.unload.call(this);
    };
    /** @inheritdoc */
    Texture2DAsset.prototype.createTextureData = function (image) {
        // If there was a previous texture loaded, dispose of it.
        if (this.runtimeData) {
            this.runtimeData.dispose();
        }
        // TODO - what about animated GIFs? Can they share logic with videos?
        if (this.getImage() instanceof VideoAsset_1.default) {
            this.runtimeData = new THREE.VideoTexture(image.imageData);
        }
        else {
            // Depending on the data returned, handle as an image tag or a compressed texture
            switch (image.compression) {
                case 'dxt':
                    this.runtimeData = this.createDxtTextureData(image.imageData);
                    break;
                default:
                    this.runtimeData = new THREE.Texture(image.imageData);
                    break;
            }
            this.runtimeData.needsUpdate = true;
            // If the image is HDR, unpack it.
            if (this.getHdrPackingType(image.channels)) {
                this.unpackHdrTextureData(image);
            }
        }
        this.runtimeData.encoding = BaseImageAsset_1.default.getThreeImageEncoding(this.getImage().getProperty('encoding'));
        this.runtimeData.name = this.getName();
    };
    return Texture2DAsset;
}(BaseTextureAsset_1.default));
Schemas_1.addSchemas('Texture2DAsset', Texture2DAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Texture2DAsset;


/***/ },
/* 67 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseTextureAsset_1 = __webpack_require__(20);
var Schemas_1 = __webpack_require__(4);
/**
 * @class TextureCubeAsset
 * @constructor
 */
var TextureCubeAsset = (function (_super) {
    tslib_1.__extends(TextureCubeAsset, _super);
    function TextureCubeAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    TextureCubeAsset.prototype.createTextureData = function (image) {
        // If there was a previous texture loaded, dispose of it.
        if (this.runtimeData) {
            this.runtimeData.dispose();
        }
        // Depending on the data returned, handle as an image tag or a compressed texture
        switch (image.compression) {
            case 'dxt':
                this.runtimeData = this.createDxtTextureData(image.imageData);
                break;
            default:
                this.runtimeData = new THREE.CubeTexture(image.imageData, THREE.CubeReflectionMapping);
                break;
        }
        if (this.getHdrPackingType(image.channels)) {
            this.createHdrTextureData(image);
        }
        this.runtimeData.name = this.getName();
    };
    /**
     * Unpack this texture into a 16-bit floating point colour texture.
     * @return {[type]} [description]
     */
    TextureCubeAsset.prototype.createHdrTextureData = function (_image) {
        throw new Error('createHdrTextureData isn\'t implemented yet.');
    };
    /** @inheritdoc */
    TextureCubeAsset.prototype.getDataSizeInMemorySelf = function () {
        var oneFaceSize = _super.prototype.getDataSizeInMemorySelf.call(this);
        return oneFaceSize * 6;
    };
    return TextureCubeAsset;
}(BaseTextureAsset_1.default));
Schemas_1.addSchemas('TextureCubeAsset', TextureCubeAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TextureCubeAsset;


/***/ },
/* 68 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * @vid audio_listener
 * @vname Audio Listener
 * @vcategory Audio
 * @vdescription Audio listener for 3D, positional sound effects
 */
"use strict";
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var AudioListener = (function (_super) {
    tslib_1.__extends(AudioListener, _super);
    function AudioListener() {
        var _this = _super.call(this) || this;
        _this.context = null;
        return _this;
    }
    /** @inheritdoc */
    AudioListener.prototype.onStartup = function () {
        this.context = this.getEntity().engine.getAudioContext();
        if (!this.context) {
            Logger_1.default.warn('Failed to create Web Audio context.');
            return;
        }
    };
    /** @inheritdoc */
    AudioListener.prototype.onUpdate = function () {
        if (this.hasRuntimeData() && this.context) {
            var xform = this.getRuntimeData().matrixWorld, objPos = new THREE.Vector3(0, 0, 0).applyMatrix4(xform), objDir = new THREE.Vector3(0, 0, -1).applyMatrix4(xform).sub(objPos).normalize(), objUp = new THREE.Vector3(0, 1, 0).applyMatrix4(xform).sub(objPos).normalize();
            this.context.listener.setPosition(objPos.x, objPos.y, objPos.z);
            this.context.listener.setOrientation(objDir.x, objDir.y, objDir.z, objUp.x, objUp.y, objUp.z);
        }
    };
    return AudioListener;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = AudioListener;


/***/ },
/* 69 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid audio_source
 * @vname Audio Source
 * @vcategory Audio
 * @vdescription Controls playback of audio assets
 * @vattr Float gain  { 'description': 'Volume control', 'default': 1.0, 'min': 0.0, 'max': 100.0 }
 * @vattr Boolean autoPlay { 'description': 'Play the audio once loaded', 'default': true }
 * @vattr Boolean loop { 'description': 'Continuously replay the audio', 'default': true }
 * @vattr Boolean preload { 'description': 'Load the audio when the component is initialized',
 *   'default': true }
 * @vattr Boolean positional { 'description': 'Enable/disable 3D, positional audio effects',
 *   'default': false }
 * @vattr Boolean stream { 'description': 'Stream the audio', 'default': false }
 * @vattr Asset asset {
 *  'description': 'Audio or video asset',
 *  'default': null,
 *  'type': 'asset',
 *  'filter': { 'audio': true, 'video': true }
 * }
 * @vevent local playAudio {'scope': 'local', 'action': true, 'category': 'Audio', 'parameters': [
 *   {'name': 'offset', 'type': 'f', 'description': 'Defined in seconds', 'default': 0}
 * ]}
 * @vevent local pauseAudio {'scope': 'local', 'action': true, 'category': 'Audio',
 *   'parameters': []}
 * @vevent local stopAudio {'scope': 'local', 'action': true, 'category': 'Audio',
 *   'parameters': []}
 * @vevent local toggleAudio {'scope': 'local', 'action': true, 'category': 'Audio',
 *   'parameters': []}
 */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var VideoAsset_1 = __webpack_require__(30);
var BaseComponent_1 = __webpack_require__(2);
var AudioSource = (function (_super) {
    tslib_1.__extends(AudioSource, _super);
    function AudioSource() {
        var _this = _super.call(this) || this;
        _this.gainNode = null;
        _this.sourceNode = null;
        _this.pannerNode = null;
        _this.context = null;
        _this.buffer = null;
        _this.startTime = 0;
        _this.playOffset = 0;
        _this.state = 'stopped';
        _this.element = null;
        _this.isVideo = false;
        return _this;
    }
    AudioSource.prototype.freeAudioGraph = function () {
        if (this.element) {
            this.element.pause();
            this.element.currentTime = 0;
        }
        if (this.sourceNode) {
            // If sourceNode is an AudioBufferSourceNode, stop it first.
            if (!this.stream) {
                this.sourceNode.stop(0);
            }
            this.sourceNode.disconnect();
            this.sourceNode = null;
        }
        if (this.gainNode) {
            this.gainNode.disconnect();
        }
        if (this.pannerNode) {
            this.pannerNode.disconnect();
        }
    };
    AudioSource.prototype.getCurrentTime = function () {
        if (this.state === 'playing') {
            if (this.element) {
                return this.element.currentTime;
            }
            else if (this.context) {
                return this.context.currentTime - this.startTime;
            }
        }
        return this.playOffset;
    };
    AudioSource.prototype.getGain = function () {
        return this.gain;
    };
    AudioSource.prototype.getState = function () {
        return this.state;
    };
    /** @inheritdoc */
    AudioSource.prototype.onStartup = function () {
        this.context = this.getEntity().engine.getAudioContext();
        if (this.context) {
            this.gainNode = this.context.createGain();
            this.pannerNode = this.context.createPanner();
        }
        else {
            Logger_1.default.warn('No audio context, using fallback.');
            this.stream = true; // Must stream via an audio element.
            this.positional = false; // Positional audio not supported.
        }
        // Always stream video assets.
        this.isVideo = this.asset instanceof VideoAsset_1.default;
        if (this.isVideo) {
            this.stream = true;
        }
        if (this.autoPlay) {
            this.play();
        }
        else if (this.preload) {
            this.load(function (err) {
                if (err) {
                    Logger_1.default.warn(err);
                }
            });
        }
        this.listenTo(this.getEntity(), 'playAudio', this.play);
        this.listenTo(this.getEntity(), 'pauseAudio', this.pause);
        this.listenTo(this.getEntity(), 'stopAudio', this.stop);
        this.listenTo(this.getEntity(), 'toggleAudio', this.toggle);
    };
    AudioSource.prototype.initAudioGraph = function (fn) {
        var that = this;
        this.load(function (err, source) {
            if (err) {
                return fn(err);
            }
            else if (!that.context) {
                return fn(null, null);
            }
            var nodes = [];
            if (that.stream) {
                that.sourceNode = that.context.createMediaElementSource(source);
            }
            else {
                that.sourceNode = that.context.createBufferSource();
                that.sourceNode.buffer = source;
            }
            nodes.push(that.sourceNode);
            nodes.push(that.gainNode);
            if (that.positional) {
                nodes.push(that.pannerNode);
            }
            nodes.push(that.context.destination);
            for (var iNode = 1; iNode < nodes.length; ++iNode) {
                nodes[iNode - 1].connect(nodes[iNode]);
            }
            fn(null, that.sourceNode);
        });
    };
    AudioSource.prototype.isLoop = function () {
        return this.loop;
    };
    AudioSource.prototype.isPaused = function () {
        return this.state === 'paused';
    };
    AudioSource.prototype.isPlaying = function () {
        return this.state === 'playing';
    };
    AudioSource.prototype.isStopped = function () {
        return this.state === 'stopped';
    };
    AudioSource.prototype.load = function (fn) {
        var that = this;
        // Return the element or buffer, if they have already been created.
        if (this.stream && this.element) {
            return fn(null, this.element);
        }
        else if (!this.stream && this.buffer) {
            return fn(null, this.buffer);
        }
        if (!this.asset) {
            return fn(new Error('No audio asset'));
        }
        // If we are streaming, load the audio asset and reference the audio or video
        // element. If we aren't streaming, load the entire file into an audio buffer.
        if (this.stream) {
            this.asset.load(function (asset) {
                if (!asset) {
                    return fn(new Error('Error loading audio/video file'));
                }
                if (that.isVideo) {
                    that.element = asset.runtimeData.image;
                }
                else {
                    that.element = asset.runtimeData;
                }
                fn(null, that.element);
            });
        }
        else {
            if (!this.context) {
                return fn(new Error('No Web Audio context'));
            }
            var xhr = new XMLHttpRequest();
        }
    };
    AudioSource.prototype.pause = function () {
        if (this.state === 'playing') {
            // The order of these function calls is important: getCurrentTime() must be
            // called while state is 'playing' and before freeAudioGraph().
            this.playOffset = this.getCurrentTime();
            this.state = 'paused';
            this.freeAudioGraph();
        }
    };
    AudioSource.prototype.play = function (offset) {
        if (this.state === 'paused' || this.state === 'stopped') {
            var that = this;
            // Add the specified offset to the current play offset.
            offset = offset !== undefined ? offset : 0;
            this.playOffset += offset;
            this.initAudioGraph(function (err) {
                if (err) {
                    Logger_1.default.warn('Error playing audio: ' + err);
                    return;
                }
                // Update the gain and loop settings.
                that.setGain(that.gain);
                that.setLoop(that.loop);
                // If we are streaming, play the audio/video element; otherwise, play the
                // buffer source node.
                if (that.stream) {
                    that.element.currentTime = that.playOffset;
                    that.element.play();
                }
                else if (that.context) {
                    that.startTime = that.context.currentTime;
                    that.sourceNode.start(0, that.playOffset);
                }
                else {
                    Logger_1.default.warn('No Web Audio context.');
                }
                that.state = 'playing';
            });
        }
    };
    AudioSource.prototype.setGain = function (gain) {
        this.gain = gain;
        // If we have a gain node, set the gain on it; otherwise, set the gain on the
        // audio/video element.
        if (this.gainNode) {
            this.gainNode.gain.value = this.gain;
        }
        else if (this.element) {
            this.element.volume = this.gain;
        }
    };
    AudioSource.prototype.setLoop = function (loop) {
        this.loop = loop;
        if (this.element) {
            this.element.loop = this.loop;
        }
        else if (this.sourceNode) {
            this.sourceNode.loop = this.loop;
        }
    };
    AudioSource.prototype.stop = function () {
        if (this.state === 'playing' || this.state === 'paused') {
            this.playOffset = 0;
            this.state = 'stopped';
            this.freeAudioGraph();
        }
    };
    AudioSource.prototype.toggle = function () {
        if (this.state === 'playing') {
            this.pause();
        }
        else {
            this.play();
        }
    };
    /** @inheritdoc */
    AudioSource.prototype.onUpdate = function () {
        if (this.hasRuntimeData() && this.positional) {
            var xform = this.getRuntimeData().matrixWorld, objPos = new THREE.Vector3(0, 0, 0).applyMatrix4(xform), objDir = new THREE.Vector3(0, 0, 1).applyMatrix4(xform).sub(objPos).normalize();
            this.pannerNode.setPosition(objPos.x, objPos.y, objPos.z);
            this.pannerNode.setOrientation(objDir.x, objDir.y, objDir.z);
        }
    };
    return AudioSource;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = AudioSource;


/***/ },
/* 70 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid bounding_box_renderer
 * @vname BoundingBox Renderer
 * @vcategory Rendering
 * @vfilter object
 */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var MeshObject_1 = __webpack_require__(47);
var BoundingBoxRenderer = (function (_super) {
    tslib_1.__extends(BoundingBoxRenderer, _super);
    function BoundingBoxRenderer() {
        var _this = _super.apply(this, arguments) || this;
        /**
         * Automatically render bounding boxes for all meshes in the hierarchy.
         * @vattr bool recursive {
         *   default: true,
         *   description: 'Automatically render bounding boxes for all meshes in the hierarchy'
         * }
         */
        _this.recursive = true;
        /**
         * The geometry used to render the bounding boxes.
         */
        _this.boxGeometry = new THREE.BoxGeometry(1, 1, 1);
        /** The material to render the top bounding box with. */
        _this.topBoxMaterial = new THREE.MeshBasicMaterial({ color: 0x0011ff, wireframe: true });
        /** The material to render all sub-meshes with. */
        _this.subBoxMaterial = new THREE.MeshBasicMaterial({ color: 0xff0800, wireframe: true });
        /** Internal Box3 for doing calculations. To avoid repeated allocation of Box3's. */
        _this.workBounds = new THREE.Box3();
        /**
         * An internal array of all the created BB helpers. Used to enable and disable the
         * BB's at anytime.
         */
        _this.helpers = [];
        return _this;
    }
    /** @inheritdoc */
    BoundingBoxRenderer.prototype.onStartup = function () {
        var _this = this;
        var object = this.getEntity();
        if (this.recursive) {
            object.getDescendantsByType('mesh').forEach(function (mesh) {
                _this.createBoundingBox(mesh, _this.subBoxMaterial);
            });
        }
        this.createBoundingBox(object, this.topBoxMaterial, false);
    };
    /** @inheritdoc */
    BoundingBoxRenderer.prototype.onShutdown = function () {
        this.helpers.forEach(function (helper) {
            if (helper.boxMesh.parent) {
                helper.boxMesh.parent.remove(helper.boxMesh);
            }
        });
    };
    /** @inheritdoc */
    BoundingBoxRenderer.prototype.onEnable = function () {
        this.helpers.forEach(function (helper) { return helper.boxMesh.visible = true; });
    };
    /** @inheritdoc */
    BoundingBoxRenderer.prototype.onDisable = function () {
        this.helpers.forEach(function (helper) { return helper.boxMesh.visible = false; });
    };
    /**
     * Setup bounding box rendering for the given object.
     * @param object The mesh to setup the BB render for.
     * @param hexColor The hexidecimal color used to render the bounding box.
     */
    BoundingBoxRenderer.prototype.createBoundingBox = function (object, material, localBounds) {
        var _this = this;
        if (localBounds === void 0) { localBounds = true; }
        if (!object) {
            return;
        }
        object.when('loadBase', function () {
            var bounds = object instanceof MeshObject_1.default && localBounds ?
                object.getLocalBounds(_this.workBounds) : object.getBounds(_this.workBounds);
            var boxHelper = {
                boxMesh: new THREE.Mesh(_this.boxGeometry, material),
                object: object,
                bounds: bounds
            };
            if (!_this.isEnabled()) {
                boxHelper.boxMesh.visible = false;
            }
            _this.helpers.push(boxHelper);
            boxHelper.bounds.getSize(boxHelper.boxMesh.scale);
            boxHelper.bounds.getCenter(boxHelper.boxMesh.position);
            object.runtimeData.add(boxHelper.boxMesh);
        });
    };
    return BoundingBoxRenderer;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BoundingBoxRenderer;


/***/ },
/* 71 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @author Mike Bond
 * A component to make rendering to a cube map easier.
 *
 * @class CubeMapCapture
 * @vid cubemap_capture
 * @vname Cube-Map Capture
 * @vcategory Rendering
 * @vreserved
 * @vfilter Object
 */
var CubeMapCapture = (function (_super) {
    tslib_1.__extends(CubeMapCapture, _super);
    /**
     * Creates an instance of CubeMapCapture.
     */
    function CubeMapCapture() {
        var _this = _super.call(this) || this;
        _this.framesElapsed = 0;
        _this.near = 1.0;
        _this.far = 12000.0;
        _this.updateFrameInterval = 0.0;
        _this.cubeMaterial = undefined;
        _this.tempRenderTexture = undefined;
        return _this;
    }
    /** @inheritdoc */
    CubeMapCapture.prototype.onStartup = function () {
        this.initCameras();
    };
    /** @inheritdoc */
    CubeMapCapture.prototype.onShutdown = function () {
        this.getRuntimeData().remove(this.cubeCamera);
    };
    /** @inheritdoc */
    CubeMapCapture.prototype.onEntityLoaded = function () {
        var threeData = this.getRuntimeData();
        threeData.add(this.cubeCamera);
    };
    /** @inheritdoc */
    CubeMapCapture.prototype.onAttributesChanged = function (changes) {
        var _this = this;
        if (changes.indexOf('captureTexture') !== -1) {
            if (this.captureTexture) {
                this.captureTexture.when('load', function () {
                    if (_this.tempRenderTexture) {
                        _this.tempRenderTexture.unload();
                    }
                });
                if (this.captureTexture.isBaseUnloaded()) {
                    this.captureTexture.load();
                }
            }
            else if (!this.tempRenderTexture) {
                this.createTempRenderTexture();
            }
        }
        if (changes.indexOf('near') !== -1 || changes.indexOf('far') !== -1) {
            this.cameraPX.near = this.near;
            this.cameraPX.far = this.far;
            this.cameraPX.updateProjectionMatrix();
            this.cameraNX.near = this.near;
            this.cameraNX.far = this.far;
            this.cameraNX.updateProjectionMatrix();
            this.cameraPY.near = this.near;
            this.cameraPY.far = this.far;
            this.cameraPY.updateProjectionMatrix();
            this.cameraNY.near = this.near;
            this.cameraNY.far = this.far;
            this.cameraNY.updateProjectionMatrix();
            this.cameraPZ.near = this.near;
            this.cameraPZ.far = this.far;
            this.cameraPZ.updateProjectionMatrix();
            this.cameraNZ.near = this.near;
            this.cameraNZ.far = this.far;
            this.cameraNZ.updateProjectionMatrix();
        }
        if (changes.indexOf('debugView') !== -1) {
            this.cubeCamera.traverse(function (obj) {
                if (obj instanceof THREE.PerspectiveCamera) {
                    // FIXME: Should we be attaching this camera helper like this?
                    if (!obj.cameraHelper) {
                        obj.cameraHelper = new THREE.CameraHelper(obj);
                        _this.getRootThreeObject().add(obj.cameraHelper);
                    }
                    obj.cameraHelper.visible = !!_this.debugView;
                }
            });
        }
    };
    /**
     * Render the scene to the texture.
     * @method captureScene
     * @public
     * @return {void}
     */
    CubeMapCapture.prototype.captureScene = function () {
        var renderer = this.getRenderer();
        var scene = this.getRootThreeObject();
        var renderTarget = this.captureTexture ? this.captureTexture.runtimeData :
            this.tempRenderTexture.runtimeData;
        if (renderTarget) {
            var generateMipmaps_1 = renderTarget.texture.generateMipmaps;
            var cameras_1 = [];
            var faces_1 = [];
            renderTarget.texture.generateMipmaps = false;
            if (this.renderPosX) {
                faces_1.push(0);
                cameras_1.push(this.cameraPX);
            }
            if (this.renderNegX) {
                faces_1.push(1);
                cameras_1.push(this.cameraNX);
            }
            if (this.renderPosY) {
                faces_1.push(2);
                cameras_1.push(this.cameraPY);
            }
            if (this.renderNegY) {
                faces_1.push(3);
                cameras_1.push(this.cameraNY);
            }
            if (this.renderPosZ) {
                faces_1.push(4);
                cameras_1.push(this.cameraPZ);
            }
            if (this.renderNegZ) {
                faces_1.push(5);
                cameras_1.push(this.cameraNZ);
            }
            cameras_1.forEach(function (camera, idx) {
                if (idx === cameras_1.length - 1) {
                    renderTarget.texture.generateMipmaps = generateMipmaps_1;
                }
                renderTarget.activeCubeFace = faces_1[idx];
                renderer.renderView(scene, camera, {
                    renderTarget: renderTarget,
                    clearColor: true
                });
            });
            renderTarget.needsUpdate = true;
        }
    };
    /** @inheritdoc */
    CubeMapCapture.prototype.onPreRender = function () {
        var scene = this.getRootObject();
        if (!scene.isLoaded()) {
            return;
        }
        this.framesElapsed++;
        if (this.framesElapsed >= this.updateFrameInterval && this.isEnabled()) {
            this.framesElapsed = 0.0;
            this.captureScene();
        }
    };
    /**
     * Creates a temporary render texture.
     * @private
     */
    CubeMapCapture.prototype.createTempRenderTexture = function () {
        this.tempRenderTexture = this.getEngine().createRenderTextureCube({
            width: 512,
            height: 512,
            format: 'rgba',
            type: 'uByte'
        }, 'render_tex_cube');
        this.tempRenderTexture.load();
    };
    /**
     * Called immediately after after component creation
     * @private
     * @returns {void}
     */
    CubeMapCapture.prototype.initCameras = function () {
        this.cubeCamera = new THREE.Object3D();
        // this.cubeCamera.position.copy( this.getEntity().getPosition() );
        var fov = 90;
        var aspect = 1;
        this.cameraPX = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraPX.up.set(0, -1, 0);
        this.cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
        this.cubeCamera.add(this.cameraPX);
        this.cameraNX = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraNX.up.set(0, -1, 0);
        this.cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
        this.cubeCamera.add(this.cameraNX);
        this.cameraPY = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraPY.up.set(0, 0, 1);
        this.cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
        this.cubeCamera.add(this.cameraPY);
        this.cameraNY = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraNY.up.set(0, 0, -1);
        this.cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
        this.cubeCamera.add(this.cameraNY);
        this.cameraPZ = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraPZ.up.set(0, -1, 0);
        this.cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
        this.cubeCamera.add(this.cameraPZ);
        this.cameraNZ = new THREE.PerspectiveCamera(fov, aspect, this.near, this.far);
        this.cameraNZ.up.set(0, -1, 0);
        this.cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
        this.cubeCamera.add(this.cameraNZ);
    };
    return CubeMapCapture;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CubeMapCapture;


/***/ },
/* 72 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid curve_component
 * @vname Curve
 * @vfilter object
 * @vreserved
 * @vdescription Creates a spline curve that can be used for various things, including making objects follow it. Add controls points to shape the curve.
 * @vcategory General
 * @vattr Object[] controlPoints {
 *   description: 'The list of objects that define the curve shape.'
 * }
 * @vattr Boolean closed {
 *   description: 'If toggled, the start and end of the curve will be smoothly joined.',
 *   default: false
 * }
 */
var Logger_1 = __webpack_require__(3);
var functions_1 = __webpack_require__(6);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @author Mike Bond
 * A component to render spline curves.
 *
 * @class Curve
 */
var Curve = (function (_super) {
    tslib_1.__extends(Curve, _super);
    function Curve() {
        var _this = _super.call(this) || this;
        _this.isEditor = false;
        _this.controlPoints = undefined;
        _this.prevControlPointsLength = 0;
        _this.closed = false;
        //Editor
        _this.cameraPosition = new THREE.Vector3();
        _this.tempPosition = new THREE.Vector3();
        _this.tempVector = new THREE.Vector3();
        _this.tempVector4 = new THREE.Vector4();
        _this.tempMatrix = new THREE.Matrix4();
        _this.editorCurveColour = 0x222222;
        _this.editorCurveSelectedColour = 0x0d56a6;
        _this.orientationHelpers = [];
        _this.canTryUpdateAgain = true;
        _this.curveMaterial = undefined;
        _this.curveGeometry = undefined;
        _this.curveMesh = undefined;
        _this.curveTesselation = 200;
        _this.selected = false;
        _this.updateStarted = false;
        return _this;
    }
    /** @inheritdoc */
    Curve.prototype.onStartup = function () {
        this.initCurve();
    };
    Curve.prototype.onSelected = function () {
        this.selected = true;
        if (this.curveMaterial) {
            this.curveMaterial.color.setHex(this.editorCurveSelectedColour);
        }
        function show(obj) {
            obj.visible = true;
        }
        for (var i = 0; i < this.orientationHelpers.length; i++) {
            this.orientationHelpers[i].traverse(show);
        }
    };
    Curve.prototype.onUnselected = function () {
        this.selected = false;
        if (this.curveMaterial) {
            this.curveMaterial.color.setHex(this.editorCurveColour);
        }
        function hide(obj) {
            obj.visible = false;
        }
        for (var i = 0; i < this.orientationHelpers.length; i++) {
            this.orientationHelpers[i].traverse(hide);
        }
    };
    Curve.prototype.initCurve = function () {
        if (!this.updateStarted && this.controlPoints && this.controlPoints.length) {
            this.updateStarted = true;
            this.cleanupCurveMesh();
            this.cleanupOrientationHelpers();
            this.prevControlPointsLength = this.controlPoints.length;
            this.createCurve();
        }
    };
    Curve.prototype.isCurveInit = function () {
        return this.curve.points.length > 0;
    };
    Curve.prototype.createCurve = function () {
        for (var i in this.controlPoints) {
            if (this.controlPoints[i]) {
                this.controlPoints[i].off('propertyChanges', this.updateCurve, this);
            }
        }
        if (this.closed) {
            this.curve = new THREE.ClosedSplineCurve3();
        }
        else {
            this.curve = new THREE.SplineCurve3();
        }
        var that = this;
        var scene = this.getEntity().getRootObject();
        scene.when('loadDependencies', function (scene) {
            var _this = this;
            scene.runtimeData.updateMatrixWorld(true);
            functions_1.forEach(that.controlPoints, function (point) {
                if (point) {
                    var newPos = new THREE.Vector3();
                    _this.curve.points.push(newPos);
                    _this.tempMatrix.makeRotationFromQuaternion(point.runtimeData.quaternion);
                    var matArray = _this.tempMatrix.toArray();
                    _this.tempVector.set(matArray[0], matArray[1], matArray[2]);
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, newPos, 1, 0xff0000));
                    _this.tempVector.set(matArray[4], matArray[5], matArray[6]);
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, newPos, 1, 0x00ff00));
                    _this.tempVector.set(matArray[8], matArray[9], matArray[10]);
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, newPos, 1, 0x0000ff));
                    point.on('propertyChanges', that.updateCurve, that);
                }
                else {
                    _this.tempVector.set(0, 0, 0);
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, _this.tempVector, 1, 0xff0000));
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, _this.tempVector, 1, 0xff0000));
                    _this.orientationHelpers.push(new THREE.ArrowHelper(_this.tempVector, _this.tempVector, 1, 0xff0000));
                }
            });
            that.updateCurve({});
            that.updateStarted = false;
            if (!this.selected) {
                this.onUnselected();
            }
            that.trigger('curveInit');
        }, this);
    };
    Curve.prototype.updateCurve = function (changes) {
        var _this = this;
        var index = 0;
        if (changes.hasOwnProperty('position')) {
            functions_1.forEach(this.controlPoints, function (point) {
                if (point) {
                    if (point.runtimeData.parent) {
                        point.getPosition(_this.tempVector);
                        _this.tempVector4.set(_this.tempVector.x, _this.tempVector.y, _this.tempVector.z, 1.0);
                        _this.tempVector4.applyMatrix4(point.runtimeData.parent.matrixWorld);
                        _this.curve.points[index].set(_this.tempVector4.x, _this.tempVector4.y, _this.tempVector4.z);
                        index++;
                    }
                    else if (_this.canTryUpdateAgain) {
                        _this.canTryUpdateAgain = false;
                        setTimeout(function () {
                            Logger_1.default.info('Trying again');
                            this.updateCurve();
                        }.bind(_this), 10);
                    }
                }
            });
            if (this.isEditor) {
                this.cleanupCurveMesh();
                this.createCurveMesh();
            }
            this.canTryUpdateAgain = true;
        }
        if (changes.hasOwnProperty('quaternion')) {
            this.updateOrientationHelpers();
        }
    };
    Curve.prototype.cleanupCurveMaterial = function () {
        if (this.curveMaterial) {
            this.curveMaterial.dispose();
            this.curveMaterial = undefined;
        }
    };
    Curve.prototype.cleanupOrientationHelpers = function () {
        var _this = this;
        this.orientationHelpers.forEach(function (helper) {
            _this.getRootThreeObject().remove(helper);
        });
        this.orientationHelpers = [];
    };
    Curve.prototype.cleanupCurveMesh = function () {
        if (this.isEditor && this.curveMesh) {
            this.getEngine().globalEvents.trigger('studioApp::unregisterPickingObject', this.getEntity(), this.curveMesh);
            this.getRootThreeObject().remove(this.curveMesh);
            this.curveGeometry.dispose();
            this.curveMesh.material = undefined;
        }
    };
    Curve.prototype.createCurveMesh = function () {
        if (!this.curveMaterial) {
            this.curveMaterial = new THREE.MeshBasicMaterial({
                color: this.editorCurveColour,
                transparent: true,
                opacity: 0.75,
                blending: THREE.AdditiveBlending
            });
        }
        if (this.curve.points.length) {
            this.curveGeometry = new THREE.TubeGeometry(this.curve, this.curveTesselation, 2.5, 8, this.closed);
            this.curveMesh = new THREE.Mesh(this.curveGeometry, this.curveMaterial);
            this.getRootObject().once('loadBase', function () {
                var _this = this;
                this.getRootThreeObject().add(this.curveMesh);
                functions_1.forEach(this.orientationHelpers, function (helper) {
                    _this.getRootThreeObject().add(helper);
                });
            }, this);
            this.getRootObject().once('load', function () {
                this.getEngine().globalEvents.trigger('studioApp::registerPickingObject', this.getEntity(), this.curveMesh);
                this.getGlobalEvents().on('studioApp::toggleVisualization', this.toggleVisualization, this);
            }, this);
            this.getRootObject().load();
            this.updateOrientationHelpers();
        }
    };
    //Update arrow helpers when a control point's quaternion changes
    Curve.prototype.updateOrientationHelpers = function () {
        for (var i = 0; i < this.controlPoints.length; i++) {
            if (this.controlPoints[i]) {
                var obj = this.controlPoints[i].runtimeData;
                this.orientationHelpers[i * 3].position.copy(this.curve.points[i]);
                this.orientationHelpers[i * 3 + 1].position.copy(this.curve.points[i]);
                this.orientationHelpers[i * 3 + 2].position.copy(this.curve.points[i]);
                this.tempMatrix.makeRotationFromQuaternion(obj.quaternion);
                var matArray = this.tempMatrix.toArray();
                this.tempVector.set(matArray[0], matArray[1], matArray[2]);
                this.orientationHelpers[i * 3].setDirection(this.tempVector);
                this.tempVector.set(matArray[4], matArray[5], matArray[6]);
                this.orientationHelpers[i * 3 + 1].setDirection(this.tempVector);
                this.tempVector.set(matArray[8], matArray[9], matArray[10]);
                this.orientationHelpers[i * 3 + 2].setDirection(this.tempVector);
            }
        }
    };
    /** @inheritdoc */
    Curve.prototype.onAttributesChanged = function () {
        this.initCurve();
    };
    Curve.prototype.toggleVisualization = function () {
        var that = this;
        this.curveMesh.visible = !this.curveMesh.visible;
        function toggle(obj) {
            obj.visible = that.selected && !obj.visible;
        }
        for (var i = 0; i < this.orientationHelpers.length; i++) {
            this.orientationHelpers[i].traverse(toggle);
        }
    };
    return Curve;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Curve;


/***/ },
/* 73 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid debug_console_display
 * @vname Debug Console Display
 * @vcategory Debug
 * @vfilter Application
 */
var BaseComponent_1 = __webpack_require__(2);
var DebugConsoleDisplay = (function (_super) {
    tslib_1.__extends(DebugConsoleDisplay, _super);
    function DebugConsoleDisplay() {
        return _super.call(this) || this;
    }
    /** @inheritdoc */
    DebugConsoleDisplay.prototype.onStartup = function () {
        var logTag = document.createElement('div');
        logTag.id = 'consoleLogger';
        logTag.style.position = 'absolute';
        logTag.style.top = '0';
        logTag.style.left = '0';
        logTag.style.width = '100%';
        logTag.style.height = '100%';
        logTag.style.margin = '0';
        logTag.style.padding = '0';
        logTag.style.color = '#fff';
        logTag.style.fontWeight = 'bold';
        logTag.style.textAlign = 'left';
        logTag.style.overflow = 'scroll';
        logTag.style['pointer-events'] = 'none';
        window.document.body.appendChild(logTag);
        window.console.log = window.console.error = window.console.warn = function (text) {
            logTag.innerHTML += text + '<br>';
        };
    };
    return DebugConsoleDisplay;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DebugConsoleDisplay;


/***/ },
/* 74 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid debug_performance
 * @vname Debug Performance
 * @vcategory Debug
 * @vfilter Application
 */
var BaseComponent_1 = __webpack_require__(2);
var Stats = __webpack_require__(245);
var DebugPerformance = (function (_super) {
    tslib_1.__extends(DebugPerformance, _super);
    function DebugPerformance() {
        var _this = _super.call(this) || this;
        _this.stats = new Stats();
        _this.initialized = false;
        return _this;
    }
    /** @inheritdoc */
    DebugPerformance.prototype.onStartup = function () {
        this.stats.showPanel(0); // 0: fps, 1: ms, 2: mb, 3+: custom
    };
    /** @inheritdoc */
    DebugPerformance.prototype.onPreUpdate = function () {
        if (this.isEnabled()) {
            this.stats.begin();
        }
    };
    /** @inheritdoc */
    DebugPerformance.prototype.onPostRender = function () {
        if (this.isEnabled()) {
            this.stats.end();
        }
    };
    /** @inheritdoc */
    DebugPerformance.prototype.onEnable = function () {
        document.body.appendChild(this.stats.dom);
        this.initialized = true;
    };
    /** @inheritdoc */
    DebugPerformance.prototype.onDisable = function () {
        if (this.initialized) {
            document.body.removeChild(this.stats.dom);
            this.initialized = false;
        }
    };
    return DebugPerformance;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DebugPerformance;


/***/ },
/* 75 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var functions_1 = __webpack_require__(6);
var CopyShader_1 = __webpack_require__(197);
var elementCss = {
    position: 'absolute',
    left: '0',
    top: '0',
    padding: '8px',
    'border-radius': '5px',
    'font-family': 'proxima_nova_regular,Helvetica,Arial,sans-serif',
    'max-width': '25%',
    'min-width': '25px',
    transition: 'opacity 0.1s ease-in-out, background 0.1s ease-in-out',
    cursor: 'pointer'
};
/**
 * Changes the css styles for a given element.
 * @param el The element.
 * @param styles An object of key-value pairs representing the styles.
 */
function css(el, styles) {
    if (!el || !el.style) {
        return;
    }
    for (var i in styles) {
        if (styles.hasOwnProperty(i)) {
            el.style[i] = styles[i];
        }
    }
}
/**
 * Adds a class to the given element.
 * @param el The element.
 * @param className The class name to add.
 */
function addClass(el, className) {
    if (el.classList) {
        el.classList.add(className);
    }
    else {
        el.className += ' ' + className;
    }
}
/**
 * @vid debug_texture_viewer
 * @vname Debug Texture Viewer
 * @vreserved
 * @vcategory Debug
 * @vfilter Application
 */
var DebugTextureViewer = (function (_super) {
    tslib_1.__extends(DebugTextureViewer, _super);
    /**
     * Creates an instance of DebugTextureViewer.
     */
    function DebugTextureViewer() {
        var _this = _super.call(this) || this;
        _this.renderEventName = 'render';
        _this.textureRegistryById = {};
        return _this;
    }
    /** @inheritdoc */
    DebugTextureViewer.prototype.onAwake = function () {
        this.getEngine().on('assetLoaded', this.registerTexture, this);
        this.getEngine().on('assetUnloaded', this.unregisterTexture, this);
    };
    /** @inheritdoc */
    DebugTextureViewer.prototype.onStartup = function () {
        var _this = this;
        this.init2dScene();
        this.initCubeScene();
        this.renderEventName += 'Group' + this.renderGroup;
        this.getEngine().on(this.renderEventName, this.renderView, this);
        this.getEngine().on('resize', this.resize, this);
        var assetTypes = ['texture2D', 'textureCube', 'renderTexture2D', 'renderTextureCube'];
        var textures = [];
        assetTypes.forEach(function (type) { return textures.push.apply(textures, _this.getEngine().getAssetsByType(type)); });
        textures.forEach(function (tex) { return _this.registerTexture(tex); });
        this.resize();
    };
    /** @inheritdoc */
    DebugTextureViewer.prototype.onShutdown = function () {
        this.getEngine().off('assetLoaded', this.registerTexture, this);
        this.getEngine().off('assetUnloaded', this.unregisterTexture, this);
        this.getEngine().off(this.renderEventName, this.renderView, this);
        this.getEngine().off('resize', this.resize, this);
    };
    /**
     * Initializes the 2D scene.
     */
    DebugTextureViewer.prototype.init2dScene = function () {
        this.camera2D = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.scene2D = new THREE.Scene();
        this.material2D = new THREE.ShaderMaterial(CopyShader_1.default);
        this.mesh2D = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), this.material2D);
        this.scene2D.add(this.mesh2D);
    };
    /**
     * Initializes the cube scene.
     */
    DebugTextureViewer.prototype.initCubeScene = function () {
        var fov = 90;
        var aspect = 1;
        var cubeShader = THREE.ShaderLib.cube;
        this.sceneCube = new THREE.Scene();
        this.geoCube = new THREE.BoxGeometry(100, 100, 100);
        this.materialCube = new THREE.ShaderMaterial({
            fragmentShader: cubeShader.fragmentShader,
            vertexShader: cubeShader.vertexShader,
            uniforms: cubeShader.uniforms,
            depthWrite: false,
            depthTest: false,
            side: THREE.BackSide
        });
        this.meshCube = new THREE.Mesh(this.geoCube, this.materialCube);
        this.cameraPX = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraPX.up.set(0, 1, 0);
        this.cameraPX.lookAt(new THREE.Vector3(1, 0, 0));
        this.sceneCube.add(this.cameraPX);
        this.cameraNX = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraNX.up.set(0, 1, 0);
        this.cameraNX.lookAt(new THREE.Vector3(-1, 0, 0));
        this.sceneCube.add(this.cameraNX);
        this.cameraPY = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraPY.up.set(0, 0, -1);
        this.cameraPY.lookAt(new THREE.Vector3(0, 1, 0));
        this.sceneCube.add(this.cameraPY);
        this.cameraNY = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraNY.up.set(0, 0, 1);
        this.cameraNY.lookAt(new THREE.Vector3(0, -1, 0));
        this.sceneCube.add(this.cameraNY);
        this.cameraPZ = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraPZ.up.set(0, 1, 0);
        this.cameraPZ.lookAt(new THREE.Vector3(0, 0, 1));
        this.sceneCube.add(this.cameraPZ);
        this.cameraNZ = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameraNZ.up.set(0, 1, 0);
        this.cameraNZ.lookAt(new THREE.Vector3(0, 0, -1));
        this.sceneCube.add(this.cameraNZ);
        this.sceneCube.add(this.meshCube);
    };
    /**
     * Sets the texture to debug.
     * @param textureId The id of the texture
     */
    DebugTextureViewer.prototype.setTexture = function (textureId) {
        var _this = this;
        this.currentTexture = this.textureRegistryById[textureId];
        if (this.currentTexture) {
            this.currentTexture.load(function () {
                /* tslint:disable no-string-literal */
                // Rule disabled as uniforms is used as a mapping of strings to uniforms rather than a strongly typed
                // object.
                switch (_this.currentTexture.type) {
                    case 'renderTextureCube':
                    case 'textureCube':
                        _this.materialCube.uniforms['tCube'].value = _this.currentTexture.getThreeTexture();
                        break;
                    case 'texture2D':
                    case 'renderTexture2D':
                        _this.material2D.uniforms['tDiffuse'].value = _this.currentTexture.getThreeTexture();
                        break;
                    default: // nothing
                }
                /* tslint:enable no-string-literal */
                _this.mesh2D.visible = true;
                _this.meshCube.visible = true;
            });
        }
        else {
            this.mesh2D.visible = false;
            this.meshCube.visible = false;
        }
    };
    /**
     * Updates the viewport, useful after resize, etc.
     */
    DebugTextureViewer.prototype.updateViewport = function () {
        var percent;
        var cWidth = this.getEngine().getRenderer().getWidth();
        var cHeight = this.getEngine().getRenderer().getHeight();
        if (this.viewportBottom.slice(-1) === '%') {
            percent = parseFloat(this.viewportBottom.slice(0, -1)) * 0.01;
            this.y = percent * cHeight;
        }
        else {
            this.y = parseInt(this.viewportBottom, 10);
        }
        if (this.viewportLeft.slice(-1) === '%') {
            percent = parseFloat(this.viewportLeft.slice(0, -1)) * 0.01;
            this.x = percent * cWidth;
        }
        else {
            this.x = parseInt(this.viewportLeft, 10);
        }
        if (this.viewportWidth.slice(-1) === '%') {
            percent = parseFloat(this.viewportWidth.slice(0, -1)) * 0.01;
            this.width = percent * cWidth;
        }
        else {
            this.width = parseInt(this.viewportWidth, 10);
        }
        if (this.viewportHeight.slice(-1) === '%') {
            percent = parseFloat(this.viewportHeight.slice(0, -1)) * 0.01;
            this.height = percent * cHeight;
        }
        else {
            this.height = parseInt(this.viewportHeight, 10);
        }
        if (this.x < 0) {
            this.x += cWidth;
        }
        if (this.y < 0) {
            this.y += cHeight;
        }
    };
    /**
     * Updates the texture dropdown dom element.
     */
    DebugTextureViewer.prototype.updateTextureDropdown = function () {
        var _this = this;
        if (this.isEnabled()) {
            setTimeout(function () {
                var newOption;
                if (!_this.textureDropDown) {
                    _this.textureDropDown = document.createElement('select');
                    _this.textureDropDown.name = 'Poop';
                    _this.textureDropDown.id = 'Poop';
                    addClass(_this.textureDropDown, 'debugger-dropdown');
                    css(_this.textureDropDown, elementCss);
                    var canvas = _this.getThreeRenderer().domElement;
                    if (canvas.parentElement) {
                        canvas.parentElement.appendChild(_this.textureDropDown);
                    }
                    else {
                        canvas.appendChild(_this.textureDropDown);
                    }
                    _this.textureDropDown.onchange = function () {
                        _this.setTexture(_this.textureDropDown.value);
                    };
                }
                _this.textureDropDown.options.length = 0;
                newOption = document.createElement('option');
                newOption.value = 0;
                newOption.text = 'None';
                _this.textureDropDown.appendChild(newOption);
                functions_1.forEach(_this.textureRegistryById, function (tex, id) {
                    newOption = document.createElement('option');
                    newOption.value = id;
                    newOption.text = tex.name !== '' ? tex.getName() : id;
                    _this.textureDropDown.appendChild(newOption);
                });
                _this.textureDropDown.style.top = (_this.getEngine().getRenderer().getHeight() -
                    _this.y - _this.height) + 'px';
                _this.textureDropDown.style.left = _this.x + 'px';
                _this.textureDropDown.style.zIndex = '200';
            }, 0);
        }
    };
    /**
     * Handles the engine resize event.
     */
    DebugTextureViewer.prototype.resize = function () {
        if (this.isEnabled()) {
            this.updateTextureDropdown();
            this.updateViewport();
        }
    };
    /**
     * Renders the debug texture viewer.
     */
    DebugTextureViewer.prototype.renderView = function () {
        var renderer = this.getThreeRenderer();
        if (this.isEnabled() && this.currentTexture) {
            renderer.setRenderTarget(null);
            switch (this.currentTexture.type) {
                case 'texture2D':
                case 'renderTexture2D':
                    renderer.setViewport(this.x, this.y, this.width, this.height);
                    renderer.render(this.scene2D, this.camera2D);
                    break;
                case 'textureCube':
                case 'renderTextureCube':
                    {
                        var portWidthInc = 0.25 * this.width;
                        var portHeightInc = 0.3333 * this.height;
                        renderer.setViewport(this.x, this.y + portHeightInc, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraPX, null, false);
                        renderer.setViewport(this.x + 1.999 * portWidthInc, this.y + portHeightInc, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraNX, null, false);
                        renderer.setViewport(this.x + portWidthInc, this.y + 1.99 * portHeightInc, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraPY, null, false);
                        renderer.setViewport(this.x + portWidthInc, this.y, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraNY, null, false);
                        renderer.setViewport(this.x + portWidthInc, this.y + portHeightInc, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraPZ, null, false);
                        renderer.setViewport(this.x + 2.99 * portWidthInc, this.y + portHeightInc, portWidthInc, portHeightInc);
                        renderer.render(this.sceneCube, this.cameraNZ, null, false);
                    }
                    break;
                default: // nothing
            }
        }
    };
    /**
     * Registers the texture asset.
     * @param texture The texture asset to register.
     */
    DebugTextureViewer.prototype.registerTexture = function (texture) {
        if (!texture) {
            return;
        }
        switch (texture.type) {
            case 'renderTextureCube':
            case 'textureCube':
            case 'texture2D':
            case 'renderTexture2D':
                this.textureRegistryById[texture.id] = texture;
                break;
            default: // nothing
        }
    };
    /**
     * Unregisters the texture asset.
     * @param texture The texture asset to unregister.
     */
    DebugTextureViewer.prototype.unregisterTexture = function (texture) {
        if (texture) {
            if (this.textureRegistryById[texture.id]) {
                delete this.textureRegistryById[texture.id];
            }
        }
    };
    return DebugTextureViewer;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DebugTextureViewer;


/***/ },
/* 76 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-classes-per-file */
var BaseComponent_1 = __webpack_require__(2);
/**
 * A class which represents a change to make to properties on a matching entities.
 * @class QualityChangeLevel
 */
var QualityChangeLevel = (function () {
    /**
     * Creates an instance of QualityChangeLevel.
     * @param targetEntityType    The target entity's type
     * @param targetComponentName The name of the target entity
     * @param propertyName        The property name
     * @param targetValue         The target value
     */
    function QualityChangeLevel(targetEntityType, targetComponentName, propertyName, targetValue) {
        this.targetEntityType = targetEntityType;
        this.targetComponentName = targetComponentName;
        this.propertyName = propertyName;
        this.targetValue = targetValue;
        /** A mapping of component/entity ids to previous values */
        this.previousValues = {};
        /** A number representing the time savings from the last step. */
        this.lastTimeSavings = 0;
        this.targetEntityType = targetEntityType;
        this.targetComponentName = targetComponentName;
        this.propertyName = propertyName;
        this.targetValue = targetValue;
    }
    return QualityChangeLevel;
}());
exports.QualityChangeLevel = QualityChangeLevel;
/**
 * A percentage used to prevent jumping back and forth between performance levels.
 * We must achieve a frame time equal to this constant multiplied by our frameTimeThreshold
 * minus the performance savings from the last quality drop before we step back up a
 * quality level.
 */
var stepUpBufferPercentage = 0.9;
/**
 * DynamicOptimizer
 * This class controls the dynamic down-stepping of rendering features in an
 * attempt to achieve goal performance.
 * @vid dynamic_optimizer
 * @vname Dynamic Performance Optimizer
 * @vreserved
 * @vcategory Rendering
 * @vfilter Application
 */
var DynamicOptimizer = (function (_super) {
    tslib_1.__extends(DynamicOptimizer, _super);
    /**
     * Creates an instance of DynamicOptimizer.
     */
    function DynamicOptimizer() {
        var _this = _super.call(this) || this;
        /** A reference to the constructor of QualityChangeLevel */
        /* tslint:disable ext-variable-name */
        // Disabled rule to preserve backwards compatibility.
        _this.QualityChangeLevel = QualityChangeLevel;
        _this.frameTimeThreshold = 33.333333333; // Attribute defined above
        _this.testInterval = 2000.0; // Attribute defined above
        _this.qualityChangeLevels = [];
        _this.currentLevel = _this.qualityChangeLevels.length;
        _this.elapsedRenderTime = 0.0;
        _this.framesRecorded = 0;
        _this.justStarted = true;
        _this.justAutoSteppedDown = false;
        _this.autoOptimize = true;
        return _this;
    }
    /**
     * Assign the descriptions of the quality levels to be used by the optimizer.
     * @param qualityLevels Array of DynamicOptimizer.QualityChangeLevel objects in order
     *                      from lowest quality level to highest.
     */
    DynamicOptimizer.prototype.setQualityChangeLevels = function (qualityLevels) {
        // First, set the quality back to the top to reset all changed values.
        this.setMaxQuality();
        this.qualityChangeLevels = qualityLevels;
        this.currentLevel = this.qualityChangeLevels.length;
        if (this.isEnabled()) {
            this.autoOptimize = true;
        }
    };
    /**
     * Set the length of frame, above which we will drop a quality level. i.e. if the frame time
     * is above this threshold, the performance is considered poor enough that we will try to
     * disable features to improve it.
     * @param threshold The length of a frame above which we will move down in quality.
     */
    DynamicOptimizer.prototype.setFrameTimeThreshold = function (threshold) {
        this.frameTimeThreshold = threshold;
    };
    /**
     * Set the time interval over which we will average the performance measurement.
     * @param interval The time interval in milliseconds.
     */
    DynamicOptimizer.prototype.setTestInterval = function (interval) {
        this.testInterval = interval;
        this.elapsedRenderTime = 0.0;
        this.framesRecorded = 0;
    };
    /** @inheritdoc */
    DynamicOptimizer.prototype.onPreUpdate = function (delta) {
        if (!this.isEnabled()) {
            return;
        }
        this.elapsedRenderTime += delta * 1000;
        this.framesRecorded++;
        if (this.elapsedRenderTime < this.testInterval) {
            return;
        }
        // When the given amount of rendering time has passed, make a decision
        // about whether to take action based on the current performance
        this.lastAvgFrameTime = this.elapsedRenderTime / this.framesRecorded;
        this.elapsedRenderTime = 0.0;
        this.framesRecorded = 0;
        if (this.justAutoSteppedDown && this.currentLevel < this.qualityChangeLevels.length) {
            var info = this.qualityChangeLevels[this.currentLevel];
            info.lastTimeSavings = info.frameTimeAtDrop - this.lastAvgFrameTime;
            this.justAutoSteppedDown = false;
        }
        // If this is the first recorded interval, don't do anything.
        // This lets the browser settle (after doing its own optimization) and
        // all GPU data to finish uploading to the device.
        if (this.justStarted || !this.autoOptimize || !this.qualityChangeLevels.length) {
            this.justStarted = false;
            return;
        }
        // If the average time it takes to render a frame is larger than our threshold
        // step the rendering quality down.
        if (this.lastAvgFrameTime > this.frameTimeThreshold) {
            // Step down
            this.stepRenderingQualityDown();
            this.justAutoSteppedDown = true;
        }
        else if (this.qualityChangeLevels[this.currentLevel] &&
            this.lastAvgFrameTime < stepUpBufferPercentage * (this.frameTimeThreshold -
                this.qualityChangeLevels[this.currentLevel].lastTimeSavings)) {
            this.stepRenderingQualityUp();
        }
    };
    /**
     * Move to the next lower quality level that actually has an impact. i.e. if the defined
     * quality change isn't applicable to the current scene, we'll skip it and move on.
     */
    DynamicOptimizer.prototype.stepRenderingQualityDown = function () {
        var needsStep = true;
        while (needsStep && this.currentLevel > 0) {
            this.currentLevel = this.currentLevel > 1 ? this.currentLevel - 1 : 0;
            needsStep = !this.stepRenderingQuality(false);
        }
        // Record frame time at time of step down. Only if we actually did a step.
        if (!needsStep) {
            this.qualityChangeLevels[this.currentLevel].frameTimeAtDrop = this.lastAvgFrameTime;
        }
    };
    /**
     * Move to the next higher quality level that actually has an impact. i.e. if the defined
     * quality change isn't applicable to the current scene, we'll skip it and move on.
     */
    DynamicOptimizer.prototype.stepRenderingQualityUp = function () {
        var needsStep = true;
        while (needsStep && this.currentLevel < this.qualityChangeLevels.length) {
            needsStep = !this.stepRenderingQuality(true);
            this.currentLevel = Math.min(this.currentLevel + 1, this.qualityChangeLevels.length);
        }
    };
    /** @inheritdoc */
    DynamicOptimizer.prototype.onEnable = function () {
        this.autoOptimize = true;
    };
    /** @inheritdoc */
    DynamicOptimizer.prototype.onDisable = function () {
        this.autoOptimize = false;
        this.setMaxQuality();
    };
    /** Turn off the auto-optimization and turn all disabled rendering features back on. */
    DynamicOptimizer.prototype.setMaxQuality = function () {
        this.autoOptimize = false;
        while (this.currentLevel < this.qualityChangeLevels.length) {
            this.stepRenderingQualityUp();
        }
    };
    /**
     * Get the next value to set on an entity/component, given the current quality level.
     * @param qualityLevel  The quality level change to consider.
     * @param id            The ID of the BaseEntity or BaseComponent to change.
     * @param currentValue  The current value of the property/attribute
     * @param stepUp        True if we're stepping up a performance level
     * @returns             The next value of the property/attribute
     */
    DynamicOptimizer.prototype.stepValue = function (qualityLevel, id, currentValue, stepUp) {
        if (stepUp) {
            return qualityLevel.previousValues[id];
        }
        qualityLevel.previousValues[id] = currentValue;
        return qualityLevel.targetValue;
    };
    /**
     * Using a quality level definition, set the appropriate values on the entity, depending
     * whether we're dropping a quality level or going up a level.
     * @param entity        The entity to apply the changes to.
     * @param qualityLevel  The description of the quality changes for this level
     * @param stepUp        True if we're stepping up a quality level. Otherwise,
     *                      we're stepping down.
     * @returns             True if applying the quality change actually had an affect.
     *                      That is, the quality settings actually resulted in changes to the entity.
     */
    DynamicOptimizer.prototype.applyLevelToEntity = function (entity, qualityLevel, stepUp) {
        var _this = this;
        var stepSuccess = false;
        // If the component name is defined, we're modifying a component attribute.
        if (qualityLevel.targetComponentName) {
            var components = entity.getComponentsByScriptName(qualityLevel.targetComponentName);
            components.forEach(function (component) {
                var currentValue = component.getAttribute(qualityLevel.propertyName);
                var newValue = _this.stepValue(qualityLevel, component.getId(), currentValue, stepUp);
                // If the current and new values are the same, skip setting it.
                if (currentValue !== newValue) {
                    component.setAttribute(qualityLevel.propertyName, newValue);
                    stepSuccess = true;
                }
            });
        }
        else {
            var currentValue = entity.getProperty(qualityLevel.propertyName);
            var newValue = this.stepValue(qualityLevel, entity.id, currentValue, stepUp);
            // If the current and new values are the same, skip setting it.
            if (currentValue !== newValue) {
                entity.setProperty(qualityLevel.propertyName, newValue);
                stepSuccess = true;
            }
        }
        return stepSuccess;
    };
    /**
     * Apply the next step in the rendering quality.
     * @param stepUp True if we want to step the quality up. Otherwise, we step down.
     * @returns      True if the stepping was successful.
     */
    DynamicOptimizer.prototype.stepRenderingQuality = function (stepUp) {
        var _this = this;
        // Find the target entities that we'll apply the quality change to.
        var qualityLevel = this.qualityChangeLevels[this.currentLevel];
        var entities = this.getEngine().getEntitiesByType(qualityLevel.targetEntityType);
        var stepSuccess = false;
        // For each entity, make the change.
        entities.forEach(function (entity) {
            if (_this.applyLevelToEntity(entity, qualityLevel, stepUp)) {
                stepSuccess = true;
            }
        });
        return stepSuccess;
    };
    return DynamicOptimizer;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DynamicOptimizer;


/***/ },
/* 77 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid event_handler_component
 * @vname Event Handler
 * @vcategory Interaction
 * @vattr Event listen {
 *   description: 'The event to listen for. When this event is captured, all of the defined trigger events will be fired.'
 * }
 * @vattr Event[] triggers {
 *   description: 'Fire each of these events in response to the captured listen event.'
 * }
 */
var BaseComponent_1 = __webpack_require__(2);
var functions_1 = __webpack_require__(6);
function callEvent(object, eventName, parameters) {
    var events, data = [], i;
    if (object.getEvents) {
        events = object.getEvents();
        data.push(eventName);
        if (events[eventName]) {
            for (i in events[eventName].params) {
                if (parameters[i] !== undefined && parameters[i] !== null) {
                    data.push(parameters[i]);
                }
                else {
                    data.push(events[eventName].params[i].default);
                }
            }
        }
        object.trigger.apply(object, data);
    }
    else {
        data.push(eventName);
        object.trigger.apply(object, data.concat(parameters));
    }
}
var EventHandler = (function (_super) {
    tslib_1.__extends(EventHandler, _super);
    function EventHandler() {
        return _super.apply(this, arguments) || this;
    }
    /**
     * Called immediately after after component creation
     */
    /** @inheritdoc */
    EventHandler.prototype.onStartup = function () {
        // this.entity is available
        var local = 'this ' + this.getEntity().getType();
        var sourceEvent = this.listen;
        var entity;
        var bindEventName;
        if (sourceEvent && this.isEnabled()) {
            if (sourceEvent.eventScope === local) {
                entity = this.getEntity();
                this.listenTo(entity, sourceEvent.event, this.onEvent);
            }
            else if (sourceEvent.eventScope === 'object') {
                entity = this.getEngine().getEntityById(sourceEvent.object);
                if (entity) {
                    this.listenTo(entity, sourceEvent.event, this.onEvent);
                }
            }
            else if (sourceEvent.eventScope === 'asset') {
                entity = this.getEngine().getEntityById(sourceEvent.asset);
                if (entity) {
                    this.listenTo(entity, sourceEvent.event, this.onEvent);
                }
            }
            else {
                entity = this.getGlobalEvents();
                this.listenTo(entity, sourceEvent.event, this.onEvent);
            }
            bindEventName = sourceEvent.event + ':bound';
            this.getEngine().trigger(bindEventName, entity);
        }
    };
    EventHandler.prototype.onEvent = function () {
        var _this = this;
        if (this.isEnabled()) {
            var local = 'this ' + this.getEntity().getType();
            var actions = this.triggers;
            functions_1.forEach(actions, function (action) {
                if (action) {
                    var eventName = action.event;
                    var parameters = action.parameters;
                    var entity;
                    if (action.eventScope === local) {
                        callEvent(_this.getEntity(), eventName, parameters);
                    }
                    else if (action.eventScope === 'object') {
                        entity = _this.getEngine().getEntityById(action.object);
                        if (entity) {
                            callEvent(entity, eventName, parameters);
                        }
                    }
                    else if (action.eventScope === 'asset') {
                        entity = _this.getEngine().getEntityById(action.asset);
                        if (entity) {
                            callEvent(entity, eventName, parameters);
                        }
                    }
                    else {
                        callEvent(_this.getGlobalEvents(), eventName, parameters);
                    }
                }
            });
        }
    };
    /**
     * Called when a verold object is destroyed or this component is removed
     * from a verold object.
     */
    /** @inheritdoc */
    EventHandler.prototype.onShutdown = function () {
        // make sure to clean up any events or other bindings that you have created
        // to avoid memory leaks
    };
    return EventHandler;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EventHandler;


/***/ },
/* 78 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var tmpVec = new THREE.Vector3();
var tmpMatrix = new THREE.Matrix4();
/**
 * http://javascript.info/tutorial/animation
 * This function works as the bow: first we “push back the string” and then “shoot”.
 * @param progress  The current progress as a number between 0.0 and 1.0.
 * @param x         The coefficient of elasticity.
 * @returns         The translated value.
 */
function back(progress, x) {
    return Math.pow(progress, 2) * ((x + 1) * progress - x);
}
/**
 * http://javascript.info/tutorial/animation
 * Applies an EaseInOut calculation an input progress number. This applies the
 * easing to both the start and the end of the animation.
 * @param progress  The current progress as a number between 0.0 and 1.0.
 * @returns         The resulting value after being eased.
 */
function makeEaseInOut(progress) {
    if (progress < .5) {
        return back(2 * progress, 2.0) / 2;
    }
    else {
        return (2 - back(2 * (1 - progress), 2.0)) / 2;
    }
}
/**
 * A function which is used to transform meshes in a grid formation.
 * @param length    The total number of items.
 * @param center    The center of the animation.
 * @param scale     The scale of the animation.
 * @param rotation  The initial rotation.
 * @returns         A function which is used for the animation.
 */
function gridFormation(length, center, scale, rotation) {
    // get the length of both sides of the grid! All grids want to be square
    var square = Math.floor(Math.sqrt(length));
    var xInc = 1 / square;
    var yInc = 1 / square;
    var startX = -xInc * (square - 1) * 0.5;
    var startY = (square - 1) / 2 * yInc;
    var row = 0;
    return function (index, outVec) {
        var x = startX + (index % square * xInc);
        var y = startY - row * yInc;
        outVec.set(x, y, 0).applyQuaternion(rotation);
        outVec.copy(center.clone().add(outVec.multiply(scale)));
        if (index % square === square - 1) {
            row++;
        }
    };
}
/**
 * A function which is used to transform meshes in a scale formation.
 * @param center  The center of the animation.
 * @param scale   The scale of the animation.
 * @returns       A function which is used for the animation.
 */
function scaleFormation(center, scale) {
    return function (_index, outVec, child) {
        child.getRuntimeData().updateMatrixWorld(true);
        outVec.setFromMatrixPosition(child.getRuntimeData().matrixWorld);
        var distVec = outVec.clone().sub(center);
        outVec.copy(center).add(distVec.multiply(scale));
    };
}
/**
 * Returns a function which is used to translate the mesh parts in a circle formation.
 * @param length    The number of items.
 * @param center    The center point of the meshes.
 * @param scale     The scale of the transformation.
 * @param rotation  The initial rotation
 * @returns         A function which takes an index and a
 */
function circleFormation(length, center, scale, rotation) {
    return function (index, outVec) {
        var x = center.x + (scale.x * Math.cos(2 * Math.PI * index / length));
        var y = center.y + (scale.y * Math.sin(2 * Math.PI * index / length));
        outVec.set(x, y, center.z).applyQuaternion(rotation);
    };
}
/**
 * Explodes your objects and their hierarchies into different formations. Great
 * for showing off parts in a model!
 * @vid exploder_component
 * @vname Exploder
 * @vreserved
 * @vdescription Explodes your objects and their hierarchies into different formations.
 *               Great for showing off parts in a model!
 * @vfilter object
 * @vcategory Animation
 */
var Exploder = (function (_super) {
    tslib_1.__extends(Exploder, _super);
    /**
     * Creates an instance of Exploder.
     */
    function Exploder() {
        var _this = _super.call(this) || this;
        _this.currentTime = 0;
        // dest and src positions
        _this.objects = [];
        _this.sources = [];
        _this.destinations = [];
        _this.direction = -1;
        return _this;
    }
    /** @inheritdoc */
    Exploder.prototype.onStartup = function () {
        // event listeners
        this.listenTo(this.getEntity(), 'playExplode', this.explode.bind(this));
        this.listenTo(this.getEntity(), 'playContract', this.contract.bind(this));
        this.listenTo(this.getEntity(), 'toggleExploder', this.toggle.bind(this));
        this.listenTo(this.getEntity(), 'resetExploder', this.reset.bind(this));
        this.listenTo(this.getEntity(), 'useCircleExplode', this.explode.bind(this, 'Circle'));
        this.listenTo(this.getEntity(), 'useGridExplode', this.explode.bind(this, 'Grid'));
        this.listenTo(this.getEntity(), 'useScaleOutExplode', this.explode.bind(this, 'Scale'));
    };
    /** @inheritdoc */
    Exploder.prototype.onUpdate = function (delta) {
        var _this = this;
        if (this.hasRuntimeData() && this.currentTime < this.time) {
            this.currentTime += delta;
            var percent_1 = this.currentTime > this.time ? 1.0 : makeEaseInOut(Math.max(0.0, Math.min(1.0, this.currentTime / this.time)));
            this.objects.forEach(function (obj, idx) {
                var dst = obj.runtimeData.parent.worldToLocal(tmpVec.copy(_this.destinations[idx])).clone();
                var srcPos = _this.direction > 0 ? _this.sources[idx] : dst;
                var destPos = _this.direction > 0 ? dst : _this.sources[idx];
                tmpVec.lerpVectors(srcPos, destPos, percent_1);
                obj.alignToPosition(tmpVec, {
                    x: 0.0,
                    y: 0.0,
                    z: 0.0
                });
            });
            if (this.currentTime > this.time) {
                this.getEntity().trigger(this.direction > 0 ? 'endExplode' : 'endContract');
            }
        }
    };
    /**
     * Reset the component state.
     */
    Exploder.prototype.reset = function () {
        var _this = this;
        this.objects.forEach(function (obj, idx) {
            obj.alignToPosition(_this.sources[idx], {
                x: 0.0,
                y: 0.0,
                z: 0.0
            });
        });
        this.objects.length = 0;
        this.sources.length = 0;
        this.destinations.length = 0;
        this.currentTime = this.time;
    };
    /**
     * Begin contraction.
     */
    Exploder.prototype.contract = function () {
        if (!this.isEnabled()) {
            return;
        }
        this.direction = -1;
        this.currentTime = 0;
        this.getEntity().trigger('beginContract');
    };
    /**
     * Initiates explosion.
     * @param [formation] The formation to use.
     * @param [scale]     The scale for the transformation.
     */
    Exploder.prototype.explode = function (formation, scale) {
        var _this = this;
        if (!this.isEnabled()) {
            return;
        }
        this.reset();
        var children = this.getEntity().getDescendantsByType('mesh');
        var center = new THREE.Vector3();
        center.setFromMatrixPosition(this.getRuntimeData().matrixWorld);
        var rotation = new THREE.Quaternion();
        rotation.setFromRotationMatrix(this.getRuntimeData().matrixWorld);
        var formationFunc = this.getFormationFunc(formation || this.formation, children.length, center, rotation, scale || this.scale).bind(this);
        // Explode each child mesh...
        children.forEach(function (childObject, idx) {
            formationFunc(idx, tmpVec, childObject);
            _this.objects.push(childObject);
            var sourceVec = new THREE.Vector3();
            var child = childObject.getRuntimeData();
            tmpMatrix
                .getInverse(child.parent.matrixWorld)
                .multiply(child.matrixWorld);
            sourceVec.setFromMatrixPosition(tmpMatrix);
            _this.sources.push(sourceVec);
            _this.destinations.push(tmpVec.clone());
        });
        this.currentTime = 0;
        this.direction = 1;
        this.getEntity().trigger('beginExplode');
    };
    /**
     * Toggles the mode contraction/explosion.
     */
    Exploder.prototype.toggle = function () {
        if (this.direction > 0) {
            this.contract();
        }
        else {
            this.explode();
        }
    };
    /**
     * Returns a function used to animate the mesh parts based on the provided formation enum.
     * @param formation The formation  to uses
     * @param length    The total number of items
     * @param center    The center point of the animation
     * @param rotation  The initial rotation
     * @param scale     The scale of the animation
     * @returns         A function which is used for animating the mesh parts
     */
    Exploder.prototype.getFormationFunc = function (formation, length, center, rotation, scale) {
        switch (formation) {
            case 'Grid':
                return gridFormation(length, center, scale, rotation);
            case 'Scale':
                return scaleFormation(center, scale);
            default:
            case 'Circle':
                return circleFormation(length, center, scale, rotation);
        }
    };
    return Exploder;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Event definitions:
 * @vevent local playExplode {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent local playContract {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent local toggleExploder {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent local resetExploder {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent local useCircleExplode {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: [
 *     {
 *       name: 'Scale',
 *       type: 'v3',
 *       description: 'The scale to apply to the explosion',
 *       default: { x:1, y:1, z:1 }
 *     }
 *   ]
 * }
 * @vevent local useGridExplode {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: [
 *     {
 *       name: 'Scale',
 *       type: 'v3',
 *       description: 'The scale to apply to the explosion',
 *       default: { 'x':1, 'y':1, 'z':1 }
 *     }
 *   ]
 * }
 * @vevent local useScaleOutExplode {
 *   action: true,
 *   category: 'Exploder',
 *   parameters: [
 *     {
 *       name: 'Scale',
 *       type: 'v3',
 *       description: 'The scale to apply to the explosion',
 *       default: { 'x':2, 'y':2, 'z':2 }
 *     }
 *   ]
 * }
 * @vevent other beginExplode {
 *   action: false,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent other endExplode {
 *   action: false,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent other beginContract {
 *   action: false,
 *   category: 'Exploder',
 *   parameters: []
 * }
 * @vevent other endContract {
 *   action:false,
 *   category: 'Exploder',
 *   parameters: []
 * }
 */
exports.default = Exploder;


/***/ },
/* 79 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid free_camera_controller
 * @vname Free Camera Controller
 * @vcategory Camera-Controllers
 * @vfilter camera
 * @vattr Float inertialDamping {
 *   default: 0.20,
 *   min: 0.0,
 *   max: 1.0,
 *   type: 'f'
 * }
 * @vattr Boolean usePointerLock {
 *   description: '',
 *   default: false
 * }
 * @vattr Boolean invertX { default: false }
 * @vattr Boolean invertY { default: false }
 * @vattr Boolean invertZoom { default: false }
 * @vattr Float lookSpeed { default: 1.0, min: 0.0001, max: 1000 }
 * @vattr Float movementSpeed { default: 3, max: 1000, min: 0.01 }
 * @vattr Vector2 pitchAngleBounds { default: { max: 75.0, min: -75 }, max: { max: 90.0, min: 90.0 }, min: { max: -90, min: -90.01 }}
 * @vattr Boolean enablePan { default: true }
 * @vattr Boolean enableZoom { default: true }
 * @vevent local enableFreeCameraController { parameters: [] }
 * @vevent local disableFreeCameraController { parameters: [] }
 * @vevent local toggleFreeCameraController { parameters: [] }
 */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var UserAgent_1 = __webpack_require__(13);
var FreeCamera = (function (_super) {
    tslib_1.__extends(FreeCamera, _super);
    function FreeCamera() {
        var _this = _super.call(this) || this;
        _this._moveVector = new THREE.Vector3();
        _this._tempVector = new THREE.Vector3();
        _this._tempVector2 = new THREE.Vector3();
        _this.tempCamera = new THREE.PerspectiveCamera();
        _this.tempEuler = new THREE.Euler();
        _this.tempQuaternion = new THREE.Quaternion();
        _this._currentMoveSpeed = new THREE.Vector3();
        _this.ellapsedTimeSinceInput = 0;
        _this.enablePan = undefined;
        _this.enableZoom = undefined;
        _this.invertX = false;
        _this.invertY = false;
        _this.invertZoom = false;
        _this.touchState = 'none';
        _this.touchLast = new THREE.Vector2();
        _this.touchLastPinchDist = 0.0;
        _this.touchYStart = 0.0;
        _this.lookDelta = new THREE.Vector2();
        _this.moveDelta = new THREE.Vector3();
        _this.zoomDelta = 0.0;
        _this.currentLookSpeed = new THREE.Vector2();
        _this.currentMoveSpeed = new THREE.Vector3();
        _this.currentZoomSpeed = 0.0;
        _this.lookDeltaLength = 0.0;
        _this.moveDeltaLength = 0.0;
        _this.pitchAngleBoundsRadians = {
            max: 0.0,
            min: 0.0
        };
        _this.onMouseDown_PointerLock = _this.onMouseDown_PointerLock.bind(_this);
        _this.onMouseUp_PointerLock = _this.onMouseUp_PointerLock.bind(_this);
        return _this;
    }
    /** @inheritdoc */
    FreeCamera.prototype.onStartup = function () {
        if (this.usePointerLock) {
            this.togglePointerLock(true);
        }
        var engine = this.getEngine();
        this.pitchAngleBoundsRadians.max = Math.PI * this.pitchAngleBounds.max / 180.0;
        this.pitchAngleBoundsRadians.min = Math.PI * this.pitchAngleBounds.min / 180.0;
        if (UserAgent_1.isMobile()) {
            engine.on('touchStart', this.onTouchStart, this);
            engine.on('touchMove', this.onTouchMove, this);
            engine.on('touchEnd', this.onTouchEnd, this);
        }
        else {
            engine.on('mouseMove', this.onMouseMove, this);
            engine.on('mouseScroll', this.onMouseScroll, this);
        }
        this.getEntity().on('enableFreeCameraController', this.freeCameraEnable, this);
        this.getEntity().on('disableFreeCameraController', this.freeCameraDisable, this);
        this.getEntity().on('toggleFreeCameraController', this.freeCameraToggle, this);
    };
    /**
     * Called when a verold object is destroyed or this component is removed
     * from a verold object.
     */
    /** @inheritdoc */
    FreeCamera.prototype.onShutdown = function () {
        // make sure to clean up any events or other bindings that you have created
        // to avoid memory leaks
        var engine = this.getEngine();
        if (UserAgent_1.isMobile()) {
            engine.off('touchStart', this.onTouchStart, this);
            engine.off('touchMove', this.onTouchMove, this);
            engine.off('touchEnd', this.onTouchEnd, this);
        }
        else {
            engine.off('mouseMove', this.onMouseMove, this);
            engine.off('mouseScroll', this.onMouseScroll, this);
        }
        this.getEntity().off('enableFreeCameraController', this.freeCameraEnable, this);
        this.getEntity().off('disableFreeCameraController', this.freeCameraDisable, this);
        this.getEntity().off('toggleFreeCameraController', this.freeCameraToggle, this);
        this.togglePointerLock(false);
    };
    FreeCamera.prototype.setTargetByID = function (targetID, interpTime) {
        var targetObj = this.getEngine().getObjectById(targetID);
        this.setTarget(targetObj);
    };
    FreeCamera.prototype.setTarget = function (targetObj) {
        var _this = this;
        if (targetObj) {
            var targetPos_1 = new THREE.Vector3();
            this.getRootObject().once('loadDependencies', function () {
                targetObj.getCenterInWorldSpace(targetPos_1);
                var dist;
                var bb = targetObj.getBounds();
                if (bb) {
                    dist = _this.adjustDistanceForObject(targetObj);
                }
                else {
                    targetObj.traverse(function (obj) {
                        var bb = obj.getBounds();
                        if (bb) {
                            dist = _this.adjustDistanceForObject(obj);
                            return true;
                        }
                    });
                }
                var runtimeData = _this.getRuntimeData();
                runtimeData.lookAt(targetPos_1);
                var distanceVector = new THREE.Vector3(0, 0, dist);
                distanceVector.applyQuaternion(runtimeData.quaternion);
                targetPos_1.add(distanceVector);
                runtimeData.position.copy(targetPos_1);
            }, this);
            this.getRootObject().loadDependencies();
        }
    };
    FreeCamera.prototype.adjustDistanceForObject = function (targetObj) {
        var bb = targetObj.getBounds();
        if (bb) {
            var dist = new THREE.Vector3();
            dist.set(bb.max.x - bb.min.x, bb.max.y - bb.min.y, bb.max.z - bb.min.z);
            var scale = new THREE.Vector3();
            scale.setFromMatrixScale(targetObj.runtimeData.matrixWorld);
            dist.multiply(scale);
            var size = dist.length();
            var newDist = Math.abs(size / (2.0 * Math.tan(this.getRuntimeData().fov *
                Math.PI / 360.0)));
            return newDist;
        }
    };
    /** @inheritdoc */
    FreeCamera.prototype.onPreUpdate = function (delta) {
        if (this.hasRuntimeData() && this.isEnabled()) {
            //Check WASD state and move camera appropriately
            //Also check for modifier keys like ctrl and cmd. If these are pressed,
            //don't move the camera.
            var input = this.getInput();
            var modKey = input.keyDown('ctrl') || input.keyDown('cmd');
            var forwardKey = input.keyDown('upArrow') || input.keyDown('W');
            var backwardKey = input.keyDown('downArrow') || input.keyDown('S');
            var leftKey = input.keyDown('leftArrow') || input.keyDown('A');
            var rightKey = input.keyDown('rightArrow') || input.keyDown('D');
            if (!modKey && (forwardKey || backwardKey || leftKey || rightKey)) {
                if (this.enableZoom) {
                    if (forwardKey) {
                        this.moveDelta.z = -delta;
                    }
                    else if (backwardKey) {
                        this.moveDelta.z = delta;
                    }
                }
                if (this.enablePan) {
                    if (rightKey) {
                        this.moveDelta.x = -delta;
                    }
                    else if (leftKey) {
                        this.moveDelta.x = delta;
                    }
                }
            }
            this.updateCamera(delta);
        }
    };
    /** @inheritdoc */
    FreeCamera.prototype.onPostUpdate = function () {
        this.hasChanged = false;
    };
    FreeCamera.prototype.updateCamera = function (delta) {
        //Handle inverting the controls
        if (this.invertX) {
            this.lookDelta.x *= -1.0;
            this.moveDelta.x *= -1.0;
        }
        if (this.invertY) {
            this.lookDelta.y *= -1.0;
            this.moveDelta.y *= -1.0;
        }
        if (this.invertZoom) {
            this.zoomDelta *= -1.0;
        }
        //Handle speed modifier keys
        var speedMod = 1.0;
        if (this.getInput().keyDown('shift')) {
            speedMod = 5.0;
        }
        // else if ( this.getInput().keyDown( 'ctrl' ) ) {
        //   speedMod = 0.25;
        // }
        var damping = Math.min((delta - 0.017) * 33.3 + this.inertialDamping, 1.0);
        var oneMinusDamping = 1.0 - damping;
        this.currentLookSpeed.x = oneMinusDamping * this.currentLookSpeed.x + damping *
            6.0 * speedMod * this.lookSpeed * this.lookDelta.x;
        this.currentLookSpeed.y = oneMinusDamping * this.currentLookSpeed.y + damping *
            6.0 * speedMod * this.lookSpeed * this.lookDelta.y;
        //If the movement controls have been used, update the movement speed.
        this.currentMoveSpeed.x = oneMinusDamping * this.currentMoveSpeed.x + damping *
            speedMod * this.movementSpeed * this.moveDelta.x;
        this.currentMoveSpeed.y = oneMinusDamping * this.currentMoveSpeed.y + damping *
            speedMod * this.movementSpeed * this.moveDelta.y;
        this.currentMoveSpeed.z = oneMinusDamping * this.currentMoveSpeed.z + damping *
            speedMod * this.movementSpeed * this.moveDelta.z;
        //Handle zoom
        this.currentMoveSpeed.z += oneMinusDamping * this.currentZoomSpeed + damping *
            speedMod * this.movementSpeed * this.zoomDelta;
        //Update the three camera based on the current movement speed.
        var runtimeData = this.getRuntimeData();
        //Using current x,y rotation speed, determine the new quaternion for the camera
        //New position is based on the distance and direction to target
        this.tempEuler.set(this.currentLookSpeed.y, this.currentLookSpeed.x, 0.0);
        this.tempQuaternion.setFromEuler(this.tempEuler);
        runtimeData.quaternion.multiply(this.tempQuaternion);
        //Set bounds on the pitch angle
        this.tempEuler.setFromQuaternion(runtimeData.quaternion, 'YXZ');
        if (-this.tempEuler.x > this.pitchAngleBoundsRadians.max) {
            this.tempEuler.x = -this.pitchAngleBoundsRadians.max;
            runtimeData.quaternion.setFromEuler(this.tempEuler);
            this.currentLookSpeed.y = 0.0;
        }
        else if (-this.tempEuler.x < this.pitchAngleBoundsRadians.min) {
            this.tempEuler.x = -this.pitchAngleBoundsRadians.min;
            runtimeData.quaternion.setFromEuler(this.tempEuler);
            this.currentLookSpeed.y = 0.0;
        }
        //Handle linear movement of the camera
        this._tempVector.copy(this.currentMoveSpeed);
        this._tempVector.x *= -1.0;
        this._tempVector.applyQuaternion(runtimeData.quaternion);
        runtimeData.position.add(this._tempVector);
        //Set the camera's position using the orientation and
        this._tempVector.set(0.0, 0.0, -10.0);
        this._tempVector.applyQuaternion(runtimeData.quaternion);
        this._tempVector.add(runtimeData.position);
        runtimeData.lookAt(this._tempVector);
        if (this.currentZoomSpeed || this.currentLookSpeed.x || this.currentLookSpeed.y ||
            this.currentMoveSpeed.x || this.currentMoveSpeed.y || this.currentMoveSpeed.z) {
            this.getEngine().needsRender = true;
            this.hasChanged = true;
        }
        this.lookDelta.set(0.0, 0.0);
        this.moveDelta.set(0.0, 0.0, 0.0);
        this.zoomDelta = 0.0;
    };
    FreeCamera.prototype.freeCameraEnable = function () {
        this.enable();
    };
    FreeCamera.prototype.freeCameraDisable = function () {
        this.disable();
    };
    FreeCamera.prototype.freeCameraToggle = function () {
        if (this.isEnabled()) {
            this.disable();
        }
        else {
            this.enable();
        }
        if (this.usePointerLock && !this.isEnabled()) {
            document.exitPointerLock();
        }
    };
    FreeCamera.prototype.getEulerAngles = function (outEuler) {
        var returnVector = outEuler;
        if (!outEuler) {
            returnVector = new THREE.Euler();
        }
        returnVector.setFromQuaternion(this.getRuntimeData().quaternion, 'YXZ');
        return returnVector;
    };
    FreeCamera.prototype.setEulerAngles = function (euler) {
        this.getRuntimeData().quaternion.setFromEuler(euler);
    };
    FreeCamera.prototype.togglePointerLock = function (on) {
        var renderer = this.getThreeRenderer();
        if (!renderer) {
            return;
        }
        this.usePointerLock = on;
        if (this.usePointerLock) {
            renderer.domElement.addEventListener('mousedown', this.onMouseDown_PointerLock);
        }
        else {
            renderer.domElement.removeEventListener('mousedown', this.onMouseDown_PointerLock);
        }
    };
    FreeCamera.prototype.onMouseDown_PointerLock = function (event) {
        if (this.isEnabled() && event.button === 0 || event.button === 2) {
            this.getThreeRenderer().domElement.requestPointerLock();
            this.getThreeRenderer().domElement.addEventListener('mouseup', this.onMouseUp_PointerLock);
        }
    };
    FreeCamera.prototype.onMouseUp_PointerLock = function (event) {
        if (this.getEntity()) {
            if (event.button === 2 && this.getInput().mouseButtonUp('left') ||
                event.button === 0 && this.getInput().mouseButtonUp('right')) {
                this.getThreeRenderer().domElement.removeEventListener('mouseup', this.onMouseUp_PointerLock);
                document.exitPointerLock();
            }
        }
    };
    FreeCamera.prototype.onMouseMove = function (event) {
        if (this.isEnabled()) {
            var rightButton = this.getInput().mouseButtonDown('right');
            var leftButton = this.getInput().mouseButtonDown('left');
            if ((rightButton) && this.enablePan) {
                this.moveDelta.x = event.scenePercentDeltaX;
                this.moveDelta.y = event.scenePercentDeltaY;
            }
            else if (leftButton) {
                this.lookDelta.x = -event.scenePercentDeltaX;
                this.lookDelta.y = -event.scenePercentDeltaY;
            }
        }
    };
    FreeCamera.prototype.onMouseScroll = function (delta) {
        if (this.isEnabled() && typeof delta === 'number' && this.enableZoom) {
            this.zoomDelta = -delta * 0.1;
        }
    };
    FreeCamera.prototype.onTouchStart = function (event) {
        if (this.isEnabled()) {
            var touches = event.touches;
            if (!touches) {
                return;
            }
            switch (touches.length) {
                case 1:
                    this.touchState = 'rotate';
                    this.touchLast.set(touches[0].scenePercentX, touches[0].scenePercentY);
                    break;
                case 2:
                    this.touchState = 'zoom';
                    var dx = touches[0].scenePercentX - touches[1].scenePercentX;
                    var dy = touches[0].scenePercentY - touches[1].scenePercentY;
                    var distance = Math.sqrt(dx * dx + dy * dy);
                    this.touchLastPinchDist = distance;
                    this.touchYStart = touches[0].scenePercentY;
                    break;
                case 3:
                    this.touchState = 'pan';
                    this.touchLast.set(touches[0].scenePercentX, touches[0].scenePercentY);
                    break;
                default:
                    this.touchLast.set(touches[0].scenePercentX, touches[0].scenePercentY);
                    this.touchLastPinchDist = -1;
            }
        }
    };
    FreeCamera.prototype.onTouchMove = function (event) {
        var touches = event.touches;
        if (!touches) {
            return;
        }
        // var speedMod = 0.3;
        var dx, dy;
        switch (touches.length) {
            case 1:
                if (this.touchLast.x >= 0) {
                    dx = -0.5 * (this.touchLast.x - touches[0].scenePercentX);
                    dy = -0.5 * (this.touchLast.y - touches[0].scenePercentY);
                }
                else {
                    dx = 0.0;
                    dy = 0.0;
                }
                this.touchLast.x = touches[0].scenePercentX;
                this.touchLast.y = touches[0].scenePercentY;
                this.ellapsedTimeSinceInput = 0;
                this.lookDelta.set(dx, dy);
                break;
            case 2:
                dx = touches[0].scenePercentX - touches[1].scenePercentX;
                dy = touches[0].scenePercentY - touches[1].scenePercentY;
                var distance = Math.sqrt(dx * dx + dy * dy);
                if (this.touchLast.x >= 0.0) {
                    var pinchChange = this.touchLastPinchDist - distance;
                    var scrollChange = this.touchLast.y - touches[0].scenePercentY;
                    if (Math.abs(pinchChange) > Math.abs(scrollChange)) {
                        this.zoomDelta = 20.0 * pinchChange;
                    }
                    else {
                        this.zoomDelta = 20.0 * scrollChange;
                    }
                }
                this.touchLastPinchDist = distance;
                this.touchLast.x = touches[0].scenePercentX;
                this.touchLast.y = touches[0].scenePercentY;
                break;
            case 3:
                dx = touches[0].scenePercentX - this.touchLast.x;
                dy = touches[0].scenePercentY - this.touchLast.y;
                if (this.touchLast.x >= 0.0) {
                    this.moveDelta.set(dx, dy, 0.0);
                }
                this.touchLast.x = touches[0].scenePercentX;
                this.touchLast.y = touches[0].scenePercentY;
                break;
        }
    };
    FreeCamera.prototype.onTouchEnd = function () {
        this.touchLast.set(-1.0, -1.0);
        this.touchLastPinchDist = -1;
        this.touchState = 'none';
    };
    return FreeCamera;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = FreeCamera;


/***/ },
/* 80 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid fullscreen_script
 * @vname Fullscreen
 * @vfilter application
 * @vdescription ses fullscreen API to make your app fullscreen!
 * This will fullscreen the canvas' parent element, so your UI can be
 * fullscreened as well! If a selector is provided, then we will fullscreen that element instead.
 * @vcategory Rendering
 * @vevent local toggleFullscreen {'scope' : 'local', 'action':true, 'category':'Rendering', 'parameters' : []}
 */
var BaseComponent_1 = __webpack_require__(2);
var Fullscreen = (function (_super) {
    tslib_1.__extends(Fullscreen, _super);
    function Fullscreen() {
        var _this = _super.call(this) || this;
        _this.el = undefined;
        _this.fsEnabled = false;
        return _this;
    }
    /** @inheritdoc */
    Fullscreen.prototype.onStartup = function () {
        this.toggle = this.toggle.bind(this);
        this.getEntity().on('toggleFullscreen', this.toggle, this);
        this.listenTo(this.getGlobalEvents(), 'fullscreen::toggle', this.toggle);
        this.listenTo(this.getGlobalEvents(), 'fullscreen::enable', this.enable);
        this.listenTo(this.getGlobalEvents(), 'fullscreen::disable', this.disable);
    };
    /**
     * Toggle fullscreen on and off
     * @returns {void}
     */
    Fullscreen.prototype.toggle = function () {
        if (this.fsEnabled) {
            this.disable();
        }
        else {
            this.enable();
        }
    };
    /** @inheritdoc */
    Fullscreen.prototype.onEnable = function () {
        if (!this.el) {
            this.attachFullscreenAPI();
        }
        this.el.requestFullscreen();
        this.fsEnabled = true;
    };
    /** @inheritdoc */
    Fullscreen.prototype.onDisable = function () {
        if (!this.el) {
            this.attachFullscreenAPI();
        }
        if (this.fsEnabled) {
            document.exitFullscreen();
        }
        this.fsEnabled = false;
    };
    /**
     * Attaches all event listeners for fullscreen changes to the parent container element
     * of the Engine instance.
     * @returns {void}
     */
    Fullscreen.prototype.attachFullscreenAPI = function () {
        this.el = this.getEngine().container;
        this.el.requestFullscreen = this.el.requestFullscreen || this.el.requestFullScreen ||
            this.el.mozRequestFullscreen || this.el.mozRequestFullScreen ||
            this.el.webkitRequestFullscreen || this.el.webkitRequestFullScreen ||
            this.el.msRequestFullscreen || this.el.msRequestFullScreen;
        document.exitFullscreen = document.exitFullscreen || document.exitFullScreen ||
            document.mozCancelFullscreen || document.mozCancelFullScreen ||
            document.webkitExitFullscreen || document.webkitExitFullScreen ||
            document.msExitFullscreen || document.msExitFullScreen;
        document.addEventListener('fullscreenchange', this.onFullscreenChange.bind(this), false);
        document.addEventListener('mozfullscreenchange', this.onFullscreenChange.bind(this), false);
        document.addEventListener('webkitfullscreenchange', this.onFullscreenChange.bind(this), false);
        document.addEventListener('msfullscreenchange', this.onFullscreenChange.bind(this), false);
    };
    /**
     * Trigger fullscreen change events on the runtime
     * @param {DomEvent} event The event created by the DOM
     * @returns {void}
     */
    Fullscreen.prototype.onFullscreenChange = function (event) {
        this.getGlobalEvents().trigger('fullscreen::change', event);
    };
    return Fullscreen;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Fullscreen;


/***/ },
/* 81 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid gamepad_input_controller
 * @vname Gamepad Input Controller
 * @vfilter application
 * @vcategory Input
 */
var GamepadInput = (function (_super) {
    tslib_1.__extends(GamepadInput, _super);
    function GamepadInput() {
        var _this = _super.apply(this, arguments) || this;
        /** The state of all gamepads on the controller. */
        _this.gamepadStates = [];
        return _this;
    }
    /** @inheritDoc */
    GamepadInput.prototype.onPreUpdate = function (_delta) {
        if (!this.isEnabled()) {
            return;
        }
        var gamepads = navigator.getGamepads();
        // getGamepads() doesn't return a regular array in Chrome so we need to iterate
        // with a for loop. Firefox does return a normal array.
        for (var i = 0; i < gamepads.length; i++) {
            // If the gamepad isn't there, skip over it. Because it may have been disconnected, nullify the state.
            if (!gamepads[i]) {
                this.gamepadStates[i] = null;
                continue;
            }
            // If the state hasn't been created yet, create it with default values and with an appropriate
            // number of button and axes.
            if (!this.gamepadStates[i]) {
                this.gamepadStates[i] = { buttonState: null, axesState: null };
                this.gamepadStates[i].buttonState = gamepads[i].buttons.map(function () {
                    return {
                        pressed: false,
                        touched: false,
                        value: 0
                    };
                });
                this.gamepadStates[i].axesState = gamepads[i].axes.map(function () { return 0; });
            }
            this.updateState(gamepads[i], this.gamepadStates[i]);
        }
    };
    /** Update the states of all controller buttons and fire appropriate events. */
    GamepadInput.prototype.updateState = function (gamepad, state) {
        var engine = this.getEngine();
        // For each axis, check if the value has changed and then fire an event if it has.
        gamepad.axes.forEach(function (axis, idx) {
            if (axis !== state.axesState[idx]) {
                state.axesState[idx] = axis;
                engine.trigger('gamepadAxisChanged', gamepad);
            }
        });
        // For each button, check if its value has changed and fire an event if it has.
        gamepad.buttons.forEach(function (but, idx) {
            var button = but; // FIXME: When type defs for Gamepad extensions are released
            if (button.pressed !== state.buttonState[idx].pressed) {
                state.buttonState[idx].pressed = button.pressed;
                var eventName = state.buttonState[idx].pressed ?
                    'gamepadButtonDown' : 'gamepadButtonUp';
                engine.trigger(eventName, gamepad, idx);
            }
            if (button.value !== state.buttonState[idx].value) {
                state.buttonState[idx].value = button.value;
                engine.trigger('gamepadButtonChanged', gamepad, idx);
            }
            if (button.touched !== state.buttonState[idx].touched) {
                state.buttonState[idx].touched = button.touched;
                var eventName = state.buttonState[idx].touched ?
                    'gamepadButtonTouched' : 'gamepadButtonReleased';
                engine.trigger(eventName, gamepad, idx);
            }
        });
    };
    return GamepadInput;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = GamepadInput;


/***/ },
/* 82 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/*
@vid input_controller_component
@vname Input Controller
@vfilter application
@vcategory Input
@vattr custom mouseEvents {
  attributes : {
    'enable' : { type: 'b', default: true, description: 'Enable mouse events?' },
    'scroll' : { type: 'b', default: true, description: 'Listen to scroll events?' },
    'scroll_preventDefault' : { type: 'b', default: false, description: 'Prevent default scroll behaviour?' },
    'move' : { type: 'b', default: true, description: 'Listen to mouse move events?' },
    'down' : { type: 'b', default: true, description: 'Listen to mouse down event?' },
    'down_preventDefault' : { type: 'b', default: false, description: 'Prevent default mouse down behaviour?' },
    'up' : { type: 'b', default: true, description: 'Listen to mouse up event?' },
    'double_click' : { type: 'b', default: true, description: 'Listen to double click event?' },
    'leave' : { type: 'b', default: true, description: 'Listen to mouse leave event' },
    'contextMenu' : { type: 'b', default: true, description: 'Listen for the context menu event? (ie, right click)' },
    'contextMenu_preventDefault' : { type: 'b', default: true, description: 'Prevent context menu default behaviour (ie, the context menu popping open)' },
    'dragBufferDistance' : { type: 'float', default: 12, name: 'Drag Buffer Distance', description: 'The distance from initial click that you need to move your mouse before a drag event is fired, in pixels' },
    'eventHandler' : { type: 'b', default: true, description: 'Events fired from the mouse are picked up by the Event Handler'  }
  }
}

@vattr custom touchEvents {
  attributes : {
    'enable': { type: 'b', default: true, description: 'Enable touch events?' },
    'start': { type: 'b', default: true, description: 'Listen for Touch Start' },
    'start_preventDefault': { type: 'b', default: true, description: 'Prevent default behaviour of touch start event' },
    'end': { type: 'b', default: true, description: 'Listen for touch end event' },
    'doubleTap': { type: 'b', default: true, description: 'Listen for a touch double tap event'},
    'cancel': { type: 'b', default: true, description: 'Listen for touch cancel event' },
    'leave': { type: 'b', default: true, description: 'Listen for touch leave event' },
    'move': { type: 'b', default: true, description: 'Listen for touch move event' },
    'move_preventDefault': { type: 'b', default: true, description: 'Prevent default move behaviour (ie, dragging the window)' },
    'dragBufferDistance' : {
      type : 'float', default : 12.0,
      name : 'Drag Buffer Distance',
      description : 'The distance from initial touch down that you need to move your finger before a drag event is fired, in pixels'
    },
    'eventHandler' : { type: 'b', default: true, description: 'Events fired from the touches are picked up by the Event Handler'  }
  }
}

@vattr custom keyEvents {
  attributes : {
    'enable': { type: 'b', default: true, description: 'Enable keyboard events' },
    'down': { type: 'b', default: true, description: 'Listen to key down events' },
    'up': { type: 'b', default: true, description: 'Listen to key up events' },
    'preventDefault': { type: 'b', default: false, description: 'Prevent default keypress behaviour' },
    'eventHandler' : { type: 'b', default: true, description: 'Events fired from the keys are picked up by the Event Handler'  }
  }
}

@vevent global mouse_down_left { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
@vevent global mouse_down_right { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
@vevent global mouse_down_middle { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
@vevent global mouse_up_left { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
@vevent global mouse_up_right { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
@vevent global mouse_up_middle { scope: 'global', action: false, 'category':'Input - Mouse', parameters: [] }
@vevent global keypress_a { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_b { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_c { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_d { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_f { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_g { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_e { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_h { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_i { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_j { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_k { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_l { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_m { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_n { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_o { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_p { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_q { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_r { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_s { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_t { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_u { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_v { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_w { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_x { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_y { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_z { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_up_arrow { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_down_arrow { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_left_arrow { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_right_arrow { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global keypress_space { 'scope': 'global', 'action': false, 'category':'Input - Keys', 'parameters': [] }
@vevent global touch_start { 'scope': 'global', 'action': false, 'category':'Input - Touch', 'parameters': [] }
@vevent global touch_end { 'scope': 'global', 'action': false, 'category':'Input - Touch', 'parameters': [] }
*/
var Logger_1 = __webpack_require__(3);
var BaseComponent_1 = __webpack_require__(2);
var Box3DInputEvent_1 = __webpack_require__(187);
var UserAgent_1 = __webpack_require__(13);
// Amount of time to wait, is milliseconds, for a double tap to occur. Used on Mobile Devices
var DOUBLE_TAP_TIME = 300;
var Box3DMouseVector = (function () {
    function Box3DMouseVector(x, y) {
        if (x === void 0) { x = 0; }
        if (y === void 0) { y = 0; }
        this.x = x;
        this.y = y;
    }
    Box3DMouseVector.prototype.copy = function (otherVector) {
        this.x = otherVector.x;
        this.y = otherVector.y;
    };
    ;
    Box3DMouseVector.prototype.distanceTo = function (otherVector) {
        var x = this.x - otherVector.x;
        var y = this.y - otherVector.y;
        return Math.sqrt(x * x + y * y);
    };
    ;
    return Box3DMouseVector;
}());
exports.Box3DMouseVector = Box3DMouseVector;
var percents = {
    scenePercentX: 0,
    scenePercentY: 0
};
var pos = {
    sceneX: 0,
    sceneY: 0
};
var keyCodes = {
    'tab': 9,
    'shift': 16,
    'ctrl': 17,
    'alt': 18,
    'esc': 27,
    'space': 32,
    'rightArrow': 39,
    'leftArrow': 37,
    'upArrow': 38,
    'downArrow': 40,
    'delete': 46,
    '0': 48,
    '1': 49,
    '2': 50,
    '3': 51,
    '4': 52,
    '5': 53,
    '6': 54,
    '7': 55,
    '8': 56,
    '9': 57,
    'a': 65,
    'b': 66,
    'c': 67,
    'd': 68,
    'e': 69,
    'f': 70,
    'g': 71,
    'h': 72,
    'i': 73,
    'j': 74,
    'k': 75,
    'l': 76,
    'm': 77,
    'n': 78,
    'o': 79,
    'p': 80,
    'q': 81,
    'r': 82,
    's': 83,
    't': 84,
    'u': 85,
    'v': 86,
    'w': 87,
    'x': 88,
    'y': 89,
    'z': 90,
    'A': 65,
    'B': 66,
    'C': 67,
    'D': 68,
    'E': 69,
    'F': 70,
    'G': 71,
    'H': 72,
    'I': 73,
    'J': 74,
    'K': 75,
    'L': 76,
    'M': 77,
    'N': 78,
    'O': 79,
    'P': 80,
    'Q': 81,
    'R': 82,
    'S': 83,
    'T': 84,
    'U': 85,
    'V': 86,
    'W': 87,
    'X': 88,
    'Y': 89,
    'Z': 90,
    'cmd': 91,
    'numpad_0': 96,
    'numpad_1': 97,
    'numpad_2': 98,
    'numpad_3': 99,
    'numpad_4': 100,
    'numpad_5': 101,
    'numpad_6': 102,
    'numpad_7': 103,
    'numpad_8': 104,
    'numpad_9': 105,
    '>': 187,
    '<': 188,
    '_': 189,
    '.': 190,
    '/': 191,
    '[': 219,
    ']': 221
};
var InputController = (function (_super) {
    tslib_1.__extends(InputController, _super);
    function InputController() {
        var _this = _super.call(this) || this;
        _this.inputQueue = [];
        _this.inputPool = [];
        _this.mouseButtonState = new Array(3);
        _this.mouseButtonStatePrevious = new Array(3);
        _this.mouseButtons = {
            left: 0,
            middle: 1,
            right: 2
        };
        _this.mousePosition = new Box3DMouseVector();
        _this.mousePositionPercent = new Box3DMouseVector();
        _this.mousePreviousPosition = new Box3DMouseVector();
        _this.mouseDragState = new Array(3);
        _this.mouseDragStatePrevious = new Array(3);
        _this.mouseDragDistance = [
            new Box3DMouseVector(),
            new Box3DMouseVector(),
            new Box3DMouseVector()
        ];
        _this.touchPosition = new Box3DMouseVector();
        _this.touchPositionPercent = new Box3DMouseVector();
        _this.touchPreviousPosition = new Box3DMouseVector();
        _this.touchDragState = false;
        _this.touchDragStatePrevious = false;
        // Double tap handling
        _this.doubleTapHandle = null;
        _this.doubleTapPosition = new Box3DMouseVector();
        _this.listenForTouchStart = false;
        _this.listenForTouchEnd = false;
        _this.touchesStart = [];
        _this.touchesOutOfBuffer = [];
        _this.keyState = new Array(256);
        _this.keyStatePrevious = new Array(256);
        _this.canvas = null;
        _this.pointerLockElement = null;
        _this.pointerLockEnabled = false;
        return _this;
    }
    /** @inheritdoc */
    InputController.prototype.onStartup = function () {
        this.canvas = this.getEngine().canvas;
        this.pointerLockElement = this.canvas;
        this.pointerLockElement.requestPointerLock = this.pointerLockElement.requestPointerLock ||
            this.pointerLockElement['mozRequestPointerLock'] ||
            this.pointerLockElement['webkitRequestPointerLock'];
        document.exitPointerLock = document.exitPointerLock ||
            document['mozExitPointerLock'] ||
            document['webkitExitPointerLock'];
        this.clearKeyStates = this.clearKeyStates.bind(this);
        this.onMouseMove = this.onMouseMove.bind(this);
        this.onMouseDown = this.onMouseDown.bind(this);
        this.onMouseUp = this.onMouseUp.bind(this);
        this.onMouseWheel = this.onMouseWheel.bind(this);
        this.onMouseLeave = this.onMouseLeave.bind(this);
        this.onContextMenu = this.onContextMenu.bind(this);
        this.onKeyDown = this.onKeyDown.bind(this);
        this.onKeyUp = this.onKeyUp.bind(this);
        this.onTouchStart = this.onTouchStart.bind(this);
        this.onTouchEnd = this.onTouchEnd.bind(this);
        this.onTouchCancel = this.onTouchCancel.bind(this);
        this.onTouchLeave = this.onTouchLeave.bind(this);
        this.onTouchMove = this.onTouchMove.bind(this);
        this.onDoubleClick = this.onDoubleClick.bind(this);
        this.onDoubleTap = this.onDoubleTap.bind(this);
        window.addEventListener('blur', this.clearKeyStates, false);
        if (this.isEnabled()) {
            if (this.mouseEvents.enable) {
                this.enableMouseEvents();
            }
            if (this.keyEvents.enable) {
                this.enableKeyEvents();
            }
            if (this.touchEvents.enable) {
                this.enableTouchEvents();
            }
        }
    };
    /*UTILITIES*/
    //if output is passed in, append scenePercent properties to it
    InputController.prototype.getScenePercent = function (event, output) {
        output = output || percents;
        this.getScenePos(event, event);
        output.scenePercentX = event.sceneX / this.getEngine().getRenderer().getWidth();
        output.scenePercentY = event.sceneY / this.getEngine().getRenderer().getHeight();
        return output;
    };
    //if output is passed in, we are going to append sceneX and sceneY properties to it
    InputController.prototype.getScenePos = function (event, output) {
        output = output || pos;
        var rect = event.target.getBoundingClientRect();
        var top = rect.top + document.body.scrollTop;
        var left = rect.left + document.body.scrollLeft;
        output.sceneX = event.clientX - left;
        output.sceneY = event.clientY - top;
        return output;
    };
    /*END UTILITIES*/
    //if mouse enabled, turn on specific listeners
    InputController.prototype.enableMouseEvents = function () {
        if (this.mouseEvents.move) {
            this.canvas.addEventListener('mousemove', this.onMouseMove);
        }
        if (this.mouseEvents.down) {
            this.canvas.addEventListener('mousedown', this.onMouseDown);
        }
        if (this.mouseEvents.scroll) {
            this.canvas.addEventListener('wheel', this.onMouseWheel);
        }
        if (this.mouseEvents.double_click) {
            this.canvas.addEventListener('dblclick', this.onDoubleClick);
        }
        document.body.addEventListener('mouseleave', this.onMouseLeave);
        this.canvas.addEventListener('contextmenu', this.onContextMenu);
    };
    //if keys enabled, turn on specific listeners
    InputController.prototype.enableKeyEvents = function () {
        if (this.keyEvents.down) {
            document.addEventListener('keydown', this.onKeyDown);
        }
        if (this.keyEvents.up) {
            document.addEventListener('keyup', this.onKeyUp);
        }
    };
    //if touches enabled, turn on specific listeners
    InputController.prototype.enableTouchEvents = function () {
        if (this.touchEvents.start) {
            this.canvas.addEventListener('touchstart', this.onTouchStart);
        }
        if (this.touchEvents.end) {
            this.canvas.addEventListener('touchend', this.onTouchEnd);
        }
        if (this.touchEvents.doubleTap) {
            this.canvas.addEventListener('touchstart', this.onDoubleTap);
        }
        if (this.touchEvents.cancel) {
            this.canvas.addEventListener('touchcancel', this.onTouchCancel);
        }
        if (this.touchEvents.leave) {
            this.canvas.addEventListener('touchleave', this.onTouchLeave);
        }
        if (this.touchEvents.move) {
            this.canvas.addEventListener('touchmove', this.onTouchMove);
        }
    };
    InputController.prototype.clearKeyStates = function () {
        if (this.keyState) {
            for (var code = 0; code < this.keyState.length; ++code) {
                this.keyState[code] = false;
            }
        }
    };
    InputController.prototype.onMouseMove = function (e) {
        e.mouseDelta = {};
        e.mouseDelta.x = e.movementX || e.mozMovementX || e.webkitMovementX || 0;
        e.mouseDelta.y = e.movementY || e.mozMovementY || e.webkitMovementY || 0;
        if (!e.mouseDelta.y && !e.mouseDelta.x) {
            e.mouseDelta.x = (this.mousePosition.x - this.mousePreviousPosition.x);
            e.mouseDelta.y = (this.mousePosition.y - this.mousePreviousPosition.y);
        }
        //If we use pointer lock, we need to use virtual mouse positioning
        //as mouseDelta is one of the few props that updates in PointerLock mode
        if (this.pointerLockEnabled) {
            this.mousePosition.x += e.mouseDelta.x;
            this.mousePosition.y += e.mouseDelta.y;
            this.mousePositionPercent.x = e.scenePercentX = this.mousePosition.x /
                this.getEngine().getRenderer().getWidth();
            this.mousePositionPercent.y = e.scenePercentY = this.mousePosition.y /
                this.getEngine().getRenderer().getHeight();
        }
        else {
            this.getScenePercent(e, e);
            this.mousePosition.x = e.sceneX || e.clientX;
            this.mousePosition.y = e.sceneY || e.clientY;
            this.mousePositionPercent.x = e.scenePercentX;
            this.mousePositionPercent.y = e.scenePercentY;
        }
        e.scenePercentDeltaX = e.mouseDelta.x / this.getEngine().getRenderer().getWidth();
        e.scenePercentDeltaY = e.mouseDelta.y / this.getEngine().getRenderer().getHeight();
        for (var b = 0; b < this.mouseButtonState.length; b++) {
            if (this.mouseButtonState[b] === true) {
                this.mouseDragDistance[b].x += e.mouseDelta.x;
                this.mouseDragDistance[b].y += e.mouseDelta.y;
                var distance = this.mouseDragDistance[b];
                //Drag state check
                if (distance.x * distance.x + distance.y * distance.y >
                    this.mouseEvents.dragBufferDistance) {
                    this.mouseDragState[b] = true;
                }
            }
            else {
                this.mouseDragState[b] = false;
            }
        }
        this.inputQueue.push(this.getInputEvent(e, 'mouseMove'));
    };
    InputController.prototype.onMouseDown = function (e) {
        this.getScenePercent(e, e);
        if (!this.mouseUpBound) {
            this.mouseUpBound = true;
            document.addEventListener('mouseup', this.onMouseUp);
        }
        Array.prototype.forEach.call(document.querySelectorAll('input, textarea, select, option'), function (el) {
            el.blur();
        });
        if (this.mouseEvents.down_preventDefault) {
            e.preventDefault();
        }
        this.mouseButtonState[e.button] = true;
        //this.getEngine().trigger('mouseDown', event );
        this.inputQueue.push(this.getInputEvent(e, 'mouseDown'));
        if (this.mouseEvents.eventHandler) {
            var button = this.getKeyByValue(this.mouseButtons, e.button);
            if (button) {
                this.getGlobalEvents().trigger('mouse_down_' + button);
            }
        }
    };
    InputController.prototype.onMouseUp = function (e) {
        this.getScenePercent(e, e);
        this.mouseButtonState[e.button] = false;
        this.mouseDragState[e.button] = false;
        this.mouseDragDistance[e.button].x = 0;
        this.mouseDragDistance[e.button].y = 0;
        if (this.mouseButtonUp('left') &&
            this.mouseButtonUp('right') &&
            this.mouseButtonUp('middle')) {
            this.mouseUpBound = false;
            document.removeEventListener('mouseup', this.onMouseUp);
        }
        this.inputQueue.push(this.getInputEvent(e, 'mouseUp'));
        if (this.mouseEvents.eventHandler) {
            var button = this.getKeyByValue(this.mouseButtons, e.button);
            if (button) {
                this.getGlobalEvents().trigger('mouse_up_' + button);
            }
        }
    };
    InputController.prototype.onDoubleClick = function (e) {
        this.getScenePercent(e, e);
        Array.prototype.forEach.call(document.querySelectorAll('input, textarea, select, option'), function (el) {
            el.blur();
        });
        this.inputQueue.push(this.getInputEvent(e, 'doubleClick'));
    };
    InputController.prototype.onMouseWheel = function (e) {
        if (this.mouseEvents.scroll_preventDefault) {
            e.preventDefault();
        }
        var delta;
        if (e.wheelDeltaY !== undefined) {
            delta = 1 / 40 * e.wheelDeltaY;
        }
        else if (UserAgent_1.isIE()) {
            delta = -e.deltaY / 40;
        }
        else {
            delta = -e.deltaY;
        }
        this.inputQueue.push(this.getInputEvent(delta, 'mouseScroll'));
    };
    InputController.prototype.onMouseLeave = function (e) {
        for (var b = 0; b < this.mouseButtonState.length; b++) {
            //If a button is down, force the up event
            if (this.mouseButtonState[b]) {
                this.onMouseUp(e);
            }
        }
        this.clearKeyStates();
    };
    InputController.prototype.onContextMenu = function (e) {
        if (this.mouseEvents.contextMenu_preventDefault) {
            e.preventDefault();
        }
        this.inputQueue.push(this.getInputEvent(e, 'contextMenu'));
    };
    InputController.prototype.onKeyDown = function (e) {
        if (document.activeElement && (document.activeElement.getAttribute('contenteditable') === 'true' ||
            document.activeElement.tagName === 'DIV' ||
            document.activeElement.tagName === 'INPUT' ||
            document.activeElement.tagName === 'SELECT' ||
            document.activeElement.tagName === 'OPTION' ||
            document.activeElement.tagName === 'TEXTAREA')) {
            return;
        }
        if (this.keyEvents.preventDefault) {
            e.preventDefault();
        }
        this.keyState[e.keyCode] = true;
        this.inputQueue.push(this.getInputEvent(e, 'keyDown'));
        if (this.keyEvents.eventHandler) {
            var button = this.getKeyByValue(keyCodes, e.keyCode);
            if (button) {
                this.getGlobalEvents().trigger('keypress_' + button);
            }
        }
    };
    InputController.prototype.onKeyUp = function (e) {
        this.keyState[e.keyCode] = false;
        this.inputQueue.push(this.getInputEvent(e, 'keyUp'));
    };
    InputController.prototype.onTouchStart = function (e) {
        if (this.touchEvents.start_preventDefault) {
            e.preventDefault();
        }
        var event = this.onTouchEvent(e, 'touchStart');
        this.touchesStart = event.touches;
        this.touchesOutOfBuffer.length = 0;
        if (event.touches.length) {
            this.touchPosition.x = event.touches[event.touches.length - 1].sceneX;
            this.touchPosition.y = event.touches[event.touches.length - 1].sceneY;
            this.touchPositionPercent.x = event.touches[event.touches.length - 1].scenePercentX;
            this.touchPositionPercent.y = event.touches[event.touches.length - 1].scenePercentY;
        }
        if (this.touchEvents.eventHandler) {
            this.getGlobalEvents().trigger('touch_start');
        }
    };
    InputController.prototype.onTouchEnd = function (e) {
        if (this.touchEvents.end_preventDefault) {
            e.preventDefault();
        }
        this.touchDragState = false;
        this.onTouchEvent(e, 'touchEnd');
        if (this.touchEvents.eventHandler) {
            this.getGlobalEvents().trigger('touch_end');
        }
    };
    /**
     * Mobile device support for double click
     * @param {DOMEvent} e The event passed from the DOM event handler
     * @returns {void}
     */
    InputController.prototype.onDoubleTap = function (e) {
        // If any events, make sure position doesn't change EVER!
        if ((this.listenForTouchStart || this.listenForTouchEnd) &&
            this.doubleTapPosition.distanceTo(this.touchPosition) > this.touchEvents.dragBufferDistance) {
            this.clearDoubleTapState();
            return;
        }
        // Initial touch down, listen for up
        if (!this.listenForTouchStart && !this.listenForTouchEnd) {
            this.doubleTapPosition.copy(this.touchPosition);
            this.clearDoubleTapState();
            // Listen for next touch release to signify first tap completion
            this.canvas.addEventListener('touchend', this.onDoubleTap);
            this.listenForTouchEnd = true;
        }
        else if (!this.listenForTouchStart && this.listenForTouchEnd) {
            this.clearDoubleTapState();
            this.listenForTouchStart = true;
        }
        else if (this.listenForTouchStart && !this.listenForTouchEnd) {
            this.clearDoubleTapState();
            this.listenForTouchStart = true;
            this.listenForTouchEnd = true;
            // Last release refers to final touch completion
            this.canvas.addEventListener('touchend', this.onDoubleTap);
        }
        else {
            this.clearDoubleTapState();
            // Add to queue that will be flushed on next update
            this.onTouchEvent(e, 'doubleTap');
        }
        // Setup a deadline for the state transition to occur!
        this.doubleTapHandle = setTimeout(this.clearDoubleTapState.bind(this), DOUBLE_TAP_TIME);
    };
    /**
     * Clear and reset handles for double tap events
     * @returns {void}
     */
    InputController.prototype.clearDoubleTapState = function () {
        clearTimeout(this.doubleTapHandle);
        this.doubleTapHandle = null;
        this.listenForTouchStart = false;
        this.listenForTouchEnd = false;
        this.canvas.removeEventListener('touchend', this.onDoubleTap);
    };
    InputController.prototype.onTouchCancel = function (e) {
        if (this.touchEvents.cancel_preventDefault) {
            e.preventDefault();
        }
        this.touchDragState = false;
        var event = {};
        event.originalEvent = e;
        event.touches = [];
        this.inputQueue.push(this.getInputEvent(event, 'touchCancel'));
    };
    InputController.prototype.onTouchLeave = function (e) {
        if (this.touchEvents.leave_preventDefault) {
            e.preventDefault();
        }
        this.touchDragState = false;
        this.onTouchEvent(e, 'touchLeave');
    };
    InputController.prototype.onTouchMove = function (e) {
        if (this.touchEvents.move_preventDefault) {
            e.preventDefault();
        }
        // this.touchDragState = true;
        var event = {};
        event.originalEvent = e;
        event.touches = [];
        for (var i = 0; i < e.touches.length; ++i) {
            var touchObj = {};
            this.getScenePos(e.touches[i], touchObj);
            this.getScenePercent(e.touches[i], touchObj);
            touchObj.originalTouch = e.touches[i];
            if (this.touchesStart[i] && this.distance(e.touches[i], this.touchesStart[i]) >
                this.touchEvents.dragBufferDistance) {
                this.touchDragState = true;
            }
            event.touches.push(touchObj);
        }
        //assign final touch to the position value
        //#TODO: REFACTOR ALL REFERENCES TO THIS!
        if (event.touches.length) {
            this.touchPosition.x = event.touches[event.touches.length - 1].sceneX;
            this.touchPosition.y = event.touches[event.touches.length - 1].sceneY;
            this.touchPositionPercent.x = event.touches[event.touches.length - 1].scenePercentX;
            this.touchPositionPercent.y = event.touches[event.touches.length - 1].scenePercentY;
        }
        //TODO need touch drag distance state
        this.inputQueue.push(this.getInputEvent(event, 'touchMove'));
    };
    InputController.prototype.onTouchEvent = function (e, eventName) {
        var event = {};
        event.originalEvent = e;
        event.touches = [];
        for (var i = 0; i < e.touches.length; ++i) {
            var touchObj = {};
            //save pos and percents to object
            this.getScenePos(e.touches[i], touchObj);
            this.getScenePercent(e.touches[i], touchObj);
            touchObj.originalTouch = e.touches[i];
            event.touches.push(touchObj);
        }
        this.inputQueue.push(this.getInputEvent(event, eventName));
        //if we need to do something with the end result (ie: touch start, )
        return event;
    };
    /** @inheritdoc */
    InputController.prototype.onPreUpdate = function () {
        if (this.isEnabled()) {
            while (this.inputQueue.length > 0) {
                this.getEngine().trigger(this.inputQueue[0].name, this.inputQueue[0].event);
                this.recycleInputEvent(this.inputQueue.splice(0, 1)[0]);
            }
        }
    };
    /** @inheritdoc */
    InputController.prototype.onPostUpdate = function () {
        if (this.isEnabled()) {
            if (this.keyEvents.enable) {
                for (var code = 0; code < this.keyState.length; code++) {
                    this.keyStatePrevious[code] = this.keyState[code];
                }
            }
            if (this.mouseEvents.enable) {
                for (var id = 0; id < this.mouseButtonState.length; id++) {
                    this.mouseButtonStatePrevious[id] = this.mouseButtonState[id];
                    this.mouseDragStatePrevious[id] = this.mouseDragState[id];
                }
                this.mousePreviousPosition.x = this.mousePosition.x;
                this.mousePreviousPosition.y = this.mousePosition.y;
            }
            if (this.touchEvents.enable) {
                this.touchDragStatePrevious = this.touchDragState;
            }
        }
    };
    InputController.prototype.recycleInputEvent = function (obj) {
        obj.name = null;
        obj.event = null;
        this.inputPool.push(obj);
    };
    InputController.prototype.getInputEvent = function (event, name) {
        if (this.inputPool.length === 0) {
            //make more, dag nabbit!!
            this.inputPool.push(new Box3DInputEvent_1.default());
        }
        var vEvent = this.inputPool.pop();
        vEvent.event = event;
        vEvent.name = name;
        return vEvent;
    };
    /**
     * Get the current drag state of the mouse
     * @param {number} [buttonId] The id for the button who's drag state we're checking.
     * left: 0, middle: 1, right: 2. Uses left mouse button by default
     * @returns {Bool} True if the current state is dragging
     */
    InputController.prototype.getMouseDragState = function (buttonId) {
        if (buttonId === void 0) { buttonId = 0; }
        return this.mouseDragState[buttonId];
    };
    /**
     * Get the previous drag state of the mouse
     * @param {number} [buttonId] The id for the button who's drag state we're checking.
     * left: 0, middle: 1, right: 2. Uses left mouse button by default
     * @returns {Bool} True if the previous state is dragging
     */
    InputController.prototype.getPreviousMouseDragState = function (buttonId) {
        if (buttonId === void 0) { buttonId = 0; }
        return this.mouseDragStatePrevious[buttonId];
    };
    /**
     * Get the current drag state of touch input
     * @returns {Bool} True if current state is dragging
     */
    InputController.prototype.getTouchDragState = function () {
        return this.touchDragState;
    };
    /**
     * Get the previous drag state of touch input
     * @returns {Bool} True if previous state is dragging
     */
    InputController.prototype.getPreviousTouchDragState = function () {
        return this.touchDragStatePrevious;
    };
    InputController.prototype.mouseButtonDown = function (button) {
        if (button === 'any') {
            for (var i in this.mouseButtons) {
                if (this.mouseButtonState[this.mouseButtons[i]]) {
                    return true;
                }
            }
            return false;
        }
        return this.mouseButtonState[this.mouseButtons[button]];
    };
    InputController.prototype.mouseButtonUp = function (button) {
        return !this.mouseButtonState[this.mouseButtons[button]];
    };
    InputController.prototype.mouseButtonPressed = function (button) {
        return this.mouseButtonState[this.mouseButtons[button]] &&
            !this.mouseButtonStatePrevious[this.mouseButtons[button]] ? true : false;
    };
    InputController.prototype.mouseButtonReleased = function (button) {
        return !this.mouseButtonState[this.mouseButtons[button]] &&
            this.mouseButtonStatePrevious[this.mouseButtons[button]] ? true : false;
    };
    InputController.prototype.keyPressed = function (key) {
        return this.keyState[keyCodes[key]] &&
            !this.keyStatePrevious[keyCodes[key]] ? true : false;
    };
    InputController.prototype.keyReleased = function (key) {
        return !this.keyState[keyCodes[key]] &&
            this.keyStatePrevious[keyCodes[key]] ? true : false;
    };
    InputController.prototype.keyDown = function (key) {
        return !!this.keyState[keyCodes[key]];
    };
    InputController.prototype.keyUp = function (key) {
        return !this.keyState[keyCodes[key]];
    };
    InputController.prototype.distance = function (eventA, eventB) {
        var dx = eventA.sceneX - eventB.sceneX, dy = eventA.sceneY - eventB.sceneY;
        return Math.sqrt(dx * dx + dy * dy);
    };
    InputController.prototype.getKeyByValue = function (obj, value) {
        for (var prop in obj) {
            if (obj.hasOwnProperty(prop) && obj[prop] === value) {
                return prop;
            }
        }
        Logger_1.default.warn('Value not present in object: ', value);
        return null;
    };
    InputController.prototype.enablePointerLock = function () {
        this.pointerLockEnabled = true;
        this.pointerLockElement.requestPointerLock();
    };
    InputController.prototype.disablePointerLock = function () {
        this.pointerLockEnabled = false;
        document.exitPointerLock();
    };
    InputController.prototype.togglePointerLock = function () {
        if (this.pointerLockEnabled) {
            this.enablePointerLock();
        }
        else {
            this.disablePointerLock();
        }
    };
    /** @inheritdoc */
    InputController.prototype.onShutdown = function () {
        if (this.canvas) {
            this.canvas.removeEventListener('touchstart', this.onTouchStart);
            this.canvas.removeEventListener('touchend', this.onTouchEnd);
            this.canvas.removeEventListener('touchcancel', this.onTouchCancel);
            this.canvas.removeEventListener('touchleave', this.onTouchLeave);
            this.canvas.removeEventListener('touchmove', this.onTouchMove);
            this.canvas.removeEventListener('mousemove', this.onMouseMove);
            document.removeEventListener('mouseup', this.onMouseUp);
            this.canvas.removeEventListener('mousedown', this.onMouseDown);
            this.canvas.removeEventListener('wheel', this.onMouseWheel);
            document.removeEventListener('keydown', this.onKeyDown);
            document.removeEventListener('keyup', this.onKeyUp);
            document.body.removeEventListener('mouseleave', this.onMouseLeave);
            this.canvas.removeEventListener('contextmenu', this.onContextMenu);
            this.canvas.removeEventListener('dblclick', this.onDoubleClick);
            this.canvas.removeEventListener('touchstart', this.onDoubleTap);
        }
        this.mouseButtonState = undefined;
        this.mouseButtonStatePrevious = undefined;
        this.mouseDragState = undefined;
        this.mouseDragStatePrevious = undefined;
        this.mousePosition = undefined;
        this.mousePreviousPosition = undefined;
        this.touchPosition = undefined;
        this.touchPreviousPosition = undefined;
        this.keyState = undefined;
        this.keyStatePrevious = undefined;
    };
    return InputController;
}(BaseComponent_1.default));
exports.InputController = InputController;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = InputController;


/***/ },
/* 83 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * @vid animation
 * @vname Animation
 * @vfilter object
 * @vcategory Animation
 * @vattr Boolean autoPlay  {
 *   description: 'Play the animation once loaded',
 *   default: true
 * }
 * @vattr Boolean loop {
 *   description: 'Continuously replay the animation',
 *   default: true
 * }
 * @vattr Float speed {
 *   description: 'Playback speed',
 *   default: 1.0,
 *   min: 0.0,
 *   max: 100.0
 * }
 * @vattr Float startTime {
 *   description: 'Begin playback at this time offset',
 *   default: 0.0,
 *   min: 0.0
 * }
 * @vattr Float weight {
 *   description: 'Blending weight',
 *   default: 1.0,
 *   min: 0.0,
 *   max: 1.0
 * }
 * @vattr Asset asset {
 *   description: 'Animation asset',
 *   default: null,
 *   filter: { animation: true }
 * }
 * @vattr Integer clipId {
 *   description: 'The animation clip ID',
 *   default: null,
 * }
 * @vevent local playAnimation {
 *  scope: 'local',
 *  action: true,
 *  category: 'Animation',
 *  parameters: [{
 *    name: 'asset',
 *    type: 'asset',
 *    description: 'The animation asset to play.',
 *    default: null,
 *    filter: { 'animation': true }
 *  }, {
 *    name: 'clipId',
 *    type: 's',
 *    description: 'The ID of the clip to play.',
 *    default: null
 *  }, {
 *    name: 'loop',
 *    type: 'b',
 *    description: 'Continuously replay the animation.',
 *    default: true
 *  }, {
 *    name: 'speed',
 *    type: 'f',
 *    description: 'Playback speed.',
 *    default: 1.0,
 *    min: 0.0,
 *    max: 100.0
 *  }, {
 *    name: 'startTime',
 *    type: 'f',
 *    description: 'Begin playback at this time offset.',
 *    default: 0.0,
 *    min: 0.0
 *  }]
 * }
 * @vevent local pauseAnimation {
 *   'scope': 'local',
 *   'action': true,
 *   'category': 'Animation',
 *   'parameters': []
 * }
 * @vevent local stopAnimation {
 *   scope: 'local',
 *   action: true,
 *   category: 'Animation',
 *   'parameters': []
 * }
 * @vevent local toggleAnimation {
 *   scope: 'local',
 *   action: true,
 *   category: 'Animation',
 *   parameters: []
 * }
 * @vevent local animationLoaded {
 *   'scope': 'local',
 *   'action': false,
 *   'category': 'Animation',
 *   'parameters': []
 * }
 * @vevent local endAnimation {
 *   'scope': 'local',
 *   'action': false,
 *   'category': 'Animation',
 *   'parameters': []
 * }
 */
"use strict";
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var Animation = (function (_super) {
    tslib_1.__extends(Animation, _super);
    function Animation() {
        var _this = _super.apply(this, arguments) || this;
        /**
         * Whether or not this needs to update.
         * @private
         * @type {boolean}
         */
        _this.dirty = true;
        /**
         * Whehter or not the animation is currently paused.
         * @private
         * @type {boolean}
         */
        _this.paused = false;
        /**
         * Whether the animation needs to be reset or not.
         * @private
         * @type {boolean}
         */
        _this.needsReset = false;
        /**
         * Whether or not the animation is ended.
         * @private
         * @type {boolean}
         */
        _this.ended = false;
        return _this;
    }
    /** @inheritdoc */
    Animation.prototype.onEntityLoaded = function () {
        var _this = this;
        // Don't recreate the mixer if it already exists unless the runtime data is different.
        if (!this.mixer || this.mixer._root !== this.getRuntimeData()) {
            this.mixer = new THREE.AnimationMixer(this.getRuntimeData());
            this.mixer.addEventListener('finished', function (event) { return _this.onMixerEvent(event); });
        }
    };
    /**
     * Returns the animation time.
     * @method getTime
     * @returns {number} The animation time.
     */
    Animation.prototype.getTime = function () {
        if (this.action) {
            return this.action.time;
        }
        return 0.0;
    };
    /**
     * Called when the BaseEntity begins to load.
     * @method start
     * @public
     * @returns {void}
     */
    /** @inheritdoc */
    Animation.prototype.onStartup = function () {
        // Listen to changes on the animation asset.
        if (this.asset) {
            this.listenTo(this.asset, 'propertyChanges', this.onAssetChanged);
        }
        // this.entity is available here but the Three.JS data isn't loaded yet.
        this.getEntity().on('playAnimation', this.playAnimation, this);
        this.getEntity().on('pauseAnimation', this.pause, this);
        this.getEntity().on('stopAnimation', this.stop, this);
        this.getEntity().on('toggleAnimation', this.toggle, this);
    };
    /**
     * Returns true if the animation is playing; otherwise, returns false.
     * @method isPlaying
     * @public
     * @returns {Boolean} true if the animation is playing; otherwise, false.
     */
    Animation.prototype.isPlaying = function () {
        // FIXME isScheduled not defined on typings
        return this.action && this.action.isScheduled() && !this.paused;
    };
    /**
     * Load the currently assigned animation asset and clip and reset playback. Use this method to
     * preload the animation asset prior to calling play(); otherwise, playback might be delayed.
     * @method load
     * @public
     * @param {Function} [callback] Called when the animation is loaded or an error occurs.
     * @returns {void}
     */
    Animation.prototype.load = function (callback) {
        var _this = this;
        if (!this.mixer) {
            if (callback) {
                callback(new Error('Mixer is not initialized'));
            }
            return;
        }
        // Release the current animation (if there is one).
        this.release();
        // Make sure an animation asset is set.
        if (!this.asset) {
            if (callback) {
                callback(new Error('No asset assigned'));
            }
            return;
        }
        this.asset.when('load', function () {
            // Get the THREE.AnimationClip from the asset.
            var clip = _this.asset.getAnimationClip(_this.clipId);
            if (!clip) {
                if (callback) {
                    callback(new Error("Failed to get animation clip \"" + _this.clipId + "\""));
                }
                return;
            }
            // Create a THREE.AnimationAction.
            _this.action = _this.mixer.clipAction(clip);
            if (!_this.action) {
                if (callback) {
                    callback(new Error('Failed to create THREE.AnimationAction'));
                }
                return;
            }
            // FIXME typings workaround
            _this.action.setLoop(_this.loop ? THREE.LoopRepeat : THREE.LoopOnce, Infinity);
            _this.action.timeScale = _this.speed;
            _this.action.time = _this.startTime;
            _this.action.weight = _this.weight;
            _this.action.clampWhenFinished = true;
            _this.action.paused = _this.paused;
            _this.dirty = false;
            _this.getEntity().trigger('animationLoaded');
            if (callback) {
                callback(null, _this);
            }
        });
        if (this.asset.isUnloaded()) {
            this.asset.load();
        }
    };
    /**
     * Pause the animation, without resetting the playhead.
     * @method pause
     * @public
     * @returns {void}
     */
    Animation.prototype.pause = function () {
        this.paused = true;
        if (this.action) {
            this.action.paused = this.paused;
        }
    };
    /**
     * Play the currently assigned animation asset and clip.
     * @method play
     * @public
     * @returns {void}
     */
    Animation.prototype.play = function () {
        var _this = this;
        this.paused = false;
        if (this.dirty) {
            this.load(function (err) {
                if (err) {
                    Logger_1.default.error('Error playing animation: ', err.toString());
                    return;
                }
                _this.play();
            });
            return;
        }
        if (this.action) {
            if (this.needsReset) {
                this.action.reset();
                this.action.time = this.startTime;
                this.needsReset = false;
            }
            this.action.play();
            this.action.paused = this.paused;
        }
    };
    /**
     * Play the specified animation, with the given playback settings.
     * @method playAnimation
     * @public
     * @param {String} assetId The ID of the animation asset.
     * @param {String} clipId The ID of the clip to play.
     * @param {Boolean} loop Whether or not to loop the animation.
     * @param {number} speed The playback speed.
     * @param {number} startTime The time offset to start the animation at.
     * @returns {void}
     */
    Animation.prototype.playAnimation = function (assetId, clipId, loop, speed, startTime) {
        if (assetId !== undefined) {
            this.setAsset(this.getEngine().getEntityById(assetId));
        }
        if (clipId !== undefined) {
            this.setClipId(clipId);
        }
        this.loop = loop !== undefined ? loop : this.loop;
        this.speed = speed !== undefined ? speed : this.speed;
        this.startTime = startTime !== undefined ? startTime : this.startTime;
        this.play();
    };
    /**
     * Stop and release the current animation.
     * @method release
     * @public
     * @returns {void}
     */
    Animation.prototype.release = function () {
        this.stop();
        if (this.action) {
            this.action.stop();
            this.action = undefined;
        }
    };
    /**
     * Set the current animation asset.
     * @method setAsset
     * @public
     * @param {AnimationAsset|null} asset The animation asset or null to unset the asset.
     * @returns {void}
     */
    Animation.prototype.setAsset = function (asset) {
        if (this.asset === asset) {
            return;
        }
        // Remove old change listener from the animation asset.
        if (this.asset) {
            this.stopListening(this.asset, 'propertyChanges', this.onAssetChanged);
            this.unregisterDependency(this.asset);
        }
        this.asset = asset;
        this.dirty = true;
        // Add new change listener to the animation asset.
        if (this.asset) {
            this.listenTo(this.asset, 'propertyChanges', this.onAssetChanged);
            this.registerDependency(this.asset);
        }
    };
    /**
     * Set the current animation clip.
     * @method setClipId
     * @public
     * @param {String} clipId The ID of the clip.
     * @returns {void}
     */
    Animation.prototype.setClipId = function (clipId) {
        if (this.clipId === clipId) {
            return;
        }
        this.clipId = clipId;
        this.dirty = true;
    };
    /**
     * Enable or disable looping.
     * @method setLoop
     * @public
     * @param {Boolean} loop Whether or not looping is enabled.
     * @returns {void}
     */
    Animation.prototype.setLoop = function (loop) {
        this.loop = loop;
        if (this.action) {
            // FIXME, workaround for typings
            this.action.setLoop.apply(this.action, [this.loop ? THREE.LoopRepeat : THREE.LoopOnce, Infinity]);
        }
    };
    /**
     * Set the animation speed.
     * @method setSpeed
     * @public
     * @param {number} speed The animation speed.
     * @returns {void}
     */
    Animation.prototype.setSpeed = function (speed) {
        this.speed = speed;
        if (this.action) {
            this.action.timeScale = speed;
        }
    };
    /**
     * Set the animation time.
     * @method setTime
     * @param {number} time The animation time.
     * @returns {void}
     */
    Animation.prototype.setTime = function (time) {
        if (this.action) {
            this.action.time = time;
        }
    };
    /**
     * Set the animation weight.
     * @method setWeight
     * @param {number} weight The animation weight.
     * @returns {void}
     */
    Animation.prototype.setWeight = function (weight) {
        this.weight = weight;
        if (this.action) {
            this.action.weight = this.weight;
        }
    };
    /** @inheritdoc */
    Animation.prototype.onShutdown = function () {
        // Remove the change listener from the animation asset.
        if (this.asset) {
            this.stopListening(this.asset, 'stopListening', this.onAssetChanged);
        }
        // Release the animation.
        this.release();
        this.getEntity().off('playAnimation', this.playAnimation, this);
        this.getEntity().off('pauseAnimation', this.pause, this);
        this.getEntity().off('stopAnimation', this.stop, this);
        this.getEntity().off('toggleAnimation', this.toggle, this);
    };
    /**
     * Stop the animation and reset the playhead to 0.
     * @method stop
     * @returns {void}
     */
    Animation.prototype.stop = function () {
        if (this.action) {
            this.action.stop();
        }
    };
    /**
     * Toggle between the play and paused state.
     * @method toggle
     * @public
     * @returns {void}
     */
    Animation.prototype.toggle = function () {
        if (this.isPlaying()) {
            this.pause();
        }
        else {
            this.play();
        }
    };
    /** @inheritdoc */
    Animation.prototype.onUpdate = function (deltaTime) {
        if (this.mixer) {
            this.mixer.update(deltaTime);
            this.getEngine().needsRender = true;
            if (this.ended) {
                this.getEntity().trigger('endAnimation');
                this.ended = false;
            }
        }
    };
    /**
     * Called when the animation asset's properties change.
     * @method onAssetChanged
     * @private
     * @returns {void}
     */
    Animation.prototype.onAssetChanged = function () {
        this.dirty = true;
    };
    /**
     * Called when mixer events occur.
     * @method onMixerEvent
     * @private
     * @param {Object} event The mixer event.
     * @returns {void}
     */
    Animation.prototype.onMixerEvent = function (event) {
        // These events are fired in the mixer update loop. Rather than firing an event immediately,
        // set the "ended" flag to true, and fire the event after the mixer update loop completes. This
        // prevents callbacks from modifying animation state during the update loop, which can cause
        // unexpected problems.
        // TODO: Fix THREE.js typings? action is missing on the event.
        if (event.action === this.action && event.type === 'finished') {
            this.needsReset = true;
            this.ended = true;
        }
    };
    return Animation;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Animation;


/***/ },
/* 84 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid light_environment_component
 * @vname Light Environment
 * @vcategory Rendering
 * @vfilter scene
 * @vattr Asset irradianceMap { filter: { renderTexture2D: true, texture2D: true } }
 * @vattr Asset radianceMapHalfGloss { filter: { renderTexture2D: true, texture2D: true } }
 * @vattr Asset radianceMap { filter: { renderTexture2D: true, texture2D: true } }
 * @vattr Boolean useSceneLighting { default: true }
 */
var BaseComponent_1 = __webpack_require__(2);
var MaterialAsset_1 = __webpack_require__(14);
var LightEnvironment = (function (_super) {
    tslib_1.__extends(LightEnvironment, _super);
    function LightEnvironment() {
        var _this = _super.call(this) || this;
        _this.setupMaterial = _this.setupMaterial.bind(_this);
        return _this;
    }
    /** @inheritdoc */
    LightEnvironment.prototype.onAwake = function () {
        var _this = this;
        this.listenTo(this.getEngine(), 'entityCreated', function (entity) {
            if (entity instanceof MaterialAsset_1.default) {
                _this.setupMaterial(entity);
            }
        });
    };
    /** @inheritdoc */
    LightEnvironment.prototype.onAttributesChanged = function () {
        this.setupAllMaterials();
    };
    /** @inheritdoc */
    LightEnvironment.prototype.onDisable = function () {
        this.getEngine().getAssetsByType('material').forEach(function (material) {
            material.setProperty('envMapIrradiance', null);
            material.setProperty('envMapRadianceHalfGloss', null);
            material.setProperty('envMapRadiance', null);
        });
    };
    /** @inheritdoc */
    LightEnvironment.prototype.onEnable = function () {
        this.setupAllMaterials();
    };
    /**
     * Setup lighting for all materials. e.g. assigning IBL textures, disabling
     * scene lighting, etc.
     * @private
     * @memberOf LightEnvironment
     */
    LightEnvironment.prototype.setupAllMaterials = function () {
        this.getEngine().getAssetsByType('material').forEach(this.setupMaterial);
    };
    /**
     * Setup lighting for the given material. e.g. assigning IBL textures, disabling
     * scene lighting, etc.
     * @private
     * @param {MaterialAsset} materialAsset
     * @returns {void}
     * @memberOf LightEnvironment
     */
    LightEnvironment.prototype.setupMaterial = function (materialAsset) {
        if (!materialAsset || !this.isEnabled()) {
            return;
        }
        materialAsset.setProperty('envMapIrradiance', this.getAttribute('irradianceMap'));
        materialAsset.setProperty('envMapRadiance', this.getAttribute('radianceMap'));
        materialAsset.setProperty('envMapRadianceHalfGloss', this.getAttribute('radianceMapHalfGloss'));
    };
    return LightEnvironment;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LightEnvironment;


/***/ },
/* 85 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid lookat_component
 * @vname Look At Target
 * @vdescription A component that automatically points the object at a target. This can be used for billboarding an object to the camera, making a character look at another, etc.
 * @vcategory General
 * @vfilter Object
 * @vattr Object target {
 *   description: 'The object that you want this object to point towards. e.g. for billboarding, this would be the camera used to render the scene.'
 * }
 * @vattr Boolean local {
 *   description: 'If toggled, whatever rotation you have already applied to this object will be taken into account.',
 *   default: false
 * }
 * @vattr Boolean showPreview {
 *   description: 'Run the lookAt in the editor.',
 *   default: true,
 * }
 */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var NodeObject_1 = __webpack_require__(9);
var LookAt = (function (_super) {
    tslib_1.__extends(LookAt, _super);
    function LookAt() {
        var _this = _super.apply(this, arguments) || this;
        _this.playing = true;
        return _this;
    }
    /** @inheritdoc */
    LookAt.prototype.onStartup = function () {
        this.tempVec = new THREE.Vector3();
        this.tempMatrix = new THREE.Matrix4();
        this.tempQuaternion = new THREE.Quaternion();
    };
    /** @inheritdoc */
    LookAt.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('showPreview') !== -1) {
            this.playing = this.showPreview;
        }
        if (!this.playing) {
            var entity = this.getEntity();
            if (entity instanceof NodeObject_1.default) {
                this.getRuntimeData().position.copy(entity.getPosition());
                this.getRuntimeData().quaternion.copy(entity.getQuaternion());
            }
        }
    };
    /** @inheritdoc */
    LookAt.prototype.onEnable = function () {
        this.playing = this.showPreview;
    };
    /** @inheritdoc */
    LookAt.prototype.onDisable = function () {
        this.playing = false;
        var entity = this.getEntity();
        if (entity instanceof NodeObject_1.default) {
            this.getRuntimeData().position.copy(entity.getPosition());
            this.getRuntimeData().quaternion.copy(entity.getQuaternion());
        }
    };
    /** @inheritdoc */
    LookAt.prototype.onPostUpdate = function () {
        var runtimeData;
        if (this.hasRuntimeData() && this.playing && this.isEnabled()) {
            runtimeData = this.getRuntimeData();
            if (this.target && this.target.runtimeData) {
                this.getEngine().needsRender = true;
                var lookAtObject = this.target.runtimeData;
                this.tempVec.setFromMatrixPosition(lookAtObject.matrixWorld);
                if (runtimeData.parent) {
                    this.tempMatrix.getInverse(runtimeData.parent.matrixWorld);
                }
                else {
                    this.tempMatrix.identity();
                }
                this.tempVec.applyMatrix4(this.tempMatrix);
                if (this.local) {
                    runtimeData.lookAt(this.tempVec);
                    var entity = this.getEntity();
                    if (entity instanceof NodeObject_1.default) {
                        runtimeData.quaternion.multiply(entity.getQuaternion());
                    }
                }
                else {
                    runtimeData.lookAt(this.tempVec);
                }
            }
        }
    };
    /**
     * Called when a verold object is destroyed or this component is removed
     * from a verold object.
     */
    /** @inheritdoc */
    LookAt.prototype.onShutdown = function () {
        // make sure to clean up any events or other bindings that you have created
        // to avoid memory leaks
    };
    return LookAt;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LookAt;


/***/ },
/* 86 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid material_capture
 * @vname Material Capture
 * @vfilter material
 * @vcategory Rendering
 * @vdescription A component that captures an image of a rendered material as a spherical map, complete
 * with lighting. This image can then be applied (with a sphere map projection) to a mesh to achieve
 * convincing material shading (although the mesh will appear with the same lighting from all directions).
 * @vattr Asset captureTexture { 'description': '', 'filter': { 'renderTexture2D': true }, default: null }
 */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var SCENE_RADIUS = 0.5;
var SPHERE_TESSELATION = 36;
var SCENE_NEAR = 1;
var SCENE_FAR = 80;
var MaterialCapture = (function (_super) {
    tslib_1.__extends(MaterialCapture, _super);
    function MaterialCapture() {
        var _this = _super.call(this) || this;
        _this.createScene();
        return _this;
    }
    /**
     * Creates the scene and camera used to render the material capture.
     * @method createScene
     * @private
     * @return {void}
     */
    MaterialCapture.prototype.createScene = function () {
        this.camera = new THREE.OrthographicCamera(-SCENE_RADIUS, SCENE_RADIUS, SCENE_RADIUS, -SCENE_RADIUS, SCENE_NEAR, SCENE_FAR);
        this.scene = new THREE.Scene();
        this.createGeometry();
        this.scene.add(this.sphereMesh);
        this.scene.add(this.planeMesh);
        this.scene.add(this.camera);
        // Move the camera a significant fraction of the far clip plane away from the sphere.
        // This will get the camera vector within the shader closer to the ideal orthographic
        // projection that they should be. This won't be necessary when we support true, ortho
        // camera vectors in our shaders.
        this.camera.position.z = SCENE_FAR * 0.5;
        // Also bump the xy position of the camera to get better lighting in the capture.
        // This obviously depends on the environment map setup so this should be made into a
        // component attribute at some point.
        this.camera.position.y = SCENE_FAR * 0.25;
        this.camera.position.x = SCENE_FAR * 0.25;
        this.camera.lookAt(new THREE.Vector3(0, 0, 0));
        this.planeMesh.lookAt(this.camera.position);
    };
    /**
     * Create the geometry and meshes needed to render the matcap texture.
     * @method createGeometry
     * @private
     * @return {void}
     */
    MaterialCapture.prototype.createGeometry = function () {
        this.geometry =
            new THREE.SphereBufferGeometry(SCENE_RADIUS, SPHERE_TESSELATION, SPHERE_TESSELATION);
        this.planeGeometry = new THREE.PlaneBufferGeometry(SCENE_RADIUS * 2, 2);
        // Adjust the plane's normals to point outward so they kind of match the edge of the sphere
        var xyLength = Math.sqrt(0.5);
        // FIXME: square bracket notation to avoid type error, is this an actual bug or an issue with the
        // typings?
        var normalBuffer = this.planeGeometry.attributes['normal'];
        // TODO - this should just copy the position array...
        normalBuffer.array = new Float32Array([-1, 1, 0, 1, 1, 0, -1, -1, 0, 1, -1, 0]);
        for (var i = 0; i < normalBuffer.array.length; i++) {
            normalBuffer.array[i] *= xyLength;
        }
        this.sphereMesh = new THREE.Mesh(this.geometry);
        this.planeMesh = new THREE.Mesh(this.planeGeometry);
    };
    /** @inheritdoc */
    MaterialCapture.prototype.onAttributesChanged = function (changes) {
        var _this = this;
        if (changes.indexOf('captureTexture') !== -1) {
            this.getEntity().when('load', function () {
                _this.captureScene();
            });
        }
    };
    /**
     * Render the scene to the texture
     * @method captureScene
     * @private
     * @return {void}
     */
    MaterialCapture.prototype.captureScene = function () {
        var _this = this;
        var threeMaterial = this.getRuntimeData().static;
        this.sphereMesh.material = threeMaterial;
        this.planeMesh.material = threeMaterial;
        var renderer = this.getThreeRenderer();
        if (this.captureTexture) {
            this.captureTexture.when('load', function (textureAsset) {
                renderer.render(_this.scene, _this.camera, textureAsset.runtimeData);
            });
            if (!this.captureTexture.isLoaded()) {
                this.captureTexture.load();
            }
        }
    };
    return MaterialCapture;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MaterialCapture;


/***/ },
/* 87 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid normal_map_generator_component
 * @vname Normal Map Generator
 * @vcategory Rendering
 * @vfilter renderTexture2D
 * @vattr Asset bumpTexture { filter: { renderTexture2D: true, texture2D: true } }
 * @vattr Float smoothness { slider: true, default: 0.25, min: 0.0001, max: 1.0 }
 * @vattr Float spread { slider: true, default: 4, min: 1, max: 10 }
 * @vattr Boolean autoLoad { default: true }
 * @vevent local renderNormalMap { action: true, category: 'Rendering', parameters: []}
 */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Normal map shader
 * - compute normals from bumpTexture
 */
var VertexShader = [
    'varying vec2 vUv;',
    'void main() {',
    'vUv = uv;',
    'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
    '}'
].join('\n');
var FragmentShader = [
    'precision lowp float;',
    'uniform float smoothness;',
    'uniform float spread;',
    'uniform vec2 resolution;',
    'uniform sampler2D bumpTexture;',
    'vec2 size = vec2( smoothness, 0.0 );',
    'vec3 off = vec3(-spread / resolution.x, 0.0, spread / resolution.y);',
    'varying vec2 vUv;',
    'void main() {',
    'vec4 wave = texture2D( bumpTexture, vUv);',
    'float s11 = wave.x;',
    'float s01 = texture2D( bumpTexture, vUv + off.xy ).x;',
    'float s21 = texture2D( bumpTexture, vUv + off.zy ).x;',
    'float s10 = texture2D( bumpTexture, vUv + off.yx ).x;',
    'float s12 = texture2D( bumpTexture, vUv + off.yz ).x;',
    'vec3 va = normalize(vec3( size.xy, s21-s01));',
    'vec3 vb = normalize(vec3( size.yx, s12-s10));',
    'vec3 norm = cross(va,vb);',
    'gl_FragColor = vec4( norm * 0.5 + 0.5, s11 );',
    '}'
].join('\n');
var NormalMapGenerator = (function (_super) {
    tslib_1.__extends(NormalMapGenerator, _super);
    function NormalMapGenerator() {
        var _this = _super.apply(this, arguments) || this;
        _this.m_Uniforms = null;
        _this.normalMaterial = null;
        return _this;
    }
    /** @inheritdoc */
    NormalMapGenerator.prototype.onStartup = function () {
        this.getEntity().on('renderNormalMap', this.renderNormalMap, this);
        this.m_Uniforms = {
            bumpTexture: {
                type: 't',
                value: null
            },
            resolution: {
                type: 'v2',
                value: new THREE.Vector2(256, 256)
            },
            smoothness: {
                type: 'f',
                value: 0.25
            },
            spread: {
                type: 'f',
                value: 4.0
            }
        };
        //create noise material
        this.normalMaterial = new THREE.ShaderMaterial({
            uniforms: this.m_Uniforms,
            vertexShader: VertexShader,
            fragmentShader: FragmentShader,
            blending: THREE.NoBlending
        });
        this.normalMaterial.depthTest = false;
        this.normalMaterial.depthWrite = false;
        this.cameraRTT = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10, 10);
        this.cameraRTT.position.z = 1;
        this.sceneRTT = new THREE.Scene();
        this.sceneRTT.add(this.cameraRTT);
        this.quadGeo = new THREE.PlaneGeometry(1, 1);
        this.quadRTT = new THREE.Mesh(this.quadGeo, this.normalMaterial);
        this.quadRTT.position.z = -5;
        this.sceneRTT.add(this.quadRTT);
    };
    /** @inheritdoc */
    NormalMapGenerator.prototype.onShutdown = function () {
        this.getEntity().off('renderNormalMap', this.renderNormalMap, this);
        this.sceneRTT.remove(this.cameraRTT);
        this.sceneRTT.remove(this.quadRTT);
        this.sceneRTT = undefined;
        this.quadRTT = undefined;
        this.quadGeo.dispose();
        this.normalMaterial.dispose();
        this.m_Uniforms = undefined;
    };
    /** @inheritdoc */
    NormalMapGenerator.prototype.onEntityReady = function () {
        var that = this;
        this.updateUniforms(function () {
            if (that.autoLoad) {
                that.renderNormalMap();
            }
        });
    };
    NormalMapGenerator.prototype.renderNormalMap = function (smoothness) {
        if (smoothness !== undefined) {
            this.m_Uniforms.smoothness.value = smoothness;
        }
        var renderer = this.getThreeRenderer();
        renderer.render(this.sceneRTT, this.cameraRTT, this.getEntity().runtimeData, true);
        this.getThreeRenderer().setRenderTarget(null);
    };
    /** @inheritdoc */
    NormalMapGenerator.prototype.onAttributesChanged = function () {
        var that = this;
        this.updateUniforms(function () {
            that.renderNormalMap();
        });
    };
    NormalMapGenerator.prototype.updateUniforms = function (callback) {
        this.m_Uniforms.smoothness.value = this.smoothness;
        this.m_Uniforms.spread.value = this.spread;
        if (this.bumpTexture) {
            if (this.bumpTexture.runtimeData) {
                this.m_Uniforms.bumpTexture.value = this.bumpTexture.runtimeData;
                this.m_Uniforms.resolution.value.set(this.bumpTexture.getWidth(), this.bumpTexture.getHeight());
                if (typeof callback === 'function') {
                    callback();
                }
            }
            else {
                this.bumpTexture.once('load', function () {
                    this.m_Uniforms.bumpTexture.value = this.bumpTexture.runtimeData;
                    this.m_Uniforms.resolution.value.set(this.bumpTexture.getWidth(), this.bumpTexture.getHeight());
                    if (typeof callback === 'function') {
                        callback();
                    }
                }, this);
                this.bumpTexture.load();
            }
        }
    };
    return NormalMapGenerator;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = NormalMapGenerator;


/***/ },
/* 88 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid object_animator_component
 * @vname Object Animator
 * @vcategory Animation
 * @vfilter Object
 * @vevent local playAnimateAlongCurve {
 *   action: true,
 *   category: 'Animation',
 *   parameters: [
 *     {name: 'curve', 'type' : 'object', 'componentFilter': { 'Curve' : true }},
 *     {name: 'animationTime', 'type': 'f', 'description': 'Time to animate to object. Defined in seconds', 'default': 3},
 *     {name: 'easeIn', 'type' : 'f', 'description': 'The percentage of animation time spent speeding up.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
 *     {name: 'easeOut', 'type' : 'f', 'description': 'The percentage of animation time spent slowing down.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
 *     {name: 'orientation', 'description': 'Orient the object following the curve to either the direction of the curve or to the objects defining the curve.', 'type': 'opt', 'default': 'toCurve', 'options' : { 'None': 'None', 'To Curve' : 'toCurve', 'To Nodes' : 'toNode'}},
 *     {name: 'loop', 'type' : 'b', 'description': '', 'default': false}
 *   ]
 * }
 * @vevent local playAnimateToObject {
 *   action: true,
 *   category: 'Animation',
 *   parameters: [
 *     {name: 'object', 'type' : 'object', 'default': null},
 *     {name: 'animationTime', 'type': 'f', 'description': 'Total time that the animation will take. Defined in seconds', 'default': 3},
 *     {name: 'easeIn', 'type' : 'f', 'description': 'The percentage of animation time spent speeding up.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
 *     {name: 'easeOut', 'type' : 'f', 'description': 'The percentage of animation time spent slowing down.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
 *     {name: 'update orientation', 'type' : 'b', 'default': true}
 *   ]
 * }
 * @vevent local playAnimateTranslation {
 *   action: true,
 *   category: 'Animation',
 *   parameters: [
 *     {name: 'animationTime', 'type': 'f', 'description': 'Time to animate. Defined in seconds', 'default': 3},
 *     {name: 'easeIn', 'type' : 'f', 'description': 'The percentage of animation time spent speeding up.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
 *     {name: 'easeOut', 'type' : 'f', 'description': 'The percentage of animation time spent slowing down.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
 *     {name: 'velocity', 'description': '', 'type': 'v3', 'default': {x:0,y:0,z:1.0}, 'min': -1.0, 'max': 1.0},
 *     {name: 'objectUsage', 'type' : 'opt', 'description': 'Specify what part of the animation the current object\'s position represents.', 'default': 'beginning', 'options': { 'Beginning': 'beginning', 'Middle': 'middle', 'End': 'end' } },
 *   ]
 * }
 * @vevent local playAnimateRotation {
 *   action: true,
 *   category: 'Animation',
 *   parameters: [
 *     {name: 'animationTime', 'type': 'f', 'description': 'Time to animate to object. Defined in seconds', 'default': 3},
 *     {name: 'easeIn', 'type' : 'f', 'description': 'The percentage of animation time spent speeding up.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
 *     {name: 'easeOut', 'type' : 'f', 'description': 'The percentage of animation time spent slowing down.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
 *     {name: 'angularVelocity', 'description': '', 'type': 'v3', 'default': {x:0,y:0,z:1.0}, 'min': -100.0, 'max': 100.0},
 *     {name: 'objectUsage', 'type' : 'opt', 'description': 'Specify what part of the animation the current object\'s rotation represents.', 'default': 'beginning', 'options': { 'Beginning': 'beginning', 'Middle': 'middle', 'End': 'end' } },
 *     {name: 'axisOrder', 'type' : 'opt', 'description': 'Specify the axis order that the angular velocity will be applied in.', 'default': 'YXZ', 'options': {
 *       'XYZ': 'XYZ',
 *       'YXZ': 'YXZ',
 *       'ZXY': 'ZXY',
 *       'XZY': 'XZY',
 *       'YZX': 'YZX',
 *       'ZYX': 'ZYX'}
 *     }
 *   ]
 * }
 * @vevent local playAnimateScale {
 *   action: true,
 *   category: 'Animation',
 *   parameters: [
 *     {name: 'animationTime', 'type': 'f', 'description': 'Time to animate to object. Defined in seconds', 'default': 3},
 *     {name: 'easeIn', 'type' : 'f', 'description': 'The percentage of animation time spent speeding up.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
 *     {name: 'easeOut', 'type' : 'f', 'description': 'The percentage of animation time spent slowing down.', 'default' : 0.25, 'min': 0.0, 'max': 1.0 },
 *     {name: 'velocity', 'description': '', 'type': 'v3', 'default': {x:0,y:0,z:1.0}, 'min': -10.0, 'max': 10.0},
 *     {name: 'objectUsage', 'type' : 'opt', 'description': 'Specify what part of the animation the current object\'s scale represents.', 'default': 'beginning', 'options': { 'Beginning': 'beginning', 'Middle': 'middle', 'End': 'end' } },
 *   ]
 * }
 * @vevent local pauseCurveAnimation { 'action': true, 'category': 'Animation', 'parameters': []}
 * @vevent local stopCurveAnimation {'action': true, 'category': 'Animation', 'parameters': []}
 * @vevent local unpauseCurveAnimation {'action': true, 'category': 'Animation', 'parameters': []}
 * @vevent local endAnimateAlongCurve {'action': false, 'category': 'Animation', 'parameters': []}
 * @vevent local endAnimateToObject {'action': false, 'category': 'Animation', 'parameters': []}
 * @vevent lcoal endAnimateTranslation {'action': false, 'category': 'Animation', 'parameters': []}
 */
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var ObjectAnimator = (function (_super) {
    tslib_1.__extends(ObjectAnimator, _super);
    function ObjectAnimator() {
        var _this = _super.apply(this, arguments) || this;
        _this.playingCurveAnimation = false;
        _this.curveAnim = undefined;
        return _this;
    }
    /**
     * Called immediately after after component creation
     */
    /** @inheritdoc */
    ObjectAnimator.prototype.onStartup = function () {
        this.getEntity().on('playAnimateAlongCurve', this.animateAlongCurve, this);
        this.getEntity().on('playAnimateToObject', this.animateToObject, this);
        this.getEntity().on('playAnimateTranslation', this.animateTranslation, this);
        this.getEntity().on('playAnimateRotation', this.animateRotation, this);
        this.getEntity().on('playAnimateScale', this.animateScale, this);
        this.getEntity().on('pauseCurveAnimation', this.onPauseCurveAnimation, this);
        this.getEntity().on('unpauseCurveAnimation', this.onUnpauseCurveAnimation, this);
        this.getEntity().on('stopCurveAnimation', this.stopCurveAnimation, this);
    };
    /** @inheritdoc */
    ObjectAnimator.prototype.onShutdown = function () {
        this.getEntity().off('playAnimateAlongCurve', this.animateAlongCurve, this);
        this.getEntity().off('playAnimateToObject', this.animateToObject, this);
        this.getEntity().off('playAnimateTranslation', this.animateTranslation, this);
        this.getEntity().off('playAnimateRotation', this.animateRotation, this);
        this.getEntity().off('playAnimateScale', this.animateScale, this);
        this.getEntity().off('pauseCurveAnimation', this.onPauseCurveAnimation, this);
        this.getEntity().off('unpauseCurveAnimation', this.onUnpauseCurveAnimation, this);
        this.getEntity().off('stopCurveAnimation', this.stopCurveAnimation, this);
    };
    /** @inheritdoc */
    ObjectAnimator.prototype.onDisable = function () {
        this.getRuntimeData().position.copy(this.getEntity().getPosition());
        this.getRuntimeData().quaternion.copy(this.getEntity().getQuaternion());
        this.getRuntimeData().scale.copy(this.getEntity().getScale());
    };
    ObjectAnimator.prototype.stopCurveAnimation = function () {
        this.getEngine().off('update', this.curveAnim, this);
        this.curveAnim = undefined;
    };
    ObjectAnimator.prototype.animateAlongCurve = function (curveObjectId, animationTime, easeIn, easeOut, orientation, loop) {
        function curveAnim(delta) {
            if (!this.entity || !this.isEnabled()) {
                engine.off('update', this.curveAnim, this);
                this.curveAnim = undefined;
                return;
            }
            if (curveComponent && this.playingCurveAnimation) {
                this.getEngine().needsRender = true;
                currentTime += delta;
                var currentTimePercent = currentTime / animationTime;
                if (currentTimePercent >= 1.0) {
                    currentTimePercent -= 1.0;
                }
                var easeOutStart = 1 - easeOut;
                //Ease in
                if (easeIn && currentTimePercent < easeIn) {
                    var easeInProgress = currentTimePercent / easeIn;
                    curveProgressPercent += delta * fullSpeed / animationTime *
                        (Math.cos(easeInProgress * Math.PI + Math.PI) * 0.5 + 0.5);
                }
                else if (easeOut && currentTimePercent > easeOutStart) {
                    //Ease out
                    var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;
                    curveProgressPercent += delta * fullSpeed / animationTime *
                        Math.max(Math.cos(easeOutProgress * Math.PI + Math.PI) * 0.5 + 0.5, 0.0);
                }
                else {
                    //Full speed animation
                    curveProgressPercent += delta * fullSpeed / animationTime;
                }
                //If the animation is finished
                if (curveProgressPercent >= 1.0 || curveProgressPercent < 0.0) {
                    curveProgressPercent %= 1.0;
                    currentTime = 0.0;
                    if (!loop) {
                        curveProgressPercent = 0.99999999;
                        this.playingCurveAnimation = false;
                        this.getEngine().off('update', this.curveAnim, this);
                        this.curveAnim = undefined;
                    }
                    this.getEntity().trigger('endAnimateAlongCurve');
                }
                var curve = curveComponent.curve;
                var curveProgress_NodeRelative = curve.getUtoTmapping(curveProgressPercent);
                runtimeData.position.copy(curve.getPoint(curveProgress_NodeRelative));
                if (orientation === 'toCurve') {
                    var tangent = curve.getTangent(curveProgress_NodeRelative);
                    tempVector1.set(0, -1, 0);
                    tempVector2.crossVectors(tangent, tempVector1);
                    tempVector3.crossVectors(tangent, tempVector2);
                    tempVector1.copy(runtimeData.position);
                    tempVector1.add(tangent);
                    tempMatrix.lookAt(runtimeData.position, tempVector1, tempVector3);
                    runtimeData.quaternion.setFromRotationMatrix(tempMatrix);
                }
                else if (orientation === 'toNode') {
                    var curveSegments;
                    if (curveComponent.closed) {
                        curveSegments = curve.points.length;
                    }
                    else {
                        curveSegments = curve.points.length - 1;
                    }
                    var prevNode = Math.floor(curveProgress_NodeRelative * curveSegments);
                    var nextNode = Math.ceil(curveProgress_NodeRelative * curveSegments) %
                        curve.points.length;
                    if (prevNode !== currentPrevNode) {
                        if (prevNode > 0) {
                            curveComponent.controlPoints[prevNode].getQuaternionInWorldSpace(prevQuaternion);
                        }
                        else {
                            curveComponent.controlPoints[0].getQuaternionInWorldSpace(prevQuaternion);
                        }
                    }
                    if (nextNode !== currentNextNode) {
                        if (nextNode > 0) {
                            curveComponent.controlPoints[nextNode].getQuaternionInWorldSpace(nextQuaternion);
                        }
                        else {
                            curveComponent.controlPoints[0].getQuaternionInWorldSpace(nextQuaternion);
                        }
                    }
                    var interp = curveProgress_NodeRelative * curveSegments - prevNode;
                    runtimeData.quaternion.copy(prevQuaternion);
                    runtimeData.quaternion.slerp(nextQuaternion, interp);
                }
            }
        }
        var that = this;
        var curveComponent;
        var curveObject;
        if (curveObjectId) {
            curveObject = this.getEngine().getEntityById(curveObjectId);
            curveComponent = curveObject.getComponentByScriptId('curve_component');
        }
        if (!curveComponent) {
            return;
        }
        var runtimeData = this.getRuntimeData();
        var engine = this.getEngine();
        var currentTime = 0;
        var curveProgressPercent = 0.0;
        var tempVector1 = new THREE.Vector3();
        var tempVector2 = new THREE.Vector3();
        var tempVector3 = new THREE.Vector3();
        var tempMatrix = new THREE.Matrix4();
        var prevQuaternion = new THREE.Quaternion();
        var nextQuaternion = new THREE.Quaternion();
        if (easeIn + easeOut > 1.0) {
            Logger_1.default.warn('Ease-In and Ease-Out value can\'t total more than 1.0.');
            easeIn = 0.5;
            easeOut = 0.5;
        }
        var fullSpeedTime = 1.0 - easeIn - easeOut;
        var fullSpeed = 1.0 / (easeIn / 2 + easeOut / 2 + fullSpeedTime);
        if (animationTime > 0) {
            this.playingCurveAnimation = true;
            var currentPrevNode = -1;
            var currentNextNode = -1;
            if (curveComponent.isCurveInit()) {
                this.curveAnim = curveAnim;
                this.getEngine().on('update', this.curveAnim, this);
            }
            else {
                curveComponent.on('curveInit', function () {
                    this.curveAnim = curveAnim;
                    that.getEngine().on('update', this.curveAnim, that);
                }, this);
            }
        }
    };
    ObjectAnimator.prototype.onPauseCurveAnimation = function () {
        this.playingCurveAnimation = false;
    };
    ObjectAnimator.prototype.onUnpauseCurveAnimation = function () {
        this.playingCurveAnimation = true;
    };
    ObjectAnimator.prototype.animateToObject = function (objectId, animationTime, easeIn, easeOut, orientation) {
        var that = this;
        var engine = this.getEngine();
        function _animateTo(threeObject) {
            var entity_data = that.getRuntimeData();
            var tempMatrix = new THREE.Matrix4();
            var currTime = 0;
            var curveProgressPercent = 0.0;
            if (easeIn + easeOut > 1.0) {
                Logger_1.default.warn('Ease-In and Ease-Out value can\'t total more than 1.0.');
                easeIn = 0.5;
                easeOut = 0.5;
            }
            var fullSpeedTime = 1.0 - easeIn - easeOut;
            var fullSpeed = 1.0 / (easeIn / 2 + easeOut / 2 + fullSpeedTime);
            //var easeInDistance = easeIn * fullSpeed / 2.0;
            //var easeOutDistance = easeOut * fullSpeed / 2.0;
            var startPos = new THREE.Vector3();
            var startQuat;
            startPos.copy(entity_data.position);
            var targetPosition = threeObject.position;
            var targetQuaternion = threeObject.quaternion;
            if (targetQuaternion && orientation) {
                startQuat = new THREE.Quaternion();
                startQuat.copy(entity_data.quaternion);
            }
            threeObject.updateMatrixWorld();
            targetPosition.setFromMatrixPosition(threeObject.matrixWorld);
            tempMatrix.extractRotation(threeObject.matrixWorld);
            targetQuaternion.setFromRotationMatrix(tempMatrix);
            if (animationTime > 0) {
                that.getEngine().on('update', function objAnim(delta) {
                    if (!this.entity || !this.isEnabled()) {
                        engine.off('update', objAnim, this);
                        return;
                    }
                    that.getEngine().needsRender = true;
                    currTime += delta;
                    var currentTimePercent = currTime / animationTime;
                    var easeOutStart = 1 - easeOut;
                    if (easeIn && currentTimePercent < easeIn) {
                        //Ease in
                        var easeInProgress = currentTimePercent / easeIn;
                        curveProgressPercent += delta * fullSpeed / animationTime *
                            (Math.cos(easeInProgress * Math.PI + Math.PI) * 0.5 + 0.5);
                    }
                    else if (easeOut && currentTimePercent > easeOutStart) {
                        //Ease out
                        var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;
                        curveProgressPercent += delta * fullSpeed / animationTime *
                            Math.max(Math.cos(easeOutProgress * Math.PI + Math.PI) * 0.5 + 0.5, 0.0);
                    }
                    else {
                        //Full speed animation
                        curveProgressPercent += delta * fullSpeed / animationTime;
                    }
                    //clamp at 1
                    curveProgressPercent = Math.min(curveProgressPercent, 1.0);
                    if (curveProgressPercent >= 1.0 || curveProgressPercent < 0.0) {
                        that.getEngine().off('update', objAnim, that);
                        that.getEntity().trigger('endAnimateToObject');
                    }
                    entity_data.position.copy(startPos);
                    entity_data.position.lerp(targetPosition, curveProgressPercent);
                    if (targetQuaternion && orientation) {
                        entity_data.quaternion.copy(startQuat);
                        entity_data.quaternion.slerp(targetQuaternion, curveProgressPercent);
                    }
                }, that);
            }
            else {
                entity_data.position.copy(targetPosition);
                if (targetQuaternion) {
                    entity_data.quaternion.copy(targetQuaternion);
                }
                //complete
                that.getEntity().trigger('endAnimateToObject');
            }
        }
        var object = this.getEngine().getEntityById(objectId);
        if (object.runtimeData) {
            _animateTo(object.runtimeData);
        }
        else {
            object.once('loadBase', function () {
                _animateTo(object.runtimeData);
            }, this);
            object.load();
        }
    };
    ObjectAnimator.prototype.animateTranslation = function (animationTime, easeIn, easeOut, velocity, objectUsage) {
        var runtimeData = this.getRuntimeData();
        runtimeData.position.copy(this.getEntity().getPosition());
        runtimeData.quaternion.copy(this.getEntity().getQuaternion());
        runtimeData.scale.copy(this.getEntity().getScale());
        var currTime = 0;
        var engine = this.getEngine();
        if (easeIn + easeOut > 1.0) {
            Logger_1.default.warn('Ease-In and Ease-Out value can\'t total more than 1.0.');
            easeIn = 0.5;
            easeOut = 0.5;
        }
        var easeInTime = animationTime * easeIn;
        // var easeOutTime = animationTime * easeOut;
        var currentVelocity = new THREE.Vector3();
        var direction = new THREE.Vector3();
        direction.copy(velocity);
        var speed = direction.length();
        runtimeData.updateMatrixWorld();
        // runtimeData.updateMatrix();
        direction.applyQuaternion(runtimeData.quaternion);
        direction.normalize();
        if (objectUsage) {
            var fullSpeedTime = (1.0 - easeIn - easeOut) * animationTime;
            var halfSpeedTime = (easeIn + easeOut) * 0.5 * animationTime;
            //Based on the object usage, set the original position so that the
            //animation plays forward from there...
            if (objectUsage === 'middle') {
                //postiion - velocity * time * 0.5
                currentVelocity.copy(velocity);
                currentVelocity.multiplyScalar(-0.5 * (fullSpeedTime + halfSpeedTime));
                runtimeData.position.add(currentVelocity);
            }
            else if (objectUsage === 'end') {
                currentVelocity.copy(velocity);
                currentVelocity.multiplyScalar(-1.0 * (fullSpeedTime + halfSpeedTime));
                runtimeData.position.add(currentVelocity);
            }
        }
        if (animationTime > 0) {
            this.getEngine().on('update', function objAnim(delta) {
                if (!this.entity || !this.isEnabled()) {
                    engine.off('update', objAnim, this);
                    return;
                }
                currentVelocity.copy(direction);
                this.getEngine().needsRender = true;
                currTime += delta;
                var currentTimePercent = Math.min(currTime / animationTime, 1.0); //clamp to 100%
                var easeOutStart = (1.0 - easeOut);
                var easeOutStartTime = animationTime * easeOutStart;
                if (easeIn && currTime < easeInTime) {
                    //Ease in
                    var easeInProgress = currentTimePercent / easeIn;
                    currentVelocity.multiplyScalar(delta * speed *
                        (Math.cos(easeInProgress * Math.PI + Math.PI) * 0.5 + 0.5));
                }
                else if (easeOut && currTime > easeOutStartTime) {
                    //Ease out
                    var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;
                    currentVelocity.multiplyScalar(delta * speed *
                        Math.max(Math.cos(easeOutProgress * Math.PI + Math.PI) * 0.5 + 0.5, 0.0));
                }
                else {
                    //Full speed animation
                    currentVelocity.multiplyScalar(delta * speed);
                }
                if (currTime >= animationTime) {
                    this.getEngine().off('update', objAnim, this);
                    this.getEntity().trigger('endAnimateTranslation');
                }
                runtimeData.position.add(currentVelocity);
            }, this);
        }
    };
    ObjectAnimator.prototype.animateRotation = function (animationTime, easeIn, easeOut, velocity, objectUsage, axisOrder) {
        var runtimeData = this.getRuntimeData();
        runtimeData.position.copy(this.getEntity().getPosition());
        runtimeData.quaternion.copy(this.getEntity().getQuaternion());
        runtimeData.scale.copy(this.getEntity().getScale());
        var currTime = 0;
        var engine = this.getEngine();
        if (easeIn + easeOut > 1.0) {
            Logger_1.default.warn('Ease-In and Ease-Out value can\'t total more than 1.0.');
            easeIn = 0.5;
            easeOut = 0.5;
        }
        var easeInTime = animationTime * easeIn;
        // var easeOutTime = animationTime * easeOut;
        var currentVelocity = new THREE.Quaternion();
        var fullSpeedQuat = new THREE.Quaternion();
        var tempVector1 = new THREE.Vector3();
        var eulerVelocity = new THREE.Euler(axisOrder);
        eulerVelocity.set(velocity.x, velocity.y, velocity.z);
        //Convert the euler angles to quaternion
        currentVelocity.setFromEuler(eulerVelocity);
        fullSpeedQuat.copy(currentVelocity);
        runtimeData.updateMatrixWorld();
        if (objectUsage) {
            var fullSpeedTime = (1.0 - easeIn - easeOut) * animationTime;
            var halfSpeedTime = (easeIn + easeOut) * 0.5 * animationTime;
            //Based on the object usage, set the original rotation so that the
            //animation plays forward from there...
            if (objectUsage === 'middle') {
                //postiion - velocity * time * 0.5
                tempVector1.copy(velocity);
                tempVector1.multiplyScalar(-0.5 * (fullSpeedTime + halfSpeedTime));
                eulerVelocity.set(tempVector1.x, tempVector1.y, tempVector1.z);
                currentVelocity.setFromEuler(eulerVelocity);
                runtimeData.quaternion.multiply(currentVelocity);
            }
            else if (objectUsage === 'end') {
                tempVector1.copy(velocity);
                tempVector1.multiplyScalar(-1.0 * (fullSpeedTime + halfSpeedTime));
                eulerVelocity.set(tempVector1.x, tempVector1.y, tempVector1.z);
                currentVelocity.setFromEuler(eulerVelocity);
                runtimeData.quaternion.multiply(currentVelocity);
            }
        }
        if (animationTime > 0) {
            this.getEngine().on('update', function objAnim(delta) {
                if (!this.entity || !this.isEnabled()) {
                    engine.off('update', objAnim, this);
                    return;
                }
                var speed = 1.0;
                this.getEngine().needsRender = true;
                currTime += delta;
                var currentTimePercent = Math.min(currTime / animationTime, 1.0);
                var easeOutStart = (1.0 - easeOut);
                var easeOutStartTime = animationTime * easeOutStart;
                if (easeIn && currTime < easeInTime) {
                    //Ease in
                    var easeInProgress = currentTimePercent / easeIn;
                    speed *= delta * (Math.cos(easeInProgress * Math.PI + Math.PI) * 0.5 + 0.5);
                }
                else if (easeOut && currTime > easeOutStartTime) {
                    //Ease out
                    var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;
                    speed *= delta * Math.max(Math.cos(easeOutProgress * Math.PI + Math.PI) *
                        0.5 + 0.5, 0.0);
                }
                else {
                    //Full speed animation
                    speed *= delta;
                }
                if (currTime >= animationTime) {
                    this.getEngine().off('update', objAnim, this);
                    this.getEntity().trigger('endAnimateTranslation');
                }
                currentVelocity.set(0.0, 0.0, 0.0, 1.0);
                currentVelocity.slerp(fullSpeedQuat, speed);
                runtimeData.quaternion.multiply(currentVelocity);
            }, this);
        }
    };
    ObjectAnimator.prototype.animateScale = function (animationTime, easeIn, easeOut, velocity, objectUsage) {
        var runtimeData = this.getRuntimeData();
        runtimeData.position.copy(this.getEntity().getPosition());
        runtimeData.quaternion.copy(this.getEntity().getQuaternion());
        runtimeData.scale.copy(this.getEntity().getScale());
        var currTime = 0;
        var engine = this.getEngine();
        if (easeIn + easeOut > 1.0) {
            Logger_1.default.warn('Ease-In and Ease-Out value can\'t total more than 1.0.');
            easeIn = 0.5;
            easeOut = 0.5;
        }
        var easeInTime = animationTime * easeIn;
        // var easeOutTime = animationTime * easeOut;
        var currentVelocity = new THREE.Vector3();
        runtimeData.updateMatrixWorld();
        if (objectUsage) {
            var fullSpeedTime = (1.0 - easeIn - easeOut) * animationTime;
            var halfSpeedTime = (easeIn + easeOut) * 0.5 * animationTime;
            //Based on the object usage, set the original scale so that the
            //animation plays forward from there...
            if (objectUsage === 'middle') {
                //postiion - velocity * time * 0.5
                currentVelocity.copy(velocity);
                currentVelocity.multiplyScalar(-0.5 * (fullSpeedTime + halfSpeedTime));
                runtimeData.scale.add(currentVelocity);
            }
            else if (objectUsage === 'end') {
                currentVelocity.copy(velocity);
                currentVelocity.multiplyScalar(-1.0 * (fullSpeedTime + halfSpeedTime));
                runtimeData.scale.add(currentVelocity);
            }
        }
        if (animationTime > 0) {
            this.getEngine().on('update', function objAnim(delta) {
                if (!this.entity || !this.isEnabled()) {
                    engine.off('update', objAnim, this);
                    return;
                }
                currentVelocity.copy(velocity);
                this.getEngine().needsRender = true;
                currTime += delta;
                var currentTimePercent = Math.min(currTime / animationTime, 1.0); //clamp to 100%
                var easeOutStart = (1.0 - easeOut);
                var easeOutStartTime = animationTime * easeOutStart;
                if (easeIn && currTime < easeInTime) {
                    //Ease in
                    var easeInProgress = currentTimePercent / easeIn;
                    currentVelocity.multiplyScalar(delta * (Math.cos(easeInProgress *
                        Math.PI + Math.PI) * 0.5 + 0.5));
                }
                else if (easeOut && currTime > easeOutStartTime) {
                    //Ease out
                    var easeOutProgress = 1.0 - (currentTimePercent - easeOutStart) / easeOut;
                    currentVelocity.multiplyScalar(delta * Math.max(Math.cos(easeOutProgress *
                        Math.PI + Math.PI) * 0.5 + 0.5, 0.0));
                }
                else {
                    //Full speed animation
                    currentVelocity.multiplyScalar(delta);
                }
                if (currTime >= animationTime) {
                    this.getEngine().off('update', objAnim, this);
                    this.getEntity().trigger('endAnimateTranslation');
                }
                runtimeData.scale.add(currentVelocity);
            }, this);
        }
    };
    return ObjectAnimator;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ObjectAnimator;


/***/ },
/* 89 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid object_picker
 * @vname Object Picker
 * @vfilter Scene
 * @vcategory General
 * @vattr Dropdown pickTrigger {
 *   description: 'What mouse action will trigger the pick?',
 *   default: 'leftMouseClick',
 *   options: {
 *     'Left Mouse Click': 'leftMouseClick',
 *     'Middle Mouse Click': 'middleMouseClick',
 *     'Right Mouse Click': 'rightMouseClick',
 *     'Left Mouse Down': 'leftMouseDown',
 *     'Middle Mouse Down': 'middleMouseDown',
 *     'Right Mouse Down': 'rightMouseDown',
 *     'Left Mouse Up': 'leftMouseUp',
 *     'Middle Mouse Up': 'middleMouseUp',
 *     'Right Mouse Up': 'rightMouseUp'
 *   }
 * }
 * @vattr Boolean enableHoverByDefault {
 *   default: false,
 *   advanced: true,
 *   description: 'Enable hover detection when mouse cursor is over a mesh. Note that this has a potential performance impact.'
 * }
 * @vattr Integer hoverFrameSkip {
 *   description: 'Skip this many frames inbetween hover checks.',
 *   default: 1,
 *   min: 0,
 *   max: 60
 * }
 * @vevent other pick { action: false, category: 'General', parameters: [] }
 * @vevent other beginHover { action: false, category: 'General', parameters: [] }
 * @vevent other endHover { action: false, category: 'General', parameters: []}
 */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var UserAgent_1 = __webpack_require__(13);
var functions_1 = __webpack_require__(6);
var ObjectPicker = (function (_super) {
    tslib_1.__extends(ObjectPicker, _super);
    function ObjectPicker() {
        var _this = _super.apply(this, arguments) || this;
        _this.pickingMaterialDef = undefined;
        _this.meshRegistry = {};
        _this.meshList = [];
        _this.pickingTexture = undefined;
        _this.currentHoverObject = undefined;
        _this.currentFrame = 0;
        _this.enableHoverByDefault = false;
        _this.pickTrigger = null;
        _this.hoverEnabled = false;
        return _this;
    }
    /** @inheritdoc */
    ObjectPicker.prototype.onAwake = function () {
        this.getEngine().once('endHover:bound', this._enableHover, this);
        this.getEngine().once('beginHover:bound', this._enableHover, this);
    };
    /** @inheritdoc */
    ObjectPicker.prototype.onStartup = function () {
        // this.entity is available
        this.getEngine().on('resize', this.resize, this);
        this.initPickingEvents();
        this.initPickingMaterial();
        this.initMeshRegistry();
        //listen to register objects
        this.getGlobalEvents().on('registerPickingObject', this.registerObject, this);
        this.getGlobalEvents().on('unregisterPickingObject', this.unregisterObject, this);
        this.resize();
    };
    /** @inheritdoc */
    ObjectPicker.prototype.onShutdown = function () {
        // make sure to clean up any events or other bindings that you have created
        // to avoid memory leaks
        this.uninitPickingEvents();
        this.getEngine().off('resize', this.resize, this);
        this.getGlobalEvents().off('registerPickingObject', this.registerObject, this);
        this.getGlobalEvents().off('unregisterPickingObject', this.unregisterObject, this);
        // TODO - Listen to different events to make ObjectPicker work again.
        // var parentAsset = this.getEntity().getParentAsset();
        // parentAsset.off('meshLoaded', this.registerMesh, this);
        // parentAsset.off('meshUnloaded', this.unregisterMesh, this);
        if (this.pickingTexture) {
            this.pickingTexture.dispose();
            this.pickingTexture = undefined;
        }
        for (var x in this.meshRegistry) {
            if (this.meshRegistry[x].pickingMaterial) {
                this.meshRegistry[x].pickingMaterial.dispose();
            }
        }
        this.meshRegistry = {};
        this.meshList = [];
    };
    ObjectPicker.prototype.initPickingEvents = function () {
        if (this.pickTrigger.substr(-2) === 'Up') {
            if (UserAgent_1.isMobile()) {
                this.getEngine().on('touchEnd', this.touchPick, this);
            }
            else {
                this.getEngine().on('mouseUp', this.pick, this);
            }
        }
        else if (this.pickTrigger.substr(-4) === 'Down') {
            if (UserAgent_1.isMobile()) {
                this.getEngine().on('touchStart', this.touchPick, this);
            }
            else {
                this.getEngine().on('mouseDown', this.pick, this);
            }
        }
        else if (this.pickTrigger.substr(-5) === 'Click') {
            if (UserAgent_1.isMobile()) {
                this.getEngine().on('touchEnd', this.touchPickNoDrag, this);
            }
            else {
                this.getEngine().on('mouseUp', this.pickNoDrag, this);
            }
        }
        if (this.enableHoverByDefault && !UserAgent_1.isMobile()) {
            this._enableHover();
        }
    };
    ObjectPicker.prototype.uninitPickingEvents = function () {
        if (this.pickTrigger.substr(-2) === 'Up') {
            if (UserAgent_1.isMobile()) {
                this.getEngine().off('touchEnd', this.touchPick, this);
            }
            else {
                this.getEngine().off('mouseUp', this.pick, this);
            }
        }
        else {
            if (UserAgent_1.isMobile()) {
                this.getEngine().off('touchStart', this.touchPick, this);
            }
            else {
                this.getEngine().off('mouseDown', this.pick, this);
            }
        }
    };
    /** @inheritdoc */
    ObjectPicker.prototype.onPostRender = function () {
        if (this.enableHoverByDefault && !UserAgent_1.isMobile()) {
            this.hoverUpdate();
        }
    };
    ObjectPicker.prototype.initPickingMaterial = function () {
        this.pickingMaterialDef = {
            depthTest: true,
            depthWrite: true,
            transparent: false,
            side: THREE.DoubleSide,
            uniforms: {
                color: {
                    type: 'c',
                    value: 0xff0000
                }
            },
            vertexShader: [
                THREE.ShaderChunk['skinning_pars_vertex'],
                THREE.ShaderChunk['logdepthbuf_pars_vertex'],
                'void main() {',
                THREE.ShaderChunk['skinbase_vertex'],
                THREE.ShaderChunk['skinnormal_vertex'],
                THREE.ShaderChunk['defaultnormal_vertex'],
                THREE.ShaderChunk['skinning_vertex'],
                THREE.ShaderChunk['project_vertex'],
                THREE.ShaderChunk['logdepthbuf_vertex'],
                '}'
            ].join('\n'),
            fragmentShader: [
                'uniform vec3 color;',
                THREE.ShaderChunk['logdepthbuf_pars_fragment'],
                'void main() {',
                THREE.ShaderChunk['logdepthbuf_fragment'],
                'gl_FragColor = vec4( color, 1.0 );',
                '}'
            ].join('\n')
        };
    };
    ObjectPicker.prototype.initMeshRegistry = function () {
        // TODO - Listen to different events to make ObjectPicker work again.
        // var parentAsset = this.getEntity().getParentAsset();
        // parentAsset.on('meshLoaded', this.registerMesh, this);
        // parentAsset.on('meshUnloaded', this.unregisterMesh, this);
        var _this = this;
        this.getEntity().getParentObject().traverse(function (obj) {
            if (obj.type === 'mesh') {
                _this.registerMesh(obj);
            }
        });
    };
    ObjectPicker.prototype._enableHover = function () {
        if (!this.hoverEnabled && !UserAgent_1.isMobile()) {
            this.hoverEnabled = true;
        }
    };
    /**
    * reset the size of the texture used to test against geometry picking parameters
    * @method resize
    */
    ObjectPicker.prototype.resize = function () {
        var oldPickingTexture = this.pickingTexture;
        var width = this.getRenderer().getWidth();
        var height = this.getRenderer().getHeight();
        this.pickingTexture = new THREE.WebGLRenderTarget(Math.floor(width / 4.0), Math.floor(height / 4.0), {
            minFilter: THREE.LinearFilter
        });
        this.pickingTexture.texture.generateMipmaps = false;
        if (oldPickingTexture) {
            oldPickingTexture.dispose();
        }
    };
    ObjectPicker.prototype.registerObject = function (object, runtimeData) {
        if (!this.meshRegistry[runtimeData.id]) {
            this.meshRegistry[runtimeData.id] = {
                entity: object,
                runtimeData: runtimeData,
                prevMaterial: null,
                pickingMaterial: new THREE.ShaderMaterial(this.pickingMaterialDef)
            };
            //Array for fast iteration
            this.meshList.push(this.meshRegistry[runtimeData.id]);
            this.meshRegistry[runtimeData.id].index = this.meshList.length - 1;
            var material = this.meshRegistry[runtimeData.id].pickingMaterial;
            material.uniforms = THREE.UniformsUtils.clone(this.pickingMaterialDef.uniforms);
            material.uniforms.color.value = new THREE.Color(runtimeData.id);
            if (runtimeData instanceof THREE.SkinnedMesh) {
                material.skinning = true;
            }
        }
    };
    ObjectPicker.prototype.unregisterObject = function (object, runtimeData) {
        if (runtimeData) {
            //remove the enitity data from the pick history, if it's there
            // FIXME... what is this? doesn't seem to exist
            //this.removeFromHistory(runtimeData.id);
            //The meshUnloaded event should fire just before the runtimeData is deleted.
            if (this.meshRegistry[runtimeData.id]) {
                this.meshRegistry[runtimeData.id].entity = null;
                this.meshRegistry[runtimeData.id].pickingMaterial.dispose();
                this.meshList.splice(this.meshRegistry[runtimeData.id].index, 1);
                delete this.meshRegistry[runtimeData.id];
            }
        }
    };
    ObjectPicker.prototype.registerMesh = function (veroldMesh) {
        //When the THREE.Mesh is created, register it so that it can be selected.
        veroldMesh.when('loadBase', function (mesh) {
            this.registerObject(mesh, mesh.runtimeData);
        }, this);
    };
    ObjectPicker.prototype.unregisterMesh = function (veroldMesh) {
        if (veroldMesh) {
        }
    };
    ObjectPicker.prototype.getThreeObjects = function (objects) {
        var sceneObjects = [];
        functions_1.forEach(objects, function (object) {
            if (object && object.runtimeData) {
                sceneObjects.push(object.runtimeData);
            }
        });
        return sceneObjects;
    };
    ObjectPicker.prototype.touchPickNoDrag = function (event, callback) {
        //Check drag state
        if (!this.getInput().touchDragStatePrevious) {
            this.touchPick(event, callback);
        }
    };
    ObjectPicker.prototype.touchPick = function (event, callback) {
        if (!this.isEnabled()) {
            return;
        }
        // if ( this.getInput().touchPosition.x ) {
        var x = this.getInput().touchPosition.x;
        var y = this.getInput().touchPosition.y;
        var mesh = this.pickMesh(x, y);
        if (mesh) {
            mesh.trigger('pick');
            var parent = mesh.getParentObject();
            while (parent) {
                parent.trigger('pick');
                parent = parent.getParentObject();
            }
            if (typeof callback === 'function') {
                callback(mesh);
            }
        }
    };
    ObjectPicker.prototype.pickNoDrag = function (event, callback) {
        //Check drag state
        if (!this.getInput().mouseDragStatePrevious[event.button]) {
            this.pick(event, callback);
        }
    };
    ObjectPicker.prototype.pick = function (event, callback) {
        if (!this.isEnabled()) {
            return;
        }
        if (this.pickTrigger.substr(0, 4) === 'left') {
            if (event.button !== 0) {
                return;
            }
        }
        else if (this.pickTrigger.substr(0, 4) === 'right') {
            if (event.button !== 2) {
                return;
            }
        }
        else if (event.button !== 1) {
            return;
        }
        var x = event.clientX;
        var y = event.clientY;
        var mesh = this.pickMesh(x, y);
        if (mesh) {
            mesh.trigger('pick');
            var parent = mesh.getParentObject();
            while (parent) {
                parent.trigger('pick');
                parent = parent.getParentObject();
            }
            if (typeof callback === 'function') {
                callback(mesh);
            }
        }
    };
    ObjectPicker.prototype.hoverUpdate = function () {
        if (!this.isEnabled()) {
            return;
        }
        if (this.currentFrame < this.hoverFrameSkip) {
            this.currentFrame++;
            return;
        }
        this.currentFrame = 0;
        var x = this.getInput().mousePosition.x;
        var y = this.getInput().mousePosition.y;
        var parent;
        var mesh = this.pickMesh(x, y);
        if (mesh !== this.currentHoverObject) {
            if (this.currentHoverObject) {
                this.currentHoverObject.trigger('endHover');
                parent = this.currentHoverObject.getParentObject();
                while (parent) {
                    parent.trigger('endHover');
                    parent = parent.getParentObject();
                }
            }
            if (mesh) {
                this.currentHoverObject = mesh;
                mesh.trigger('beginHover');
                parent = mesh.getParentObject();
                while (parent) {
                    parent.trigger('beginHover');
                    parent = parent.getParentObject();
                }
            }
            else {
                this.currentHoverObject = null;
            }
        }
    };
    ObjectPicker.prototype.pickMesh = function (x, y) {
        var _this = this;
        var that = this;
        var scenes = this.getEngine().getObjectsByType('scene');
        var i;
        var pickedMesh = null;
        functions_1.forEach(scenes, function (scene) {
            var cameras = scene.getDescendantsByType('camera');
            var renderViews = [];
            functions_1.forEach(cameras, function (camera) {
                var renderViewComponents = camera.getComponentsByScriptId('render_view_component');
                functions_1.forEach(renderViewComponents, function (renderViewComponent) {
                    if (renderViewComponent.isEnabled()) {
                        if (renderViews.length > 0) {
                            for (i = 0; i < renderViews.length; i++) {
                                var renderView = renderViews[i];
                                if (renderViewComponent.renderGroup >= renderView.renderGroup) {
                                    renderViews.splice(i, 0, renderViewComponent);
                                    break;
                                }
                            }
                        }
                        else {
                            renderViews.push(renderViewComponent);
                        }
                    }
                });
            });
            for (i = 0; i < renderViews.length; i++) {
                var renderView = renderViews[i];
                var canvas_height = that.getRenderer().getHeight();
                var viewport_offset = canvas_height - renderView._height - renderView._y;
                //Get the percentage x,y positions of the mouse on the viewport
                var mouseX = ((x - renderView._x) / renderView._width);
                var mouseY = ((y - viewport_offset) / renderView._height);
                // pickedMesh = this.doRaycastPick( scene, renderView.entity, mouseX, mouseY );
                pickedMesh = _this.doGPUPick(scene, renderView.entity, mouseX, mouseY);
                if (pickedMesh) {
                    return;
                }
            }
        }, this);
        return pickedMesh;
    };
    ObjectPicker.prototype.doRaycastPick = function (scene, camera, mouseX, mouseY) {
        var x = mouseX * 2 - 1;
        var y = -mouseY * 2 + 1;
        var vector = new THREE.Vector3(x, y, 0.5);
        vector.unproject(camera.runtimeData);
        var raycaster = new THREE.Raycaster(camera.runtimeData.position, vector.sub(camera.runtimeData.position).normalize());
        var sceneObjects = this.getThreeObjects(scene.getObjects());
        var intersections = raycaster.intersectObjects(sceneObjects, false);
        if (intersections.length > 0) {
            for (var i = 0; i < intersections.length; i++) {
                var parent = intersections[i].object.parent;
                var entityId = intersections[i].object.id;
                var isVisible = true;
                if (!intersections[i].object.visible) {
                    isVisible = false;
                    continue;
                }
                while (parent) {
                    if (!parent.visible) {
                        isVisible = false;
                        break;
                    }
                    parent = parent.parent;
                }
                if (isVisible) {
                    return this.meshRegistry[entityId].entity;
                }
            }
        }
        return null;
    };
    ObjectPicker.prototype.doGPUPick = function (scene, camera, mouseX, mouseY) {
        if (mouseX < 0.0 || mouseY < 0.0 || mouseX > 1.0 || mouseY > 1.0) {
            return null;
        }
        var i = 0;
        var material;
        for (i = 0; i < this.meshList.length; i++) {
            if (this.meshList[i].runtimeData) {
                material = this.meshList[i].runtimeData.material;
                this.meshList[i].prevMaterial = material;
                this.meshList[i].runtimeData.material = this.meshList[i].pickingMaterial;
            }
        }
        var renderer = this.getThreeRenderer();
        var currentShadowMapEnabled = renderer.shadowMap.enabled;
        renderer.shadowMap.enabled = false;
        // renderer.enableScissorTest( true );
        renderer.setViewport(0, 0, this.pickingTexture.width, this.pickingTexture.height);
        //render the picking scene off-screen
        var gl = renderer.getContext();
        renderer.render(scene.runtimeData, camera.runtimeData, this.pickingTexture, true);
        //Return materials to their previous state
        for (i = 0; i < this.meshList.length; i++) {
            if (this.meshList[i].runtimeData) {
                this.meshList[i].runtimeData.material = this.meshList[i].prevMaterial;
            }
        }
        var pixelBuffer = new Uint8Array(4);
        //read the pixel under the mouse from the texture
        gl.readPixels(mouseX * this.pickingTexture.width, this.pickingTexture.height *
            (1.0 - mouseY), 1, 1, gl.RGBA, gl.UNSIGNED_BYTE, pixelBuffer);
        //interpret the pixel as an ID
        var id = (pixelBuffer[0] << 16) | (pixelBuffer[1] << 8) | (pixelBuffer[2]);
        renderer.shadowMap.enabled = currentShadowMapEnabled;
        renderer.setRenderTarget(null);
        if (this.meshRegistry[id]) {
            var entityId = this.meshRegistry[id].entity.id;
            return this.getEngine().getEntityById(entityId);
        }
        return null;
    };
    return ObjectPicker;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ObjectPicker;


/***/ },
/* 90 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-file-line-count */
/* tslint:disable max-line-length */
/*
@vid orbit_camera_controller
@vname Orbit Camera Controller
@vdescription A controller that allows a camera to easily orbit a target object.
@vfilter camera
@vcategory Camera Controllers
@vattr object targetObject {
  default : null,
  description : 'The object that the camera orbit point will be relative to.',
}
@vattr v3 targetOffset {
  'default' : {'x': 0.0, 'y': 0.0, 'z': 0.0 },
  'description' : 'An offset relative to the target object. This will allow you to target a specific point on an object.',
}
@vattr float inertialDamping {
  'default': 0.20,
  'description': 'How quickly the camera stops moving when input stops.',
  'min' : 0.0,
  'max' : 1.0
}
@vattr bool invertX {
  'default': false,
  'description': 'Reverse the default direction that the camera moves horizontally.'
}
@vattr bool invertY {
  'default': false,
  'description': 'Reverse the default direction that the camera moves vertically.'
}
@vattr bool invertZoom {
  'default': false,
  'description': 'Reverse the default direction that the camera moves when zooming.'
}
@vattr float lookSpeed {
  'description' : 'The speed that the camera orbits the target',
  'default' : 1.0,
  'max' : 1000,
  'min' : 0.0001
}
@vattr float movementSpeed {
  'description' : 'The speed that the camera moves when panning',
  'default' : 8.0,
  'max' : 2000,
  'min' : 0.1
}
@vattr bool autoOrbit {
  'default': false,
  'description': 'Automatically orbit the camera when the user is not controlling it.'
}
@vattr float autoOrbitSpeed {
  'description' : 'The speed of the automatic orbit.',
  'default' : 1.0,
  'max' : 1000,
  'min' : -1000
}
@vattr float autoOrbitDelay {
  'description' : 'The period of time with no mouse input before the auto-orbit starts (in seconds).',
  'default' : 1.0,
  'max' : 1000,
  'min' : 0.0001
}
@vattr float orbitDistanceMin {
  'description' : 'The closest that the camera is allowed to get to the target.',
  'default' : 0.1,
  'max' : 1000,
  'min' : 0.001
}
@vattr float orbitDistanceMax {
  'description' : 'The furthest that the camera is allowed to get from the target.',
  'default' : 50.0,
  'max' : 100000,
  'min' : 1.0
}
@vattr Vector2 pitchAngleBounds {
  'description' : 'Allows you to set how far the camera can pitch (tilt) from horizontal. Defined in degrees with horizontal being 0.',
  'default': {x: 75.0, y: -75.0 },
  'max': { x: 90.0, y: 90.0 },
  'min': { x: -90.0, y: -90.001 }
}
@vattr bool enablePan {
  'default': true,
  'description': 'Allow the user to pan side-to-side and up and down with the camera.'
}
@vattr bool enableZoom {
  'default': true,
  'description': 'Allow the user to zoom in and out with the camera.'
}
@vattr bool interpolation {
  'default': true,
  'description': 'When enabled, the camera will smoothly interpolate toward its desired state. e.g. If something else moves the camera, interpolation will cause the camera to smoothly focus on the target again. Otherwise, it will snap back.'
}
@vattr float interpSpeed {
  'description' : 'The speed at which the orbiting camera locks on to its target, if set to point away from it.',
  'default' : 0.5,
  'max' : 10.0,
  'min' : 0.01
}
@vattr bool usePointerLock {
  'default': false,
  'description': 'The mouse cursor will be hidden during camera control and won\'t move. Requires the user to accept pointer lock message in web browser.'
}
@vattr bool useKeyboard {
  'default': true,
  'description': 'Allow the camera to be controlled via keyboard input. This allows for movement with W,A,S,D/arrow keys as well as modifiers.'
}

@vevent local enableOrbitCameraController {'scope' : 'local', 'action':true, 'category':'Orbit Camera', 'parameters' : []}
@vevent local disableOrbitCameraController {'scope' : 'local', 'action':true, 'category':'Orbit Camera', 'parameters' : []}
@vevent local toggleOrbitCameraController {'scope' : 'local', 'action':true, 'category':'Orbit Camera', 'parameters' : []}
@vevent local resetOrbitCameraController {'scope' : 'local', 'action':true, 'category':'Orbit Camera', 'parameters' : []}
@vevent local setOrbitDistance {'scope' : 'local', 'action':true, 'category':'Orbit Camera', 'parameters' : [
  {'name': 'newDistance', 'type': 'f', 'description': 'The new distance that the camera will orbit at.', 'default': 1.0},
]}
@vevent local setTarget {'scope' : 'local', 'description': 'Sets the camera to orbit the given object', 'action':true, 'category':'Orbit Camera', 'parameters' : [
  {'name': 'newTarget', 'type': 'object', 'description': 'The new target that the camera will orbit.', 'default': null},
  {'name': 'center', 'type': 'b', 'description': 'Whether or not to target the center of the object. If false, the camera will orbit the origin of the object.', 'default': true},
]}
@vevent local focusOnTarget {'scope' : 'local', 'description': 'Look at the center of the current target and zoom so that the object nicely fills the field of view.', 'action':true, 'category':'Orbit Camera', 'parameters' : []}
*/
/* tslint:enable max-line-length */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var UserAgent_1 = __webpack_require__(13);
var ORIGIN_VEC = new THREE.Vector3();
var ORTHO_ZOOM_MAX = 2.5;
var ORTHO_ZOOM_MIN = 0.05;
var ORTHO_ZOOM_SPEED = 0.1;
function fuzzyEquals(qa, qb, epsilon) {
    epsilon = epsilon || 0.001;
    if (Math.abs(qa.x - qb.x) < epsilon &&
        Math.abs(qa.y - qb.y) < epsilon &&
        Math.abs(qa.z - qb.z) < epsilon &&
        Math.abs(qa.w - qb.w) < epsilon) {
        return true;
    }
    return false;
}
;
var OrbitCamera = (function (_super) {
    tslib_1.__extends(OrbitCamera, _super);
    function OrbitCamera() {
        var _this = _super.call(this) || this;
        _this.targetOffset = new THREE.Vector3();
        _this.enablePan = true;
        _this.enableZoom = true;
        _this.invertX = false;
        _this.invertY = false;
        _this.invertZoom = false;
        _this.pitchAngleBounds = new THREE.Vector2(0.0, 0.0);
        // These are accessed from outside of this class and are forced to be public.
        _this._pivotWorldPos = new THREE.Vector3(); // used from PreviewCameraFocus
        // The point that the camera will orbit (using the targetObject and targetOffset)
        _this.pivotPoint = new THREE.Object3D();
        _this.tempCamera = new THREE.PerspectiveCamera();
        _this.targetEuler = new THREE.Euler(0, 0, 0, 'YXZ');
        _this.tempQuaternion = new THREE.Quaternion();
        _this.currentOrbitDistance = 2.50;
        _this.newOrbitDistance = 0.0;
        _this.targetMoved = true;
        _this.ellapsedTimeSinceInput = 0;
        _this.touchLast = new THREE.Vector2();
        _this.touchLastPinchDist = 0.0;
        _this.mouseDraggedMovement = new THREE.Vector2();
        _this.linearMovementDelta = new THREE.Vector3();
        _this.zoomDelta = 0.0;
        _this.currentMoveSpeed = new THREE.Vector2();
        _this.currentZoomSpeed = 0.0;
        _this.moveStart = new THREE.Vector2();
        _this.pan = false;
        _this.look = false;
        _this.zoom = false;
        _this.isMouseDragging = false;
        _this.isTouchDragging = false;
        _this.autoOrbitOn = false;
        _this.quaternionStart = new THREE.Quaternion();
        _this.eulerStart = new THREE.Euler(0, 0, 0, 'YXZ');
        _this.currentDraggingMousePosition = new THREE.Vector2();
        _this.pitchAngleBoundsRadians = { min: 0.0, max: 0.0 };
        _this._moveVector = new THREE.Vector3();
        _this._tempVector = new THREE.Vector3();
        _this._tempVector2 = new THREE.Vector3();
        _this._tempVector4 = new THREE.Vector4();
        _this._tempMatrix4 = new THREE.Matrix4();
        _this.onMouseDown_PointerLock = _this.onMouseDown_PointerLock.bind(_this);
        _this.onMouseUp_PointerLock = _this.onMouseUp_PointerLock.bind(_this);
        return _this;
    }
    /** @inheritdoc */
    OrbitCamera.prototype.onEnable = function () {
        this.targetOffset = new THREE.Vector3();
        this.targetOffset.copy(this.getAttribute('targetOffset'));
        this.onAttributesChanged(['targetOffset']);
        this.currentMoveSpeed.set(0, 0);
        this.moveStart.copy(this.currentDraggingMousePosition);
    };
    /** @inheritdoc */
    OrbitCamera.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('targetObject') !== -1) {
            this.targetMoved = true;
            this.initTarget();
        }
        else if (changes.indexOf('targetOffset') !== -1 && this.targetOffset.x !== undefined) {
            this.setTargetOffset(this.targetOffset);
        }
    };
    /** @inheritdoc */
    OrbitCamera.prototype.onStartup = function () {
        this.canvasEl = this.getThreeRenderer().domElement;
        if (this.usePointerLock) {
            this.togglePointerLock(true);
        }
        this.pitchAngleBoundsRadians.max = Math.PI * this.pitchAngleBounds.x / 180.0;
        this.pitchAngleBoundsRadians.min = Math.PI * this.pitchAngleBounds.y / 180.0;
        this.getEntity().when('loadBase', this.initTarget, this);
        if (UserAgent_1.isMobile()) {
            this.listenTo(this.getEngine(), 'touchStart', this.onTouchStart);
            this.listenTo(this.getEngine(), 'touchMove', this.onTouchMove);
            this.listenTo(this.getEngine(), 'touchEnd', this.onTouchEnd);
        }
        else {
            this.listenTo(this.getEngine(), 'mouseUp', this.onMouseUp);
            this.listenTo(this.getEngine(), 'mouseDown', this.onMouseDown);
            this.listenTo(this.getEngine(), 'mouseMove', this.onMouseMove);
            this.listenTo(this.getEngine(), 'mouseScroll', this.onMouseScroll);
        }
        this.listenTo(this.getEntity(), 'enableOrbitCameraController', this.orbitCameraEnable);
        this.listenTo(this.getEntity(), 'disableOrbitCameraController', this.orbitCameraDisable);
        this.listenTo(this.getEntity(), 'toggleOrbitCameraController', this.orbitCameraToggle);
        this.listenTo(this.getEntity(), 'resetOrbitCameraController', this.resetOrbitCameraController);
        this.listenTo(this.getEntity(), 'setOrbitDistance', this.setOrbitDistance);
        this.listenTo(this.getEntity(), 'setTarget', this.setTarget);
        this.listenTo(this.getEntity(), 'focusOnTarget', this.focusOnTarget);
    };
    /** @inheritdoc */
    OrbitCamera.prototype.onShutdown = function () {
        this.togglePointerLock(false);
    };
    /** @inheritdoc */
    OrbitCamera.prototype.onEntityReady = function () {
        this.resetOrbitRotation();
    };
    // reset the rotation point of the camera to what it currently is. Stops camera from
    // interpolating position after a pivot point move
    OrbitCamera.prototype.resetOrbitRotation = function () {
        this.quaternionStart.copy(this.getRuntimeData().quaternion);
        this.eulerStart.setFromQuaternion(this.quaternionStart, 'YXZ');
    };
    OrbitCamera.prototype.resetOrbitCameraController = function () {
        // Reset the transform of the camera to what it is in the entity data.
        this.getEntity().reset();
        this.setTargetOffset(ORIGIN_VEC);
        // Reset control parameters so that we don't try to interpolate back to
        // where we were.
        this.currentDraggingMousePosition.copy(this.moveStart);
        this.resetOrbitRotation();
        this.currentZoomSpeed = 0.0;
    };
    OrbitCamera.prototype.setTargetOffset = function (newOffset) {
        this.targetMoved = true;
        this.pivotPoint.position.copy(newOffset);
    };
    OrbitCamera.prototype.setOrbitDistance = function (newDistance) {
        this.newOrbitDistance = newDistance;
    };
    OrbitCamera.prototype.setTarget = function (newObjectId, center) {
        if (typeof newObjectId === 'string' || !newObjectId) {
            this.setAttribute('targetObject', newObjectId);
        }
        else if (newObjectId && newObjectId.id) {
            this.setAttribute('targetObject', newObjectId.id);
        }
        if (center) {
            this.lookAtCenter();
        }
    };
    OrbitCamera.prototype.lookAtCenter = function () {
        this.targetMoved = true;
        var data = { x: 0, y: 0, z: 0 };
        if (this.targetObject) {
            var center = this.targetObject.getCenter();
            this.pivotPoint.position.copy(center);
            data = { x: center.x, y: center.y, z: center.z };
        }
        this.setAttribute('targetOffset', data);
    };
    OrbitCamera.prototype.focusOnTarget = function () {
        // adjust target offset to point to centre of object
        // call setOrbitDistance to cause the target to fill the field of view
        if (this.targetObject) {
            this.lookAtCenter();
            var newDistance = void 0;
            var bb = this.targetObject.getBounds();
            if (bb) {
                var dist = new THREE.Vector3();
                dist.set(bb.max.x - bb.min.x, bb.max.y - bb.min.y, bb.max.z - bb.min.z);
                var scale = void 0;
                if (this.targetObject.runtimeData) {
                    this.targetObject.runtimeData.updateMatrixWorld();
                    scale = new THREE.Vector3();
                    scale.setFromMatrixScale(this.targetObject.runtimeData.matrixWorld);
                }
                else {
                    scale = this.targetObject.getScale();
                }
                dist.multiply(scale);
                var size = dist.length();
                if (this.getEntity().getProperty('cameraType') === 'perspective') {
                    newDistance = Math.abs(size / (2.0 * Math.tan(this.getEntity().getProperty('fov') *
                        Math.PI / 360.0)));
                }
                else {
                    newDistance = 0.5 * (this.getEntity().getProperty('near') +
                        this.getEntity().getProperty('far'));
                }
                newDistance = Math.max(Math.min(newDistance, this.orbitDistanceMax), this.orbitDistanceMin);
            }
            else {
                this._tempVector.subVectors(this.getEntity().getPosition(), this.targetObject.getProperty('position'));
                newDistance = Math.max(Math.min(this._tempVector.length(), this.orbitDistanceMax), this.orbitDistanceMin);
            }
            this.setOrbitDistance(newDistance);
        }
    };
    /** @inheritdoc */
    OrbitCamera.prototype.onPreUpdate = function (delta) {
        if (this.hasRuntimeData() && this.isEnabled()) {
            // Check WASD state and move camera appropriately
            // Also check for modifier keys like ctrl and cmd. If these are pressed,
            // don't move the camera.
            var input = this.getInput();
            var modKey = this.useKeyboard && (input.keyDown('ctrl') || input.keyDown('cmd'));
            var forwardKey = this.useKeyboard && (input.keyDown('upArrow') || input.keyDown('W'));
            var backwardKey = this.useKeyboard && (input.keyDown('downArrow') || input.keyDown('S'));
            var leftKey = this.useKeyboard && (input.keyDown('leftArrow') || input.keyDown('A'));
            var rightKey = this.useKeyboard && (input.keyDown('rightArrow') || input.keyDown('D'));
            if (!modKey && (forwardKey || backwardKey || leftKey || rightKey)) {
                if (this.enableZoom) {
                    if (forwardKey) {
                        this.zoomDelta = -delta;
                    }
                    else if (backwardKey) {
                        this.zoomDelta = delta;
                    }
                }
                if (this.enablePan) {
                    if (rightKey) {
                        this.linearMovementDelta.x = -delta;
                    }
                    else if (leftKey) {
                        this.linearMovementDelta.x = delta;
                    }
                }
            }
            this.updateCamera(delta);
        }
    };
    /** @inheritdoc */
    OrbitCamera.prototype.onPostUpdate = function () {
        this.hasChanged = false;
    };
    OrbitCamera.prototype.getEulerAngles = function (outEuler) {
        var returnVector = outEuler;
        if (!outEuler) {
            returnVector = new THREE.Euler();
        }
        returnVector.setFromQuaternion(this.getRuntimeData().quaternion, 'YXZ');
        return returnVector;
    };
    OrbitCamera.prototype.setEulerAngles = function (euler) {
        this.getRuntimeData().quaternion.setFromEuler(euler);
    };
    OrbitCamera.prototype.togglePointerLock = function (on) {
        this.usePointerLock = on;
        if (this.usePointerLock) {
            this.canvasEl.addEventListener('mousedown', this.onMouseDown_PointerLock);
        }
        else {
            this.canvasEl.removeEventListener('mousedown', this.onMouseDown_PointerLock);
        }
    };
    OrbitCamera.prototype.onMouseDown = function (event) {
        if (this.isEnabled()) {
            var rightButton = this.getInput().mouseButtonDown('right');
            var leftButton = this.getInput().mouseButtonDown('left');
            this.pan = false;
            this.look = false;
            if (rightButton && this.enablePan) {
                this.pan = true;
            }
            else if (leftButton) {
                this.look = true;
            }
            this.moveStart.x = event.scenePercentX;
            this.moveStart.y = event.scenePercentY;
            this.currentDraggingMousePosition.copy(this.moveStart);
            this.quaternionStart.copy(this.getRuntimeData().quaternion);
            this.eulerStart.setFromQuaternion(this.quaternionStart, 'YXZ');
        }
    };
    OrbitCamera.prototype.updateCamera = function (delta) {
        // Handle speed modifier keys
        var speedMod = 1.0;
        if (this.useKeyboard && this.getInput().keyDown('shift')) {
            speedMod = 5.0;
        }
        // If there is any user control, reset the ellapsed time.
        if (this.isMouseDragging || this.zoomDelta) {
            this.ellapsedTimeSinceInput = 0.0;
        }
        else {
            this.ellapsedTimeSinceInput += delta;
        }
        this.mouseDraggedMovement.copy(this.currentDraggingMousePosition);
        this.mouseDraggedMovement.sub(this.moveStart);
        this.mouseDraggedMovement.multiplyScalar(6.0 * speedMod * this.lookSpeed);
        var runtimeData = this.getRuntimeData();
        var damping = Math.max(0.0, Math.min(delta * 33.3 * this.inertialDamping, 1.0));
        var oneMinusDamping = 1.0 - damping;
        var interpDistance = 0.0;
        // Handle inverting the controls
        if (this.invertX) {
            this.mouseDraggedMovement.x *= -1.0;
            this.linearMovementDelta.x *= -1.0;
        }
        if (this.invertY) {
            this.mouseDraggedMovement.y *= -1.0;
            this.linearMovementDelta.y *= -1.0;
        }
        if (this.invertZoom) {
            this.zoomDelta *= -1.0;
        }
        // Look at current angular movement since the start of control and clamp the min/max pitch.
        this.targetEuler.copy(this.eulerStart);
        this.targetEuler.x -= this.mouseDraggedMovement.y;
        this.targetEuler.y -= this.mouseDraggedMovement.x;
        if (this.targetEuler.x > this.pitchAngleBoundsRadians.max) {
            this.eulerStart.x -= this.targetEuler.x - this.pitchAngleBoundsRadians.max;
            this.targetEuler.x = this.pitchAngleBoundsRadians.max;
        }
        else if (this.targetEuler.x < this.pitchAngleBoundsRadians.min) {
            this.eulerStart.x += this.pitchAngleBoundsRadians.min - this.targetEuler.x;
            this.targetEuler.x = this.pitchAngleBoundsRadians.min;
        }
        // Handle automatic orbiting when there has been to user input for a given amount of time.
        if (this.autoOrbit && this.ellapsedTimeSinceInput > this.autoOrbitDelay) {
            // update cursor position so that when we zoom/move the camera, it won't
            // attempt to force itself to where it began rotating from(the jitter)
            this.currentDraggingMousePosition.x -= ((this.autoOrbitSpeed * 0.1 *
                Math.min(1.0, this.ellapsedTimeSinceInput - this.autoOrbitDelay)) %
                (2.0 * Math.PI)) * delta;
            this.autoOrbitOn = true;
            this.hasChanged = true;
        }
        // Handle panning of the camera
        this.linearMovementDelta.multiplyScalar(speedMod * this.movementSpeed);
        this.currentMoveSpeed.x = oneMinusDamping * this.currentMoveSpeed.x +
            damping * this.linearMovementDelta.x;
        this.currentMoveSpeed.y = oneMinusDamping * this.currentMoveSpeed.y +
            damping * this.linearMovementDelta.y;
        if (Math.abs(this.currentMoveSpeed.y) < 0.0001 && Math.abs(this.currentMoveSpeed.x) < 0.0001) {
            this.currentMoveSpeed.set(0, 0);
        }
        if (this.currentMoveSpeed.x || this.currentMoveSpeed.y) {
            // If there is panning movement, shift the location of the pivot point.
            this._tempVector.set(-this.currentMoveSpeed.x, this.currentMoveSpeed.y, 0.0);
            this._tempVector.applyQuaternion(runtimeData.quaternion);
            this._tempMatrix4.getInverse(this.pivotPoint.matrixWorld);
            this._tempVector4.set(this._tempVector.x, this._tempVector.y, this._tempVector.z, 0.0);
            this._tempVector4.applyMatrix4(this._tempMatrix4);
            this._tempVector.set(this._tempVector4.x, this._tempVector4.y, this._tempVector4.z);
            this.pivotPoint.position.add(this._tempVector);
            // Get the world-space position of the pivot point.
            this.pivotPoint.getWorldPosition(this._pivotWorldPos);
            this.hasChanged = true;
        }
        else {
            // Otherwise, just update the world-space position of the pivot point.
            this._pivotWorldPos.setFromMatrixPosition(this.pivotPoint.matrixWorld);
        }
        if (runtimeData.parent) {
            this._tempMatrix4.getInverse(runtimeData.parent.matrixWorld);
            this._pivotWorldPos.applyMatrix4(this._tempMatrix4);
        }
        // Handle zoom
        // Calculate the distance to orbit at.
        this._tempVector.subVectors(this._pivotWorldPos, runtimeData.position);
        var currentDistance = this._tempVector.length();
        var targetDistance;
        // If the user is actively zooming or if no new target distance is set and
        // the inertia of the camera is still moving it.
        if (this.zoomDelta || !this.newOrbitDistance) {
            this.newOrbitDistance = 0.0;
            this.currentZoomSpeed = oneMinusDamping * this.currentZoomSpeed + damping *
                speedMod * 0.1 * this.movementSpeed * this.zoomDelta;
            if (Math.abs(this.currentZoomSpeed) < 0.0001) {
                this.currentZoomSpeed = 0.0;
            }
            if (this.getRuntimeData() instanceof THREE.PerspectiveCamera) {
                var newDistance = currentDistance + this.currentZoomSpeed *
                    this.currentOrbitDistance;
                targetDistance = Math.min(this.orbitDistanceMax, Math.max(this.orbitDistanceMin, newDistance));
                interpDistance = (targetDistance - currentDistance);
                this.currentOrbitDistance = targetDistance;
            }
            else {
                var camera = this.getRuntimeData();
                var change = this.currentZoomSpeed * ORTHO_ZOOM_SPEED;
                var aspect = camera.right / camera.top;
                var maxHeight = ORTHO_ZOOM_MAX;
                var minHeight = ORTHO_ZOOM_MIN;
                camera.top += change;
                camera.bottom -= change;
                camera.top = Math.max(Math.min(camera.top, maxHeight), minHeight);
                camera.bottom = -camera.top;
                camera.left = camera.bottom * aspect;
                camera.right = camera.top * aspect;
                camera.updateProjectionMatrix();
                this.currentOrbitDistance = currentDistance;
            }
            if (this.currentZoomSpeed) {
                this.hasChanged = true;
            }
        }
        else {
            // If we still have a new orbit distance defined, we'll try to move to that.
            targetDistance = Math.min(this.orbitDistanceMax, Math.max(this.orbitDistanceMin, this.newOrbitDistance));
            if (this.interpolation) {
                interpDistance = (targetDistance - currentDistance);
                this.currentOrbitDistance = interpDistance * 10.0 * this.interpSpeed *
                    delta + currentDistance;
            }
            else {
                this.currentOrbitDistance = targetDistance;
            }
            if (Math.abs(this.currentOrbitDistance - this.newOrbitDistance) < 0.0001) {
                this.newOrbitDistance = 0.0;
            }
            this.hasChanged = true;
        }
        // If the camera is being controlled, use the current x,y rotation speed
        // to determine the new quaternion for the camera
        if (!this.targetMoved) {
            this.tempQuaternion.setFromEuler(this.targetEuler);
            if (!fuzzyEquals(runtimeData.quaternion, this.tempQuaternion) || this.hasChanged) {
                runtimeData.quaternion.slerp(this.tempQuaternion, this.inertialDamping);
                runtimeData.position.set(0, 0, this.currentOrbitDistance);
                runtimeData.position.applyQuaternion(runtimeData.quaternion);
                runtimeData.position.add(this._pivotWorldPos);
                runtimeData.lookAt(this._pivotWorldPos);
                this.hasChanged = true;
            }
        }
        else {
            this.targetMoved = false;
            // If the camera isn't being controlled by the user, continue interpolating
            // to the desired position/quaternion
            if (this.interpolation) {
                // lerp the current quaternion towards the assigned pivot.
                this.tempCamera.position.copy(runtimeData.position);
                this.tempCamera.lookAt(this._pivotWorldPos);
                runtimeData.quaternion.slerp(this.tempCamera.quaternion, 0.1 * this.interpSpeed);
                // Set the camera's position using the quaternion and orbit distance
                if (interpDistance) {
                    this._tempVector.set(0, 0, 1);
                    this._tempVector.applyQuaternion(this.tempCamera.quaternion);
                    this._tempVector.multiplyScalar(interpDistance * 10.0 * this.interpSpeed * delta);
                    runtimeData.position.add(this._tempVector);
                }
            }
            else {
                runtimeData.lookAt(this._pivotWorldPos);
                runtimeData.position.set(0, 0, this.currentOrbitDistance);
                runtimeData.position.applyQuaternion(runtimeData.quaternion);
                runtimeData.position.add(this._pivotWorldPos);
            }
            this.hasChanged = true;
        }
        if (this.hasChanged) {
            this.getEngine().needsRender = true;
        }
        this.mouseDraggedMovement.set(0.0, 0.0);
        this.linearMovementDelta.set(0.0, 0.0, 0.0);
        this.zoomDelta = 0.0;
    };
    OrbitCamera.prototype.orbitCameraEnable = function () {
        this.enable();
    };
    OrbitCamera.prototype.orbitCameraDisable = function () {
        this.disable();
    };
    OrbitCamera.prototype.orbitCameraToggle = function () {
        if (this.isEnabled()) {
            this.disable();
        }
        else {
            this.enable();
        }
        if (this.usePointerLock && !this.isEnabled()) {
            this.getInput().disablePointerLock();
        }
    };
    OrbitCamera.prototype.onMouseUp = function () {
        if (this.isEnabled()) {
            var rightButton = this.getInput().mouseButtonDown('right');
            var leftButton = this.getInput().mouseButtonDown('left');
            this.pan = false;
            this.look = false;
            if ((rightButton) && this.enablePan) {
                this.pan = true;
            }
            else if (leftButton) {
                this.look = true;
            }
            else {
                this.isMouseDragging = false;
            }
        }
    };
    OrbitCamera.prototype.onMouseDown_PointerLock = function (event) {
        if (this.isEnabled() && event.button === 0 || event.button === 2) {
            this.getInput().enablePointerLock();
            this.canvasEl.addEventListener('mouseup', this.onMouseUp_PointerLock);
        }
    };
    OrbitCamera.prototype.onMouseUp_PointerLock = function (event) {
        if (this.getEntity()) {
            if (event.button === 2 && this.getInput().mouseButtonUp('left') ||
                event.button === 0 && this.getInput().mouseButtonUp('right')) {
                this.canvasEl.removeEventListener('mouseup', this.onMouseUp_PointerLock);
                this.getInput().disablePointerLock();
            }
        }
    };
    OrbitCamera.prototype.onMouseMove = function (event) {
        if (this.isEnabled()) {
            var rightButton = this.getInput().mouseButtonDown('right');
            var leftButton = this.getInput().mouseButtonDown('left');
            if ((rightButton) && this.enablePan) {
                this.hasChanged = true;
                this.isMouseDragging = true;
                // FIXME: we probably shouldn't be modifying the raw input events to
                // decorate them with our custom properties. See @InputController for
                // where this is happening.
                this.linearMovementDelta.x = event.scenePercentDeltaX;
                this.linearMovementDelta.y = event.scenePercentDeltaY;
            }
            else if (leftButton) {
                this.hasChanged = true;
                this.isMouseDragging = true;
                this.currentDraggingMousePosition.x = event.scenePercentX;
                this.currentDraggingMousePosition.y = event.scenePercentY;
            }
        }
    };
    OrbitCamera.prototype.onMouseScroll = function (delta) {
        if (this.isEnabled() && typeof delta === 'number' && this.enableZoom) {
            this.zoomDelta = -delta * 0.1;
        }
    };
    OrbitCamera.prototype.onTouchStart = function (event) {
        // FIXME: we probably shouldn't be modifying the raw input events to
        // decorate them with our custom properties. See @InputController for
        // where this is happening.
        if (this.isEnabled()) {
            var touches = event.touches;
            if (!touches) {
                return;
            }
            switch (touches.length) {
                case 1:
                    this.touchLast.set(touches[0].scenePercentX, touches[0].scenePercentY);
                    this.look = true;
                    this.pan = false;
                    this.zoom = false;
                    break;
                case 2:
                    this.look = false;
                    this.pan = false;
                    this.zoom = false;
                    if (this.enableZoom) {
                        this.zoom = true;
                        var dx = touches[0].scenePercentX - touches[1].scenePercentX;
                        var dy = touches[0].scenePercentY - touches[1].scenePercentY;
                        var distance = Math.sqrt(dx * dx + dy * dy);
                        this.touchLastPinchDist = distance;
                    }
                    this.touchLast.set(touches[0].scenePercentX, touches[0].scenePercentY);
                    break;
                case 3:
                    this.touchLast.set(touches[0].scenePercentX, touches[0].scenePercentY);
                    this.look = false;
                    this.pan = false;
                    if (this.enablePan) {
                        this.pan = true;
                    }
                    this.zoom = false;
                    break;
                default:
                    this.touchLast.set(touches[0].scenePercentX, touches[0].scenePercentY);
                    this.touchLastPinchDist = -1;
            }
            this.moveStart.x = touches[0].scenePercentX;
            this.moveStart.y = touches[0].scenePercentY;
            this.currentDraggingMousePosition.copy(this.moveStart);
            this.quaternionStart.copy(this.getRuntimeData().quaternion);
            this.eulerStart.setFromQuaternion(this.quaternionStart, 'YXZ');
        }
        this.isTouchDragging = false;
    };
    OrbitCamera.prototype.onTouchMove = function (event) {
        if (this.isEnabled()) {
            var touches = event.touches;
            if (!touches) {
                return;
            }
            var dx = void 0;
            var dy = void 0;
            switch (touches.length) {
                case 1:
                    this.look = true;
                    this.pan = false;
                    this.zoom = false;
                    this.touchLast.x = touches[0].scenePercentX;
                    this.touchLast.y = touches[0].scenePercentY;
                    this.isMouseDragging = true;
                    this.hasChanged = true;
                    if (!this.isTouchDragging) {
                        if (this.moveStart.distanceTo(this.touchLast) > 0.01) {
                            this.isTouchDragging = true;
                        }
                    }
                    else {
                        this.currentDraggingMousePosition.x = touches[0].scenePercentX;
                        this.currentDraggingMousePosition.y = touches[0].scenePercentY;
                    }
                    break;
                case 2:
                    this.look = false;
                    this.pan = false;
                    this.zoom = false;
                    if (this.enableZoom) {
                        this.zoom = true;
                        dx = touches[0].scenePercentX - touches[1].scenePercentX;
                        dy = touches[0].scenePercentY - touches[1].scenePercentY;
                        var distance = Math.sqrt(dx * dx + dy * dy);
                        var pinchChange = this.touchLastPinchDist - distance;
                        var scrollChange = this.touchLast.y - touches[0].scenePercentY;
                        if (Math.abs(pinchChange) > Math.abs(scrollChange)) {
                            this.zoomDelta = 20.0 * pinchChange;
                        }
                        else {
                            this.zoomDelta = 20.0 * scrollChange;
                        }
                        this.hasChanged = true;
                        this.touchLastPinchDist = distance;
                    }
                    this.touchLast.x = touches[0].scenePercentX;
                    this.touchLast.y = touches[0].scenePercentY;
                    break;
                case 3:
                    this.look = false;
                    this.pan = false;
                    this.zoom = false;
                    if (this.enablePan) {
                        this.isMouseDragging = true;
                        this.pan = true;
                        dx = touches[0].scenePercentX - this.touchLast.x;
                        dy = touches[0].scenePercentY - this.touchLast.y;
                        this.linearMovementDelta.x = dx;
                        this.linearMovementDelta.y = dy;
                    }
                    this.hasChanged = true;
                    this.touchLast.x = touches[0].scenePercentX;
                    this.touchLast.y = touches[0].scenePercentY;
                    break;
                default:
            }
        }
    };
    OrbitCamera.prototype.onTouchEnd = function (event) {
        if (this.isEnabled()) {
            this.touchLast.set(-1.0, -1.0);
            this.touchLastPinchDist = -1;
            var touches = event.touches;
            switch (touches.length) {
                case 0:
                    this.isMouseDragging = false;
                    this.look = false;
                    this.pan = false;
                    this.zoom = false;
                    break;
                case 1:
                    this.look = true;
                    this.pan = false;
                    this.zoom = false;
                    this.touchLast.set(touches[0].scenePercentX, touches[0].scenePercentY);
                    this.moveStart.x = touches[0].scenePercentX;
                    this.moveStart.y = touches[0].scenePercentY;
                    this.currentDraggingMousePosition.copy(this.moveStart);
                    this.quaternionStart.copy(this.getRuntimeData().quaternion);
                    this.eulerStart.setFromQuaternion(this.quaternionStart, 'YXZ');
                    break;
                case 2:
                    this.look = false;
                    this.pan = false;
                    this.zoom = false;
                    if (this.enableZoom) {
                        this.zoom = true;
                        var dx = touches[0].scenePercentX - touches[1].scenePercentX;
                        var dy = touches[0].scenePercentY - touches[1].scenePercentY;
                        var distance = Math.sqrt(dx * dx + dy * dy);
                        this.touchLastPinchDist = distance;
                    }
                    this.touchLast.set(touches[0].scenePercentX, touches[0].scenePercentY);
                    break;
                case 3:
                    this.look = false;
                    this.pan = false;
                    if (this.enablePan) {
                        this.pan = true;
                    }
                    this.zoom = false;
                    this.touchLast.set(touches[0].scenePercentX, touches[0].scenePercentY);
                    break;
                default:
            }
            this.isTouchDragging = false;
        }
    };
    // Sets the orbit point to that defined by targetObject and targetOffset.
    OrbitCamera.prototype.initTarget = function () {
        var _this = this;
        this.getRootObject().when('load', function () {
            if (_this.targetObject && _this.targetObject !== _this.getEntity() &&
                _this.targetObject.runtimeData) {
                _this.targetObject.runtimeData.add(_this.pivotPoint);
                _this.pivotPoint.position.copy(_this.targetOffset);
            }
            else {
                _this.getRootThreeObject().add(_this.pivotPoint);
                _this.pivotPoint.position.copy(_this.targetOffset);
            }
        });
    };
    return OrbitCamera;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = OrbitCamera;


/***/ },
/* 91 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable no-string-literal */
// Rule disabled as uniforms is used as a mapping of strings to uniforms rather
// than a strongly typed object.
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid panorama_to_cubemap_script
 * @vname Panorama To Cube Map
 * @vdescription Converts a panorama to a cube map.
 * @vfilter renderTextureCube
 * @vcategory Rendering
 */
var PanoramaToCubeMap = (function (_super) {
    tslib_1.__extends(PanoramaToCubeMap, _super);
    function PanoramaToCubeMap() {
        var _this = _super.apply(this, arguments) || this;
        /** The scene which is used for rendering the cube map.  */
        _this.skyboxScene = undefined;
        /** An array of cameras, one for each side of the cube. */
        _this.cameras = [null, null, null, null, null, null];
        return _this;
    }
    /** @inheritdoc */
    PanoramaToCubeMap.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('inputTexture') !== -1) {
            var prevTex = this.getPreviousAttribute('inputTexture');
            this.unregisterDependency(prevTex);
            this.registerDependency(this.inputTexture);
            this.updateTexture();
        }
    };
    /** @inheritdoc */
    PanoramaToCubeMap.prototype.onStartup = function () {
        this.skyboxScene = new THREE.Scene();
        this.registerDependency(this.inputTexture);
        this.initCameras();
        this.createSkybox();
    };
    /** @inheritdoc */
    PanoramaToCubeMap.prototype.onEntityReady = function () {
        this.updateTexture();
    };
    /** @inheritdoc */
    PanoramaToCubeMap.prototype.onShutdown = function () {
        if (this.inputTexture) {
            this.unregisterDependency(this.inputTexture);
            this.inputTexture.off('load', this.renderToCube, this);
        }
        if (this.skyboxGeometry) {
            this.skyboxGeometry.dispose();
        }
        if (this.equirectMaterial) {
            this.equirectMaterial.dispose();
        }
        this.skyboxScene = undefined;
        this.skyboxMesh = undefined;
        this.inputTexture = undefined;
    };
    /**
     * Prepares the texture on change or startup.
     */
    PanoramaToCubeMap.prototype.updateTexture = function () {
        if (this.inputTexture && !this.getEntity().isUnloaded()) {
            this.inputTexture.off('load', this.renderToCube, this);
            this.inputTexture.when('load', this.renderToCube, this);
            if (this.inputTexture.isBaseUnloaded()) {
                this.inputTexture.load();
            }
        }
    };
    /**
     * Creates the skybox.
     */
    PanoramaToCubeMap.prototype.createSkybox = function () {
        var equirectShader = THREE.ShaderLib.equirect;
        equirectShader.uniforms['tFlip'].value = 1.0;
        this.equirectMaterial = new THREE.ShaderMaterial({
            fragmentShader: equirectShader.fragmentShader,
            vertexShader: equirectShader.vertexShader,
            uniforms: equirectShader.uniforms,
            depthWrite: false,
            side: THREE.BackSide
        });
        this.skyboxGeometry = new THREE.BoxGeometry(100, 100, 100, 1, 1, 1);
        this.skyboxMesh = new THREE.Mesh(this.skyboxGeometry, this.equirectMaterial);
        this.skyboxMesh.frustumCulled = false;
        this.skyboxMesh.castShadow = false;
        this.skyboxMesh.receiveShadow = false;
        if (this.isEnabled()) {
            this.skyboxScene.add(this.skyboxMesh);
        }
    };
    /**
     * Initializes the cameras.
     */
    PanoramaToCubeMap.prototype.initCameras = function () {
        var fov = 90;
        var aspect = 1;
        this.cameras[0] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[0].up.set(0, -1, 0);
        this.cameras[0].lookAt(new THREE.Vector3(1, 0, 0));
        this.skyboxScene.add(this.cameras[0]);
        this.cameras[1] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[1].up.set(0, -1, 0);
        this.cameras[1].lookAt(new THREE.Vector3(-1, 0, 0));
        this.skyboxScene.add(this.cameras[1]);
        this.cameras[2] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[2].up.set(0, 0, 1);
        this.cameras[2].lookAt(new THREE.Vector3(0, 1, 0));
        this.skyboxScene.add(this.cameras[2]);
        this.cameras[3] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[3].up.set(0, 0, -1);
        this.cameras[3].lookAt(new THREE.Vector3(0, -1, 0));
        this.skyboxScene.add(this.cameras[3]);
        this.cameras[4] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[4].up.set(0, -1, 0);
        this.cameras[4].lookAt(new THREE.Vector3(0, 0, 1));
        this.skyboxScene.add(this.cameras[4]);
        this.cameras[5] = new THREE.PerspectiveCamera(fov, aspect, 1, 1000);
        this.cameras[5].up.set(0, -1, 0);
        this.cameras[5].lookAt(new THREE.Vector3(0, 0, -1));
        this.skyboxScene.add(this.cameras[5]);
    };
    /**
     * Renders the cube map.
     */
    PanoramaToCubeMap.prototype.renderToCube = function () {
        if (this.hasRuntimeData()) {
            this.equirectMaterial.uniforms['tEquirect'].value = this.inputTexture.getThreeTexture();
            var renderTarget = this.getRuntimeData();
            var renderer = this.getThreeRenderer();
            renderTarget.texture.generateMipmaps = false;
            renderer.setViewport(0, 0, renderTarget.width, renderTarget.height);
            for (var i = 0; i < 5; i++) {
                renderTarget.activeCubeFace = i;
                renderer.render(this.skyboxScene, this.cameras[i], renderTarget);
            }
            renderTarget.texture.generateMipmaps = this.getEntity().getProperty('generateMipmaps');
            renderTarget.activeCubeFace = 5;
            renderer.render(this.skyboxScene, this.cameras[5], renderTarget);
        }
    };
    return PanoramaToCubeMap;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PanoramaToCubeMap;


/***/ },
/* 92 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/*
* @vid preview_axis_rotation
* @vname Preview Axis Rotation
* @vdescription Set the rotation of any axis.
* @vfilter object
* @vattr float speed {
*    description : 'The speed that we rotate the object, if a transition is triggered',
*    default : 0.4,
*    max : 100,
*    min : 0.1
*  }
*/
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var degToRad = 0.0174532925;
var AXES = {
    '+X': new THREE.Vector3(1, 0, 0),
    '-X': new THREE.Vector3(-1, 0, 0),
    '+Y': new THREE.Vector3(0, 1, 0),
    '-Y': new THREE.Vector3(0, -1, 0),
    '+Z': new THREE.Vector3(0, 0, 1),
    '-Z': new THREE.Vector3(0, 0, -1)
};
var PreviewAxisRotation = (function (_super) {
    tslib_1.__extends(PreviewAxisRotation, _super);
    function PreviewAxisRotation() {
        var _this = _super.apply(this, arguments) || this;
        _this.time = 0;
        _this.target = new THREE.Quaternion();
        _this.tempQuat = new THREE.Quaternion();
        return _this;
    }
    /**
     * Get the right vector from a matrix
     * @param {THREE.Matrix4} matrix The matrix to extract a right vector from
     * @returns {THREE.Vector3} A right vector extracted from the matrix
     */
    PreviewAxisRotation.prototype.getRightVector = function (matrix) {
        return new THREE.Vector3(matrix.elements[0], matrix.elements[1], matrix.elements[2]);
    };
    /**
     * Extract the up vector from a matrix
     * @param {THREE.Matrix4} matrix The matrix to extract from
     * @returns {THREE.Vector3} The extracted up vector
     */
    PreviewAxisRotation.prototype.getUpVector = function (matrix) {
        return new THREE.Vector3(matrix.elements[4], matrix.elements[5], matrix.elements[6]);
    };
    /**
     * Extract the forward vector from a matrix
     * @param {THREE.Matrix4} matrix The matrix to extract from
     * @returns {THREE.Vector3} The extracted forward vector
     */
    PreviewAxisRotation.prototype.getForwardVector = function (matrix) {
        return new THREE.Vector3(matrix.elements[8], matrix.elements[9], matrix.elements[10]);
    };
    /**
     * Set the right vector of a Matrix
     * @param {THREE.Matrix4} matrix The matrix who's right vector we want to set
     * @param {THREE.Vector3} vector The vector to set the matrix to
     * @returns {void}
     */
    PreviewAxisRotation.prototype.setRightVector = function (matrix, vector) {
        matrix.elements[0] = vector.x;
        matrix.elements[1] = vector.y;
        matrix.elements[2] = vector.z;
    };
    /**
     * Set the up vector of a Matrix
     * @param {THREE.Matrix4} matrix The matrix who's up vector we want to set
     * @param {THREE.Vector3} vector The vector to set the matrix to
     * @returns {void}
     */
    PreviewAxisRotation.prototype.setUpVector = function (matrix, vector) {
        matrix.elements[4] = vector.x;
        matrix.elements[5] = vector.y;
        matrix.elements[6] = vector.z;
    };
    /**
     * Set the forward vector of a Matrix
     * @param {THREE.Matrix4} matrix The matrix who's forward vector we want to set
     * @param {THREE.Vector3} vector The vector to set the matrix to
     * @returns {void}
     */
    PreviewAxisRotation.prototype.setForwardVector = function (matrix, vector) {
        matrix.elements[8] = vector.x;
        matrix.elements[9] = vector.y;
        matrix.elements[10] = vector.z;
    };
    /** @inheritdoc */
    PreviewAxisRotation.prototype.onStartup = function () {
        this.listenTo(this.getEngine(), 'rotate_to', this.rotateToEuler);
        this.listenTo(this.getEngine(), 'rotate_on_axis', this.rotateOnWorldAxis);
        this.listenTo(this.getEngine(), 'set_local_rotation', this.setLocalRotation);
        this.listenTo(this.getEngine(), 'set_axes', this.setAxes);
        this.listenTo(this.getEngine(), 'get_axes', this.getAxes);
        this.listenTo(this.getEntity(), 'rotate_to', this.rotateToEuler);
        this.listenTo(this.getEntity(), 'rotate_on_axis', this.rotateOnWorldAxis);
        this.listenTo(this.getEntity(), 'set_local_rotation', this.setLocalRotation);
        this.listenTo(this.getEntity(), 'set_axes', this.setAxes);
        this.listenTo(this.getEntity(), 'get_axes', this.getAxes);
    };
    /**
     * Given an set of axis keys, rotate to the correct axis
     * @param {string} up The up axis key
     * @param {string} forward The forward axis key
     * @param {bool} transition Whether or not to trigger a smooth transition
     * @returns {void}
     */
    PreviewAxisRotation.prototype.setAxes = function (up, forward, transition) {
        var upAxis = AXES[up];
        var forwardAxis = AXES[forward];
        if (!upAxis) {
            return Logger_1.default.error('No Up Axis available For ', up);
        }
        else if (!forwardAxis) {
            return Logger_1.default.error('No Forward Axis available For ', forward);
        }
        var rightVec = new THREE.Vector3();
        var rotationMatrix = new THREE.Matrix4();
        this.setUpVector(rotationMatrix, upAxis);
        this.setForwardVector(rotationMatrix, forwardAxis);
        rightVec.crossVectors(upAxis, forwardAxis);
        this.setRightVector(rotationMatrix, rightVec);
        this.target.setFromRotationMatrix(rotationMatrix);
        // Transition smoothly, over time
        if (transition) {
            this.time = this.speed;
        }
        else {
            this.setRotation(this.target);
            this.getEntity().trigger('axis_transition_complete');
        }
    };
    /**
     * Make the passed in rotation object useful
     * @param {Vector3Def} rotation Create an Euler from an object with x/y/z components
     * @return {THREE.Euler}
     */
    PreviewAxisRotation.prototype.eulerFromObject = function (rotation) {
        var x = isNaN(rotation.x) ? 0 : rotation.x * degToRad;
        var y = isNaN(rotation.y) ? 0 : rotation.y * degToRad;
        var z = isNaN(rotation.z) ? 0 : rotation.z * degToRad;
        var euler = new THREE.Euler(x, y, z);
        euler.order = 'YXZ';
        return euler;
    };
    /**
     * Easier interface for rotating about three axes
     * @param {Object} axis Axes to rotate on, by degrees
     * @param {boolean} additive Whether or not to add to the current rotation OR just set as world rotation
     * @param {boolean} force Force this to happen without a transition
     * @returns {void}
     */
    PreviewAxisRotation.prototype.rotateOnWorldAxis = function (axis, additive, force) {
        if (this.time > 0) {
            return;
        }
        // set at origin with origin scale
        var runtimeData = this.getRuntimeData();
        var position = new THREE.Vector3();
        var scale = new THREE.Vector3();
        position.copy(runtimeData.position);
        scale.copy(runtimeData.scale);
        runtimeData.position.set(0, 0, 0);
        runtimeData.scale.set(1, 1, 1);
        runtimeData.updateMatrix();
        // setup rotation matrices
        var x = new THREE.Matrix4().makeRotationX((axis.x || 0) * degToRad);
        var y = new THREE.Matrix4().makeRotationY((axis.y || 0) * degToRad);
        var z = new THREE.Matrix4().makeRotationZ((axis.z || 0) * degToRad);
        // add matrices
        z.multiply(y);
        z.multiply(x);
        // additive to the current matrix?
        if (additive) {
            z.multiply(runtimeData.matrix);
        }
        this.target.setFromRotationMatrix(z);
        // Do it now...
        if (force) {
            this.setRotation(this.target);
            this.getEngine().needsRender = true;
        }
        else {
            // ...otherwise transition nicely, over time
            this.time = this.speed;
        }
        // Reset back to position
        runtimeData.position.copy(position);
        runtimeData.scale.copy(scale);
    };
    /**
     * Smoothly rotate around an axis
     * @param {VectorXYZ} rotation Euler rotation values for each axis.
     * @returns {void}
     */
    PreviewAxisRotation.prototype.rotateToEuler = function (rotation) {
        this.target.setFromEuler(this.eulerFromObject(rotation));
        this.time = this.speed;
    };
    /**
     * Set the rotation of an axis
     * @param Object rotation Euler rotation values for each axis. {x,y,z}
     */
    PreviewAxisRotation.prototype.setLocalRotation = function (rotation) {
        // interrupt if transitioning
        this.time = 0;
        // just reusing target here, not going to interpolate to it
        this.target.setFromEuler(this.eulerFromObject(rotation));
        this.setRotation(this.target);
    };
    /**
     * Apply a quaternion rotation to the entity!
     */
    PreviewAxisRotation.prototype.setRotation = function (target) {
        this.getEntity().setQuaternion(target.x, target.y, target.z, target.w);
        // alternative instead of forcing a change event on the entity
        if (this.hasRuntimeData() && !this.getRuntimeData().quaternion.equals(target)) {
            this.getRuntimeData().quaternion.copy(target);
        }
        this.getEngine().needsRender = true;
    };
    /**
     * Get the sign for the value provided.
     * @returns {string} + if a positive value, - if negative
     */
    PreviewAxisRotation.prototype.getSign = function (value) {
        return value > 0 ? '+' : '-';
    };
    /**
     * Get the up and forward axes, useable by preview
     * @param {Function} callback Recieves the up and forward axes
     * @returns {Object} An object with an up and forward component. Used for Box Preview
     */
    PreviewAxisRotation.prototype.getAxes = function (callback) {
        var matrix = this.getRuntimeData().matrix;
        var upVec = this.getUpVector(matrix).normalize();
        var forwardVec = this.getForwardVector(matrix).normalize();
        var absX = Math.abs(upVec.x);
        var absY = Math.abs(upVec.y);
        var absZ = Math.abs(upVec.z);
        var up = absX < absZ ? (absZ < absY ? 'y' : 'z') : (absX < absY ? 'y' : 'x');
        absX = Math.abs(forwardVec.x);
        absY = Math.abs(forwardVec.y);
        absZ = Math.abs(forwardVec.z);
        var forward = absX < absZ ? (absZ < absY ? 'y' : 'z') : (absX < absY ? 'y' : 'x');
        // translate to values usable by preview
        var axes = {
            up: ("" + this.getSign(upVec[up]) + up).toUpperCase(),
            forward: ("" + this.getSign(forwardVec[forward]) + forward).toUpperCase()
        };
        if (callback) {
            callback(axes);
        }
        return axes;
    };
    /** @inheritdoc */
    PreviewAxisRotation.prototype.onUpdate = function (dt) {
        if (this.time >= 0 && this.hasRuntimeData()) {
            this.time -= dt;
            this.tempQuat.copy(this.getRuntimeData().quaternion);
            this.tempQuat.slerp(this.target, Math.min(1, Math.max(0, 1 - 1 / (this.speed / this.time))));
            this.getEntity().setQuaternion(this.tempQuat.x, this.tempQuat.y, this.tempQuat.z, this.tempQuat.w);
            // force render
            this.getEngine().needsRender = true;
            // transition over, notify user!
            if (this.time < 0) {
                this.setRotation(this.target);
                this.getEntity().trigger('axis_transition_complete');
            }
        }
    };
    return PreviewAxisRotation;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PreviewAxisRotation;


/***/ },
/* 93 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/*
* @vid preview_camera_focus
* @vname Preview Camera Focus
* @vdescription A controller that allows a camera to easily orbit a target object.
* @vfilter camera
* @vcategory Camera Controllers
* @vattr float speed {
*    description : 'The speed that we move to focus on the target',
*    default : 0.8,
*    max : 100,
*    min : 0.1
*  }
*/
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var NodeObject_1 = __webpack_require__(9);
var UserAgent_1 = __webpack_require__(13);
var PreviewCameraFocus = (function (_super) {
    tslib_1.__extends(PreviewCameraFocus, _super);
    function PreviewCameraFocus() {
        var _this = _super.apply(this, arguments) || this;
        /** Interpolation timer */
        _this.time = -1;
        /** Distance away from target look position the camera needs to be positioned at */
        _this.cameraDistance = 0;
        /** Used for triggering or interrupting focus event */
        _this.isMouseDown = false;
        return _this;
    }
    /** @inheritdoc */
    PreviewCameraFocus.prototype.onStartup = function () {
        _super.prototype.onStartup.call(this);
        var entity = this.getEntity();
        if (entity instanceof NodeObject_1.default) {
            var rootObject = entity.getRootObject();
            rootObject.when('load', this.onSceneLoaded, this);
        }
    };
    /** @inheritdoc */
    PreviewCameraFocus.prototype.onDisable = function () {
        this.interrupt();
    };
    /** @inheritdoc */
    PreviewCameraFocus.prototype.onUpdate = function (dt) {
        if (this.isEnabled() && this.time > 0) {
            var runtimeData = this.getRuntimeData();
            var lerpVal = this.easeInOut(1 - 1 / (this.speed / this.time));
            if (runtimeData instanceof THREE.PerspectiveCamera) {
                this.lerp(this.srcPos, this.targetPos, lerpVal, this.currentPos);
                runtimeData.position.copy(this.currentPos);
            }
            this.lerp(this.srcLook, this.targetLook, lerpVal, this.currentLook);
            runtimeData.lookAt(this.currentLook);
            this.time -= dt;
            if (this.time < 0) {
                this.onEnd();
            }
            this.getEngine().needsRender = true;
        }
    };
    /**
     * Re-enable the preview camera controller and reset the time tracker.
     * @returns {void}
     */
    PreviewCameraFocus.prototype.onReset = function () {
        this.orbitCamControl.enable();
        this.time = -1;
    };
    /**
     * Set mouse state to allow for focus event.
     * @returns {void}
     */
    PreviewCameraFocus.prototype.onMouseDown = function () {
        if (this.isEnabled()) {
            this.isMouseDown = true;
        }
    };
    /**
     * Set mouse state to not allow focus event.
     * @returns {void}
     */
    PreviewCameraFocus.prototype.onMouseUp = function () {
        this.isMouseDown = false;
    };
    /**
     * Depending on mouse state, interrupt camera transition if moving the mouse.
     * @returns {void}
     */
    PreviewCameraFocus.prototype.onMouseMove = function () {
        if (this.isMouseDown) {
            this.interrupt();
        }
    };
    /**
     * On dobule click, trigger the focus transition to occur, and move the camera into position.
     * @param {Box3DInputEvent} event The Box3DInput event created by the input controller,
     * from the 'doubleClick' event
     */
    PreviewCameraFocus.prototype.onDoubleClick = function (event) {
        if (this.isEnabled() && this.hasRuntimeData()) {
            if (!this.raycaster) {
                this.raycaster = new THREE.Raycaster();
                this.mouseVector = new THREE.Vector2();
                this.targetLook = new THREE.Vector3();
                this.srcLook = new THREE.Vector3();
                this.targetPos = new THREE.Vector3();
                this.currentLook = new THREE.Vector3();
                this.currentPos = new THREE.Vector3();
                this.srcPos = new THREE.Vector3();
            }
            var pointX = UserAgent_1.isMobile() ? this.getInput().touchPositionPercent.x : event.scenePercentX;
            var pointY = UserAgent_1.isMobile() ? this.getInput().touchPositionPercent.y : event.scenePercentY;
            this.mouseVector.set(pointX * 2 - 1, -pointY * 2 + 1);
            this.raycaster.near = 0;
            // a bit longer to accommodate being fully zoomed out
            this.raycaster.far = this.orbitCamControl.orbitDistanceMax + 1;
            this.raycaster.setFromCamera(this.mouseVector, this.getRuntimeData());
            var visFilter = function (intersect) { return intersect.object.visible; };
            var intersections = this.raycaster.intersectObjects(this.getRootThreeObject().children, true)
                .filter(visFilter);
            var intersection = (intersections.length) > 0 ? intersections[0] : undefined;
            // interrupt the current transition, continue to next target
            // from the current look position and position
            if (this.time > 0) {
                this.interrupt();
                this.srcLook.copy(this.currentLook);
            }
            else {
                this.srcLook.copy(this.orbitCamControl._pivotWorldPos);
            }
            if (intersection) {
                this.orbitCamControl.disable();
                this.targetLook.copy(intersection.point);
                this.srcPos.copy(this.getRuntimeData().position);
                this.targetPos.copy(this.getTargetPosition(this.srcPos, this.targetLook, this.orbitCamControl.orbitDistanceMin));
            }
            else {
                // reset the camera to look at origin
                this.targetLook.set(0, 0, 0);
                this.srcPos.copy(this.getRuntimeData().position);
                this.targetPos.copy(this.getTargetPosition(this.srcPos, this.targetLook, this.cameraDistance));
            }
            // trigger the move to happen
            this.time = this.speed;
        }
    };
    /**
     * Called when the root of the scene is finished loading (the first time only).
     * @method onSceneLoaded
     * @private
     * @memberOf PreviewCameraFocus
     */
    PreviewCameraFocus.prototype.onSceneLoaded = function () {
        var _this = this;
        this.orbitCamControl =
            this.getEntity().getComponentByScriptName('Orbit Camera Controller');
        // explicit set of target
        this.orbitCamControl.setTarget(this.getRootObject());
        this.getEntity().when('load', function () {
            _this.cameraDistance = _this.getRuntimeData().position.distanceTo(_this.orbitCamControl.pivotPoint.position);
        });
        if (UserAgent_1.isMobile()) {
            this.listenTo(this.getEngine(), 'touchStart', this.onMouseDown);
            this.listenTo(this.getEngine(), 'touchMove', this.onMouseMove);
            this.listenTo(this.getEngine(), 'touchEnd', this.onMouseUp);
            this.listenTo(this.getEngine(), 'doubleTap', this.onDoubleClick);
        }
        else {
            this.listenTo(this.getEngine(), 'mouseScroll', this.interrupt);
            this.listenTo(this.getEngine(), 'mouseMove', this.onMouseMove);
            this.listenTo(this.getEngine(), 'mouseDown', this.onMouseDown);
            this.listenTo(this.getEngine(), 'mouseUp', this.onMouseUp);
            this.listenTo(this.getEngine(), 'keyDown', this.interrupt);
            this.listenTo(this.getEngine(), 'doubleClick', this.onDoubleClick);
        }
        this.listenTo(this.getEntity(), 'resetOrbitCameraController', this.onReset);
    };
    /**
     * Immediatly interrupt the transition, if it is occurring, and set the camera lookat and
     * position to current position and target.
     * @returns {void}
     */
    PreviewCameraFocus.prototype.interrupt = function () {
        if (this.isEnabled() && this.time > 0) {
            this.onEnd();
        }
    };
    /**
     * Get the target position to move the camera to, given a target look position.
     * @returns {THREE.Vector3} A Vector3 with the position to move the camera to.
     */
    PreviewCameraFocus.prototype.getTargetPosition = function (currentPos, targetLook, distance) {
        var diff = new THREE.Vector3();
        diff.subVectors(currentPos, targetLook);
        diff.normalize().multiplyScalar(distance);
        return diff.add(targetLook);
    };
    /**
     * Set the position of the camera and update OrbitCameraController properties based off of new
     * look target and position.
     * @returns {void}
     */
    PreviewCameraFocus.prototype.onEnd = function () {
        this.time = -1;
        this.orbitCamControl.enable();
        this.orbitCamControl.setTargetOffset(this.currentLook);
        this.orbitCamControl.resetOrbitRotation();
        this.orbitCamControl.setOrbitDistance(this.getRuntimeData().position.distanceTo(this.currentLook));
    };
    /**
     * Ease in out formula.
     * @returns {Number}
     */
    PreviewCameraFocus.prototype.easeInOut = function (t) {
        return t < 0.5 ? 4 * t * t * t : (t - 1) * (2 * t - 2) * (2 * t - 2) + 1;
    };
    /**
     * Linearly interpolate between two Vector3s.
     * @param {THREE.Vector3} src Source Vector3 to lerp from.
     * @param {THREE.Vector3} dst Destination Vector3 to lerp to.
     * @param {Number} val The percentage point from src to dst to lerp to (0 = src, 1 = dst, 0.5 = half way in between).
     * @param {THREE.Vector3} out The Vector3 to apply the resulting interpolated value to.
     * @returns {void}
     */
    PreviewCameraFocus.prototype.lerp = function (src, dst, val, out) {
        var x = src.x + (dst.x - src.x) * val;
        var y = src.y + (dst.y - src.y) * val;
        var z = src.z + (dst.z - src.z) * val;
        out.set(x, y, z);
    };
    return PreviewCameraFocus;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = PreviewCameraFocus;


/***/ },
/* 94 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid reflection_capture_planar
 * @vname Reflection Capture Plane
 * @vfilter Object
 * @vcategory Rendering
 * @vreserved
 * @vattr Asset captureTexture {
 *   description: 'The RenderTexture2D to render the reflection to.',
 *   filter: { renderTexture2D: true }
 * }
 * @vattr Float clipBias {
 *   description: 'Pushes the rendered scene forward or backwards to adjust clipping with reflection plane.',
 *   default: 0.01
 * }
 * @vattr Integer updateFrameInterval {
 *   description: 'The number of frames to skip in between updates of the reflection. Default is 0.',
 *   default: 0
 * }
 */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var ReflectionCapture = (function (_super) {
    tslib_1.__extends(ReflectionCapture, _super);
    function ReflectionCapture() {
        var _this = _super.apply(this, arguments) || this;
        _this.framesElapsed = 0;
        _this.reflectionNormal = new THREE.Vector3(0, 1, 0);
        _this.reflectionPlane = new THREE.Plane();
        _this.clipPlane = new THREE.Vector4();
        _this.reflectionPosition = new THREE.Vector3();
        _this.cameraWorldPosition = new THREE.Vector3();
        _this.rotationMatrix = new THREE.Matrix4();
        _this.lookAtPosition = new THREE.Vector3(0, 0, -1);
        _this.up = new THREE.Vector3(0, 1, 0);
        _this.perspectiveCamera = null;
        _this.orthoCamera = null;
        return _this;
    }
    /** @inheritdoc */
    /** @inheritdoc */
    ReflectionCapture.prototype.onEntityReady = function () {
        this.initCameras();
        this.initTexture();
    };
    ReflectionCapture.prototype.createTempRenderTexture = function () {
        this.tempRenderTexture = this.getEngine().createRenderTexture2d({
            width: 512,
            height: 512,
            format: 'rgba',
            type: 'uByte'
        }, 'render_tex_reflection');
        this.tempRenderTexture.load();
    };
    /** @inheritdoc */
    ReflectionCapture.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('captureTexture') !== -1) {
            this.initTexture();
        }
    };
    ReflectionCapture.prototype.initTexture = function () {
        if (this.captureTexture) {
            var that = this;
            this.captureTexture.when('load', function () {
                if (that.tempRenderTexture) {
                    that.tempRenderTexture.unload();
                }
            });
            if (this.captureTexture.isBaseUnloaded()) {
                this.captureTexture.load();
            }
        }
        else {
            this.createTempRenderTexture();
        }
    };
    /**
     * Called immediately after after component creation
     */
    ReflectionCapture.prototype.initCameras = function () {
        if (this.captureTexture) {
            this.captureTexture.load();
        }
        this.perspectiveCamera = new THREE.PerspectiveCamera();
        this.orthoCamera = new THREE.OrthographicCamera(undefined, undefined, undefined, undefined);
    };
    ReflectionCapture.prototype.updateReflection = function (camera) {
        if (this.isEnabled()) {
            var sign = function (num) {
                return num < 0 ? -1 : 1;
            };
            this.getEntity().runtimeData.updateMatrixWorld();
            camera.updateMatrixWorld();
            this.reflectionPosition.setFromMatrixPosition(this.getEntity().runtimeData.matrixWorld);
            this.cameraWorldPosition.setFromMatrixPosition(camera.matrixWorld);
            this.rotationMatrix.extractRotation(this.getEntity().runtimeData.matrixWorld);
            this.reflectionNormal.set(0, 1, 0);
            this.reflectionNormal.applyMatrix4(this.rotationMatrix);
            var view = this.reflectionPosition.clone().sub(this.cameraWorldPosition);
            var reflectView = view.reflect(this.reflectionNormal).negate();
            reflectView.add(this.reflectionPosition);
            this.rotationMatrix.extractRotation(camera.matrixWorld);
            this.lookAtPosition.set(0, 0, -1);
            this.lookAtPosition.applyMatrix4(this.rotationMatrix);
            this.lookAtPosition.add(this.cameraWorldPosition);
            var target = this.reflectionPosition.clone().sub(this.lookAtPosition);
            var reflectTarget = target.reflect(this.reflectionNormal).negate();
            reflectTarget.add(this.reflectionPosition);
            this.up.set(0, -1, 0);
            this.up.applyMatrix4(this.rotationMatrix);
            var reflectUp = this.up.reflect(this.reflectionNormal).negate();
            if (camera instanceof THREE.PerspectiveCamera && this.perspectiveCamera) {
                this.perspectiveCamera.aspect = camera.aspect;
                this.perspectiveCamera.fov = camera.fov;
                this.perspectiveCamera.near = camera.near;
                this.perspectiveCamera.far = camera.far;
                this.reflectionCamera = this.perspectiveCamera;
            }
            else if (this.orthoCamera) {
                this.orthoCamera.left = camera.left;
                this.orthoCamera.right = camera.right;
                this.orthoCamera.top = camera.top;
                this.orthoCamera.bottom = camera.bottom;
                this.orthoCamera.near = camera.near;
                this.orthoCamera.far = camera.far;
                this.reflectionCamera = this.orthoCamera;
            }
            else {
                return;
            }
            this.reflectionCamera.position.copy(reflectView);
            this.reflectionCamera.up = reflectUp;
            this.reflectionCamera.lookAt(reflectTarget);
            this.reflectionCamera.updateProjectionMatrix();
            this.reflectionCamera.updateMatrixWorld();
            this.reflectionCamera.matrixWorldInverse.getInverse(this.reflectionCamera.matrixWorld);
            // Now update projection matrix with new clip plane, implementing code
            // from: http://www.terathon.com/code/oblique.html
            // Paper explaining this technique: http://www.terathon.com/lengyel/Lengyel-Oblique.pdf
            this.reflectionPlane.setFromNormalAndCoplanarPoint(this.reflectionNormal, this.reflectionPosition);
            this.reflectionPlane.applyMatrix4(this.reflectionCamera.matrixWorldInverse);
            this.clipPlane.set(this.reflectionPlane.normal.x, this.reflectionPlane.normal.y, this.reflectionPlane.normal.z, this.reflectionPlane.constant);
            var q = new THREE.Vector4();
            var projectionMatrix = this.reflectionCamera.projectionMatrix;
            projectionMatrix.copy(camera.projectionMatrix);
            // If any left-right asymetry  exists in the fov, flip the projection.
            projectionMatrix.elements[8] *= -1;
            q.x = (sign(this.clipPlane.x) + projectionMatrix.elements[8]) /
                projectionMatrix.elements[0];
            q.y = (sign(this.clipPlane.y) + projectionMatrix.elements[9]) /
                projectionMatrix.elements[5];
            q.z = -1.0;
            q.w = (1.0 + projectionMatrix.elements[10]) / projectionMatrix.elements[14];
            // Calculate the scaled plane vector
            var c = new THREE.Vector4();
            c = this.clipPlane.multiplyScalar(2.0 / this.clipPlane.dot(q));
            // Replacing the third row of the projection matrix
            projectionMatrix.elements[2] = c.x;
            projectionMatrix.elements[6] = c.y;
            projectionMatrix.elements[10] = c.z + 1.0 - this.clipBias;
            projectionMatrix.elements[14] = c.w;
        }
    };
    /**
     * Render the scene to the texture.
     * @method captureScene
     * @public
     * @param {Object} scene The scene that the reflection will render.
     * @param {Object} camera The camera that the reflection will be rendered relative to (since
     * reflections are dependent on view)
     * @return {void}
     */
    ReflectionCapture.prototype.captureScene = function (scene, camera) {
        if (!camera) {
            throw new Error('Call to ReflectionCapture.captureScene without specifying a camera.');
        }
        this.updateReflection(camera);
        // Render the mirrored view of the current scene into the target texture
        var threeTexture = this.captureTexture ? this.captureTexture.runtimeData : null;
        var target = threeTexture ? threeTexture : this.tempRenderTexture.runtimeData;
        this.getRenderer().renderView(scene, this.reflectionCamera, {
            renderTarget: target,
            clearDepth: true,
            enableShadows: false,
            enablePreRenderFunctions: false
        });
    };
    /** @inheritdoc */
    ReflectionCapture.prototype.onPreRenderView = function (scene, camera) {
        if (this.isEnabled()) {
            if (this.framesElapsed >= this.updateFrameInterval) {
                //render reflection
                this.captureScene(scene, camera);
                this.framesElapsed = 0;
            }
            else {
                this.framesElapsed++;
            }
        }
    };
    return ReflectionCapture;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ReflectionCapture;


/***/ },
/* 95 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * @vid render_modes
 * @vname Render Modes
 * @vfilter Application
 * @vcategory Rendering
 * @vreserved
 * @vattr String renderMode {
 *   description: 'How to render the scene',
 *   default: 'Lit'
 * }
 * @vattr Asset shapeTexture {
 *   'description': '', 'type': 'asset',
 *   'filter': {
 *     'texture2D': true,
 *     'renderTexture2D': true,
 *   },
 *   'default': null
 * }
 * @vattr Boolean skeletonsVisible {
 *   description: 'Render skeletons in the scene',
 *   default: false
 * }
 * @vattr Boolean wireframesVisible {
 *   description: 'Render mesh wireframes',
 *   default: false
 * }
 * @vevent local resetSkeletons {
 *   scope: 'local',
 *   action: true,
 *   category: 'Rendering',
 *   parameters: []
 * }
 * @vevent local setRenderMode {
 *   scope: 'local',
 *   action: true,
 *   category: 'Rendering',
 *   parameters: [{
 *     name: 'renderMode',
 *     type: 's',
 *     description: 'One of "Lit", "Unlit", etc.',
 *     default: 'Lit'
 *   }]
 * }
 * @vevent local setSkeletonsVisible {
 *   scope: 'local',
 *   action: true,
 *   category: 'Rendering',
 *   parameters: [{
 *     name: 'visible',
 *     type: 'b',
 *     description: 'Whether or not skeletons are visible.',
 *     default: false
 *   }]
 * }
 * @vevent local setWireframesVisible {
 *   scope: 'local',
 *   action: true,
 *   category: 'Rendering',
 *   parameters: [{
 *     name: 'visible',
 *     type: 'b',
 *     description: 'Whether or not wireframes are visible.',
 *     default: false
 *   }]
 * }
 */
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var Logger_1 = __webpack_require__(3);
var BaseComponent_1 = __webpack_require__(2);
var globalEvents_1 = __webpack_require__(40);
var DEFAULT_GRID_SIZE = 1024;
var DEFAULT_GRID_DIVISIONS = 10;
var DEFAULT_GRID_PADDING = 2;
/**
 * Calculates the color value for the specific UV grid cell.
 * @function calculateUvGridCellColor
 * @param {number} x The grid cell x position.
 * @param {number} y The grid cell y position.
 * @param {number} divisions The number of divisions across a single dimension.
 * @returns {String} The color in the format of rgb(x,x,x).
 */
function calculateUvGridCellColor(x, y, divisions) {
    var quadrants = [
        { r: 200, g: 200, b: 0 },
        { r: 0, g: 200, b: 200 },
        { r: 0, g: 200, b: 0 },
        { r: 200, g: 0, b: 200 }
    ];
    var center = Math.floor(divisions / 2);
    var quadrant = (Math.floor(x / Math.floor((divisions / 2))) % 2) +
        ((Math.floor(y / Math.floor((divisions / 2))) % 2) * 2);
    var distancePct = 1.0 - Math.sqrt((Math.pow(x - center, 2)) +
        (Math.pow(y - center, 2))) / Math.sqrt(Math.pow(center + center, 2));
    var color = {
        r: Math.floor(quadrants[quadrant].r * distancePct),
        g: Math.floor(quadrants[quadrant].g * distancePct),
        b: Math.floor(quadrants[quadrant].b * distancePct)
    };
    return "rgb(" + color.r + "," + color.g + "," + color.b + ")";
}
/**
 * Renders a single UV grid cell to the canvas.
 * @function renderUvGridCell
 * @param {Context2D} context The canvas's context.
 * @param {number} x The grid cell x position.
 * @param {number} y The grid cell y position.
 * @param {number} size The width / height of the grid.
 * @param {number} divisions The number of times the grid is divided.
 * @param {number} padding The grid padding.
 * @returns {void}
 */
function renderUvGridCell(context, x, y, size, divisions, padding) {
    var xPos = (size / divisions) * x;
    var yPos = (size / divisions) * y;
    var width = (size / divisions);
    var height = (size / divisions);
    // Draw the background for this grid cell.
    context.fillStyle = calculateUvGridCellColor(x, y, divisions);
    context.fillRect(xPos + padding, yPos + padding, width - (padding * 2), height - (padding * 2));
    // Render the sub grid on the grid cell.
    context.strokeStyle = 'rgba(0,0,0,0.2)';
    context.beginPath();
    context.moveTo(xPos + padding, yPos + height / 2);
    context.lineTo(xPos + width - padding, yPos + height / 2);
    context.moveTo(xPos + width / 2, yPos + padding);
    context.lineTo(xPos + width / 2, yPos + height - padding);
    context.stroke();
    // Draw the grid position on alternating grid cells.
    if ((x + y) % 2 === 0) {
        var characters = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'.split('');
        context.fillStyle = 'white';
        context.strokeStyle = 'white';
        context.font = Math.floor(size / (5 * divisions)) + 'px sans-serif';
        context.fillText(characters[y] + x, xPos + (height / 10), yPos + height - (height / 10));
    }
}
/**
 * Generate a UV grid texture programatically.
 * @function generateUvGrid
 * @param {Object} [options] Grid options.
 * @param {number} [options.size] The width / height of the grid (default is 1024).
 * @param {number} [options.divisions] The number of times the grid is divided (default is 10).
 * @param {number} [options.padding] The grid padding (default is 2).
 * @returns {Canvas} Returns a canvas containing the UV grid.
 */
function generateUvGrid(options) {
    if (options === void 0) { options = {}; }
    var size = options.size || DEFAULT_GRID_SIZE;
    var divisions = options.divisions || DEFAULT_GRID_DIVISIONS;
    var padding = options.padding !== undefined ? options.padding : DEFAULT_GRID_PADDING;
    var canvas = document.createElement('canvas');
    canvas.width = size;
    canvas.height = size;
    var context = canvas.getContext('2d');
    context.fillStyle = 'rgb(255,255,255)';
    context.fillRect(0, 0, size, size);
    for (var y = 0; y < divisions; y++) {
        for (var x = 0; x < divisions; x++) {
            renderUvGridCell(context, x, y, size, divisions, padding);
        }
    }
    return canvas;
}
var RenderModes = (function (_super) {
    tslib_1.__extends(RenderModes, _super);
    function RenderModes() {
        var _this = _super.apply(this, arguments) || this;
        _this.overrideMaterialEnabled = false;
        _this.lightsDisabled = false;
        _this.prevMaterialProperties = {};
        _this.wireframeMaterial = null;
        _this.skeletonHelpers = {};
        _this.renderModes = (_a = {},
            _a[RenderModes.LIT] = {
                overrideMaterial: null
            },
            _a[RenderModes.UNLIT] = {
                overrideMaterial: null,
                disableLights: true
            },
            _a[RenderModes.SHAPE] = {
                overrideMaterial: {
                    skinned: new THREE.ShaderMaterial(RenderModes.SHAPE_MATERIAL),
                    static: new THREE.ShaderMaterial(RenderModes.SHAPE_MATERIAL)
                },
                copyUniforms: ['bumpMap', 'normalMap']
            },
            _a[RenderModes.NORMALS] = {
                overrideMaterial: {
                    skinned: new THREE.ShaderMaterial(RenderModes.NORMALS_MATERIAL),
                    static: new THREE.ShaderMaterial(RenderModes.NORMALS_MATERIAL)
                },
                copyUniforms: ['bumpMap', 'normalMap']
            },
            _a[RenderModes.UNTEXTURED] = {
                overrideMaterial: 'flatShaded'
            },
            _a[RenderModes.UV_OVERLAY] = {
                overrideMaterial: {
                    skinned: undefined,
                    static: undefined
                }
            },
            _a[RenderModes.SKIN_WEIGHTS] = {
                overrideMaterial: {
                    skinned: new THREE.ShaderMaterial(RenderModes.SKIN_WEIGHTS_MATERIAL),
                    static: new THREE.ShaderMaterial(RenderModes.SKIN_WEIGHTS_MATERIAL)
                }
            },
            _a);
        return _this;
        var _a;
    }
    /** @inheritdoc */
    RenderModes.prototype.onStartup = function () {
        // Create a UV overlay material.
        var uvTexture = new THREE.Texture(generateUvGrid());
        uvTexture.anisotropy = 8;
        uvTexture.needsUpdate = true;
        var uvMaterialStatic = new THREE.MeshBasicMaterial({
            map: uvTexture,
            side: THREE.DoubleSide
        });
        var uvMaterialSkinned = new THREE.MeshBasicMaterial({
            map: uvTexture,
            side: THREE.DoubleSide,
            skinning: true
        });
        this.renderModes[RenderModes.UV_OVERLAY].overrideMaterial.skinned = uvMaterialSkinned;
        this.renderModes[RenderModes.UV_OVERLAY].overrideMaterial.static = uvMaterialStatic;
        // Add a flat shaded material to the registry if it doesn't already exist.
        // TODO: Why do we do this for the flat shaded material but not for the others?
        if (!this.getEngine().getAssetById('flatShaded')) {
            var flatShadedMaterial = this.flatShadedMaterial = this.getEngine().createMaterial({
                emissiveColor: { r: 0.9, g: 0.85, b: 0.8 },
                side: THREE.DoubleSide
            }, 'flatShaded');
            flatShadedMaterial.enableFeature('albedo', false);
            flatShadedMaterial.enableFeature('emissive', true);
        }
        // Create a wireframe material.
        this.wireframeMaterial = new THREE.MeshBasicMaterial({
            color: '#050505',
            wireframe: true
        });
        this.getGlobalEvents().on('resetSkeletons', this.resetSkeletons, this);
        this.getGlobalEvents().on('setRenderMode', this.setRenderMode, this);
        this.getGlobalEvents().on('setSkeletonsVisible', this.setSkeletonsVisible, this);
        this.getGlobalEvents().on('setWireframesVisible', this.setWireframesVisible, this);
    };
    /** @inheritdoc */
    RenderModes.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('shapeTexture') !== -1) {
            this.onShapeTextureChanged();
        }
        if (changes.indexOf('renderMode') !== -1) {
            this.onRenderModeChanged();
        }
        if (changes.indexOf('skeletonsVisible') !== -1) {
            this.resetSkeletons();
        }
        if (changes.indexOf('wireframesVisible') !== -1) {
            this.getEngine().needsRender = true;
        }
    };
    /** @inheritdoc */
    RenderModes.prototype.onShutdown = function () {
        var _this = this;
        globalEvents_1.default.off('resetSkeletons', this.resetSkeletons, this);
        globalEvents_1.default.off('setRenderMode', this.setRenderMode, this);
        globalEvents_1.default.off('setSkeletonsVisible', this.setSkeletonsVisible, this);
        globalEvents_1.default.off('setWireframesVisible', this.setWireframesVisible, this);
        Object.keys(this.renderModes).forEach(function (modeName) {
            var mode = _this.renderModes[modeName];
            if (mode.overrideMaterial) {
                if (mode.overrideMaterial && mode.overrideMaterial.skinned) {
                    mode.overrideMaterial.skinned.dispose();
                }
                if (mode.overrideMaterial && mode.overrideMaterial.static) {
                    mode.overrideMaterial.static.dispose();
                }
            }
        });
        if (this.flatShadedMaterial) {
            this.flatShadedMaterial.destroy();
        }
    };
    /**
     * Called when the render mode changes.
     * @method onRenderModeChanged
     * @private
     * @returns {void}
     */
    RenderModes.prototype.onRenderModeChanged = function () {
        var _this = this;
        if (!this.renderModes[this.renderMode]) {
            this.renderMode = RenderModes.LIT;
        }
        this.applyRenderModeGlobalSettings();
        // For each scene, set the render mode.
        var scenes = this.getEngine().getObjectsByType('scene');
        scenes.forEach(function (scene) {
            if (scene.isDependenciesLoaded()) {
                _this.applyRenderModeToScene(scene);
            }
        });
        this.getEngine().needsRender = true;
    };
    /**
     * Called when the shape texture changes.
     * @method onShapeTextureChanged
     * @private
     * @returns {void}
     */
    RenderModes.prototype.onShapeTextureChanged = function () {
        var _this = this;
        if (!this.shapeTexture) {
            return;
        }
        this.shapeTexture.when('load', function (texture) {
            var material = _this.renderModes[RenderModes.SHAPE].overrideMaterial;
            material.static.uniforms.matCapTexture.value = texture.runtimeData;
            material.skinned.uniforms.matCapTexture.value = texture.runtimeData;
        });
        if (this.shapeTexture.isBaseUnloaded()) {
            this.shapeTexture.load();
        }
    };
    /** @inheritdoc */
    RenderModes.prototype.onPostRenderView = function (scene, camera) {
        if (this.wireframesVisible) {
            this.renderWireframes(scene, camera);
        }
        if (this.skeletonsVisible) {
            this.renderSkeletons(scene, camera);
        }
    };
    /**
     * Render skeletons in the scene.
     * @method renderSkeletons
     * @private
     * @param {THREE.Scene} scene The Three.js scene.
     * @param {THREE.Camera} camera The Three.js camera.
     * @returns {void}
     */
    RenderModes.prototype.renderSkeletons = function (scene, camera) {
        if (!this.skeletonHelpers.hasOwnProperty(scene.uuid)) {
            Logger_1.default.warn('Skeleton cache out of date');
            return;
        }
        var skeletonScene = new THREE.Scene();
        this.skeletonHelpers[scene.uuid].update();
        skeletonScene.add(this.skeletonHelpers[scene.uuid]);
        this.getThreeRenderer().render(skeletonScene, camera);
    };
    /**
     * Render wireframes for meshes in the scene.
     * @method renderWireframes
     * @private
     * @param {THREE.Scene} scene The Three.js scene.
     * @param {THREE.Camera} camera The Three.js camera.
     * @returns {void}
     */
    RenderModes.prototype.renderWireframes = function (scene, camera) {
        // First pass: render wireframes of THREE.Mesh instances.
        var oldVisible = {};
        scene.traverse(function (obj) {
            oldVisible[obj.id] = obj.visible;
            if (obj instanceof THREE.SkinnedMesh ||
                obj instanceof THREE.Line ||
                obj instanceof THREE.Points) {
                obj.visible = false;
            }
        });
        var oldOverrideMaterial = scene.overrideMaterial;
        scene.overrideMaterial = this.wireframeMaterial;
        this.wireframeMaterial.skinning = false;
        this.getThreeRenderer().render(scene, camera);
        // Second pass: render wireframes of THREE.SkinnedMesh instances.
        scene.traverse(function (obj) {
            if (obj instanceof THREE.SkinnedMesh) {
                obj.visible = oldVisible[obj.id];
            }
            else if (obj instanceof THREE.Mesh) {
                obj.visible = false;
            }
        });
        this.wireframeMaterial.skinning = true;
        this.getThreeRenderer().render(scene, camera);
        // Restore the visibility of all objects in the scene.
        scene.traverse(function (obj) {
            obj.visible = oldVisible[obj.id];
        });
        scene.overrideMaterial = oldOverrideMaterial;
    };
    /**
     * Reset the skeleton visualization, for example, if the scene changes.
     * @method resetSkeletons
     * @public
     * @returns {void}
     */
    RenderModes.prototype.resetSkeletons = function () {
        var _this = this;
        // Clear the cache.
        this.skeletonHelpers = {};
        if (this.skeletonsVisible) {
            // Create a THREE.SkeletonHelper for each scene.
            var scenes = this.getEngine().getObjectsByType('scene');
            scenes.forEach(function (scene) {
                var runtimeData = scene.getRuntimeData();
                _this.skeletonHelpers[runtimeData.uuid] = runtimeData ?
                    new THREE.SkeletonHelper(runtimeData) : undefined;
            });
        }
        this.getEngine().needsRender = true;
    };
    /**
     * Set the render mode.
     * @method setRenderMode
     * @public
     * @param {String} renderMode One of RenderModes.LIT, RenderModes.UNLIT, etc.
     * @returns {void}
     */
    RenderModes.prototype.setRenderMode = function (renderMode) {
        this.setAttribute('renderMode', renderMode);
    };
    /**
     * Set the visibility of skeletons.
     * @method setSkeletonsVisible
     * @public
     * @param {Boolean} visible Indicates whether or not skeletons are visible.
     * @returns {void}
     */
    RenderModes.prototype.setSkeletonsVisible = function (visible) {
        this.setAttribute('skeletonsVisible', visible);
    };
    /**
     * Set the visibility of wireframes.
     * @method setWireframesVisible
     * @public
     * @param {Boolean} visible Indicates whether or not wireframes are visible.
     * @returns {void}
     */
    RenderModes.prototype.setWireframesVisible = function (visible) {
        this.setAttribute('wireframesVisible', visible);
    };
    /**
     * Apply global (non-scene specific) settings based on the render mode.
     * @method applyRenderModeGlobalSettings
     * @private
     * @returns {void}
     */
    RenderModes.prototype.applyRenderModeGlobalSettings = function () {
        var renderMode = this.renderModes[this.renderMode];
        // Disable lights if they should be for this render mode.
        if (renderMode.disableLights) {
            this.disableImageBasedLighting();
        }
        else if (this.lightsDisabled) {
            this.enableImageBasedLighting();
        }
    };
    /**
     * Clone the specified Three.js material.
     * @method cloneMaterial
     * @private
     * @param {THREE.Material} material The material to clone.
     * @returns {THREE.Material} The new material.
     */
    RenderModes.prototype.cloneMaterial = function (material) {
        var newMaterial = material.clone();
        // When cloning a material in three.js, it clones the uniforms which clones any uniform values
        // assigned. This includes textures. For some reason, when a texture is cloned, it doesn't get
        // re-uploaded to the GPU and so doesn't work. We should probably look into fixing this in
        // three.js at some point. In this case, we don't want a cloned texture anyway.
        Object.keys(newMaterial.uniforms).forEach(function (name) {
            if (newMaterial.uniforms[name].type === 't') {
                // Re-use the existing texture in the new material.
                newMaterial.uniforms[name].value = material.uniforms[name].value;
            }
        });
        newMaterial.needsUpdate = true;
        return newMaterial;
    };
    /**
     * Apply the specified override material to the mesh, while copying the specified uniforms from
     * the old materials to the override material.
     * @method applyOverrideMaterialToMesh
     * @private
     * @param {MeshObject} mesh The mesh to apply the override material to.
     * @param {Object} overrideMaterials The override materials.
     * @param {THREE.ShaderMaterial} overrideMaterials.skinned The material to use for skinned meshes.
     * @param {THREE.ShaderMaterial} overrideMaterials.static The material to use for static meshes.
     * @param {Array} [copyUniforms] The names of the uniforms to copy from the old materials.
     * @returns {void}
     */
    RenderModes.prototype.applyOverrideMaterialToMesh = function (mesh, overrideMaterials, copyUniforms) {
        var _this = this;
        var matType = mesh.isSkinned() ? 'skinned' : 'static';
        var overrideMaterial = overrideMaterials[matType];
        var materials = mesh.runtimeData.material.materials;
        var newMaterials;
        if (!copyUniforms) {
            newMaterials = materials.map(function () { return overrideMaterial; });
        }
        else {
            newMaterials = materials.map(function () { return _this.cloneMaterial(overrideMaterial); });
            // Copy certain shader uniforms from the old materials to the new materials.
            var materialAssets = mesh.getMaterials();
            materialAssets.forEach(function (materialAsset, idx) {
                var newMaterial = newMaterials[idx];
                materialAsset.when('loadBase', function () {
                    copyUniforms.forEach(function (uniformName) {
                        var material = materialAsset.runtimeData[matType];
                        if (material.uniforms[uniformName] && material.uniforms[uniformName].value) {
                            newMaterial[uniformName] = material.uniforms[uniformName].value;
                            newMaterial.uniforms[uniformName].value = material.uniforms[uniformName].value;
                        }
                    });
                });
                if (materialAsset.isBaseUnloaded()) {
                    materialAsset.load();
                }
            });
        }
        // Update the mesh materials.
        mesh.runtimeData.material.materials = newMaterials;
    };
    /**
     * Remove the material override from the mesh.
     * @method removeMaterialOverrideFromMesh
     * @private
     * @param {MeshObject} mesh The mesh to remove the override from.
     * @returns {void}
     */
    RenderModes.prototype.removeMaterialOverrideFromMesh = function (mesh) {
        if (mesh.runtimeData.material) {
            mesh.runtimeData.material.materials.forEach(function (material) {
                material.dispose();
            });
            mesh.runtimeData.material = null;
        }
        // Force the materials to update.
        var materialIds = mesh.getProperty('materials');
        var newMaterialIds = new Array(materialIds.length);
        mesh.setProperty('materials', newMaterialIds, { silent: true });
        mesh.setProperty('materials', materialIds);
    };
    /**
     * Apply the current render mode to the specified scene.
     * @method applyRenderModeToScene
     * @private
     * @param {SceneObject} scene The scene to apply to render mode to.
     * @returns {void}
     */
    RenderModes.prototype.applyRenderModeToScene = function (scene) {
        var _this = this;
        if (!scene) {
            return;
        }
        // Get the override material.
        var renderMode = this.renderModes[this.renderMode];
        var overrideMaterial;
        if (typeof renderMode.overrideMaterial === 'string') {
            var materialAsset = this.getEngine().getAssetById(renderMode.overrideMaterial);
            // TODO: Are we assuming that the asset will load immediately here?
            materialAsset.load();
            overrideMaterial = materialAsset.runtimeData;
        }
        else {
            overrideMaterial = renderMode.overrideMaterial;
        }
        // Apply override material for this render mode.
        if (overrideMaterial) {
            this.overrideMaterialEnabled = true;
            overrideMaterial.skinned.skinning = true; // TODO: this should be done in onStartup()
            scene.traverse(function (obj) {
                if (obj.type === 'mesh') {
                    _this.applyOverrideMaterialToMesh(obj, overrideMaterial, renderMode.copyUniforms);
                }
            });
        }
        else if (this.overrideMaterialEnabled) {
            // Re-apply materials if they were previously overridden.
            scene.traverse(function (obj) {
                if (obj.type === 'mesh') {
                    _this.removeMaterialOverrideFromMesh(obj);
                }
            });
            this.overrideMaterialEnabled = false;
        }
        // Disable lights if they should be for this render mode.
        if (renderMode.disableLights) {
            this.lightsDisabled = true;
            scene.traverse(function (obj) {
                if (obj.type === 'light') {
                    if (obj.getProperty('lightType') === 'ambient') {
                        obj.runtimeData.color.setRGB(1.0, 1.0, 1.0);
                    }
                    else {
                        obj.runtimeData.intensity = 0;
                    }
                }
            });
        }
        else if (this.lightsDisabled) {
            // Re-enable lights if they were turned off.
            this.lightsDisabled = false;
            scene.traverse(function (obj) {
                if (obj.type === 'light') {
                    if (obj.getProperty('lightType') === 'ambient') {
                        var colour = obj.getProperty('color');
                        obj.setProperty('color', { r: 0, g: 0, b: 0 }, { silent: true });
                        obj.setProperty('color', colour);
                    }
                    else {
                        var intensity = obj.getProperty('intensity');
                        obj.setProperty('intensity', 0, { silent: true });
                        obj.setProperty('intensity', intensity);
                    }
                }
            });
        }
    };
    /**
     * Disable image-based lighting.
     * @method disableImageBasedLighting
     * @private
     * @returns {void}
     */
    RenderModes.prototype.disableImageBasedLighting = function () {
        var _this = this;
        var materials = this.getEngine().getAssetsByType('material');
        materials.forEach(function (material) {
            var matId = material.id;
            if (!_this.prevMaterialProperties[matId]) {
                _this.prevMaterialProperties[matId] = {};
            }
            var useSpecular = material.isFeatureEnabled('specular');
            var irradianceMap = material.getProperty('irradianceMap');
            _this.prevMaterialProperties[matId].useSpecular = useSpecular;
            _this.prevMaterialProperties[matId].irradianceMap = irradianceMap;
            material.setProperty('irradianceMap', null);
            material.enableFeature('specular', false);
        });
    };
    /**
     * Enable image-based lighting.
     * @method enableImageBasedLighting
     * @private
     * @returns {void}
     */
    RenderModes.prototype.enableImageBasedLighting = function () {
        var _this = this;
        var materials = this.getEngine().getAssetsByType('material');
        materials.forEach(function (material) {
            var matId = material.id;
            if (_this.prevMaterialProperties[matId]) {
                var useSpecular = _this.prevMaterialProperties[matId].useSpecular;
                var irradianceMap = _this.prevMaterialProperties[matId].irradianceMap;
                material.enableFeature('specular', useSpecular);
                material.setProperty('irradianceMap', irradianceMap);
                delete _this.prevMaterialProperties[matId];
            }
        });
    };
    return RenderModes;
}(BaseComponent_1.default));
// Render modes:
RenderModes.LIT = 'Lit';
RenderModes.UNLIT = 'Unlit';
RenderModes.SHAPE = 'Shape';
RenderModes.NORMALS = 'Normals';
RenderModes.UNTEXTURED = 'Untextured';
RenderModes.UV_OVERLAY = 'UV Overlay';
RenderModes.SKIN_WEIGHTS = 'Skin Weights';
RenderModes.SKIN_INDICES = 'Skin Indices';
// Materials:
RenderModes.NORMALS_MATERIAL = {
    side: THREE.DoubleSide,
    uniforms: THREE.UniformsUtils.merge([
        THREE.UniformsLib.common,
        THREE.UniformsLib.bumpmap,
        THREE.UniformsLib.normalmap
    ]),
    vertexShader: [
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.uv_pars_vertex,
        THREE.ShaderChunk.bsdfs,
        THREE.ShaderChunk.skinning_pars_vertex,
        THREE.ShaderChunk['lights_phong_pars_vertex'],
        '#ifndef FLAT_SHADED',
        'varying vec3 vNormal;',
        '#endif',
        'varying vec3 vViewPosition;',
        'void main() {',
        THREE.ShaderChunk.uv_vertex,
        '#if defined(USE_NORMALMAP) || defined(USE_BUMPMAP)',
        'vUv.y = 1.0 - vUv.y;',
        '#endif',
        THREE.ShaderChunk.beginnormal_vertex,
        THREE.ShaderChunk.morphnormal_vertex,
        THREE.ShaderChunk.skinbase_vertex,
        THREE.ShaderChunk.skinnormal_vertex,
        THREE.ShaderChunk.defaultnormal_vertex,
        '#ifndef FLAT_SHADED',
        'vNormal = normalize( transformedNormal );',
        '#endif',
        THREE.ShaderChunk.begin_vertex,
        THREE.ShaderChunk.displacementmap_vertex,
        THREE.ShaderChunk.morphtarget_vertex,
        THREE.ShaderChunk.skinning_vertex,
        THREE.ShaderChunk.project_vertex,
        THREE.ShaderChunk.logdepthbuf_vertex,
        THREE.ShaderChunk.clipping_planes_vertex,
        'vViewPosition = - mvPosition.xyz;',
        THREE.ShaderChunk.worldpos_vertex,
        '}'
    ].join('\n'),
    fragmentShader: [
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.uv_pars_fragment,
        THREE.ShaderChunk.bsdfs,
        THREE.ShaderChunk.lights_phong_pars_fragment,
        THREE.ShaderChunk.normalmap_pars_fragment,
        THREE.ShaderChunk.bumpmap_pars_fragment,
        'void main() {',
        THREE.ShaderChunk.normal_flip,
        THREE.ShaderChunk.normal_fragment,
        'normal = 0.5 * normal + 0.5;',
        'gl_FragColor = vec4(normal, 1.0);',
        '}'
    ].join('\n')
};
RenderModes.SHAPE_MATERIAL = {
    side: THREE.DoubleSide,
    uniforms: THREE.UniformsUtils.merge([
        THREE.UniformsLib.common,
        THREE.UniformsLib.bumpmap,
        THREE.UniformsLib.normalmap,
        { matCapTexture: { type: 't', value: null } }
    ]),
    vertexShader: [
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.uv_pars_vertex,
        THREE.ShaderChunk.bsdfs,
        THREE.ShaderChunk.skinning_pars_vertex,
        THREE.ShaderChunk['lights_phong_pars_vertex'],
        '#ifndef FLAT_SHADED',
        'varying vec3 vNormal;',
        '#endif',
        'varying vec3 vViewPosition;',
        'void main() {',
        THREE.ShaderChunk.uv_vertex,
        '#if defined(USE_NORMALMAP) || defined(USE_BUMPMAP)',
        'vUv.y = 1.0 - vUv.y;',
        '#endif',
        THREE.ShaderChunk.beginnormal_vertex,
        THREE.ShaderChunk.morphnormal_vertex,
        THREE.ShaderChunk.skinbase_vertex,
        THREE.ShaderChunk.skinnormal_vertex,
        THREE.ShaderChunk.defaultnormal_vertex,
        '#ifndef FLAT_SHADED',
        'vNormal = normalize( transformedNormal );',
        '#endif',
        THREE.ShaderChunk.begin_vertex,
        THREE.ShaderChunk.displacementmap_vertex,
        THREE.ShaderChunk.morphtarget_vertex,
        THREE.ShaderChunk.skinning_vertex,
        THREE.ShaderChunk.project_vertex,
        THREE.ShaderChunk.logdepthbuf_vertex,
        THREE.ShaderChunk.clipping_planes_vertex,
        'vViewPosition = - mvPosition.xyz;',
        THREE.ShaderChunk.worldpos_vertex,
        '}'
    ].join('\n'),
    fragmentShader: [
        THREE.ShaderChunk.common,
        THREE.ShaderChunk.uv_pars_fragment,
        THREE.ShaderChunk.bsdfs,
        THREE.ShaderChunk.lights_phong_pars_fragment,
        THREE.ShaderChunk.normalmap_pars_fragment,
        THREE.ShaderChunk.bumpmap_pars_fragment,
        'uniform sampler2D matCapTexture;',
        'void main() {',
        'vec3 eyeVector_VS = normalize(vViewPosition);',
        THREE.ShaderChunk.normal_flip,
        THREE.ShaderChunk.normal_fragment,
        'vec3 reflect_SS = reflect(-eyeVector_VS, normal);',
        'reflect_SS.z += 1.0;',
        'float temp = 2.0 * sqrt(dot(reflect_SS, reflect_SS));',
        'reflect_SS.xy = reflect_SS.xy / vec2(temp) + vec2(0.5);',
        'reflect_SS.y = 1.0 - reflect_SS.y;',
        // Sample matCap
        'vec3 colour = texture2D(matCapTexture, reflect_SS.xy).rgb;',
        'gl_FragColor = vec4(colour, 1.0);',
        '}'
    ].join('\n')
};
RenderModes.SKIN_WEIGHTS_MATERIAL = {
    side: THREE.DoubleSide,
    vertexShader: [
        THREE.ShaderChunk.skinning_pars_vertex,
        'varying vec3 vColor;',
        'void main() {',
        THREE.ShaderChunk.skinbase_vertex,
        THREE.ShaderChunk.skinning_vertex,
        THREE.ShaderChunk.project_vertex,
        '#ifdef USE_SKINNING',
        'vColor = vec3(skinWeight.x, skinWeight.y, skinWeight.z);',
        '#else',
        'vColor = vec3(0.0, 0.0, 0);',
        '#endif',
        '}'
    ].join('\n'),
    fragmentShader: [
        'varying vec3 vColor;',
        'void main() {',
        'gl_FragColor = vec4(vColor, 1.0);',
        '}'
    ].join('\n')
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = RenderModes;


/***/ },
/* 96 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-line-length */
var THREE = __webpack_require__(1);
var Logger_1 = __webpack_require__(3);
var BaseComponent_1 = __webpack_require__(2);
var UserAgent_1 = __webpack_require__(13);
var functions_1 = __webpack_require__(6);
var browserCaps_1 = __webpack_require__(171);
var MaterialAsset_1 = __webpack_require__(14);
/**
 * @class DefaultRenderer
 * @vid box3d_renderer
 * @vreserved
 * @vname Renderer
 * @vfilter application
 * @vcategory Rendering
 */
var DefaultRenderer = (function (_super) {
    tslib_1.__extends(DefaultRenderer, _super);
    function DefaultRenderer() {
        var _this = _super.apply(this, arguments) || this;
        /** The THREE.js WebGL renderer instance. */
        _this.threeRenderer = null;
        /** The supported capabilities. */
        _this.caps = {};
        /**
         * Enable or disable anti aliasing of the rendered scene..
         * @vattr Boolean antialias {
         *   description: 'Enable or disable anti aliasing of the rendered scene.',
         *   default: true
         * }
         */
        _this.antialias = false;
        /**
         * Tells the browser to preserve drawing buffers between frames so that they are available to be read by the application.
         * @vattr Boolean preserveDrawingBuffer {
         *   description: 'Tells the browser to preserve drawing buffers between frames so that they are available to be read by the application.',
         *   default: true
         * }
         */
        _this.preserveDrawingBuffer = true;
        /**
         * The default floating point and integer precision to be used by the GPU.
         * @vattr Dropdown precision {
         *   description: 'The default floating point and integer precision to be used by the GPU.',
         *   default: 'mediump',
         *   options: {
         *     'Low': 'lowp',
         *     'Medium': 'mediump',
         *     'High':  'highp'
         *   }
         * }
         */
        _this.precision = 'highp';
        /**
         * Automatically clear the render target before each render.
         * @vattr Boolean autoClear {
         *   description: 'Automatically clear the render target before each render.',
         *   default: false
         * }
         */
        _this.autoClear = false;
        /**
         * Override the default pixel ratio of the system. Higher values will cause rendering at higher resolution while lower
         * values will force rendering at lower resolutions. You can also set this to use the device default (mobile devices
         * usually have values greater than 1).
         * @vattr Dropdown devicePixelRatio {
         *   default: 0.0,
         *   options: { 'Device Default': 0.0, 'One': 1.0, 'Two': 2.0 },
         *   description: 'Override the default pixel ratio of the system. Higher values will cause rendering at higher resolution while lower values will force rendering at lower resolutions. You can also set this to use the device default (mobile devices usually have values greater than 1).',
         * }
         */
        _this.devicePixelRatio = 1.0;
        /**
         * Enable or disable rendering of shadows.
         * @vattr Boolean shadowsEnabled {
         *   description: 'Enable or disable rendering of shadows.',
         *   default: true
         * }
         */
        _this.shadowsEnabled = true;
        /**
         * Enable or disable rendering of shadows on mobile devices.
         * @vattr Boolean shadowsEnabledMobile {
         *   description: 'Enable or disable rendering of shadows on mobile devices.',
         *   default: false
         * }
         */
        _this.shadowsEnabledMobile = false;
        /**
         * The type of shadow map to use. (PCF, Soft PCF or No Filtering)
         * @vattr Dropdown shadowType {
         *   options: {
         *     'Soft PCF': 2,
         *     'PCF': 1,
         *     'No Filtering': 0
         *   },
         *   default: 2
         * }
         */
        _this.shadowType = THREE.PCFSoftShadowMap;
        /**
         * Render shadows with reverse side of mesh.
         * @vattr Boolean shadowReverseSided {
         *   description: 'Render shadows with reverse side of mesh.',
         *   default: false
         * }
         */
        _this.shadowReverseSided = false;
        /**
         * Clamp the maximum allowed dimension of a 2d texture.
         * @vattr Integer maxTextureSize2d {
         *   description: 'Clamp the maximum allowed dimension of a 2d texture.',
         *   default: 32768,
         *   min: 1024,
         *   max: 32768
         * }
         */
        _this.maxTextureSize2d = Number.MAX_SAFE_INTEGER;
        /**
         * Clamp the maximum allowed dimension of a cube texture.
         * @vattr Integer maxTextureSizeCube {
         *   description: 'Clamp the maximum allowed dimension of a cube texture.',
         *   default: 32768,
         *   min: 512,
         *   max: 32768
         * }
         */
        _this.maxTextureSizeCube = Number.MAX_SAFE_INTEGER;
        /**
         * When the render target is cleared, this colour will be used.
         * @vattr Color clearColor {
         *   description: 'When the render target is cleared, this colour will be used',
         *   default: {r: 0, g: 0, b:0}
         * }
         */
        _this.clearColor = new THREE.Color();
        /**
         * When the render target is cleared, this value will be used to clear the transparency.
         * @vattr Float clearAlpha {
         *   description: 'When the render target is cleared, this value will be used to clear the transparency',
         *   default: 0,
         *   min: 0.0,
         *   max: 1.0,
         *   step: 0.001
         * }
         */
        _this.clearAlpha = 0.0;
        /**
         * When this is enabled, rendering will only happen when requested instead of every frame.
         * @vattr Boolean renderOnDemand {
         *   description: 'When this is enabled, rendering will only happen when requested instead of every frame.',
         *   default: true
         * }
         */
        _this.renderOnDemand = true;
        return _this;
    }
    /** @inheritdoc */
    DefaultRenderer.prototype.onAwake = function () {
        this.canvas = this.getEngine().canvas;
        this.initDefaultRenderer();
        this.getEngine().setRenderer(this);
        // Init scene sceneComposer
        var renderer = this.getThreeRenderer();
        renderer.gammaInput = false;
        renderer.gammaOutput = true;
    };
    /** @inheritdoc */
    DefaultRenderer.prototype.onStartup = function () {
        this.getEngine().on('resize', this.resize, this);
        this.getEngine().renderOnDemand = this.renderOnDemand;
        if (!this.shadowsEnabledMobile) {
            this.shadowsEnabled = UserAgent_1.isMobile() ? this.shadowsEnabledMobile &&
                this.shadowsEnabled : this.shadowsEnabled;
        }
        this.applyRenderSettings();
    };
    /** @inheritdoc */
    DefaultRenderer.prototype.onShutdown = function () {
        this.getEngine().off('resize', this.resize, this);
        if (this.threeRenderer) {
            this.threeRenderer.context = null;
        }
        this.threeRenderer = null;
        this.canvas = undefined;
    };
    /** @inheritdoc */
    DefaultRenderer.prototype.onEntityReady = function () {
        this.getEngine().trigger('resize');
    };
    /** @inheritdoc */
    DefaultRenderer.prototype.onAttributesChanged = function (changes) {
        var rebuildMaterials = false;
        if (changes.indexOf('shadowsEnabledMobile') !== -1) {
            rebuildMaterials = true;
        }
        this.shadowsEnabled = UserAgent_1.isMobile() ? this.shadowsEnabledMobile &&
            this.shadowsEnabled : this.shadowsEnabled;
        this.applyRenderSettings();
        this.getEngine().renderOnDemand = this.renderOnDemand;
        if (changes.indexOf('clearAlpha') !== -1) {
            this.threeRenderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        if (changes.indexOf('clearColor') !== -1) {
            this.threeRenderer.setClearColor(this.clearColor, this.clearAlpha);
        }
        if (changes.indexOf('gammaOutput') !== -1) {
            rebuildMaterials = true;
        }
        if (changes.indexOf('gammaInput') !== -1) {
            rebuildMaterials = true;
        }
        if (changes.indexOf('shadowsEnabled') !== -1) {
            rebuildMaterials = true;
        }
        if (changes.indexOf('shadowType') !== -1) {
            this.shadowType = parseInt(String(this.shadowType), 10);
            // TODO - need to recreate the shadow maps if the shadow
            // filtering has changed because PCFSoftShadowMap requires the shadow map
            // to be rendered with no filtering.
            rebuildMaterials = true;
        }
        if (changes.indexOf('devicePixelRatio') !== -1) {
            this.getEngine().trigger('resize');
        }
        if (rebuildMaterials) {
            Logger_1.default.info('Rebuilding materials!!!');
            this.getEngine().trigger('rebuildMaterials');
        }
    };
    /**
     * Given the name of a GPU device capability (e.g. MAX_VERTEX_TEXTURE_IMAGE_UNITS ),
     * return the current system's value for this capability.
     * @param  {String} cap The capability name
     * @returns {number}     The value of the capability
     */
    DefaultRenderer.prototype.getGPUCapability = function (cap) {
        return this.caps[cap];
    };
    /**
     * Returns the maximum texture size supported by the device.
     * @method  getMaxTextureSize2d
     * @public
     * @returns {number} The maximum texture size.
     */
    DefaultRenderer.prototype.getMaxTextureSize2d = function () {
        if (!this.maxTextureSize2d) {
            return this.getGPUCapability('MAX_TEXTURE_SIZE');
        }
        return Math.min(this.maxTextureSize2d, this.getGPUCapability('MAX_TEXTURE_SIZE'));
    };
    /**
     * Returns the maximum cube texture size supported by the device.
     * @returns The cube map maximum texture size.
     */
    DefaultRenderer.prototype.getMaxTextureSizeCube = function () {
        if (!this.maxTextureSizeCube) {
            return this.getGPUCapability('MAX_CUBE_MAP_TEXTURE_SIZE');
        }
        return Math.min(this.maxTextureSizeCube, this.getGPUCapability('MAX_CUBE_MAP_TEXTURE_SIZE'));
    };
    /** @inheritdoc */
    DefaultRenderer.prototype.onPreRender = function () {
        // this.newRenderStarted = true;
        this.threeRenderer.setRenderTarget(null);
        this.threeRenderer.clear(true, true, true);
        this.threeRenderer.setViewport(0, 0, this.getWidth(), this.getHeight());
    };
    /**
     * Renders a given scene from the perspective of a given camera with the specified options.
     * @param {THREE.Scene} scene
     * @param {THREE.Camera} camera
     * @param {RenderViewOptions} [options={}]
     * @returns {void}
     */
    DefaultRenderer.prototype.renderView = function (scene, camera, options) {
        if (options === void 0) { options = {}; }
        var screenDimensions;
        if (camera) {
            if (options.enablePreRenderFunctions) {
                this.getEngine().trigger('preRenderView', scene, camera, options);
            }
            var canvasStyle = this.getCanvas().style;
            if (options.opacity !== undefined && (!options.viewPort ||
                options.viewPort.width === this.getWidth() &&
                    options.viewPort.height === this.getHeight())) {
                if (parseFloat(canvasStyle.opacity) !== options.opacity) {
                    canvasStyle.opacity = '' + options.opacity;
                }
            }
            else if (parseFloat(canvasStyle.opacity) !== 1) {
                canvasStyle.opacity = '1.0';
            }
            if (!options.renderTarget) {
                this.threeRenderer.setRenderTarget(null);
            }
            else {
                this.threeRenderer.setRenderTarget(options.renderTarget);
            }
            this.threeRenderer.clear(options.clearColor, options.clearDepth, options.clearStencil);
            if (options.viewPort) {
                /* tslint:disable no-string-literal */
                screenDimensions = MaterialAsset_1.default.sharedUniforms['screenDimensions'];
                /* tslint:enable no-string-literal */
                screenDimensions.value.x = options.viewPort.x;
                screenDimensions.value.y = options.viewPort.y;
                screenDimensions.value.z = options.viewPort.width * this.devicePixelRatio;
                screenDimensions.value.w = options.viewPort.height * this.devicePixelRatio;
                this.threeRenderer.setViewport(options.viewPort.x, options.viewPort.y, options.viewPort.width, options.viewPort.height);
            }
            var renderer = options.effect ? options.effect : this.threeRenderer;
            if (options.renderTarget) {
                renderer.render(scene, camera, options.renderTarget, false);
            }
            else {
                renderer.render(scene, camera);
            }
            this.getEngine().trigger('postRenderView', scene, camera, options);
        }
    };
    /**
     * Returns the size of the render target in device-independent pixels (dips)
     * @returns The width of the render target.
     */
    DefaultRenderer.prototype.getWidth = function () {
        return this.canvas.clientWidth;
    };
    /**
     * Returns the size of the render target in device-independent pixels (dips)
     * @returns The height of the render target.
     */
    DefaultRenderer.prototype.getHeight = function () {
        return this.canvas.clientHeight;
    };
    /**
     * Returns the width of the canvas element.
     * @returns The width of the canvas element.
     */
    DefaultRenderer.prototype.getCanvasWidth = function () {
        return this.canvas.width;
    };
    /**
     * Returns the height of the canvas element.
     * @returns The height of the canvas element.
     */
    DefaultRenderer.prototype.getCanvasHeight = function () {
        return this.canvas.height;
    };
    /**
     * Returns the canvas element.
     * @returns The canvas element.
     */
    DefaultRenderer.prototype.getCanvas = function () {
        return this.threeRenderer.domElement;
    };
    /** Handles the resize event. */
    DefaultRenderer.prototype.resize = function () {
        if (this.canvas.parentElement) {
            var w_1 = this.canvas.parentElement.clientWidth;
            var h_1 = this.canvas.parentElement.clientHeight;
            this.threeRenderer.setPixelRatio(this.devicePixelRatio);
            if (UserAgent_1.isIOS()) {
                // This hack works around a canvas resize related bug in iOS
                var canvas_1 = this.canvas;
                this.threeRenderer.setSize(w_1, h_1, false);
                canvas_1.style.width = (w_1 + 1) + 'px';
                canvas_1.style.height = (h_1 + 1) + 'px';
                setTimeout(function () {
                    canvas_1.style.width = w_1 + 'px';
                    canvas_1.style.height = h_1 + 'px';
                }, 100);
            }
            else {
                this.threeRenderer.setSize(w_1, h_1, true);
            }
        }
    };
    /** Stores the capabilities in the caps member variable. */
    DefaultRenderer.prototype.storeGpuCaps = function () {
        var context = this.threeRenderer.getContext();
        Logger_1.default.info('WebGL VENDOR is ' + context.getParameter(context.VENDOR));
        Logger_1.default.info('WebGL SHADING_LANGUAGE_VERSION is ' +
            context.getParameter(context.SHADING_LANGUAGE_VERSION));
        Logger_1.default.info('WebGL RENDERER is ' + context.getParameter(context.RENDERER));
        var fShaderConst = context.FRAGMENT_SHADER;
        var lFloatConst = context.LOW_FLOAT;
        var mFloatConst = context.MEDIUM_FLOAT;
        var hFloatConst = context.HIGH_FLOAT;
        var shaderPrecFormat = context.getShaderPrecisionFormat(fShaderConst, lFloatConst);
        Logger_1.default.info('Fragment Shader lowp is ' + shaderPrecFormat.precision);
        shaderPrecFormat = context.getShaderPrecisionFormat(fShaderConst, mFloatConst);
        Logger_1.default.info('Fragment Shader mediump is ' + shaderPrecFormat.precision);
        shaderPrecFormat = context.getShaderPrecisionFormat(fShaderConst, hFloatConst);
        Logger_1.default.info('Fragment Shader highp is ' + shaderPrecFormat.precision);
        if (!navigator.isCocoonJS) {
            this.caps.MAX_COMBINED_TEXTURE_IMAGE_UNITS = 0;
            this.caps.MAX_CUBE_MAP_TEXTURE_SIZE = 0;
            this.caps.MAX_FRAGMENT_UNIFORM_VECTORS = 0;
            this.caps.MAX_RENDERBUFFER_SIZE = 0;
            this.caps.MAX_TEXTURE_IMAGE_UNITS = 0;
            this.caps.MAX_TEXTURE_SIZE = 0;
            this.caps.MAX_VARYING_VECTORS = 0;
            this.caps.MAX_VERTEX_ATTRIBS = 0;
            this.caps.MAX_VERTEX_TEXTURE_IMAGE_UNITS = 0;
            this.caps.MAX_VERTEX_UNIFORM_VECTORS = 0;
            this.caps.MAX_VIEWPORT_DIMS = 0;
            this.caps.ALIASED_POINT_SIZE_RANGE = 0;
            this.caps.ALIASED_LINE_WIDTH_RANGE = 0;
            this.caps.SAMPLES = 0;
            this.caps.SAMPLE_BUFFERS = 0;
            this.caps.RED_BITS = 0;
            this.caps.GREEN_BITS = 0;
            this.caps.BLUE_BITS = 0;
            this.caps.ALPHA_BITS = 0;
            this.caps.DEPTH_BITS = 0;
            this.caps.STENCIL_BITS = 0;
            this.caps.SUBPIXEL_BITS = 0;
            this.caps.COMPRESSED_TEXTURE_FORMATS = 0;
            this.caps = functions_1.map(this.caps, function (_value, key) {
                return context.getParameter(context[key]);
            });
            this.caps.EXTENSIONS = context.getSupportedExtensions();
            var glExtTexAniso = context.getExtension('EXT_texture_filter_anisotropic') ||
                context.getExtension('MOZ_EXT_texture_filter_anisotropic') ||
                context.getExtension('WEBKIT_EXT_texture_filter_anisotropic');
            this.caps.maxAnisotropy = glExtTexAniso ?
                context.getParameter(glExtTexAniso.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
            Logger_1.default.info('GPU Capabilities:', this.caps);
        }
    };
    /** Initializes the default renderer. */
    DefaultRenderer.prototype.initDefaultRenderer = function () {
        if (browserCaps_1.default.isWebGLEnabled()) {
            this.threeRenderer = new THREE.WebGLRenderer({
                canvas: this.canvas,
                antialias: this.antialias,
                preserveDrawingBuffer: this.preserveDrawingBuffer,
                alpha: true,
                precision: this.precision,
                logarithmicDepthBuffer: this.logarithmicDepthBuffer
            });
            this.threeRenderer.physicallyCorrectLights = true;
            this.threeRenderer.setPixelRatio(this.devicePixelRatio > 0 ?
                this.devicePixelRatio : window.devicePixelRatio);
            this.storeGpuCaps();
        }
        else {
            // TODO: Is there something better we can do in the case that WebGL is not supported?
            throw new Error('WebGL is not supported, no fallbacks available.');
        }
    };
    /** Apply changed render settings. */
    DefaultRenderer.prototype.applyRenderSettings = function () {
        var _this = this;
        if (this.threeRenderer) {
            // TODO: Maybe we shouldn't iterate this object in this way?
            functions_1.forEach(this, function (value, key) {
                if (_this.threeRenderer[key] !== undefined) {
                    _this.threeRenderer[key] = value;
                }
            });
            if (!(this.devicePixelRatio > 0.0)) {
                this.devicePixelRatio = window.devicePixelRatio;
            }
            this.threeRenderer.setClearColor(this.clearColor, this.clearAlpha);
            if (this.shadowsEnabled) {
                this.threeRenderer.shadowMap.enabled = true;
                this.threeRenderer.shadowMap.type = this.shadowType;
                this.threeRenderer.shadowMap.renderReverseSided = this.shadowReverseSided;
            }
        }
    };
    return DefaultRenderer;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DefaultRenderer;


/***/ },
/* 97 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/**
 * @vid rotate_component
 *
 * @vname Rotate
 *
 * @vdescription
 * A simple component to rotate an object.
 *
 * @vcategory Animation
 *
 * @vfilter object
 */
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vattr Boolean autoRotate  {
 *   description: 'Automatically start the rotation upon load.',
 *   default: true,
 * }
 *
 * @vattr Boolean previewRotation {
 *   description: 'Show the rotation in the editor.',
 *   default: true
 * }
 *
 * @vattr Vector3 rotation {
 *   description: 'Amount of rotation per second about the x, y and z axes.',
 *   default: { x: 0, y: 0.5, z: 0 }
 * }
 *
 * @vattr Boolean local {
 *   description: 'Rotate relative to the local quaternion of the object. If false, the rotation will be relative to the world.',
 *   default: false
 * }
 */
/**
 * @vevent local startRotate {
 *   action: true,
 *   category: 'Rotate',
 *   parameters: []
 * }
 *
 * @vevent local stopRotate {
 *   action: true,
 *   category: 'Rotate',
 *   parameters: []
 * }
 *
 * @vevent local toggleRotate {
 *   action: true,
 *   category: 'Rotate',
 *   parameters: []
 * }
 */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var NodeObject_1 = __webpack_require__(9);
var tmpVec = new THREE.Vector3();
var tmpEuler = new THREE.Euler();
var Rotate = (function (_super) {
    tslib_1.__extends(Rotate, _super);
    function Rotate() {
        var _this = _super.apply(this, arguments) || this;
        _this.quaternion = new THREE.Quaternion();
        _this.currentGlobalQuaternion = new THREE.Quaternion();
        return _this;
    }
    /** @inheritdoc */
    Rotate.prototype.onStartup = function () {
        this.rotate = this.autoRotate;
        this.getEntity().on('startRotate', this.onStartRotate, this);
        this.getEntity().on('stopRotate', this.onStopRotate, this);
        this.getEntity().on('toggleRotate', this.onToggleRotate, this);
    };
    /** @inheritdoc */
    Rotate.prototype.onShutdown = function () {
        this.getEntity().off('startRotate', this.onStartRotate, this);
        this.getEntity().off('stopRotate', this.onStopRotate, this);
        this.getEntity().off('toggleRotate', this.onToggleRotate, this);
    };
    /** @inheritdoc */
    Rotate.prototype.onEnable = function () {
        this.rotate = this.autoRotate;
        this.initRotation();
    };
    /** @inheritdoc */
    Rotate.prototype.onDisable = function () {
        var entity = this.getEntity();
        if (entity instanceof NodeObject_1.default) {
            this.getRuntimeData().position.copy(entity.getPosition());
            this.getRuntimeData().quaternion.copy(entity.getQuaternion());
            this.rotate = false;
        }
    };
    /** @inheritdoc */
    Rotate.prototype.onAttributesChanged = function (changes) {
        if (changes.indexOf('rotation') && this.rotation) {
            this.initRotation();
        }
        if (changes.indexOf('previewRotation') !== -1) {
            this.rotate = this.previewRotation;
            this.initRotation();
        }
    };
    /** @inheritdoc */
    Rotate.prototype.onEntityReady = function () {
        this.initialQuaternion = new THREE.Quaternion();
        this.initialQuaternion.copy(this.getRuntimeData().quaternion);
        this.initRotation();
    };
    /** @inheritdoc */
    Rotate.prototype.onUpdate = function (delta) {
        if (this.rotate && this.isEnabled()) {
            this.getEngine().needsRender = true;
            if (this.getRuntimeData() && this.rotation) {
                tmpVec.copy(this.rotation).multiplyScalar(delta);
                tmpEuler.set(tmpVec.x, tmpVec.y, tmpVec.z);
                this.quaternion.setFromEuler(tmpEuler);
                if (this.local) {
                    this.getRuntimeData().quaternion.multiply(this.quaternion);
                }
                else {
                    this.currentGlobalQuaternion.multiply(this.quaternion);
                    this.getRuntimeData().quaternion.multiplyQuaternions(this.currentGlobalQuaternion, this.initialQuaternion);
                }
            }
        }
    };
    Rotate.prototype.initRotation = function () {
        tmpEuler.set(this.rotation.x, this.rotation.y, this.rotation.z);
        if (this.local) {
            this.getRuntimeData().quaternion.copy(this.initialQuaternion);
        }
        else {
            this.currentGlobalQuaternion.set(0, 0, 0, 1);
        }
    };
    Rotate.prototype.onStartRotate = function () {
        this.rotate = true;
    };
    Rotate.prototype.onStopRotate = function () {
        this.rotate = false;
    };
    Rotate.prototype.onToggleRotate = function () {
        this.rotate = !this.rotate;
    };
    return Rotate;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Rotate;


/***/ },
/* 98 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/**
 * @vid simplex_noise_component
 * @vname Simplex Noise Generator
 * @vcategory Rendering
 * @vfilter renderTexture2D
 * @vattr Vector4 layerAmplitude { default: { x: 0.5, y: 0.4, z: 0.3, w: 0.125 } }
 * @vattr Vector4 layerScale { default: { x: 0.5, y: 2.0, z: 3.0, w: 4.0 } }
 * @vattr Vector2 scale { default: { x: 1.0, y: 1.0 } }
 * @vattr Vector2 offset { default: { x: 0.0, y: 0.0 } }
 * @vattr Boolean autoLoad { default: true }
 * @vevent local renderNoise { action: true, category: 'Rendering', parameters: []}
 * @vevent local changeNoiseValues {
 *   action: true,
 *   category: 'Rendering',
 *   parameters: [
 *     {'name': 'layerAmplitude', 'type': 'v4', 'description': '', default: { x: 0.5, y: 0.4, z: 0.3, w: 0.125 }},
 *     {'name': 'layerScale', 'type': 'v4', 'description': '', default: { x: 0.5, y: 2.0, z: 3.0, w: 4.0 }},
 *     {'name': 'scale', 'type': 'v2', 'description': '', default: { x: 1.0, y: 1.0 }},
 *     {'name': 'offset', 'type': 'v2', 'description': '', default: { x: 0.0, y: 0.0 }}
 *   ]
 * }
 */
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var VertexShader = [
    'varying vec2 vUv;',
    'uniform vec2 scale;',
    'uniform vec2 offset;',
    'void main() {',
    'vUv = uv * scale + offset;',
    'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
    '}'
].join('\n');
var FragmentShader = [
    //
    // Description : Array and textureless GLSL 3D simplex noise function.
    //      Author : Ian McEwan, Ashima Arts.
    //  Maintainer : ijm
    //     Lastmod : 20110409 (stegu)
    //     License : Copyright (C) 2011 Ashima Arts. All rights reserved.
    //               Distributed under the MIT License. See LICENSE file.
    //
    //'precision lowp float;',
    'uniform float time;',
    'uniform vec4 layerAmplitude;',
    'uniform vec4 layerScale;',
    'varying vec2 vUv;',
    'precision highp float;',
    'vec4 permute( vec4 x ) {',
    'return mod( ( ( x * 34.0 ) + 1.0 ) * x, 289.0 );',
    '}',
    'vec4 taylorInvSqrt( vec4 r ) {',
    'return 1.79284291400159 - 0.85373472095314 * r;',
    '}',
    'float snoise( vec3 v ) {',
    'vec2 C = vec2( 1.0 / 6.0, 1.0 / 3.0 );',
    'const vec4 D = vec4( 0.0, 0.5, 1.0, 2.0 );',
    // First corner
    'vec3 i  = floor( v + dot( v, C.yyy ) );',
    'vec3 x0 = v - i + dot( i, C.xxx );',
    // Other corners
    'vec3 g = step( x0.yzx, x0.xyz );',
    'vec3 l = 1.0 - g;',
    'vec3 i1 = min( g.xyz, l.zxy );',
    'vec3 i2 = max( g.xyz, l.zxy );',
    'vec3 x1 = x0 - i1 + 1.0 * C.xxx;',
    'vec3 x2 = x0 - i2 + 2.0 * C.xxx;',
    'vec3 x3 = x0 - 1. + 3.0 * C.xxx;',
    // Permutations
    'i = mod( i, 289.0 );',
    'vec4 p = permute( permute( permute(',
    'i.z + vec4( 0.0, i1.z, i2.z, 1.0 ) )',
    '+ i.y + vec4( 0.0, i1.y, i2.y, 1.0 ) )',
    '+ i.x + vec4( 0.0, i1.x, i2.x, 1.0 ) );',
    // Gradients
    // ( N*N points uniformly over a square, mapped onto an octahedron.)
    'float n_ = 1.0 / 7.0; // N=7',
    'vec3 ns = n_ * D.wyz - D.xzx;',
    'vec4 j = p - 49.0 * floor( p * ns.z *ns.z );  //  mod(p,N*N)',
    'vec4 x_ = floor( j * ns.z );',
    'vec4 y_ = floor( j - 7.0 * x_ );    // mod(j,N)',
    'vec4 x = x_ *ns.x + ns.yyyy;',
    'vec4 y = y_ *ns.x + ns.yyyy;',
    'vec4 h = 1.0 - abs( x ) - abs( y );',
    'vec4 b0 = vec4( x.xy, y.xy );',
    'vec4 b1 = vec4( x.zw, y.zw );',
    'vec4 s0 = floor( b0 ) * 2.0 + 1.0;',
    'vec4 s1 = floor( b1 ) * 2.0 + 1.0;',
    'vec4 sh = -step( h, vec4( 0.0 ) );',
    'vec4 a0 = b0.xzyw + s0.xzyw * sh.xxyy;',
    'vec4 a1 = b1.xzyw + s1.xzyw * sh.zzww;',
    'vec3 p0 = vec3( a0.xy, h.x );',
    'vec3 p1 = vec3( a0.zw, h.y );',
    'vec3 p2 = vec3( a1.xy, h.z );',
    'vec3 p3 = vec3( a1.zw, h.w );',
    // Normalise gradients
    'vec4 norm = taylorInvSqrt( vec4( dot( p0, p0 ), dot( p1, p1 ), ',
    '    dot( p2, p2 ), dot( p3, p3 ) ) );',
    'p0 *= norm.x;',
    'p1 *= norm.y;',
    'p2 *= norm.z;',
    'p3 *= norm.w;',
    // Mix final noise value
    'vec4 m = max( 0.6 - vec4( dot( x0, x0 ), dot( x1, x1 ), ',
    '    dot( x2, x2 ), dot( x3, x3 ) ), 0.0 );',
    'm = m * m;',
    'return 42.0 * dot( m*m, vec4( dot( p0, x0 ), dot( p1, x1 ),',
    'dot( p2, x2 ), dot( p3, x3 ) ) );',
    '}',
    'float surface3( vec3 coord ) {',
    'float n = 0.0;',
    'n += layerAmplitude.x * abs( snoise( coord * layerScale.x ) );',
    'n += layerAmplitude.y * abs( snoise( coord * layerScale.y ) );',
    'n += layerAmplitude.z * abs( snoise( coord * layerScale.z ) );',
    'n += layerAmplitude.w * abs( snoise( coord * layerScale.w ) );',
    'return n;',
    '}',
    'void main( void ) {',
    'vec3 coord = vec3( vUv, -time );',
    'float n = surface3( coord );',
    'gl_FragColor = vec4( vec3( n, n, n ), 1.0 );',
    '}'
].join('\n');
var SimplexNoiseRenderer = (function (_super) {
    tslib_1.__extends(SimplexNoiseRenderer, _super);
    function SimplexNoiseRenderer() {
        var _this = _super.apply(this, arguments) || this;
        _this.m_Uniforms = null;
        _this.m_NoiseMat = null;
        return _this;
    }
    /** @inheritdoc */
    SimplexNoiseRenderer.prototype.onStartup = function () {
        this.getEntity().on('changeNoiseValues', this.changeNoiseValues, this);
        this.getEntity().on('renderNoise', this.renderNoise, this);
        this.m_Uniforms = {
            time: {
                type: 'f',
                value: 1.0
            },
            scale: {
                type: 'v2',
                value: this.scale
            },
            offset: {
                type: 'v2',
                value: this.offset
            },
            layerAmplitude: {
                type: 'v4',
                value: this.layerAmplitude
            },
            layerScale: {
                type: 'v4',
                value: this.layerScale
            }
        };
        //create noise material
        this.m_NoiseMat = new THREE.ShaderMaterial({
            uniforms: this.m_Uniforms,
            vertexShader: VertexShader,
            fragmentShader: FragmentShader
        });
        this.cameraRTT = new THREE.OrthographicCamera(-0.5, 0.5, 0.5, -0.5, -10, 10);
        this.cameraRTT.position.z = 1;
        this.sceneRTT = new THREE.Scene();
        this.sceneRTT.add(this.cameraRTT);
        this.quadGeo = new THREE.PlaneGeometry(1, 1);
        this.quadRTT = new THREE.Mesh(this.quadGeo, this.m_NoiseMat);
        this.quadRTT.position.z = -5;
        this.sceneRTT.add(this.quadRTT);
    };
    /** @inheritdoc */
    SimplexNoiseRenderer.prototype.onShutdown = function () {
        this.getEntity().off('changeNoiseValues', this.changeNoiseValues, this);
        this.getEntity().off('renderNoise', this.renderNoise, this);
        this.sceneRTT.remove(this.cameraRTT);
        this.sceneRTT.remove(this.quadRTT);
        this.sceneRTT = undefined;
        this.quadRTT = undefined;
        this.quadGeo.dispose();
        this.m_NoiseMat.dispose();
        this.m_Uniforms = undefined;
    };
    /** @inheritdoc */
    SimplexNoiseRenderer.prototype.onEntityReady = function () {
        if (this.autoLoad) {
            this.renderNoise();
        }
    };
    SimplexNoiseRenderer.prototype.renderNoise = function () {
        this.getThreeRenderer().render(this.sceneRTT, this.cameraRTT, this.getRuntimeData(), true);
        this.getThreeRenderer().setRenderTarget(null);
    };
    SimplexNoiseRenderer.prototype.changeNoiseValues = function (layerAmplitude, layerScale, scale, offset) {
        this.layerAmplitude = layerAmplitude;
        this.layerScale = layerScale;
        this.scale = scale;
        this.offset = offset;
        this.onAttributesChanged(['layerAmplitude', 'layerScale', 'scale', 'offset']);
    };
    /** @inheritdoc */
    SimplexNoiseRenderer.prototype.onAttributesChanged = function (attributes) {
        if (attributes.indexOf('scale') !== -1 && this.scale.x !== undefined) {
            this.m_Uniforms.scale.value.x = this.scale.x;
            this.m_Uniforms.scale.value.y = this.scale.y;
        }
        if (attributes.indexOf('offset') !== -1 && attributes.offset.x !== undefined) {
            this.m_Uniforms.offset.value.x = this.offset.x;
            this.m_Uniforms.offset.value.y = this.offset.y;
        }
        if (attributes.indexOf('layerScale') !== -1 && this.layerScale.x !== undefined) {
            this.m_Uniforms.layerScale.value.x = this.layerScale.x;
            this.m_Uniforms.layerScale.value.y = this.layerScale.y;
            this.m_Uniforms.layerScale.value.z = this.layerScale.z;
            this.m_Uniforms.layerScale.value.w = this.layerScale.w;
        }
        if (attributes.indexOf('layerAmplitude') !== -1 && this.layerAmplitude.x !== undefined) {
            this.m_Uniforms.layerAmplitude.value.x = this.layerAmplitude.x;
            this.m_Uniforms.layerAmplitude.value.y = this.layerAmplitude.y;
            this.m_Uniforms.layerAmplitude.value.z = this.layerAmplitude.z;
            this.m_Uniforms.layerAmplitude.value.w = this.layerAmplitude.w;
        }
        this.renderNoise();
    };
    return SimplexNoiseRenderer;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SimplexNoiseRenderer;


/***/ },
/* 99 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var BaseImageAsset_1 = __webpack_require__(10);
/**
 * @vid skybox_renderer
 * @vname Skybox
 * @vcategory Rendering
 * @vfilter scene
 */
var SkyboxRenderer = (function (_super) {
    tslib_1.__extends(SkyboxRenderer, _super);
    function SkyboxRenderer() {
        var _this = _super.apply(this, arguments) || this;
        /**
         * The texture asset to use. Can be one of texture2D, textureCube,
         * renderTexture2d or renderTextureCube.
         * @vattr Asset skyboxTexture {
         *   'description': 'The texture asset to use.',
         *   'type': 'asset',
         *   'filter': {
         *     'textureCube': true,
         *     'texture2D': true,
         *     'renderTexture2D': true,
         *     'renderTextureCube': true
         *   },
         *   'default': null
         * }
         */
        _this.skyboxTexture = null;
        /**
         * Determines whether or not to render in stereoscopic mode.
         * @vattr Boolean stereoEnabled { 'default' : false }
         */
        _this.stereoEnabled = false;
        /**
         * The size (uniform scale) of the skybox.
         * @vattr Float size { 'default' : 1000, 'min' : 1.0, 'max' : 1000000.0 }
         */
        _this.size = 100.0;
        /** The skybox mesh used for the left eye. */
        _this.skyboxMesh = null;
        /** The skybox mesh used for the right eye. */
        _this.skyboxMeshRightEye = null;
        /** The skybox geometry used for the left eye. */
        _this.skyboxGeometry = null;
        /** The skybox geometry used for the right eye. */
        _this.skyboxGeometryRightEye = null;
        /** The skybox cube material. */
        _this.skyboxMaterialCube = null;
        /** Uniforms used by the skybox cube material. */
        _this.skyboxUniforms = null;
        /** The vertex shader used by the skybox cube material. */
        _this.skyboxVShader = null;
        /** The fragment shader used by the skybox cube material. */
        _this.skyboxPShader = null;
        /** The skybox 2d material. */
        _this.skyboxMaterial2D = null;
        return _this;
    }
    /** @inheritdoc */
    SkyboxRenderer.prototype.onStartup = function () {
        this.initMaterials();
    };
    /** @inheritdoc */
    SkyboxRenderer.prototype.onShutdown = function () {
        if (this.skyboxGeometry) {
            this.skyboxGeometry.dispose();
        }
        if (this.skyboxGeometryRightEye) {
            this.skyboxGeometryRightEye.dispose();
        }
        if (this.skyboxMaterialCube) {
            this.skyboxMaterialCube.dispose();
        }
        if (this.skyboxMaterial2D) {
            this.skyboxMaterial2D.dispose();
        }
        this.skyboxMesh = null;
        this.skyboxGeometry = null;
        this.skyboxGeometryRightEye = null;
        this.skyboxMaterialCube = null;
        this.skyboxMaterial2D = null;
        this.skyboxUniforms = null;
        this.skyboxTexture = null;
    };
    /**
     * Returns the Three.js mesh for the skybox.
     * @param [eye='left'] If skybox is stereo, return the mesh for a specific eye.
     * Either 'left' or 'right'
     */
    SkyboxRenderer.prototype.getMesh = function (eye) {
        if (eye === void 0) { eye = 'left'; }
        return eye === 'left' ? this.skyboxMesh : this.skyboxMeshRightEye;
    };
    /** @inheritdoc */
    SkyboxRenderer.prototype.onAttributesChanged = function (changed) {
        // Do dependency setup (should be automated in the future)
        if (changed.indexOf('skyboxTexture') !== -1) {
            var prevTextureId = this.getPreviousAttribute('skyboxTexture');
            if (prevTextureId) {
                var texture = this.getEngine().getEntityById(prevTextureId);
                this.stopListening(texture);
            }
            this.getEntity().unregisterDependencyById(this.getPreviousAttribute('skyboxTexture'));
            // Only register the texture if it wasn't already registered. This code can be removed
            // when we make this more automatic.
            var dependencies = this.getEntity().getOwnDependencyInfo();
            var newTextureId = this.getAttribute('skyboxTexture');
            if (!dependencies[newTextureId]) {
                this.getEntity().registerDependencyById(this.getAttribute('skyboxTexture'));
            }
        }
        // Don't do any setup unless the entity is loaded/loading
        if (!this.getEntity().isBaseLoaded()) {
            return;
        }
        if (changed.indexOf('skyboxTexture') !== -1 || changed.indexOf('stereoEnabled') !== -1) {
            this.initSkybox();
        }
        if (changed.indexOf('size') !== -1) {
            if (this.skyboxMesh) {
                this.skyboxMesh.scale.set(this.size, this.size, this.size);
                this.skyboxMeshRightEye.scale.set(this.size, this.size, this.size);
            }
        }
    };
    /** @inheritdoc */
    SkyboxRenderer.prototype.onEnable = function () {
        if (this.getRuntimeData()) {
            this.getRuntimeData().add(this.skyboxMesh);
            if (this.isStereo()) {
                this.getRuntimeData().add(this.skyboxMeshRightEye);
            }
            if (this.skyboxTexture && this.skyboxTexture.isUnloaded()) {
                this.skyboxTexture.load();
            }
        }
    };
    /** @inheritdoc */
    SkyboxRenderer.prototype.onDisable = function () {
        if (this.getRuntimeData()) {
            this.getRuntimeData().remove(this.skyboxMesh);
            if (this.isStereo()) {
                this.getRuntimeData().remove(this.skyboxMeshRightEye);
            }
        }
    };
    /** @inheritdoc */
    SkyboxRenderer.prototype.onEntityReady = function () {
        this.initSkybox();
    };
    /**
     * Returns true iff the texture layout is stereoscopic (i.e. contains left and right eye images).
     * @returns True iff the texture layout is stereoscopic
     */
    SkyboxRenderer.prototype.isStereo = function () {
        if (!this.skyboxTexture || !this.stereoEnabled) {
            return false;
        }
        switch (this.skyboxTexture.getLayout()) {
            case BaseImageAsset_1.ImageLayout.Stereo2dOverUnder:
            case BaseImageAsset_1.ImageLayout.Stereo2dUnderOver:
            case BaseImageAsset_1.ImageLayout.Stereo2dLeftRight:
            case BaseImageAsset_1.ImageLayout.Stereo2dRightLeft:
                return this.stereoEnabled;
            default:
                return false;
        }
    };
    /**
     * Create the geometry for the skybox
     */
    SkyboxRenderer.prototype.initGeometry = function () {
        if (this.skyboxGeometry) {
            this.skyboxGeometry.dispose();
            this.skyboxGeometryRightEye.dispose();
        }
        // TODO - this would be more efficient as a geodesic sphere...
        this.skyboxGeometry = new THREE.SphereBufferGeometry(1, 64, 64);
        this.skyboxGeometryRightEye = this.skyboxGeometry.clone();
    };
    /**
     * If the texture is stereoscopic, modify the UV's of the geometry to map the
     * texture correctly for each eye.
     */
    SkyboxRenderer.prototype.initStereoUvs = function () {
        if (this.skyboxTexture) {
            var leftEyeScale = new THREE.Vector2();
            var leftEyeBias = new THREE.Vector2();
            var rightEyeScale = new THREE.Vector2();
            var rightEyeBias = new THREE.Vector2();
            // Based on texture type and layout, start the UV's for the geometry.
            switch (this.skyboxTexture.getLayout()) {
                case BaseImageAsset_1.ImageLayout.Stereo2dOverUnder:
                    leftEyeScale.set(1.0, 0.5);
                    leftEyeBias.set(0.0, 0.0);
                    rightEyeScale.set(1.0, 0.5);
                    rightEyeBias.set(0.0, 0.5);
                    break;
                case BaseImageAsset_1.ImageLayout.Stereo2dUnderOver:
                    leftEyeScale.set(1.0, 0.5);
                    leftEyeBias.set(0.0, 0.5);
                    rightEyeScale.set(1.0, 0.5);
                    rightEyeBias.set(0.0, 0.0);
                    break;
                case BaseImageAsset_1.ImageLayout.Stereo2dLeftRight:
                    leftEyeScale.set(0.5, 1.0);
                    leftEyeBias.set(0.0, 0.0);
                    rightEyeScale.set(0.5, 1.0);
                    rightEyeBias.set(0.5, 0.0);
                    break;
                case BaseImageAsset_1.ImageLayout.Stereo2dRightLeft:
                    leftEyeScale.set(0.5, 1.0);
                    leftEyeBias.set(0.5, 0.0);
                    rightEyeScale.set(0.5, 1.0);
                    rightEyeBias.set(0.0, 0.0);
                    break;
                default:
                    // If the layout of the texture isn't a stereo type, don't modify the
                    // geometry UV's.
                    return;
            }
            var uvsLeft = this.skyboxGeometry.getAttribute('uv').array;
            var uvsRight = this.skyboxGeometryRightEye.getAttribute('uv').array;
            for (var i = 0; i < uvsLeft.length; i += 2) {
                uvsLeft[i] *= leftEyeScale.x;
                uvsLeft[i + 1] *= leftEyeScale.y;
                uvsLeft[i] += leftEyeBias.x;
                uvsLeft[i + 1] += leftEyeBias.y;
                uvsRight[i] *= rightEyeScale.x;
                uvsRight[i + 1] *= rightEyeScale.y;
                uvsRight[i] += rightEyeBias.x;
                uvsRight[i + 1] += rightEyeBias.y;
            }
        }
    };
    /**
     * Create the mesh used to render the skybox
     */
    SkyboxRenderer.prototype.initMesh = function () {
        if (this.skyboxMesh) {
            this.getRuntimeData().remove(this.skyboxMesh);
        }
        if (this.skyboxMeshRightEye) {
            this.getRuntimeData().remove(this.skyboxMeshRightEye);
        }
        this.skyboxMesh = new THREE.Mesh(this.skyboxGeometry, this.currentMaterial);
        this.skyboxMesh.frustumCulled = false;
        this.skyboxMesh.castShadow = false;
        this.skyboxMesh.receiveShadow = false;
        this.skyboxMesh.matrixAutoUpdate = true;
        this.skyboxMesh.name = 'Skybox';
        // Rotate the mesh so that the texture will appear with y-up.
        this.skyboxMesh.rotation.y = -Math.PI / 2;
        this.skyboxMesh.rotation.z = -Math.PI;
        this.skyboxMesh.scale.set(this.size, this.size, this.size);
        // Duplicate skybox for right eye (only used for stereo textures)
        this.skyboxMeshRightEye = this.skyboxMesh.clone();
        this.skyboxMeshRightEye.geometry = this.skyboxGeometryRightEye;
        this.skyboxMeshRightEye.layers.set(2);
        if (this.isEnabled()) {
            this.getRuntimeData().add(this.skyboxMesh);
            this.skyboxMesh.updateMatrix();
        }
    };
    /**
     * Based on the texture currently assigned, choose the appropriate material and initialize
     * or recreate the geometry and mesh if needed.
     */
    SkyboxRenderer.prototype.initSkybox = function () {
        this.currentMaterial = this.skyboxMaterial2D;
        this.currentMaterial.needsUpdate = true;
        if (!this.skyboxTexture) {
            this.currentMaterial.map = null;
            this.currentMaterial.needsUpdate = true;
        }
        else if (this.skyboxTexture.type === 'textureCube' ||
            this.skyboxTexture.type === 'renderTextureCube') {
            this.currentMaterial = this.skyboxMaterialCube;
        }
        this.initGeometry();
        this.initMesh();
        this.initStereoUvs();
        if (this.isStereo()) {
            this.skyboxMesh.layers.set(1);
            this.getRuntimeData().add(this.skyboxMeshRightEye);
        }
        else {
            this.skyboxMesh.layers.set(0);
            this.getRuntimeData().remove(this.skyboxMeshRightEye);
        }
        if (!this.skyboxTexture) {
            return;
        }
        this.listenTo(this.skyboxTexture, 'load', this.onSkyboxTextureLoad);
        if (this.skyboxTexture.isLoaded()) {
            this.onSkyboxTextureLoad();
        }
        if (this.isEnabled() && this.skyboxTexture.isUnloaded()) {
            this.skyboxTexture.load();
        }
    };
    /**
     * Called when the skybox texture's load event is fired. This links up the texture in
     * the skybox's material.
     */
    SkyboxRenderer.prototype.onSkyboxTextureLoad = function () {
        // @FIXME: this needs to handle cube textures.
        if (this.currentMaterial instanceof THREE.MeshBasicMaterial) {
            this.currentMaterial.map = this.skyboxTexture.getThreeTexture();
            this.currentMaterial.needsUpdate = true;
        }
    };
    /**
     * Create the materials needed to render the skybox
     */
    SkyboxRenderer.prototype.initMaterials = function () {
        this.skyboxUniforms = THREE.UniformsUtils.merge([
            {
                envMap: {
                    type: 't',
                    value: null
                }
            }
        ]);
        this.skyboxVShader = [
            'varying vec3 vCameraVector;',
            'void main() {',
            'vCameraVector = (modelMatrix * vec4( position, 1.0 )).xyz;',
            'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
            '}'
        ].join('\n');
        this.skyboxPShader = [
            'uniform samplerCube environmentTexture;',
            'varying vec3 vCameraVector;',
            'void main() {',
            'vec3 cameraVecN = normalize( vCameraVector );',
            'vec4 environmentColor = textureCube(environmentTexture,' +
                ' vec3(cameraVecN.x, cameraVecN.yz));',
            'gl_FragColor = vec4( environmentColor.xyz, 1.0 );',
            '}'
        ].join('\n');
        this.skyboxMaterialCube = new THREE.ShaderMaterial({
            vertexShader: this.skyboxVShader,
            fragmentShader: this.skyboxPShader,
            uniforms: this.skyboxUniforms,
            depthTest: true,
            depthWrite: false,
            side: THREE.BackSide
        });
        this.skyboxMaterial2D = new THREE.MeshBasicMaterial({
            depthTest: false,
            depthWrite: false,
            side: THREE.BackSide
        });
    };
    return SkyboxRenderer;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SkyboxRenderer;


/***/ },
/* 100 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/*
@vid text_renderer_component
@vname Text Renderer
@vdescription Render the desired text to the texture we are attached to
@vfilter renderTexture2D
@vcategory Text
@vattr string text { default : 'My Text', description : 'Text you want to display' }
@vattr color fontColor { default : {r: 1, g: 1, b:1}, description : 'Color of the text'}
@vattr string fontFamily { default : 'Calibri', description : 'Font family to render'}
@vattr integer pointSize { default : 48, description : 'Font size', min : 2, max : 100 }
*/
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var TextRenderer = (function (_super) {
    tslib_1.__extends(TextRenderer, _super);
    function TextRenderer() {
        var _this = _super.call(this) || this;
        _this.m_Material = null;
        _this.m_Canvas = null;
        _this.m_Mesh = null;
        _this.m_RTCam = null;
        _this.m_RTScene = null;
        return _this;
    }
    /** @inheritdoc */
    TextRenderer.prototype.onStartup = function () {
        this.createLabel();
    };
    /** @inheritdoc */
    TextRenderer.prototype.sceneLoaded = function () {
        this.renderText();
    };
    /** @inheritdoc */
    TextRenderer.prototype.onShutdown = function () {
        this.m_Material.dispose();
        this.m_Geom.dispose();
        this.m_Mesh = null;
    };
    TextRenderer.prototype.createLabel = function () {
        var text = this.text, size = this.pointSize, color = '#' + this.fontColor.getHexString();
        if (!this.m_Canvas) {
            this.m_Canvas = document.createElement('canvas');
        }
        var fontType = size + 'pt ' + this.fontFamily;
        var context = this.m_Canvas.getContext('2d');
        context.font = fontType;
        // FIXME: what were these getEntity().getWidth()/getHeight() calls returning?
        // this.m_Canvas.width = this.getEntity().getWidth();
        // this.m_Canvas.height = this.getEntity().getHeight();
        context.font = size + 'pt ' + this.fontFamily;
        context.textAlign = 'left';
        context.textBaseline = 'hanging';
        context.fillStyle = color;
        this.wrapAndRender(context, text, this.pointSize * 0.5, this.pointSize * 0.5, this.m_Canvas.width - this.pointSize * 0.5, this.pointSize * 1.5);
        /* CONVERT TO SOMETHING Box3d CAN USE */
        var texture = new THREE.Texture(this.m_Canvas);
        texture.mapping = null;
        texture.generateMipmaps = true;
        texture.magFilter = THREE.LinearFilter;
        texture.minFilter = THREE.LinearMipMapLinearFilter;
        texture.needsUpdate = true;
        if (this.m_Material)
            this.m_Material.dispose();
        this.m_Material = new THREE.MeshBasicMaterial({
            map: texture
        });
        this.m_Material.side = THREE.DoubleSide;
        if (this.m_Geom)
            this.m_Geom.dispose();
        this.m_Geom = new THREE.PlaneGeometry(this.m_Canvas.width, this.m_Canvas.height);
        if (this.m_Mesh) {
            this.m_RTScene.remove(this.m_Mesh);
            this.m_Mesh = null;
        }
        this.m_Mesh = new THREE.Mesh(this.m_Geom, this.m_Material);
        this.m_Mesh.position.z = 0;
        var halfwidth = this.m_Canvas.width * 0.5;
        var halfheight = this.m_Canvas.height * 0.5;
        if (!this.m_RTCam)
            this.m_RTCam = new THREE.OrthographicCamera(-halfwidth, halfwidth, -halfheight, halfheight, -10, 1000);
        this.m_RTCam.position.z = 10;
        this.m_RTCam.rotation.z = Math.PI;
        // left, right, top, bottom
        this.m_RTCam.left = halfwidth;
        this.m_RTCam.right = -halfwidth;
        this.m_RTCam.top = halfheight;
        this.m_RTCam.bottom = -halfheight;
        this.m_RTCam.updateProjectionMatrix();
        if (!this.m_RTScene) {
            this.m_RTScene = new THREE.Scene();
            this.m_RTScene.add(this.m_RTCam);
        }
        this.m_RTScene.add(this.m_Mesh);
    };
    /** @inheritdoc */
    TextRenderer.prototype.onAttributesChanged = function () {
        this.createLabel();
        this.renderText();
    };
    TextRenderer.prototype.renderText = function () {
        if (!this.text)
            this.text = ' ';
        if (this.getRuntimeData()) {
            this.getThreeRenderer().render(this.m_RTScene, this.m_RTCam, this.getRuntimeData());
        }
        else {
        }
    };
    TextRenderer.prototype.wrapAndRender = function (context, text, x, y, maxWidth, lineHeight) {
        var words = text.split(' ');
        var line = '';
        for (var n = 0; n < words.length; n++) {
            var testLine = line + words[n] + ' ';
            var metrics = context.measureText(testLine);
            var testWidth = metrics.width;
            if (testWidth > maxWidth && n > 0) {
                context.fillText(line, x, y);
                line = words[n] + ' ';
                y += lineHeight;
            }
            else {
                line = testLine;
            }
        }
        context.fillText(line, x, y);
    };
    return TextRenderer;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = TextRenderer;


/***/ },
/* 101 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
/**
 * @vid vr_camera_controller
 * @vname VR Camera Controller
 * @vfilter camera
 * @vcategory Camera
 */
var VrCameraController = (function (_super) {
    tslib_1.__extends(VrCameraController, _super);
    function VrCameraController() {
        var _this = _super.apply(this, arguments) || this;
        /** Treat the viewer as standing rather than sitting. */
        _this.standing = true;
        /** The user's height to be used when standing is true and the VR device doesn't offer stage parameters. */
        _this.userHeight = 6;
        /** Stores the frame data to be updated each frame from the VR display  */
        _this.frameData = window.hasOwnProperty('VRFrameData') ? new VRFrameData() : {};
        /** Internal value for to store standing matrix from device */
        _this.standingMatrix = new THREE.Matrix4();
        /** Internal vector for calculations */
        _this.workVector = new THREE.Vector3();
        /** The scale of the scene FIXME: this should be set via some global scale value so that all
         * VR can abide by it.
         */
        _this.scale = 1.0;
        return _this;
    }
    /** @inheritDoc */
    VrCameraController.prototype.onPreUpdate = function (_delta) {
        if (!this.isEnabled() || !this.hasRuntimeData()) {
            return;
        }
        var engine = this.getEngine();
        var vrDisplay = engine.getVrDisplay();
        if (!vrDisplay) {
            return;
        }
        engine.needsRender = true;
        vrDisplay.getFrameData(this.frameData);
        var pose = this.frameData.pose;
        var object = this.getRuntimeData();
        var entity = this.getEntity();
        if (pose.orientation === null) {
            return;
        }
        entity.setQuaternion(pose.orientation[0], pose.orientation[1], pose.orientation[2], pose.orientation[3]);
        if (pose.position !== null) {
            entity.setPosition(pose.position[0], pose.position[1], pose.position[2]);
        }
        if (this.standing) {
            if (vrDisplay.stageParameters) {
                // Use three.js value to calculate new position and orientation and then set it back on the
                // entity to communicate the values across engine instances.
                object.updateMatrix();
                this.standingMatrix.fromArray(vrDisplay.stageParameters.sittingToStandingTransform);
                object.applyMatrix(this.standingMatrix);
                entity.setQuaternion(object.quaternion.x, object.quaternion.y, object.quaternion.z, object.quaternion.w);
                object.position.multiplyScalar(this.scale);
                entity.setPosition(object.position.x, object.position.y, object.position.z);
            }
            else {
                // We're treating the user as standing but they aren't using a device with room-scale support.
                // So, we'll add the user's height manually.
                entity.getPosition(this.workVector);
                this.workVector.y += this.userHeight;
                this.workVector.multiplyScalar(this.scale);
                entity.setPosition(this.workVector.x, this.workVector.y, this.workVector.z);
            }
        }
        else {
            entity.getPosition(this.workVector);
            this.workVector.multiplyScalar(this.scale);
            entity.setPosition(this.workVector.x, this.workVector.y, this.workVector.z);
        }
    };
    return VrCameraController;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = VrCameraController;


/***/ },
/* 102 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var BaseComponent_1 = __webpack_require__(2);
var functions_1 = __webpack_require__(6);
/**
 * @vid vr_hand_controller_animator
 * @vname VR Hand Controller Animator
 * @vfilter object
 * @vcategory Input
 */
var VrHandControllerAnimator = (function (_super) {
    tslib_1.__extends(VrHandControllerAnimator, _super);
    function VrHandControllerAnimator() {
        var _this = _super.apply(this, arguments) || this;
        /**
         * ID's of the mesh instances for each button.
         * @vattr Object[] buttonMeshes {
         *   'default': []
         * }
         */
        _this.buttonMeshes = [];
        /**
         * Vector that represents movement of button when fully pressed in local space.
         * @vattr array buttonPressOffset {
         *   'type': 'a',
         *   'subType': {
         *      'type': 'v3',
         *      'default': {x: 0, y: 0, z: 0}
         *    }
         * }
         */
        _this.buttonPressOffset = [];
        /**
         * Quaternion that represents rotation of button when fully pressed in local space.
         * @vattr array buttonPressRotation {
         *   'type': 'a',
         *   'subType': {
         *      'type': 'q',
         *      'default': {x: 0, y: 0, z: 0, w: 1}
         *    }
         * }
         */
        _this.buttonPressRotation = [];
        /**
         * @vattr Object[] axisMeshes {
         *   'default': []
         * }
         */
        _this.axisMeshes = [];
        /**
         * Vector that represents movement of axis when fully pressed in local space.
         * @vattr array axisPivot {
         *   'type': 'a',
         *   'subType': {
         *      'type': 'v3',
         *      'default': {x: 0, y: 0, z: 0}
         *    }
         * }
         */
        _this.axisPivot = [];
        /**
         * Quaternion that represents rotation of axis when fully pressed in local space.
         * @vattr array axisRotation {
         *   'type': 'a',
         *   'subType': {
         *      'type': 'v3',
         *      'default': {x: 0, y: 0, z: 0}
         *    }
         * }
         */
        _this.axisRotation = [];
        /** Internal vector for calculations */
        _this.workVector1 = new THREE.Vector3();
        /** Internal vector for calculations */
        _this.workVector2 = new THREE.Vector3();
        /** Internal quaternion for calculations */
        _this.workQuaternion1 = new THREE.Quaternion();
        /** Internal quaternion for calculations */
        _this.workQuaternion2 = new THREE.Quaternion();
        /** Internal euler rotation for calculations */
        _this.workEuler = new THREE.Euler();
        /** Map of mesh ID's to axes and buttons that are tied to that mesh. */
        _this.meshControlMap = {};
        /** Internal flag for whether the axes rendering needs to be updated. */
        _this.updateAxes = false;
        /** Internal reference to hand controller to be used for getting gamepad state. */
        _this.handController = null;
        return _this;
    }
    /** @inheritdoc */
    VrHandControllerAnimator.prototype.onStartup = function () {
        this.listenTo(this.getEngine(), 'gamepadButtonChanged', this.onGamepadButtonEvent);
        this.listenTo(this.getEngine(), 'gamepadAxisChanged', this.onGamepadAxisEvent);
    };
    /** @inheritdoc */
    VrHandControllerAnimator.prototype.onUpdate = function (_delta) {
        // We only update the axes a maximum of once per frame by doing the update here
        // rather than in the event callback.
        if (this.updateAxes) {
            this.updateAxes = false;
            if (!this.handController) {
                return;
            }
            var currentGamepad = this.handController.getGamepad();
            this.updateAxesTransforms(currentGamepad);
        }
    };
    /**
     * Get an array of meshes linked to axes in this controller.
     * @returns Array of meshes, indexed by axis number.
     */
    VrHandControllerAnimator.prototype.getAxisMeshes = function () {
        return this.axisMeshes.map(function (mesh) { return mesh; });
    };
    /**
     * Get an array of meshes linked to buttons in this controller.
     * @returns Array of meshes, indexed by button number.
     */
    VrHandControllerAnimator.prototype.getButtonMeshes = function () {
        return this.buttonMeshes.map(function (mesh) { return mesh; });
    };
    /** @inheritdoc */
    VrHandControllerAnimator.prototype.onAttributesChanged = function (changes) {
        var _this = this;
        if (changes.indexOf('axisMeshes') !== -1 || changes.indexOf('buttonMeshes') !== -1) {
            // Update mesh mapping that links a given mesh to the controls that apply to it.
            this.meshControlMap = {};
            this.axisMeshes.forEach(function (mesh, idx) {
                if (!_this.meshControlMap[mesh.id]) {
                    _this.meshControlMap[mesh.id] = { axes: [], buttons: [] };
                }
                _this.meshControlMap[mesh.id].axes.push(idx);
            });
            this.buttonMeshes.forEach(function (mesh, idx) {
                // Don't create an entry for a mesh if only buttons are associated with it.
                if (!_this.meshControlMap[mesh.id]) {
                    return;
                }
                _this.meshControlMap[mesh.id].buttons.push(idx);
            });
        }
    };
    /**
     * Callback for when any gamepad button is pressed, released, touched, etc.
     * @param gamepad   The gamepad responsible for the event
     * @param buttonIdx The index of the button responsible for the event.
     */
    VrHandControllerAnimator.prototype.onGamepadButtonEvent = function (gamepad, buttonIdx) {
        if (!this.handController) {
            var ancestors = this.getEntity().getAncestors();
            var handControllerObj = ancestors.find(function (entity) {
                return !!entity.getComponentByScriptId('vr_hand_controller');
            });
            if (!handControllerObj) {
                this.handController = null;
                return;
            }
            this.handController = handControllerObj.getComponentByScriptId('vr_hand_controller');
        }
        var currentGamepad = this.handController.getGamepad();
        if (currentGamepad !== gamepad) {
            return;
        }
        this.updateButtonTransform(gamepad, buttonIdx);
    };
    /**
     * Update the button's position and orientation to indicate presses.
     * @param gamepad   The gamepad that holds the state for us to use.
     * @param buttonIdx The index of the button on the controller.
     */
    VrHandControllerAnimator.prototype.updateButtonTransform = function (gamepad, buttonIdx) {
        var mesh = this.buttonMeshes[buttonIdx];
        if (!mesh) {
            return;
        }
        var pressValue = gamepad.buttons[buttonIdx].value;
        this.workVector1.copy(this.buttonPressOffset[buttonIdx]).multiplyScalar(pressValue);
        mesh.setPosition(this.workVector1.x, this.workVector1.y, this.workVector1.z);
        this.workQuaternion1.set(0, 0, 0, 1);
        this.workQuaternion2.copy(this.buttonPressRotation[buttonIdx]);
        this.workQuaternion1.slerp(this.workQuaternion2, pressValue);
        mesh.setQuaternion(this.workQuaternion1.x, this.workQuaternion1.y, this.workQuaternion1.z, this.workQuaternion1.w);
    };
    /**
     * Callback for when any gamepad button is pressed, released, touched, etc.
     * @param gamepad   The gamepad responsible for the event
     * @param axisIdx The index of the axis responsible for the event.
     */
    VrHandControllerAnimator.prototype.onGamepadAxisEvent = function (gamepad, _axisIdx) {
        if (!this.handController) {
            var ancestors = this.getEntity().getAncestors();
            var handControllerObj = ancestors.find(function (entity) {
                return !!entity.getComponentByScriptId('vr_hand_controller');
            });
            if (!handControllerObj) {
                this.handController = null;
                return;
            }
            this.handController = handControllerObj.getComponentByScriptId('vr_hand_controller');
        }
        var currentGamepad = this.handController.getGamepad();
        if (currentGamepad !== gamepad) {
            return;
        }
        this.updateAxes = true;
    };
    /**
     * Update all axes positions and orientations to indicate movement.
     * @param gamepad   The gamepad that holds the state for us to use.
     */
    VrHandControllerAnimator.prototype.updateAxesTransforms = function (gamepad) {
        var _this = this;
        functions_1.forEach(this.meshControlMap, function (controls, meshId) {
            var mesh = _this.getEngine().getObjectById(meshId);
            if (!mesh) {
                return;
            }
            // Figure out the translation needed to move the mesh to the pivot point before
            // applying any rotation.
            // The shared mesh should probably always have the same pivot point for each axis.
            // If we assume that it does, we can remove the `reduce` here.
            _this.workVector1.set(0, 0, 0);
            controls.axes.reduce(function (prev, axisIdx, idx) {
                _this.workVector2.copy(_this.axisPivot[axisIdx]).multiplyScalar(-1);
                return prev.lerp(_this.workVector2, idx === 0 ? 1.0 : 0.5);
            }, _this.workVector1);
            // Figure out the rotation of the mesh based on the combined rotation of each axis.
            _this.workQuaternion1.set(0, 0, 0, 1);
            controls.axes.reduce(function (prev, axisIdx, idx) {
                var pressValue = gamepad.axes[axisIdx];
                _this.workVector2.copy(_this.axisRotation[axisIdx]).multiplyScalar(pressValue);
                _this.workEuler.setFromVector3(_this.workVector2);
                _this.workQuaternion2.setFromEuler(_this.workEuler);
                // If we're on the first axis, just use the pure rotation. Otherwise, slerp with
                // the previous one. This assumes that we'll have a maximum of two axes for one mesh.
                return prev.slerp(_this.workQuaternion2, idx === 0 ? 1.0 : 0.5);
            }, _this.workQuaternion1);
            // Copy the translation before rotating it.
            _this.workVector2.copy(_this.workVector1);
            // Rotate at the pivot point.
            _this.workVector2.applyQuaternion(_this.workQuaternion1);
            // Translate back away from pivot.
            _this.workVector1.multiplyScalar(-1);
            _this.workVector2.add(_this.workVector1);
            mesh.setQuaternion(_this.workQuaternion1.x, _this.workQuaternion1.y, _this.workQuaternion1.z, _this.workQuaternion1.w);
            mesh.setPosition(_this.workVector2.x, _this.workVector2.y, _this.workVector2.z);
            // If the mesh is also shared by a button, handle the offset for the button here.
            // This code assumes only one button is associated with a mesh.
            if (controls.buttons.length) {
                var buttonIdx = controls.buttons[0];
                var pressValue = gamepad.buttons[buttonIdx].value;
                _this.workVector1.copy(_this.buttonPressOffset[buttonIdx]).multiplyScalar(pressValue);
                _this.workVector1.applyQuaternion(_this.workQuaternion1);
                _this.workVector1.add(_this.workVector2);
                mesh.setPosition(_this.workVector1.x, _this.workVector1.y, _this.workVector1.z);
            }
        });
    };
    return VrHandControllerAnimator;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = VrHandControllerAnimator;


/***/ },
/* 103 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseComponent_1 = __webpack_require__(2);
var UserAgent_1 = __webpack_require__(13);
var Logger_1 = __webpack_require__(3);
/**
 * @vid vr_presenter_component
 * @vname VR Presenter
 * @vfilter application
 * @vcategory VR
 */
var VrPresenter = (function (_super) {
    tslib_1.__extends(VrPresenter, _super);
    function VrPresenter() {
        var _this = _super.apply(this, arguments) || this;
        /** The scale of the scene used by VR rendering. */
        _this.scale = 1.0;
        /** Indicates whether we're currently presenting to the VR display. */
        _this.isPresenting = false;
        /** Indicates whether we were just presenting to the VR display on the previous frame. */
        _this.wasPresenting = false;
        /** A list populated with the VR displays attached to the system. */
        _this.vrDisplays = null;
        /** The pixel ratio used by the renderer before presenting to the VR display. */
        _this.previousPixelRatio = 1.0;
        /** The render size used by the renderer before presenting to the VR display. */
        _this.previousRenderSize = null;
        return _this;
    }
    /** Return the scale that VR rendering is using. */
    VrPresenter.prototype.getScale = function () {
        return this.scale;
    };
    /**
     * Set the scale that VR rendering will use.
     * @param scale The new scale of the VR world.
     */
    VrPresenter.prototype.setScale = function (scale) {
        this.scale = scale;
    };
    /** Return the list of VR Displays available. */
    VrPresenter.prototype.getDisplays = function () {
        return this.vrDisplays;
    };
    /** @inheritdoc */
    VrPresenter.prototype.onAwake = function () {
        var _this = this;
        this.listenTo(this.getEngine(), 'enableVrRendering', this.onEnableVr);
        this.listenTo(this.getEngine(), 'disableVrRendering', this.onDisableVr);
        this.listenTo(this.getEngine(), 'toggleVrRendering', this.onToggleVr);
        this.onVrDisplayPresentChange = this.onVrDisplayPresentChange.bind(this);
        window.addEventListener('vrdisplaypresentchange', this.onVrDisplayPresentChange, false);
        // Get a list of all the VR displays available to use.
        if (navigator.getVRDisplays) {
            navigator.getVRDisplays().then(function (devices) {
                _this.vrDisplays = devices;
                _this.trigger('displaysInitialized');
            });
        }
        else {
            this.vrDisplays = [];
        }
    };
    /** @inheritdoc */
    VrPresenter.prototype.onShutdown = function () {
        _super.prototype.onShutdown.call(this);
        window.removeEventListener('vrdisplaypresentchange', this.onVrDisplayPresentChange, false);
    };
    /** @inheritdoc */
    VrPresenter.prototype.onDisable = function () {
        if (this.isPresenting) {
            this.onDisableVr();
        }
    };
    /** Call the provided callback when VR Displays have been successfully queried */
    VrPresenter.prototype.whenDisplaysAvailable = function (callback) {
        var _this = this;
        if (this.vrDisplays) {
            callback.call(this, this.vrDisplays);
        }
        else {
            this.listenToOnce(this, 'displaysInitialized', function () {
                callback.call(_this, _this.vrDisplays);
            });
        }
    };
    /** @inheritdoc */
    VrPresenter.prototype.onPostRender = function (_delta) {
        var vrDisplay = this.getEngine().getVrDisplay();
        if (!vrDisplay) {
            return;
        }
        // Submit the frame to the VR display.
        if (this.isPresenting) {
            vrDisplay.submitFrame();
        }
    };
    /** Called when engine-level event for enabling VR is fired. */
    VrPresenter.prototype.onEnableVr = function () {
        if (!this.isEnabled()) {
            return;
        }
        // If the display list hasn't been setup yet, listen for the event.
        if (!this.vrDisplays) {
            this.listenToOnce(this, 'displaysInitialized', this.onEnableVr.bind(this));
            return;
        }
        if (!this.vrDisplays.length) {
            return;
        }
        // Set the display on the engine.
        var vrDisplay = this.vrDisplays[0];
        this.getEngine().setVrDisplay(vrDisplay);
        var canvas = this.getRenderer().getCanvas();
        // TODO: Support multiple layers here.
        vrDisplay.requestPresent([{ source: canvas }])
            .catch(function (err) {
            Logger_1.default.error('Failed to present to VR display', err.message);
        });
    };
    /** Called when engine-level event for disabling VR is fired. */
    VrPresenter.prototype.onDisableVr = function () {
        if (this.isPresenting) {
            var vrDisplay = this.getEngine().getVrDisplay();
            if (vrDisplay) {
                vrDisplay.exitPresent();
                this.getEngine().setVrDisplay(null);
            }
        }
    };
    /** Called when engine-level event for toggling VR is fired. */
    VrPresenter.prototype.onToggleVr = function () {
        if (this.isPresenting) {
            this.onDisableVr();
        }
        else {
            this.onEnableVr();
        }
    };
    /**
     * Called when there is a change in VR presenting state.
     * Resizes the canvas and sets up appropriate pixel ratio for VR display.
     */
    VrPresenter.prototype.onVrDisplayPresentChange = function () {
        this.wasPresenting = this.isPresenting;
        var vrDisplay = this.getEngine().getVrDisplay();
        this.isPresenting = vrDisplay && vrDisplay.isPresenting;
        var renderer = this.getThreeRenderer();
        if (this.isPresenting) {
            var eyeParamsL = vrDisplay.getEyeParameters('left');
            var eyeWidth = eyeParamsL.renderWidth;
            var eyeHeight = eyeParamsL.renderHeight;
            if (!this.wasPresenting) {
                this.previousPixelRatio = renderer.getPixelRatio();
                this.previousRenderSize = renderer.getSize();
                if (!UserAgent_1.isMobile()) {
                    renderer.setPixelRatio(1);
                }
                else {
                    // If using the devicePixelRatio of the mobile device, we must be
                    // careful not to exceed the max texture dimensions of the device.
                    var maxTextureSize = renderer.capabilities.maxTextureSize;
                    var vrWidth = 2.0 * eyeWidth;
                    if (vrWidth * this.previousPixelRatio > maxTextureSize) {
                        this.previousPixelRatio = Math.floor(maxTextureSize / vrWidth);
                    }
                    renderer.setPixelRatio(this.previousPixelRatio);
                }
                renderer.setSize(eyeWidth * 2, eyeHeight, false);
            }
        }
        else if (this.wasPresenting) {
            renderer.setPixelRatio(this.previousPixelRatio);
            renderer.setSize(this.previousRenderSize.width, this.previousRenderSize.height);
        }
    };
    return VrPresenter;
}(BaseComponent_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = VrPresenter;


/***/ },
/* 104 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var RenderView_1 = __webpack_require__(45);
/**
 * Render View component that enables a stereoscopic view when a VR display is available.
 * @vid vr_render_view_component
 * @vname VR Render View
 * @vfilter camera
 * @vcategory Rendering
 */
var VrRenderView = (function (_super) {
    tslib_1.__extends(VrRenderView, _super);
    function VrRenderView() {
        var _this = _super.apply(this, arguments) || this;
        // tslint:disable max-line-length */
        /**
         * Run pre-render functions with this view. These include things like real-time reflections,
         * which need to be rendered for each view separately.
         * @vattr Boolean enablePreRenderFunctions {
         *   description: 'Run pre-render functions with this view. These include things like real-time reflections, which need to be rendered for each view separately.',
         *   default : true,
         *   advanced: true
         * }
         */
        // tslint:enable max-line-length */
        _this.enablePreRenderFunctions = true;
        /**
         * Render shadows for this view.
         * @vattr Boolean enableShadows {
         *   description: 'Render shadows for this view.',
         *   default : true,
         *   advanced: true
         * }
         */
        _this.enableShadows = true;
        /** Stores the left eye offset amount  */
        _this.eyeTranslationL = new THREE.Vector3();
        /** Stores the right eye offset amount  */
        _this.eyeTranslationR = new THREE.Vector3();
        /** Stores the default left eye bounds  */
        _this.defaultLeftBounds = [0.0, 0.0, 0.5, 1.0];
        /** Stores the default right eye bounds  */
        _this.defaultRightBounds = [0.5, 0.0, 0.5, 1.0];
        /** Stores the viewport info for the left eye  */
        _this.renderRectL = { x: 0, y: 0, width: 256, height: 256 };
        /** Stores the viewport info for the right eye  */
        _this.renderRectR = { x: 128, y: 0, width: 256, height: 256 };
        /** The internal camera for the left eye  */
        _this.cameraL = new THREE.PerspectiveCamera();
        /** The internal camera for the right eye  */
        _this.cameraR = new THREE.PerspectiveCamera();
        /** Stores the frame data to be updated each frame from the VR display  */
        _this.frameData = window.hasOwnProperty('VRFrameData') ? new VRFrameData() : {};
        /** The scale of the scene FIXME: this should be set via some global scale value so that all
         * VR can abide by it.
         */
        _this.scale = 1.0;
        return _this;
    }
    /** @inheritdoc */
    VrRenderView.prototype.renderView = function (delta) {
        if (!this.isEnabled() || !this.hasRuntimeData()) {
            return;
        }
        var scene = this.getRootObject();
        if (!scene.isBaseLoaded()) {
            return;
        }
        var threeScene = scene.getRuntimeData();
        var vrDisplay = this.getEngine().getVrDisplay();
        if (!vrDisplay) {
            return _super.prototype.renderView.call(this, delta);
        }
        var autoUpdate = threeScene.autoUpdate;
        if (autoUpdate) {
            threeScene.updateMatrixWorld();
            threeScene.autoUpdate = false;
        }
        var eyeParamsL = vrDisplay.getEyeParameters('left');
        var eyeParamsR = vrDisplay.getEyeParameters('right');
        this.eyeTranslationL.fromArray(eyeParamsL.offset);
        this.eyeTranslationR.fromArray(eyeParamsR.offset);
        var renderer = this.getThreeRenderer();
        // When rendering we don't care what the recommended size is, only what the actual size
        // of the backbuffer is.
        var size = renderer.getSize();
        var layers = vrDisplay.getLayers();
        var leftBounds;
        var rightBounds;
        if (layers.length) {
            var layer = layers[0];
            leftBounds = layer.leftBounds !== null && layer.leftBounds.length === 4 ?
                layer.leftBounds : this.defaultLeftBounds;
            rightBounds = layer.rightBounds !== null && layer.rightBounds.length === 4 ?
                layer.rightBounds : this.defaultRightBounds;
        }
        else {
            leftBounds = this.defaultLeftBounds;
            rightBounds = this.defaultRightBounds;
        }
        this.renderRectL = {
            x: Math.round(size.width * leftBounds[0]),
            y: Math.round(size.height * leftBounds[1]),
            width: Math.round(size.width * leftBounds[2]),
            height: Math.round(size.height * leftBounds[3])
        };
        this.renderRectR = {
            x: Math.round(size.width * rightBounds[0]),
            y: Math.round(size.height * rightBounds[1]),
            width: Math.round(size.width * rightBounds[2]),
            height: Math.round(size.height * rightBounds[3])
        };
        var camera = this.getRuntimeData();
        if (camera.parent === null) {
            camera.updateMatrixWorld();
        }
        camera.matrixWorld.decompose(this.cameraL.position, this.cameraL.quaternion, this.cameraL.scale);
        camera.matrixWorld.decompose(this.cameraR.position, this.cameraR.quaternion, this.cameraR.scale);
        this.cameraL.translateOnAxis(this.eyeTranslationL, this.scale);
        this.cameraR.translateOnAxis(this.eyeTranslationR, this.scale);
        vrDisplay.depthNear = camera.near;
        vrDisplay.depthFar = camera.far;
        vrDisplay.getFrameData(this.frameData);
        this.cameraL.projectionMatrix.elements = this.frameData.leftProjectionMatrix;
        this.cameraR.projectionMatrix.elements = this.frameData.rightProjectionMatrix;
        // render left eye
        renderer.setScissor(this.renderRectL.x, this.renderRectL.y, this.renderRectL.width, this.renderRectL.height);
        this.getRenderer().renderView(threeScene, this.cameraL, {
            renderTarget: this.renderTarget,
            clearDepth: true,
            clearColor: true,
            viewPort: this.renderRectL,
            enablePreRenderFunctions: true
        });
        // render right eye
        renderer.setScissor(this.renderRectR.x, this.renderRectR.y, this.renderRectR.width, this.renderRectR.height);
        this.getRenderer().renderView(threeScene, this.cameraR, {
            renderTarget: this.renderTarget,
            clearDepth: false,
            clearColor: false,
            viewPort: this.renderRectR,
            enablePreRenderFunctions: true
        });
        if (autoUpdate) {
            threeScene.autoUpdate = true;
        }
    };
    return VrRenderView;
}(RenderView_1.default));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = VrRenderView;


/***/ },
/* 105 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
/* tslint:disable max-file-line-count */
var THREE = __webpack_require__(1);
var Logger_1 = __webpack_require__(3);
var EntityDispatcher_1 = __webpack_require__(191);
var EntityRegistry_1 = __webpack_require__(192);
var GeometryUtilities_1 = __webpack_require__(186);
var MaterialUtilities_1 = __webpack_require__(196);
var RuntimeEvents_1 = __webpack_require__(21);
var ScriptRegistry_1 = __webpack_require__(64);
var ShaderAsset_1 = __webpack_require__(44);
var MaterialAsset_1 = __webpack_require__(14);
var globalEvents_1 = __webpack_require__(40);
var classComposer_1 = __webpack_require__(39);
var BaseEntity_1 = __webpack_require__(11);
var LoadingType_1 = __webpack_require__(18);
var LoadingEvent_1 = __webpack_require__(12);
var getElement = function (obj) {
    var els;
    if (obj && obj.jquery) {
        return obj.get(0);
    }
    else if (typeof obj === 'string') {
        els = document.querySelectorAll(obj);
        return els.length && els[0];
    }
    else {
        return obj;
    }
};
exports.engineMixins = classComposer_1.default({}, [EntityRegistry_1.default, RuntimeEvents_1.default]);
/**
 * This is the Box3D Engine object.
 */
var Engine = (function (_super) {
    tslib_1.__extends(Engine, _super);
    /**
     * This class defines an engine for Box3D. Each engine instance corresponds to one canvas. If you
     * want to render to multiple canvases, you'll need to instantiate two engines that use the same
     * EntityDispatcher.
     * @param properties                    The engine properties
     * @param properties.resourceLoader     Used to load resources like
     *                                      geometry, textures and animation.
     * @param [properties.engineName]       The name of the engine.
     * @param properties.container          The container for the canvas element. If a
     *                                      string is passed, it is assumed to be a jQuery
     *                                      selector string.
     * @param [properties.canvas]           The element that the engine will draw into.
     *                                      If a string is passed, it is assumed to be a
     *                                      jQuery selector string. If no canvas is supplied,
     *                                      a new one will be created and added to the
     *                                      container.
     * @param [properties.entityDispatcher] Used for synchronizing entities
     *                                      when multiple engines are used. If no entity
     *                                      dispatcher is supplied, a new one will be created.
     * @param [properties.globalEvents]     Used to trigger and listen to global events.
     */
    function Engine(properties) {
        var _this = _super.call(this) || this;
        /** Whether or not the engine should render on demand. */
        _this.renderOnDemand = false;
        /** Whether or not the engine needs to render. */
        _this.needsRender = true;
        /** The Container element. */
        _this.container = undefined;
        /** The global event system which this Engine is configured to use. */
        _this.globalEvents = undefined;
        /** The name of the engine. */
        _this.engineName = 'Unnamed Instance of Box3D Engine';
        /** The context to use for audio. */
        _this.audioContext = undefined;
        /** Whether or not this engine is paused. */
        _this.paused = false;
        /** A mapping of SIDs to runtime names (@see getRuntimeName()). */
        _this.runtimeNames = {};
        /** A number used for the generation of runtime names. */
        _this.nextRuntimeName = 1;
        Logger_1.default.info('Engine Initialization');
        _this.globalScope = properties.globalScope || window;
        // Get and validate global events.
        var initGlobalEvents = function () {
            _this.globalEvents = (properties && properties.globalEvents) || globalEvents_1.default;
            if (!_this.globalEvents) {
                throw new Error('No global event system supplied or found');
            }
        };
        // Initialize the container.
        var initContainer = function () {
            _this.container = _this.container || getElement(properties.container);
            if (!properties.canvas && _this.container) {
                properties.canvas = document.createElement('canvas');
                _this.container.appendChild(properties.canvas);
                _this.canvasCreatedByEngine = true;
            }
        };
        // Validate the canvas.
        var initCanvas = function () {
            _this.canvas = getElement(properties.canvas);
            if (!(_this.canvas instanceof HTMLCanvasElement)) {
                throw new Error('Failed to create canvas element');
            }
        };
        // Validate the resource loader.
        var initResourceLoader = function () {
            _this.resourceLoader = properties.resourceLoader;
            if (!_this.resourceLoader) {
                throw new Error('No resource loader passed to Engine');
            }
        };
        // Initialize member variables.
        var initState = function () {
            _this.engineName = properties.engineName || _this.engineName;
            _this.clock = new THREE.Clock(true);
            _this.frameDelta = 0;
            _this.frameDeltaAggregate = 0;
            _this.frameCount = 0;
            _this.lastFrameDelta = _this.getTimeNow();
            _this.avgFrameTime = 0;
            _this.paused = false;
            _this.documentVisible = true;
            _this.state = 'initializing';
            // Initialize the entity dispatcher.
            _this.entityDispatcher = properties.entityDispatcher ||
                new EntityDispatcher_1.default();
            _this.entityDispatcher.addEngine(_this);
        };
        var initAssetRegistry = function () {
            // Initialize scripts first so that other assets can use them
            // This code is temporary until we remove all asset registry logic
            _this.scriptRegistry = new ScriptRegistry_1.default(_this);
            Object.keys(ShaderAsset_1.default.builtInAssetDescriptors).forEach(function (key) {
                _this.createEntity(ShaderAsset_1.default.builtInAssetDescriptors[key]);
            });
            Object.keys(MaterialAsset_1.default.builtInAssetDescriptors).forEach(function (key) {
                _this.createEntity(MaterialAsset_1.default.builtInAssetDescriptors[key]);
            });
        };
        var initMaterialUtilities = function () {
            _this.materialUtilities = new MaterialUtilities_1.default(_this);
        };
        var initGeometryUtilities = function () {
            _this.geometryUtilities = new GeometryUtilities_1.default();
        };
        var initListeners = function () {
            _this.onResize = function () {
                _this.needsRender = true;
            };
            _this.onBlur = function () {
                _this.trigger('blur');
            };
            _this.onFocus = function () {
                _this.trigger('focus');
            };
            _this.onVisibilityChange = function () {
                var hidden = document.hidden || document.mozHidden ||
                    document.msHidden || document.webkitHidden;
                if (_this.documentVisible && hidden) {
                    _this.documentVisible = false;
                }
                else if (!_this.documentVisible) {
                    _this.frameDelta = 0;
                    // Reset delta calculations.
                    _this.lastFrameDelta = _this.getTimeNow();
                    _this.documentVisible = true;
                }
            };
            window.addEventListener('blur', _this.onBlur);
            window.addEventListener('focus', _this.onFocus);
            _this.listenTo(_this, 'resize', _this.onResize);
            document.addEventListener('visibilitychange', _this.onVisibilityChange);
        };
        var initFinish = function () {
            // Add the engine to "window" to help with debugging.
            _this.globalScope[_this.engineName] = _this;
            // Run the update loop once.
            _this.update();
            _this.state = 'initialized';
            _this.trigger('resize');
        };
        // Run each initialize task.
        initGlobalEvents();
        initContainer();
        initCanvas();
        initResourceLoader();
        initState();
        initAssetRegistry();
        initMaterialUtilities();
        initGeometryUtilities();
        initListeners();
        initFinish();
        return _this;
    }
    /**
     * Destroy the engine, cleaning up all memory and un-registering
     * the engine from the entity dispatcher.
     */
    Engine.prototype.destroy = function () {
        _super.prototype.destroy.call(this);
        Logger_1.default.info(this.engineName + ' - Destroying engine.');
        if (window[this.engineName]) {
            delete window[this.engineName];
        }
        this.baseRenderer = undefined;
        // destroy the resource loader and abort all requests
        this.resourceLoader.destroy();
        this.materialUtilities.destroy();
        this.geometryUtilities.destroy();
        // Remove event listeners.
        window.removeEventListener('blur', this.onBlur);
        window.removeEventListener('focus', this.onFocus);
        this.stopListening(this, 'resize', this.onResize);
        document.removeEventListener('visibilitychange', this.onVisibilityChange);
        this.onBlur = undefined;
        this.onFocus = undefined;
        this.onResize = undefined;
        this.onVisibilityChange = undefined;
        this.trigger('shutdown');
        this.state = 'uninitializing';
        this.cancelAnimationFrame(this.animationRequestID);
        if (this.canvas && this.canvasCreatedByEngine) {
            this.canvas.parentNode.removeChild(this.canvas);
        }
        if (this.entityDispatcher) {
            this.entityDispatcher.removeEngine(this);
        }
        this.clock = undefined;
        this.canvas = undefined;
        this.container = undefined;
        this.threeRenderer = undefined;
        this.baseRenderer = undefined;
        this.engineName = undefined;
        this.entityDispatcher = undefined;
        this.state = 'uninitialized';
    };
    /**
     * Return the name of the engine
     * @returns The name of this engine.
     */
    Engine.prototype.getName = function () {
        return this.engineName;
    };
    /**
     * Register all entities in the given collection into the runtime.
     * @param collection The entity collection
     * @returns An array of entity descriptors
     * that were added to the engine.
     */
    Engine.prototype.addEntities = function (entityArray) {
        return this.entityDispatcher.addEntities(entityArray);
    };
    /**
     * Adds entities from a remote url.
     * @param url
     * @returns A promise that resolves after the entities are all added.
     */
    Engine.prototype.addRemoteEntities = function (url) {
        var _this = this;
        return new Promise(function (resolve, reject) {
            _this.resourceLoader.load(url, LoadingType_1.default.ENTITIES, {})
                .on(LoadingEvent_1.default.LOAD, function (entities) {
                resolve(_this.addEntities(entities));
            })
                .on(LoadingEvent_1.default.ERROR, function (err) { return reject(err); });
        });
    };
    /**
     * Load the entities given by an array of entity ID's.
     * @param  {Array}   entityArray An array of entity ID's or an array of entities
     * @param  {Function} callback    Called when all of the given entities are completely loaded
     * @param {String} [loadEvent=load] The name of the loading event to listen for on each entity.
     * Default is 'load'.
     */
    Engine.prototype.loadEntities = function (entityArray, callback, loadEvent) {
        var _this = this;
        if (loadEvent === void 0) { loadEvent = 'load'; }
        Promise.all(entityArray.map(function (o) {
            var id = (o instanceof BaseEntity_1.default) ? o.id : o;
            return new Promise(function (resolve, reject) {
                var entity = _this.getEntityById(id);
                if (entity) {
                    entity.when(loadEvent, function () {
                        resolve();
                    });
                    if (entity.isUnloaded()) {
                        entity.load();
                    }
                }
                else {
                    reject(new Error('Entity can\'t be found.'));
                }
            });
        })).then(function () {
            if (typeof callback === 'function') {
                callback.call(_this);
            }
        }).catch(function (err) {
            if (typeof callback === 'function') {
                Logger_1.default.error('loadEntities error: ' + err);
                callback.call(_this, err);
            }
        });
    };
    /**
     * Mark the given device as the current VR device being rendered to. This allows
     * the render loop to be controlled by the requestAnimationFrame on the device rather
     * than the window.
     * @param device The device returned by navigator.getVrDisplays
     */
    Engine.prototype.setVrDisplay = function (device) {
        var _this = this;
        this.cancelAnimationFrame(this.animationRequestID);
        this.vrDevice = device;
        this.animationRequestID = this.requestAnimationFrame(function () {
            _this.needsRender = true;
            _this.update();
        });
    };
    /**
     * Return the current VRDisplay being used, if any.
     * @returns The current VRDisplay.
     */
    Engine.prototype.getVrDisplay = function () {
        return this.vrDevice;
    };
    /**
     * Returns the current active application.
     * @returns The application asset
     */
    Engine.prototype.getApplication = function () {
        var apps = this.getAssetsByType('application');
        return apps.find(function (app) { return app.isBaseLoaded(); });
    };
    /**
     * Return the rendering component currently assigned to the engine.
     * @return The rendering component.
     */
    Engine.prototype.getRenderer = function () {
        return this.baseRenderer;
    };
    /**
     * Assign a new component that will serve as the main renderer in this engine.
     * This renderer can be accessed from any other component via the component.getRenderer()
     * call or from the engine with the same call.
     * @param newRenderer The renderer component.
     */
    Engine.prototype.setRenderer = function (newRenderer) {
        if (this.baseRenderer) {
            this.baseRenderer.onShutdown();
            this.baseRenderer.stopListening();
        }
        this.baseRenderer = newRenderer;
        this.threeRenderer = newRenderer.threeRenderer;
    };
    /**
     * Get the THREE.WebGLRenderer associated with this Engine.
     * @returns The Three.js renderer currently in use.
     */
    Engine.prototype.getThreeRenderer = function () {
        return this.baseRenderer.threeRenderer;
    };
    /**
     * Given the name of a GPU device capability (e.g. MAX_VERTEX_TEXTURE_IMAGE_UNITS ),
     * return the current system's value for this capability.
     * @returns The value of the capability.
     */
    Engine.prototype.getGPUCapability = function (cap) {
        return this.baseRenderer.caps[cap];
    };
    /**
     * Get the audio context currently in use.
     * @returns The current audio context.
     */
    Engine.prototype.getAudioContext = function () {
        if (!this.audioContext) {
            // moved this from engine startup to here this stops the engine
            // from going down if too many audio contexts have been created
            // as a bonus, it's only created when it's needed
            var audioContext = this.globalScope.AudioContext || this.globalScope.webkitAudioContext;
            if (audioContext) {
                this.audioContext = new audioContext();
                if (!this.audioContext) {
                    Logger_1.default.warn(this.engineName + ' - Failed to create Web Audio API context');
                }
            }
        }
        return this.audioContext;
    };
    /**
     * Get the runtime name for the specified SID. This method returns a unique name for each unique
     * SID. The returned name is guaranteed to be compatible with the runtime's animation system,
     * which requires object names to contain "word" characters (i.e., [a-zA-Z0-9] and '_'.
     * @param sid The SID to return a runtime name for.
     * @returns   The runtime name.
     */
    Engine.prototype.getRuntimeName = function (sid) {
        if (!this.runtimeNames.hasOwnProperty(sid)) {
            this.runtimeNames[sid] = this.nextRuntimeName.toString();
            this.nextRuntimeName++;
        }
        return this.runtimeNames[sid];
    };
    /**
     * Pause the engine
     */
    Engine.prototype.pause = function () {
        if (!this.paused) {
            this.paused = true;
            this.clock.stop();
            this.cancelAnimationFrame(this.animationRequestID);
            Logger_1.default.info(this.engineName + ' engine has been paused.');
        }
    };
    /**
     * Unpause the engine
     */
    Engine.prototype.unpause = function () {
        if (this.paused) {
            this.paused = false;
            this.frameDelta = 0;
            this.lastFrameDelta = this.getTimeNow();
            this.clock.start();
            Logger_1.default.info(this.engineName + ' engine has been unpaused.');
            this.update();
        }
    };
    /**
     * Sets the current application.
     * @param appId The application asset ID.
     */
    Engine.prototype.setCurrentApp = function (appId) {
        var app = this.getAssetById(appId);
        if (app) {
            if (this.currentApplication) {
                Logger_1.default.warn('Already an application running in this engine. Stop it before starting the '
                    + app.getName() + ' application.');
                this.currentApplication.unload();
            }
            this.currentApplication = app;
        }
    };
    /**
     * Get the current time.
     * @returns The current time.
     */
    Engine.prototype.getTimeNow = function () {
        return ((!!window.performance && !!window.performance.now)
            ? window.performance.now() : Date.now()) * 0.001;
    };
    /**
     * Updates the engine.
     */
    Engine.prototype.update = function () {
        var _this = this;
        // Remember to put visible check.
        if (this.paused) {
            return;
        }
        this.animationRequestID = this.requestAnimationFrame(function () {
            _this.update();
        });
        if (!this.documentVisible) {
            return;
        }
        this.frameCount++;
        this.frameDelta = this.getTimeNow() - this.lastFrameDelta;
        this.lastFrameDelta = this.getTimeNow();
        this.frameDeltaAggregate += this.frameDelta;
        this.avgFrameTime = this.frameDeltaAggregate / this.frameCount;
        this.trigger('preUpdate', this.frameDelta);
        this.trigger('update', this.frameDelta);
        this.trigger('postUpdate', this.frameDelta);
        if (!this.renderOnDemand || this.needsRender) {
            this.needsRender = false;
            this.trigger('preRender', this.frameDelta);
            this.trigger('render', this.frameDelta);
            this.trigger('renderGroup1', this.frameDelta);
            this.trigger('renderGroup2', this.frameDelta);
            this.trigger('renderGroup3', this.frameDelta);
            this.trigger('renderGroup4', this.frameDelta);
            this.trigger('renderGroup5', this.frameDelta);
            this.trigger('renderGroup6', this.frameDelta);
            this.trigger('renderGroup7', this.frameDelta);
            this.trigger('renderGroup8', this.frameDelta);
            this.trigger('renderGroup9', this.frameDelta);
            this.trigger('renderGroup10', this.frameDelta);
            this.trigger('postRender', this.frameDelta);
        }
    };
    /**
     * The engine's request animation callback. This just calls the browser's RAF
     * callback unless there is a WebVR device activated. Then, this calls the RAF
     * on the VR device.
     * @param fn Callback to be executed each frame
     */
    Engine.prototype.requestAnimationFrame = function (fn) {
        if (this.vrDevice) {
            return this.vrDevice.requestAnimationFrame(fn);
        }
        return requestAnimationFrame(fn);
    };
    /**
     * The engine's cancel animation callback. This just calls the browser's CAF
     * callback unless there is a WebVR device activated. Then, this calls the CAF
     * on the VR device.
     * @param requestId ID of the current RAF callback
     */
    Engine.prototype.cancelAnimationFrame = function (requestId) {
        if (this.vrDevice) {
            return this.vrDevice.cancelAnimationFrame(requestId);
        }
        return cancelAnimationFrame(requestId);
    };
    return Engine;
}(exports.engineMixins));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Engine;


/***/ },
/* 106 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var NodeObject_1 = __webpack_require__(9);
var Schemas_1 = __webpack_require__(4);
/**
 * @class BoneObject
 * @constructor
 */
var BoneObject = (function (_super) {
    tslib_1.__extends(BoneObject, _super);
    function BoneObject() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    BoneObject.prototype.createRuntimeData = function (callback) {
        this.runtimeData = new THREE.Bone(null);
        this.runtimeData.name = this.getRuntimeName();
        callback(this);
    };
    return BoneObject;
}(NodeObject_1.default));
Schemas_1.addSchemas('BoneObject', BoneObject);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = BoneObject;


/***/ },
/* 107 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var THREE = __webpack_require__(1);
var NodeObject_1 = __webpack_require__(9);
var Schemas_1 = __webpack_require__(4);
/**
 * @class CameraObject
 * @constructor
 */
var CameraObject = (function (_super) {
    tslib_1.__extends(CameraObject, _super);
    function CameraObject() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    CameraObject.prototype.createRuntimeData = function (callback) {
        var type = this.getProperty('cameraType');
        if (type === 'orthographic') {
            this.runtimeData = new THREE.OrthographicCamera(this.getProperty('left') || 0, this.getProperty('right') || 0, this.getProperty('top') || 0, this.getProperty('bottom') || 0);
        }
        else {
            this.runtimeData = new THREE.PerspectiveCamera();
        }
        this.runtimeData.name = this.getRuntimeName();
        callback(this);
    };
    /** @inheritdoc */
    CameraObject.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        // If the camera type changed, we need to re-create runtimeData.
        if (changes.hasOwnProperty('cameraType') && reason !== 'init') {
            this.reloadBase();
            return;
        }
        var type = this.getProperty('cameraType');
        if (type === 'perspective') {
            // If any of the camera properties have changed, we'll need to update the
            // projection matrix for the camera.
            if (changes.hasOwnProperty('fov') ||
                changes.hasOwnProperty('aspect') ||
                changes.hasOwnProperty('near') ||
                changes.hasOwnProperty('far')) {
                this.runtimeData.fov = this.getProperty('fov');
                this.runtimeData.aspect = this.getProperty('aspect');
                this.runtimeData.near = this.getProperty('near');
                this.runtimeData.far = this.getProperty('far');
                this.runtimeData.updateProjectionMatrix();
            }
        }
        else if (type === 'orthographic') {
            // If any of the shadow camera properties have changed, we'll need to update the
            // projection matrix for the camera.
            if (changes.hasOwnProperty('left') ||
                changes.hasOwnProperty('right') ||
                changes.hasOwnProperty('top') ||
                changes.hasOwnProperty('bottom') ||
                changes.hasOwnProperty('near') ||
                changes.hasOwnProperty('far')) {
                this.runtimeData.left = this.getProperty('left');
                this.runtimeData.right = this.getProperty('right');
                this.runtimeData.top = this.getProperty('top');
                this.runtimeData.bottom = this.getProperty('bottom');
                this.runtimeData.near = this.getProperty('near');
                this.runtimeData.far = this.getProperty('far');
                this.runtimeData.updateProjectionMatrix();
            }
        }
    };
    return CameraObject;
}(NodeObject_1.default));
Schemas_1.addSchemas('CameraObject', CameraObject);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = CameraObject;


/***/ },
/* 108 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* tslint:disable no-bitwise */
"use strict";
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var NodeObject_1 = __webpack_require__(9);
var Schemas_1 = __webpack_require__(4);
/**
 * @class LightObject
 * @constructor
 */
var LightObject = (function (_super) {
    tslib_1.__extends(LightObject, _super);
    function LightObject() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    LightObject.prototype.initialize = function () {
        _super.prototype.initialize.call(this);
        this.on('setColor', this.setColor, this);
        this.on('setIntensity', this.setIntensity, this);
    };
    /** @inheritdoc */
    LightObject.prototype.uninitialize = function () {
        this.off('setColor', this.setColor, this);
        this.off('setIntensity', this.setIntensity, this);
        _super.prototype.uninitialize.call(this);
    };
    /** @inheritdoc */
    LightObject.prototype.createRuntimeData = function (callback) {
        var type = this.getProperty('lightType');
        if (type === 'directional') {
            this.runtimeData = new THREE.DirectionalLight();
        }
        else if (type === 'ambient') {
            this.runtimeData = new THREE.AmbientLight();
        }
        else if (type === 'spot') {
            this.runtimeData = new THREE.SpotLight();
        }
        else if (type === 'hemisphere') {
            this.runtimeData = new THREE.HemisphereLight();
        }
        else {
            this.runtimeData = new THREE.PointLight();
        }
        this.runtimeData.name = this.getRuntimeName();
        callback(this);
    };
    /** @inheritdoc */
    LightObject.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        // If the light type changed, we need to re-create the runtimeData.
        if (changes.hasOwnProperty('lightType') && reason !== 'init') {
            this.reloadBase();
            return;
        }
        if (changes.hasOwnProperty('intensity')) {
            this.runtimeData.intensity = this.getProperty('intensity');
        }
        if (changes.hasOwnProperty('color')) {
            this.runtimeData.color.copy(this.getProperty('color'));
        }
        var type = this.getProperty('lightType');
        if (type === 'directional') {
            // If any of the shadow camera properties have changed, we'll need to update the
            // projection matrix for the camera.
            if (changes.hasOwnProperty('shadowCameraNear') ||
                changes.hasOwnProperty('shadowCameraFar') ||
                changes.hasOwnProperty('shadowCameraLeft') ||
                changes.hasOwnProperty('shadowCameraRight') ||
                changes.hasOwnProperty('shadowCameraTop') ||
                changes.hasOwnProperty('shadowCameraBottom')) {
                if (this.runtimeData.shadowCamera) {
                    this.runtimeData.shadow.camera.near = this.getProperty('shadowCameraNear');
                    this.runtimeData.shadow.camera.far = this.getProperty('shadowCameraFar');
                    this.runtimeData.shadow.camera.left = this.getProperty('shadowCameraLeft');
                    this.runtimeData.shadow.camera.right = this.getProperty('shadowCameraRight');
                    this.runtimeData.shadow.camera.top = this.getProperty('shadowCameraTop');
                    this.runtimeData.shadow.camera.bottom = this.getProperty('shadowCameraBottom');
                    this.runtimeData.shadow.camera.updateProjectionMatrix();
                }
            }
            if (changes.hasOwnProperty('shadowBias')) {
                this.runtimeData.shadow.bias = this.getProperty('shadowBias');
            }
            if (changes.hasOwnProperty('shadowMapWidth') ||
                changes.hasOwnProperty('shadowMapHeight')) {
                var maxSize = this.engine.getGPUCapability('MAX_TEXTURE_SIZE');
                this.runtimeData.shadow.width = Math.min(maxSize, this.getProperty('shadowMapWidth'));
                this.runtimeData.shadow.height = Math.min(maxSize, this.getProperty('shadowMapHeight'));
                this.disposeShadowMap();
            }
            if (changes.hasOwnProperty('castShadow')) {
                this.runtimeData.castShadow = this.getProperty('castShadow');
                if (!this.runtimeData.castShadow) {
                    this.disposeShadowMap();
                }
            }
        }
        else if (type === 'point') {
            if (changes.hasOwnProperty('scale')) {
                this.runtimeData.distance = 100 * this.getProperty('scale').x;
            }
        }
    };
    /**
     * Cleanup the shadowmap data for the light, if any.
     * @method disposeShadowMap
     * @private
     * @return {void}
     */
    LightObject.prototype.disposeShadowMap = function () {
        if (this.runtimeData.shadowMap) {
            this.runtimeData.shadowMap.dispose();
            this.runtimeData.shadowMap = undefined;
            if (this.runtimeData.cameraHelper && this.runtimeData.cameraHelper.parent) {
                this.runtimeData.cameraHelper.parent.remove(this.runtimeData.cameraHelper);
            }
            if (this.runtimeData.shadowCamera && this.runtimeData.shadowCamera.parent) {
                this.runtimeData.shadowCamera.parent.remove(this.runtimeData.shadowCamera);
            }
            this.runtimeData.shadowCamera = undefined;
            this.runtimeData.cameraHelper = undefined;
        }
    };
    /** @inheritdoc */
    LightObject.prototype.unload = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        if (this.runtimeData) {
            if (this.runtimeData.shadowMap) {
                Logger_1.default.info(this.engine.getName() + ' - Deallocating shadow map texture for light ' +
                    this.getName());
                this.disposeShadowMap();
            }
        }
        _super.prototype.unload.call(this, recursive);
    };
    /**
     * Set the color of the light.
     * @method setColor
     * @public
     * @param {number} newValue        New color in numeric form (rgb)
     * @param {number} [animationTime] Optional time to animate the color change over.
     */
    LightObject.prototype.setColor = function (newValue, animationTime) {
        var _this = this;
        var ellapsedTime = 0.0;
        var newR;
        var newG;
        var newB;
        var oldR;
        var oldG;
        var oldB;
        var oldValue;
        var animateValue = function (delta) {
            ellapsedTime += delta;
            if (ellapsedTime > animationTime) {
                _this.engine.off('update', animateValue, _this);
                _this.setProperty('color', newValue);
            }
            else {
                // Interpolate
                var interp = Math.min(ellapsedTime / animationTime, 1.0);
                var interpR = (1.0 - interp) * oldR + interp * newR;
                var interpG = (1.0 - interp) * oldG + interp * newG;
                var interpB = (1.0 - interp) * oldB + interp * newB;
                _this.runtimeData.color.setRGB(interpR, interpG, interpB);
            }
        };
        if (animationTime) {
            oldValue = this.getProperty('color');
            oldR = (oldValue >> 16 & 255) / 255;
            oldG = (oldValue >> 8 & 255) / 255;
            oldB = (oldValue & 255) / 255;
            newR = (newValue >> 16 & 255) / 255;
            newG = (newValue >> 8 & 255) / 255;
            newB = (newValue & 255) / 255;
            this.engine.on('update', animateValue, this);
        }
        else {
            this.setProperty('color', newValue);
        }
    };
    /**
     * Set the brightness of the light.
     * @method setIntensity
     * @public
     * @param {number} newValue      The intensity of the light.
     * @param {number} [animationTime] Optional time to animate the brightness change over.
     */
    LightObject.prototype.setIntensity = function (newValue, animationTime) {
        var _this = this;
        var ellapsedTime = 0.0;
        var oldValue;
        var animateValue = function (delta) {
            ellapsedTime += delta;
            if (ellapsedTime > animationTime) {
                _this.engine.off('update', animateValue, _this);
                _this.setProperty('intensity', newValue);
            }
            else {
                // Interpolate
                var interp = Math.min(ellapsedTime / animationTime, 1.0);
                var interpValue = (1.0 - interp) * oldValue + interp * newValue;
                _this.runtimeData.intensity = interpValue;
            }
        };
        if (animationTime) {
            oldValue = this.getProperty('intensity');
            this.engine.on('update', animateValue, this);
        }
        else {
            this.setProperty('intensity', newValue);
        }
    };
    return LightObject;
}(NodeObject_1.default));
/** @inheritdoc */
LightObject.events = {
    setColor: {
        scope: 'local',
        action: true,
        category: 'Materials',
        params: [
            {
                name: 'value',
                type: 'c',
                description: 'The colour to set.',
                default: 0xff0000
            },
            {
                name: 'animationTime',
                type: 'f',
                description: 'The length of time that the change will take. ' +
                    'i.e. this lets you animate the change.',
                default: 0.0,
                min: 0.0
            }
        ]
    },
    setIntensity: {
        scope: 'local',
        action: true,
        category: 'Materials',
        params: [
            {
                name: 'value',
                type: 'f',
                description: 'The intensity to set.',
                default: 1.0
            },
            {
                name: 'animationTime',
                type: 'f',
                description: 'The length of time that the change will take. ' +
                    'i.e. this lets you animate the change.',
                default: 0.0,
                min: 0.0
            }
        ]
    }
};
Schemas_1.addSchemas('LightObject', LightObject);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LightObject;


/***/ },
/* 109 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var Logger_1 = __webpack_require__(3);
var THREE = __webpack_require__(1);
var NodeObject_1 = __webpack_require__(9);
var Schemas_1 = __webpack_require__(4);
/**
 * @class SceneObject
 * @constructor
 */
var SceneObject = (function (_super) {
    tslib_1.__extends(SceneObject, _super);
    function SceneObject() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    SceneObject.prototype.createRuntimeData = function (callback) {
        this.runtimeData = new THREE.Scene();
        this.runtimeData.matrixAutoUpdate = false;
        this.runtimeData.name = this.getName();
        callback();
    };
    /** @inheritdoc */
    SceneObject.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (!this.getProperty('fogEnabled')) {
            this.runtimeData.fog = null;
        }
        else {
            if (!this.runtimeData.fog) {
                this.runtimeData.fog = new THREE.FogExp2(this.getProperty('fogColor'));
            }
            if (changes.hasOwnProperty('fogColor')) {
                this.runtimeData.fog.color.setHex(this.getProperty('fogColor'));
            }
            if (changes.hasOwnProperty('fogDensity')) {
                this.runtimeData.fog.density = this.getProperty('fogDensity');
            }
        }
        if (changes.hasOwnProperty('fogEnabled')) {
            this.engine.trigger('rebuildMaterials');
            this.engine.needsRender = true;
        }
    };
    /** @inheritdoc */
    SceneObject.prototype.unload = function (recursive) {
        if (recursive === void 0) { recursive = false; }
        if (this.runtimeData) {
            Logger_1.default.info('Unloading scene, ' + this.getName());
            _super.prototype.unload.call(this, recursive);
        }
    };
    return SceneObject;
}(NodeObject_1.default));
Schemas_1.addSchemas('SceneObject', SceneObject);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = SceneObject;


/***/ },
/* 110 */
/***/ function(module, exports) {

"use strict";
"use strict";
var accessor = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'accessor',
    title: 'AccessorDef',
    type: 'object',
    description: 'A typed-view into raw binary data.',
    properties: {
        componentType: {
            type: 'string',
            enum: ['int8', 'uint8', 'int16', 'int32', 'uint32', 'float32', 'float64'],
            description: 'These correspond to typed arrays: Int8Array, Uint8Array, ' +
                'Int16Array, Uint16Array, Int32Array, Uint32Array, Float32Array, Float64Array.'
        },
        type: {
            type: 'string',
            enum: ['scalar', 'vec2', 'vec3', 'vec4', 'mat2', 'mat3', 'mat4'],
            description: 'Specifies if elements are scalars, vectors or matrices.'
        },
        byteOffset: {
            type: 'integer',
            description: 'Byte offset into the binary data.'
        },
        byteStride: {
            type: 'integer',
            description: 'The number of bytes between successive elements (0 indicates that ' +
                'the elements are tightly packed).'
        },
        count: {
            type: 'integer',
            description: 'The number of elements, not to be confused with the number of ' +
                'components or bytes. For example, the number of positions, not the number of floats.'
        }
    },
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = accessor;


/***/ },
/* 111 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var animationAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'animationAsset', title: 'AnimationAssetDef', type: 'object', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['animation']
        }, properties: {
            $ref: 'animationAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = animationAsset;


/***/ },
/* 112 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var animationAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'animationAssetProperties', title: 'AnimationAssetPropertiesDef', type: 'object', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { clips: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'animationClip.json'
            },
            default: {}
        }, layers: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'animationLayer.json'
            },
            defualt: {}
        }, channels: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'animationChannel.json'
            },
            default: {}
        } }), required: [
        'clips',
        'layers',
        'channels'
    ] });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = animationAssetProperties;


/***/ },
/* 113 */
/***/ function(module, exports) {

"use strict";
"use strict";
var animationChannel = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'animationChannel',
    title: 'AnimationChannelDef',
    type: 'object',
    description: 'An animation channel.',
    properties: {
        name: {
            type: 'string',
            description: 'The channel\'s name.'
        },
        targetObject: {
            type: 'array',
            description: 'The path of the object to animate.',
            items: {
                type: 'string'
            },
            default: []
        },
        targetProperty: {
            type: 'string',
            description: 'The path of the property to animate.'
        },
        values: {
            type: 'string',
            description: 'The ID of the accessor for the channel values.'
        },
        times: {
            type: 'string',
            description: 'The ID of the accessor for the channel times.'
        },
        interpolation: {
            type: 'string',
            enum: ['linear'],
            description: 'The interpolation type for the channel.'
        }
    },
    required: ['name', 'targetObject', 'targetProperty', 'values', 'times', 'interpolation'],
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = animationChannel;


/***/ },
/* 114 */
/***/ function(module, exports) {

"use strict";
"use strict";
var animationClip = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'animationClip',
    title: 'AnimationClipDef',
    type: 'object',
    description: 'An animation clip.',
    properties: {
        name: {
            type: 'string',
            description: 'The clip\'s name.'
        },
        start: {
            type: 'number',
            description: 'The take\'s start time, in seconds.',
            default: 0
        },
        stop: {
            type: 'number',
            description: 'The take\'s stop time, in seconds.',
            default: 0
        },
        layers: {
            type: 'array',
            items: {
                type: 'string'
            },
            default: []
        }
    },
    required: ['name', 'start', 'stop', 'layers'],
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = animationClip;


/***/ },
/* 115 */
/***/ function(module, exports) {

"use strict";
"use strict";
var animationLayer = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'animationLayer',
    title: 'AnimationLayerDef',
    type: 'object',
    description: 'An animation layer.',
    properties: {
        name: {
            type: 'string',
            description: 'The layer\'s name.'
        },
        blendMode: {
            enum: ['additive'],
            description: 'The layer\'s blend mode.',
            default: 'additive'
        },
        blendWeight: {
            type: 'number',
            description: 'The layer\'s blend weight.',
            default: 1
        },
        channels: {
            type: 'array',
            items: {
                type: 'string'
            },
            default: []
        }
    },
    required: ['name', 'blendMode', 'blendWeight', 'channels'],
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = animationLayer;


/***/ },
/* 116 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var applicationAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'applicationAsset', title: 'ApplicationAssetDef', type: 'object', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['application']
        }, properties: {
            $ref: 'applicationAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = applicationAsset;


/***/ },
/* 117 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var applicationAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'applicationAssetProperties', title: 'ApplicationAssetPropertiesDef', type: 'object', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { startupSceneId: {
            type: 'string'
        } }), required: [
        'startupSceneId'
    ] });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = applicationAssetProperties;


/***/ },
/* 118 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var audioAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'audioAsset', title: 'AudioAssetDef', type: 'object', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['audio']
        }, properties: {
            $ref: 'audioAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = audioAsset;


/***/ },
/* 119 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var audioAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'audioAssetProperties', title: 'AudioAssetPropertiesDef' });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = audioAssetProperties;


/***/ },
/* 120 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var nodeObject_1 = __webpack_require__(15);
var boneObject = tslib_1.__assign({}, nodeObject_1.default, { id: 'boneObject', title: 'BoneObjectDef', properties: tslib_1.__assign({}, nodeObject_1.default.properties, { type: {
            enum: ['bone']
        }, properties: {
            $ref: 'boneObjectProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = boneObject;


/***/ },
/* 121 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var nodeObjectProperties_1 = __webpack_require__(16);
var boneObjectProperties = tslib_1.__assign({}, nodeObjectProperties_1.default, { id: 'boneObjectProperties', title: 'BoneObjectPropertiesDef' });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = boneObjectProperties;


/***/ },
/* 122 */
/***/ function(module, exports) {

"use strict";
"use strict";
var box3 = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'box3',
    title: 'Box3Def',
    type: 'object',
    properties: {
        min: {
            $ref: 'vector3.json'
        },
        max: {
            $ref: 'vector3.json'
        }
    },
    required: ['min', 'max'],
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = box3;


/***/ },
/* 123 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var bufferAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'bufferAsset', title: 'BufferAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['buffer']
        }, properties: {
            $ref: 'bufferAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = bufferAsset;


/***/ },
/* 124 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var bufferAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'bufferAssetProperties', title: 'BufferAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { src: {
            type: 'string',
            description: 'The URL of the binary file.'
        }, contentLength: {
            type: 'number',
            description: 'The HTTP Content-Length.'
        }, accessors: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'accessor.json'
            },
            description: 'Typed-views into the binary file.'
        } }), required: [
        'src',
        'contentLength'
    ] });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = bufferAssetProperties;


/***/ },
/* 125 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var nodeObject_1 = __webpack_require__(15);
var cameraObject = tslib_1.__assign({}, nodeObject_1.default, { id: 'cameraObject', title: 'CameraObjectDef', properties: tslib_1.__assign({}, nodeObject_1.default.properties, { type: {
            enum: ['camera']
        }, properties: {
            $ref: 'cameraObjectProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = cameraObject;


/***/ },
/* 126 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var nodeObjectProperties_1 = __webpack_require__(16);
var cameraObjectProperties = tslib_1.__assign({}, nodeObjectProperties_1.default, { id: 'cameraObjectProperties', title: 'CameraObjectPropertiesDef', properties: tslib_1.__assign({}, nodeObjectProperties_1.default.properties, { cameraType: {
            type: 'string',
            description: '',
            default: 'perspective'
        }, fov: {
            type: 'number',
            default: 50
        }, aspect: {
            type: 'number',
            default: 1.77777777777777770
        }, near: {
            type: 'number',
            default: 0.1
        }, far: {
            type: 'number',
            default: 12000.0
        }, right: {
            type: 'number',
            default: 10.0
        }, left: {
            type: 'number',
            default: -10.0
        }, top: {
            type: 'number',
            default: 10.0
        }, bottom: {
            type: 'number',
            default: -10.0
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = cameraObjectProperties;


/***/ },
/* 127 */
/***/ function(module, exports) {

"use strict";
"use strict";
var component = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'component',
    title: 'ComponentDef',
    type: 'object',
    properties: {
        id: {
            type: 'string'
        },
        scriptId: {
            type: 'string'
        },
        name: {
            type: 'string'
        },
        enabled: {
            type: 'boolean'
        },
        attributes: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'componentAttribute.json'
            }
        }
    },
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = component;


/***/ },
/* 128 */
/***/ function(module, exports) {

"use strict";
"use strict";
var componentAttribute = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'componentAttribute',
    title: 'ComponentAttributeDef',
    type: 'object',
    properties: {
        type: {
            type: 'string'
        },
        subType: {
            type: 'object',
            properties: {
                type: {
                    type: 'string'
                },
                attributes: {}
            },
            additionalProperties: false
        },
        attributes: {
            type: 'array',
            items: {
                type: 'object',
                properties: {
                    type: {
                        type: 'string'
                    },
                    attributes: {}
                },
                additionalProperties: false
            }
        }
    },
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = componentAttribute;


/***/ },
/* 129 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var documentAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'documentAsset', title: 'DocumentAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['document']
        }, properties: {
            $ref: 'documentAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = documentAsset;


/***/ },
/* 130 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var documentAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'documentAssetProperties', title: 'DocumentAssetPropertiesDef' });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = documentAssetProperties;


/***/ },
/* 131 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseImageAsset_1 = __webpack_require__(49);
var imageAsset = tslib_1.__assign({}, baseImageAsset_1.default, { id: 'imageAsset', title: 'ImageAssetDef', properties: tslib_1.__assign({}, baseImageAsset_1.default.properties, { type: {
            enum: ['image']
        }, representations: tslib_1.__assign({}, baseImageAsset_1.default.properties.representations, { type: {
                $ref: 'imageRepresentation.json'
            } }), properties: {
            $ref: 'imageAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = imageAsset;


/***/ },
/* 132 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseImageAssetProperties_1 = __webpack_require__(50);
var imageAssetProperties = tslib_1.__assign({}, baseImageAssetProperties_1.default, { id: 'imageAssetProperties', title: 'ImageAssetPropertiesDef', properties: tslib_1.__assign({}, baseImageAssetProperties_1.default.properties, { useCompression: {
            type: 'boolean',
            description: 'True if we will try to use a hardware-compressed version ' +
                'of the image \'instead of a regular one. This depends on the hardware ' +
                'capabilities of the user and the data formats available.',
            default: false
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = imageAssetProperties;


/***/ },
/* 133 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var representation_1 = __webpack_require__(38);
var imageRepresentation = {
    id: 'imageRepresentation',
    title: 'ImageRepresentationDef',
    properties: tslib_1.__assign({}, representation_1.default.properties, { src: {
            type: 'string',
            description: 'The URL of the representation.'
        }, channels: {
            type: 'array',
            items: {
                type: 'string'
            }
        }, compression: {
            type: 'string',
            enum: ['dxt', 'dxt1', 'dxt5', 'jpeg', 'zip']
        }, isExternal: {
            type: 'boolean'
        }, width: {
            type: 'integer',
            description: 'The width, in pixels, of the representation.'
        }, height: {
            type: 'integer',
            description: 'The height, in pixels, of the representation.'
        } }),
    required: ['src'],
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = imageRepresentation;


/***/ },
/* 134 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var nodeObject_1 = __webpack_require__(15);
var lightObject = tslib_1.__assign({}, nodeObject_1.default, { id: 'lightObject', title: 'LightObjectDef', properties: tslib_1.__assign({}, nodeObject_1.default.properties, { type: {
            enum: ['light']
        }, properties: {
            $ref: 'lightObjectProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = lightObject;


/***/ },
/* 135 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var nodeObjectProperties_1 = __webpack_require__(16);
var lightObjectProperties = tslib_1.__assign({}, nodeObjectProperties_1.default, { id: 'lightObjectProperties', title: 'LightObjectPropertiesDef', properties: tslib_1.__assign({}, nodeObjectProperties_1.default.properties, { lightType: {
            type: 'string',
            default: 'directional'
        }, color: {
            type: ['object', 'string', 'number'],
            properties: {
                r: {
                    type: 'number'
                },
                g: {
                    type: 'number'
                },
                b: {
                    type: 'number'
                }
            },
            default: {
                r: 0.7333,
                g: 0.7333,
                b: 0.7333
            }
        }, intensity: {
            type: 'number',
            default: 1.0
        }, distance: {
            type: 'number',
            default: 100.0
        }, castShadow: {
            type: 'boolean',
            default: false
        }, shadowCameraNear: {
            type: 'number',
            default: 0.1
        }, shadowCameraFar: {
            type: 'number',
            default: 20.0
        }, shadowCameraLeft: {
            type: 'number',
            default: -10.0
        }, shadowCameraRight: {
            type: 'number',
            default: 10.0
        }, shadowCameraTop: {
            type: 'number',
            default: 10.0
        }, shadowCameraBottom: {
            type: 'number',
            default: -10.0
        }, shadowBias: {
            type: 'number',
            default: -0.0015
        }, shadowMapWidth: {
            type: 'integer',
            default: 1024
        }, shadowMapHeight: {
            type: 'integer',
            default: 1024
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = lightObjectProperties;


/***/ },
/* 136 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var materialAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'materialAsset', title: 'MaterialAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['material']
        }, properties: {
            $ref: 'materialAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = materialAsset;


/***/ },
/* 137 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var materialAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'materialAssetProperties', title: 'MaterialAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { shader: {
            type: 'string',
            default: 'box3d_pbr_shader'
        }, enabledFeatures: {
            type: ['object', 'null'],
            default: null,
            properties: {},
            additionalProperties: {
                type: 'boolean'
            }
        } }), additionalProperties: true });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = materialAssetProperties;


/***/ },
/* 138 */
/***/ function(module, exports) {

"use strict";
"use strict";
var meshAttribute = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'meshAttribute',
    title: 'MeshAttributeDef',
    type: 'object',
    description: 'Specifies a range of attribute data for the vertices of a mesh.',
    properties: {
        name: {
            type: 'string',
            description: 'The name of the this attribute. For example, texture\'s have ' +
                'a uvSet property that contains the name of a UV attribute.'
        },
        accessorId: {
            type: 'string',
            description: 'The ID of the buffer asset and accessor: <bufferId>#<accessorId>.'
        }
    },
    required: ['name', 'accessorId'],
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = meshAttribute;


/***/ },
/* 139 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseGeometryAsset_1 = __webpack_require__(34);
var meshGeometryAsset = tslib_1.__assign({}, baseGeometryAsset_1.default, { id: 'meshGeometryAsset', title: 'MeshGeometryAssetDef', properties: tslib_1.__assign({}, baseGeometryAsset_1.default.properties, { type: {
            enum: ['meshGeometry']
        }, properties: {
            $ref: 'meshGeometryAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = meshGeometryAsset;


/***/ },
/* 140 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseGeometryAssetProperties_1 = __webpack_require__(35);
var meshGeometryAssetProperties = tslib_1.__assign({}, baseGeometryAssetProperties_1.default, { id: 'meshGeometryAssetProperties', title: 'MeshGeometryAssetPropertiesDef', properties: tslib_1.__assign({}, baseGeometryAssetProperties_1.default.properties, { attributes: {
            type: 'object',
            properties: {},
            additionalProperties: {
                $ref: 'meshAttribute.json'
            },
            description: 'A collection of vertex attributes. All attributes must have the same number of elements.'
        }, indices: {
            type: ['string', 'null'],
            description: 'The ID of the accessor containing the vertex indices: <bufferId>#<accessorId>.'
        }, primitives: {
            type: 'array',
            items: {
                $ref: 'meshPrimitive.json'
            },
            description: 'The primitives (points, lines, triangles) that make up the mesh.'
        } }), required: ['attributes', 'indices', 'primitives'] });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = meshGeometryAssetProperties;


/***/ },
/* 141 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var nodeObject_1 = __webpack_require__(15);
var meshObject = tslib_1.__assign({}, nodeObject_1.default, { id: 'meshObject', title: 'MeshObjectDef', properties: tslib_1.__assign({}, nodeObject_1.default.properties, { type: {
            enum: ['mesh']
        }, properties: {
            $ref: 'meshObjectProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = meshObject;


/***/ },
/* 142 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var nodeObjectProperties_1 = __webpack_require__(16);
var meshObjectProperties = tslib_1.__assign({}, nodeObjectProperties_1.default, { id: 'meshObjectProperties', title: 'MeshObjectPropertiesDef', properties: tslib_1.__assign({}, nodeObjectProperties_1.default.properties, { customDepthMaterial: {
            type: ['string', 'null'],
            default: null
        }, materials: {
            type: 'array',
            default: [
                'missingMaterial'
            ]
        }, geometryId: {
            type: ['string', 'null'],
            default: null
        }, skinId: {
            type: ['string', 'null'],
            default: null
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = meshObjectProperties;


/***/ },
/* 143 */
/***/ function(module, exports) {

"use strict";
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'meshPrimitve',
    title: 'meshPrimitiveDef',
    type: 'object',
    description: 'A mesh primitive with an optional material assignment.',
    properties: {
        primitive: {
            enum: ['points', 'lines', 'triangles'],
            description: 'The type of primitive to render.',
            default: 'triangles'
        },
        count: {
            type: 'integer',
            description: 'The number of vertices to draw.',
            default: 0
        },
        start: {
            type: 'integer',
            description: 'The index of the first vertex to draw.',
            default: 0
        },
        offset: {
            type: 'integer',
            description: 'An offset to apply to each index. This can be used to overcome ' +
                ' the 16-bit index limit imposed by WebGL. For example, the first component ' +
                ' of a vertex attribute with a value size of 3 would be referenced as ' +
                ' follows: values[3 * (offset + indices[start + i])].',
            default: 0
        },
        materialIndex: {
            type: 'integer',
            description: 'The index of the material to apply to the primitive being rendered.',
            default: 0
        }
    },
    required: ['primitve', 'count'],
    additionalProperties: false
};


/***/ },
/* 144 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var prefabAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'prefabAsset', title: 'PrefabAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['prefab']
        }, properties: {
            $ref: 'prefabAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = prefabAsset;


/***/ },
/* 145 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var prefabAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'prefabAssetProperties', title: 'PrefabAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { rootObjectId: {
            type: ['string', 'null'],
            default: null,
            description: 'The ID of the NodeObject that serves as the root node of a hierarchy.'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = prefabAssetProperties;


/***/ },
/* 146 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseGeometryAsset_1 = __webpack_require__(34);
var primitiveGeometryAsset = tslib_1.__assign({}, baseGeometryAsset_1.default, { id: 'primitiveGeometryAsset', title: 'PrimitiveGeometryAssetDef', properties: tslib_1.__assign({}, baseGeometryAsset_1.default.properties, { type: {
            enum: ['primitiveGeometry']
        }, properties: {
            $ref: 'primitiveGeometryAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = primitiveGeometryAsset;


/***/ },
/* 147 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseGeometryAssetProperties_1 = __webpack_require__(35);
var primitiveGeometryAssetProperties = tslib_1.__assign({}, baseGeometryAssetProperties_1.default, { id: 'primitiveGeometryAssetProperties', title: 'PrimitiveGeometryAssetPropertiesDef', properties: tslib_1.__assign({}, baseGeometryAssetProperties_1.default.properties, { type: {
            type: 'string',
            default: 'sphere'
        }, radius: {
            type: 'number',
            default: 100
        }, segmentsU: {
            type: 'integer',
            default: 12
        }, segmentsV: {
            type: 'integer',
            default: 12
        }, sizeX: {
            type: 'number',
            default: 100
        }, sizeY: {
            type: 'number',
            default: 100
        }, sizeZ: {
            type: 'number',
            default: 100
        }, segmentsX: {
            type: 'integer',
            default: 1
        }, segmentsY: {
            type: 'integer',
            default: 1
        }, segmentsZ: {
            type: 'integer',
            default: 1
        }, radiusTop: {
            type: 'number',
            default: 50
        }, radiusBottom: {
            type: 'number',
            default: 50
        }, height: {
            type: 'number',
            default: 100
        }, open: {
            type: 'boolean',
            default: false
        }, tubeRadius: {
            type: 'number',
            default: 20
        }, arcAngle: {
            type: 'number',
            default: 6.2831853071795860
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = primitiveGeometryAssetProperties;


/***/ },
/* 148 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseRenderTextureAsset_1 = __webpack_require__(36);
var renderTexture2DAsset = tslib_1.__assign({}, baseRenderTextureAsset_1.default, { id: 'renderTexture2DAsset', title: 'RenderTexture2DAssetDef', properties: tslib_1.__assign({}, baseRenderTextureAsset_1.default.properties, { type: {
            enum: ['renderTexture2D']
        }, properties: {
            $ref: 'renderTexture2DAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = renderTexture2DAsset;


/***/ },
/* 149 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseRenderTextureAssetProperties_1 = __webpack_require__(37);
var renderTexture2DAsset = tslib_1.__assign({}, baseRenderTextureAssetProperties_1.default, { id: 'renderTexture2DAssetProperties', title: 'RenderTexture2DAssetPropertiesDef' });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = renderTexture2DAsset;


/***/ },
/* 150 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseRenderTextureAsset_1 = __webpack_require__(36);
var renderTextureCubeAsset = tslib_1.__assign({}, baseRenderTextureAsset_1.default, { id: 'renderTextureCubeAsset', title: 'RenderTextureCubeAssetDef', properties: tslib_1.__assign({}, baseRenderTextureAsset_1.default.properties, { type: {
            enum: ['renderTextureCube']
        }, properties: {
            $ref: 'renderTextureCubeAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = renderTextureCubeAsset;


/***/ },
/* 151 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseRenderTextureAssetProperties_1 = __webpack_require__(37);
var renderTextureCubeAssetProperties = tslib_1.__assign({}, baseRenderTextureAssetProperties_1.default, { id: 'renderTextureCubeAssetProperties', title: 'RenderTextureCubeAssetPropertiesDef', properties: tslib_1.__assign({}, baseRenderTextureAssetProperties_1.default.properties, { mappingType: {
            type: 'string',
            description: 'his value is temporarily here for compatibility with ' +
                'three.js. Remove it when adding a separate transform object to textures.',
            default: 'cube'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = renderTextureCubeAssetProperties;


/***/ },
/* 152 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var nodeObject_1 = __webpack_require__(15);
var sceneObject = tslib_1.__assign({}, nodeObject_1.default, { id: 'sceneObject', title: 'SceneObjectDef', properties: tslib_1.__assign({}, nodeObject_1.default.properties, { type: {
            enum: ['scene']
        }, properties: {
            $ref: 'sceneObjectProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = sceneObject;


/***/ },
/* 153 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var nodeObjectProperties_1 = __webpack_require__(16);
var sceneObjectProperties = tslib_1.__assign({}, nodeObjectProperties_1.default, { id: 'sceneObjectProperties', title: 'SceneObjectPropertiesDef', properties: tslib_1.__assign({}, nodeObjectProperties_1.default.properties, { fogEnabled: {
            type: 'boolean',
            default: false
        }, fogType: {
            type: 'string',
            default: 'FogExp2'
        }, fogColor: {
            type: ['number', 'string'],
            default: 12303291
        }, fogDensity: {
            type: 'number',
            default: 0.0004
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = sceneObjectProperties;


/***/ },
/* 154 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var scriptAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'scriptAsset', title: 'ScriptAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['script']
        }, properties: {
            $ref: 'scriptAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = scriptAsset;


/***/ },
/* 155 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var scriptAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'scriptAssetProperties', title: 'ScriptAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { attributes: {
            type: 'object',
            default: {}
        }, description: {
            type: 'string',
            default: ''
        }, events: {
            type: 'object',
            default: {}
        }, externalDependencies: {
            type: 'array',
            default: []
        }, filter: {
            type: 'array',
            default: []
        }, category: {
            type: 'string',
            default: ''
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = scriptAssetProperties;


/***/ },
/* 156 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var shaderAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'shaderAsset', title: 'ShaderAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['shader']
        }, properties: {
            $ref: 'shaderAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = shaderAsset;


/***/ },
/* 157 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var shaderAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'shaderAssetProperties', title: 'ShaderAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { features: {
            type: 'object',
            default: {}
        }, parameters: {
            type: 'object',
            default: {},
            additionalProperties: {
                $ref: 'shaderParameter.json'
            }
        }, uniforms: {
            type: 'object',
            default: {}
        }, vertexShader: {
            type: 'string',
            default: ''
        }, fragmentShader: {
            type: 'string',
            default: ''
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = shaderAssetProperties;


/***/ },
/* 158 */
/***/ function(module, exports) {

"use strict";
"use strict";
var shaderConditions = {
    type: 'object',
    id: 'shaderConditions',
    title: 'ShaderConditionsDef',
    properties: {
        or: {
            type: 'array',
            items: {
                // @FIXME: recursive definitions currently have issues, allowing any object for now
                type: 'object',
                properties: {},
                additionalProperties: true
            }
        },
        equals: {
            oneOf: [
                {
                    type: 'string'
                },
                {
                    type: 'number'
                },
                {
                    type: 'integer'
                },
                {
                    type: 'boolean'
                }
            ]
        },
        notEquals: {
            oneOf: [
                {
                    type: 'string'
                },
                {
                    type: 'number'
                },
                {
                    type: 'integer'
                },
                {
                    type: 'boolean'
                }
            ]
        },
        equalsDefault: {
            type: 'boolean'
        },
        notEqualsDefault: {
            type: 'boolean'
        }
    },
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = shaderConditions;


/***/ },
/* 159 */
/***/ function(module, exports) {

"use strict";
"use strict";
var shaderParameter = {
    id: 'shaderParameter',
    title: 'ShaderParameterDef',
    properties: {
        displayName: {
            type: 'string'
        },
        description: {
            type: 'string'
        },
        isRenderParam: {
            type: 'boolean'
        },
        isUniform: {
            type: 'boolean'
        },
        uniformName: {
            type: 'string'
        },
        type: {
            type: 'string',
            enum: ['b', 'c', 'f', 't', 'opt', 'v2']
        },
        min: {
            type: 'number'
        },
        max: {
            type: 'number'
        },
        options: {
            type: 'object',
            properties: {},
            additionalProperties: true
        },
        displayWhen: {
            properties: {},
            additionalProperties: {
                $ref: 'shaderConditions.json'
            }
        },
        enabledWhen: {
            properties: {},
            additionalProperties: {
                $ref: 'shaderConditions.json'
            }
        },
        defines: {
            properties: {},
            additionalProperties: {
                oneOf: [
                    {
                        type: 'string'
                    },
                    {
                        type: 'number'
                    },
                    {
                        type: 'integer'
                    },
                    {
                        type: 'boolean'
                    }
                ]
            }
        },
        derivatives: {
            type: 'boolean'
        },
        default: {
            anyOf: [
                {
                    type: 'null'
                },
                {
                    type: 'string'
                },
                {
                    type: 'number'
                },
                {
                    type: 'integer'
                },
                {
                    type: 'boolean'
                },
                {
                    // @TODO: Handles, color, v2, etc. We could define these specific
                    // types here if we wanted. (at the cost of larger json data size).
                    type: 'object',
                    properties: {},
                    additionalProperties: true
                }
            ]
        },
        transparency: {
            enum: [
                'LessThanOne',
                'GreaterThanOne'
            ]
        },
        textureUsage: {
            enum: [
                'bump',
                'normal'
            ]
        },
        forceUpdate: {
            type: 'boolean'
        },
        textureType: {
            enum: [
                'Cube'
            ]
        },
        step: {
            type: 'number'
        }
    },
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = shaderParameter;


/***/ },
/* 160 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var skinAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'skinAsset', title: 'SkinAssetDef', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['skin']
        }, properties: {
            $ref: 'skinAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = skinAsset;


/***/ },
/* 161 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAssetProperties_1 = __webpack_require__(8);
var skinAssetProperties = tslib_1.__assign({}, baseAssetProperties_1.default, { id: 'skinAssetProperties', title: 'SkinAssetPropertiesDef', properties: tslib_1.__assign({}, baseAssetProperties_1.default.properties, { bindShapeMatrix: {
            type: 'array',
            description: 'Bind shape matrix specifying how the mesh should be ' +
                'transformed into the right coordinate system for use with the joints.',
            items: {
                type: 'number'
            },
            minItems: 16,
            maxItems: 16,
            default: [
                1.0,
                0.0,
                0.0,
                0.0,
                0.0,
                1.0,
                0.0,
                0.0,
                0.0,
                0.0,
                1.0,
                0.0,
                0.0,
                0.0,
                0.0,
                1.0
            ]
        }, inverseBindMatrices: {
            type: 'string',
            description: 'The ID of the accessor containing the inverse bind matrices: <bufferId>#<accessorId>.'
        }, jointNames: {
            type: 'array',
            description: 'Names of the joints in this skin.',
            items: {
                type: 'string'
            },
            uniqueItems: true,
            default: []
        } }), required: [
        'bindShapeMatrix',
        'inverseBindMatrices',
        'jointNames'
    ] });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = skinAssetProperties;


/***/ },
/* 162 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseTextureAsset_1 = __webpack_require__(22);
var texture2DAsset = tslib_1.__assign({}, baseTextureAsset_1.default, { id: 'texture2DAsset', title: 'Texture2DAssetDef', properties: tslib_1.__assign({}, baseTextureAsset_1.default.properties, { type: {
            enum: ['texture2D']
        }, properties: {
            $ref: 'texture2DAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = texture2DAsset;


/***/ },
/* 163 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseTextureAssetProperties_1 = __webpack_require__(19);
var texture2DAssetProperties = tslib_1.__assign({}, baseTextureAssetProperties_1.default, { id: 'texture2DAssetProperties', title: 'Texture2DAssetPropertiesDef' });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = texture2DAssetProperties;


/***/ },
/* 164 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseTextureAsset_1 = __webpack_require__(22);
var textureCubeAsset = tslib_1.__assign({}, baseTextureAsset_1.default, { id: 'textureCubeAsset', title: 'TextureCubeAssetDef', properties: tslib_1.__assign({}, baseTextureAsset_1.default.properties, { type: {
            enum: ['textureCube']
        }, properties: {
            $ref: 'textureCubeAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = textureCubeAsset;


/***/ },
/* 165 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseTextureAssetProperties_1 = __webpack_require__(19);
var textureCubeAssetProperties = tslib_1.__assign({}, baseTextureAssetProperties_1.default, { id: 'textureCubeAssetProperties', title: 'TextureCubeAssetPropertiesDef', properties: tslib_1.__assign({}, baseTextureAssetProperties_1.default.properties, { 
        // This value is temporarily here for compatibility with three.js
        // Remove it when adding a separate transform object to textures.
        mappingType: {
            type: 'string',
            default: 'cube'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = textureCubeAssetProperties;


/***/ },
/* 166 */
/***/ function(module, exports) {

"use strict";
"use strict";
var vector3 = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'vector3',
    title: 'Vector3Def',
    type: 'object',
    properties: {
        x: {
            type: 'number'
        },
        y: {
            type: 'number'
        },
        z: {
            type: 'number'
        }
    },
    required: ['x', 'y', 'z'],
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = vector3;


/***/ },
/* 167 */
/***/ function(module, exports) {

"use strict";
"use strict";
var vector4 = {
    $schema: 'http://json-schema.org/draft-04/schema',
    id: 'vector4',
    title: 'Vector4Def',
    type: 'object',
    properties: {
        x: {
            type: 'number'
        },
        y: {
            type: 'number'
        },
        z: {
            type: 'number'
        },
        w: {
            type: 'number'
        }
    },
    required: ['x', 'y', 'z', 'w'],
    additionalProperties: false
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = vector4;


/***/ },
/* 168 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseAsset_1 = __webpack_require__(5);
var videoAsset = tslib_1.__assign({}, baseAsset_1.default, { id: 'videoAsset', title: 'VideoAssetDef', type: 'object', properties: tslib_1.__assign({}, baseAsset_1.default.properties, { type: {
            enum: ['video']
        }, representations: tslib_1.__assign({}, baseAsset_1.default.properties.representations, { type: {
                $ref: 'videoRepresentation.json'
            } }), properties: {
            $ref: 'videoAssetProperties.json'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = videoAsset;


/***/ },
/* 169 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var baseTextureAssetProperties_1 = __webpack_require__(19);
var videoAssetProperties = tslib_1.__assign({}, baseTextureAssetProperties_1.default, { id: 'videoAssetProperties', title: 'VideoAssetPropertiesDef', properties: tslib_1.__assign({}, baseTextureAssetProperties_1.default.properties, { autoPlay: {
            type: 'boolean',
            default: true
        }, state: {
            type: 'string',
            default: 'play'
        }, loop: {
            type: 'boolean',
            default: true
        }, querySelector: {
            type: 'string'
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = videoAssetProperties;


/***/ },
/* 170 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var representation_1 = __webpack_require__(38);
var videoRepresentation = tslib_1.__assign({}, representation_1.default, { id: 'videoRepresentation', title: 'VideoRepresentationDef', properties: tslib_1.__assign({}, representation_1.default.properties, { video: {
            type: 'object',
            properties: {
                height: {
                    type: 'integer'
                },
                width: {
                    type: 'integer'
                }
            }
        } }) });
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = videoRepresentation;


/***/ },
/* 171 */
/***/ function(module, exports) {

"use strict";
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/* tslint:disable no-string-literal */
exports.default = (function () {
    var webGLContext;
    try {
        webGLContext = (window['WebGLRenderingContext']) ?
            document.createElement('canvas').getContext('experimental-webgl') : undefined;
    }
    catch (e) {
    }
    var webGLEnabled = !!webGLContext;
    var floatingPointTexturesEnabeled = (webGLEnabled) ?
        !!webGLContext.getExtension('OES_texture_float') : false;
    var vertexTexturesEnabeled = (webGLEnabled) ?
        !!(webGLContext.getParameter(webGLContext.MAX_VERTEX_TEXTURE_IMAGE_UNITS) !== 0) :
        false;
    webGLContext = undefined;
    return {
        isWebGLEnabled: function () {
            return webGLEnabled;
        },
        isFloatingPointTexturesEnabeled: function () {
            return floatingPointTexturesEnabeled;
        },
        isVertexTexturesEnabeled: function () {
            return vertexTexturesEnabeled;
        }
    };
})();


/***/ },
/* 172 */
/***/ function(module, exports) {

"use strict";
"use strict";
/**
 * Determine whether an entity descriptor represents an object entity.
 * @param entityDef The entity descriptor
 * @returns         True if the descriptor is for an object.
 */
exports.isObject = function (entityDef) {
    return entityDef.type === 'node' || entityDef.type === 'camera' ||
        entityDef.type === 'scene' || entityDef.type === 'light' ||
        entityDef.type === 'mesh' || entityDef.type === 'bone';
};
/**
 * Determine whether an entity descriptor represents an asset type.
 * @param entityDef The entity descriptor
 * @returns         True if the descriptor is that of an asset.
 */
exports.isAsset = function (entityDef) {
    return !exports.isObject(entityDef);
};


/***/ },
/* 173 */
/***/ function(module, exports) {

var toString = {}.toString;

module.exports = function(it){
  return toString.call(it).slice(8, -1);
};

/***/ },
/* 174 */
/***/ function(module, exports, __webpack_require__) {

// optional / simple context binding
var aFunction = __webpack_require__(219);
module.exports = function(fn, that, length){
  aFunction(fn);
  if(that === undefined)return fn;
  switch(length){
    case 1: return function(a){
      return fn.call(that, a);
    };
    case 2: return function(a, b){
      return fn.call(that, a, b);
    };
    case 3: return function(a, b, c){
      return fn.call(that, a, b, c);
    };
  }
  return function(/* ...args */){
    return fn.apply(that, arguments);
  };
};

/***/ },
/* 175 */
/***/ function(module, exports) {

module.exports = function(exec){
  try {
    return !!exec();
  } catch(e){
    return true;
  }
};

/***/ },
/* 176 */
/***/ function(module, exports) {

var id = 0
  , px = Math.random();
module.exports = function(key){
  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));
};

/***/ },
/* 177 */
/***/ function(module, exports, __webpack_require__) {

var store      = __webpack_require__(234)('wks')
  , uid        = __webpack_require__(176)
  , Symbol     = __webpack_require__(25).Symbol
  , USE_SYMBOL = typeof Symbol == 'function';

var $exports = module.exports = function(name){
  return store[name] || (store[name] =
    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));
};

$exports.store = store;

/***/ },
/* 178 */
/***/ function(module, exports) {

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var byteToHex = [];
for (var i = 0; i < 256; ++i) {
  byteToHex[i] = (i + 0x100).toString(16).substr(1);
}

function bytesToUuid(buf, offset) {
  var i = offset || 0;
  var bth = byteToHex;
  return  bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] + '-' +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]] +
          bth[buf[i++]] + bth[buf[i++]];
}

module.exports = bytesToUuid;


/***/ },
/* 179 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
var rng;

var crypto = global.crypto || global.msCrypto; // for IE 11
if (crypto && crypto.getRandomValues) {
  // WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
  var rnds8 = new Uint8Array(16);
  rng = function whatwgRNG() {
    crypto.getRandomValues(rnds8);
    return rnds8;
  };
}

if (!rng) {
  // Math.random()-based (RNG)
  //
  // If all else fails, use Math.random().  It's fast, but is of unspecified
  // quality.
  var  rnds = new Array(16);
  rng = function() {
    for (var i = 0, r; i < 16; i++) {
      if ((i & 0x03) === 0) r = Math.random() * 0x100000000;
      rnds[i] = r >>> ((i & 0x03) << 3) & 0xff;
    }

    return rnds;
  };
}

module.exports = rng;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))

/***/ },
/* 180 */
/***/ function(module, exports, __webpack_require__) {

var map = {
	"./accessor": 110,
	"./accessor.ts": 110,
	"./animationAsset": 111,
	"./animationAsset.ts": 111,
	"./animationAssetProperties": 112,
	"./animationAssetProperties.ts": 112,
	"./animationChannel": 113,
	"./animationChannel.ts": 113,
	"./animationClip": 114,
	"./animationClip.ts": 114,
	"./animationLayer": 115,
	"./animationLayer.ts": 115,
	"./applicationAsset": 116,
	"./applicationAsset.ts": 116,
	"./applicationAssetProperties": 117,
	"./applicationAssetProperties.ts": 117,
	"./audioAsset": 118,
	"./audioAsset.ts": 118,
	"./audioAssetProperties": 119,
	"./audioAssetProperties.ts": 119,
	"./baseAsset": 5,
	"./baseAsset.ts": 5,
	"./baseAssetProperties": 8,
	"./baseAssetProperties.ts": 8,
	"./baseEntity": 32,
	"./baseEntity.ts": 32,
	"./baseEntityProperties": 33,
	"./baseEntityProperties.ts": 33,
	"./baseGeometryAsset": 34,
	"./baseGeometryAsset.ts": 34,
	"./baseGeometryAssetProperties": 35,
	"./baseGeometryAssetProperties.ts": 35,
	"./baseImageAsset": 49,
	"./baseImageAsset.ts": 49,
	"./baseImageAssetProperties": 50,
	"./baseImageAssetProperties.ts": 50,
	"./baseRenderTextureAsset": 36,
	"./baseRenderTextureAsset.ts": 36,
	"./baseRenderTextureAssetProperties": 37,
	"./baseRenderTextureAssetProperties.ts": 37,
	"./baseTextureAsset": 22,
	"./baseTextureAsset.ts": 22,
	"./baseTextureAssetProperties": 19,
	"./baseTextureAssetProperties.ts": 19,
	"./boneObject": 120,
	"./boneObject.ts": 120,
	"./boneObjectProperties": 121,
	"./boneObjectProperties.ts": 121,
	"./box3": 122,
	"./box3.ts": 122,
	"./bufferAsset": 123,
	"./bufferAsset.ts": 123,
	"./bufferAssetProperties": 124,
	"./bufferAssetProperties.ts": 124,
	"./cameraObject": 125,
	"./cameraObject.ts": 125,
	"./cameraObjectProperties": 126,
	"./cameraObjectProperties.ts": 126,
	"./commonImageProperties": 51,
	"./commonImageProperties.ts": 51,
	"./component": 127,
	"./component.ts": 127,
	"./componentAttribute": 128,
	"./componentAttribute.ts": 128,
	"./documentAsset": 129,
	"./documentAsset.ts": 129,
	"./documentAssetProperties": 130,
	"./documentAssetProperties.ts": 130,
	"./imageAsset": 131,
	"./imageAsset.ts": 131,
	"./imageAssetProperties": 132,
	"./imageAssetProperties.ts": 132,
	"./imageRepresentation": 133,
	"./imageRepresentation.ts": 133,
	"./index": 4,
	"./index.ts": 4,
	"./lightObject": 134,
	"./lightObject.ts": 134,
	"./lightObjectProperties": 135,
	"./lightObjectProperties.ts": 135,
	"./materialAsset": 136,
	"./materialAsset.ts": 136,
	"./materialAssetProperties": 137,
	"./materialAssetProperties.ts": 137,
	"./meshAttribute": 138,
	"./meshAttribute.ts": 138,
	"./meshGeometryAsset": 139,
	"./meshGeometryAsset.ts": 139,
	"./meshGeometryAssetProperties": 140,
	"./meshGeometryAssetProperties.ts": 140,
	"./meshObject": 141,
	"./meshObject.ts": 141,
	"./meshObjectProperties": 142,
	"./meshObjectProperties.ts": 142,
	"./meshPrimitive": 143,
	"./meshPrimitive.ts": 143,
	"./nodeObject": 15,
	"./nodeObject.ts": 15,
	"./nodeObjectProperties": 16,
	"./nodeObjectProperties.ts": 16,
	"./prefabAsset": 144,
	"./prefabAsset.ts": 144,
	"./prefabAssetProperties": 145,
	"./prefabAssetProperties.ts": 145,
	"./primitiveGeometryAsset": 146,
	"./primitiveGeometryAsset.ts": 146,
	"./primitiveGeometryAssetProperties": 147,
	"./primitiveGeometryAssetProperties.ts": 147,
	"./renderTexture2DAsset": 148,
	"./renderTexture2DAsset.ts": 148,
	"./renderTexture2DAssetProperties": 149,
	"./renderTexture2DAssetProperties.ts": 149,
	"./renderTextureCubeAsset": 150,
	"./renderTextureCubeAsset.ts": 150,
	"./renderTextureCubeAssetProperties": 151,
	"./renderTextureCubeAssetProperties.ts": 151,
	"./representation": 38,
	"./representation.ts": 38,
	"./sceneObject": 152,
	"./sceneObject.ts": 152,
	"./sceneObjectProperties": 153,
	"./sceneObjectProperties.ts": 153,
	"./scriptAsset": 154,
	"./scriptAsset.ts": 154,
	"./scriptAssetProperties": 155,
	"./scriptAssetProperties.ts": 155,
	"./shaderAsset": 156,
	"./shaderAsset.ts": 156,
	"./shaderAssetProperties": 157,
	"./shaderAssetProperties.ts": 157,
	"./shaderConditions": 158,
	"./shaderConditions.ts": 158,
	"./shaderParameter": 159,
	"./shaderParameter.ts": 159,
	"./skinAsset": 160,
	"./skinAsset.ts": 160,
	"./skinAssetProperties": 161,
	"./skinAssetProperties.ts": 161,
	"./texture2DAsset": 162,
	"./texture2DAsset.ts": 162,
	"./texture2DAssetProperties": 163,
	"./texture2DAssetProperties.ts": 163,
	"./textureCubeAsset": 164,
	"./textureCubeAsset.ts": 164,
	"./textureCubeAssetProperties": 165,
	"./textureCubeAssetProperties.ts": 165,
	"./vector3": 166,
	"./vector3.ts": 166,
	"./vector4": 167,
	"./vector4.ts": 167,
	"./videoAsset": 168,
	"./videoAsset.ts": 168,
	"./videoAssetProperties": 169,
	"./videoAssetProperties.ts": 169,
	"./videoRepresentation": 170,
	"./videoRepresentation.ts": 170
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 180;


/***/ },
/* 181 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var THREE = __webpack_require__(1);
exports.THREE = THREE;
var Schemas_1 = __webpack_require__(4);
exports.Schemas = Schemas_1.default;
var Engine_1 = __webpack_require__(105);
exports.Engine = Engine_1.default;
var ScriptRegistry_1 = __webpack_require__(64);
exports.ScriptRegistry = ScriptRegistry_1.default;
var BaseEntity_1 = __webpack_require__(11);
exports.BaseEntity = BaseEntity_1.default;
// Assets
var AnimationAsset_1 = __webpack_require__(55);
exports.AnimationAsset = AnimationAsset_1.default;
var ApplicationAsset_1 = __webpack_require__(56);
exports.ApplicationAsset = ApplicationAsset_1.default;
var AudioAsset_1 = __webpack_require__(185);
exports.AudioAsset = AudioAsset_1.default;
var BaseAsset_1 = __webpack_require__(7);
exports.BaseAsset = BaseAsset_1.default;
var BaseGeometryAsset_1 = __webpack_require__(27);
exports.BaseGeometryAsset = BaseGeometryAsset_1.default;
var BaseImageAsset_1 = __webpack_require__(10);
exports.BaseImageAsset = BaseImageAsset_1.default;
var BaseRenderTextureAsset_1 = __webpack_require__(43);
exports.BaseRenderTextureAsset = BaseRenderTextureAsset_1.default;
var BaseTextureAsset_1 = __webpack_require__(20);
exports.BaseTextureAsset = BaseTextureAsset_1.default;
var BufferAsset_1 = __webpack_require__(28);
exports.BufferAsset = BufferAsset_1.default;
var DocumentAsset_1 = __webpack_require__(57);
exports.DocumentAsset = DocumentAsset_1.default;
var ImageAsset_1 = __webpack_require__(29);
exports.ImageAsset = ImageAsset_1.default;
var MaterialAsset_1 = __webpack_require__(14);
exports.MaterialAsset = MaterialAsset_1.default;
var MeshGeometryAsset_1 = __webpack_require__(58);
exports.MeshGeometryAsset = MeshGeometryAsset_1.default;
var PrefabAsset_1 = __webpack_require__(59);
exports.PrefabAsset = PrefabAsset_1.default;
var PrimitiveGeometryAsset_1 = __webpack_require__(60);
exports.PrimitiveGeometryAsset = PrimitiveGeometryAsset_1.default;
var RenderTexture2DAsset_1 = __webpack_require__(61);
exports.RenderTexture2DAsset = RenderTexture2DAsset_1.default;
var RenderTextureCubeAsset_1 = __webpack_require__(62);
exports.RenderTextureCubeAsset = RenderTextureCubeAsset_1.default;
var ScriptAsset_1 = __webpack_require__(63);
exports.ScriptAsset = ScriptAsset_1.default;
var ShaderAsset_1 = __webpack_require__(44);
exports.ShaderAsset = ShaderAsset_1.default;
var SkinAsset_1 = __webpack_require__(65);
exports.SkinAsset = SkinAsset_1.default;
var Texture2DAsset_1 = __webpack_require__(66);
exports.Texture2DAsset = Texture2DAsset_1.default;
var TextureCubeAsset_1 = __webpack_require__(67);
exports.TextureCubeAsset = TextureCubeAsset_1.default;
var VideoAsset_1 = __webpack_require__(30);
exports.VideoAsset = VideoAsset_1.default;
// Objects
var NodeObject_1 = __webpack_require__(9);
exports.NodeObject = NodeObject_1.default;
var BoneObject_1 = __webpack_require__(106);
exports.BoneObject = BoneObject_1.default;
var CameraObject_1 = __webpack_require__(107);
exports.CameraObject = CameraObject_1.default;
var LightObject_1 = __webpack_require__(108);
exports.LightObject = LightObject_1.default;
var MeshObject_1 = __webpack_require__(47);
exports.MeshObject = MeshObject_1.default;
var SceneObject_1 = __webpack_require__(109);
exports.SceneObject = SceneObject_1.default;
// Constants, Enums
var LoadingType_1 = __webpack_require__(18);
exports.LoadingType = LoadingType_1.default;
var LoadingEvent_1 = __webpack_require__(12);
exports.LoadingEvent = LoadingEvent_1.default;
var LoadingState_1 = __webpack_require__(48);
exports.LoadingState = LoadingState_1.default;
// Components
var BaseComponent_1 = __webpack_require__(2);
exports.BaseComponent = BaseComponent_1.default;
var Components_1 = __webpack_require__(189);
exports.Components = Components_1.default;
var VrHandController_1 = __webpack_require__(46);
exports.Handedness = VrHandController_1.Handedness;
// Utilities
var Logger_1 = __webpack_require__(3);
exports.log = Logger_1.default;
var XhrResourceLoader_1 = __webpack_require__(207);
exports.XhrResourceLoader = XhrResourceLoader_1.default;
__export(__webpack_require__(13));
var globalEvents_1 = __webpack_require__(40);
exports.globalEvents = globalEvents_1.default;
var browserCaps_1 = __webpack_require__(171);
exports.browserCaps = browserCaps_1.default;


/***/ },
/* 182 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(239);
module.exports = __webpack_require__(24).Array.find;

/***/ },
/* 183 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(240);
module.exports = __webpack_require__(24).Math.log10;

/***/ },
/* 184 */
/***/ function(module, exports, __webpack_require__) {

__webpack_require__(241);
module.exports = __webpack_require__(24).Math.log2;

/***/ },
/* 185 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var BaseAsset_1 = __webpack_require__(7);
var Schemas_1 = __webpack_require__(4);
/**
 * @class AudioAsset
 * @constructor
 */
var AudioAsset = (function (_super) {
    tslib_1.__extends(AudioAsset, _super);
    function AudioAsset() {
        return _super.apply(this, arguments) || this;
    }
    /** @inheritdoc */
    AudioAsset.prototype.uninitialize = function () {
        if (this.runtimeData) {
            // TODO: should we be doing more here?
            this.runtimeData.pause();
        }
        _super.prototype.uninitialize.call(this);
    };
    /** @inheritdoc */
    AudioAsset.prototype.applyPropertiesLoaded = function (changes, reason) {
        _super.prototype.applyPropertiesLoaded.call(this, changes, reason);
        if (this.runtimeData) {
            if (changes.hasOwnProperty('loop')) {
                this.runtimeData.loop = this.getProperty('loop');
            }
            if (changes.hasOwnProperty('state')) {
                switch (this.getProperty('state')) {
                    case 'pause':
                        this.runtimeData.pause();
                        break;
                    case 'play':
                        this.runtimeData.play();
                        break;
                    default:
                        break;
                }
            }
        }
    };
    return AudioAsset;
}(BaseAsset_1.default));
Schemas_1.addSchemas('AudioAsset', AudioAsset);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = AudioAsset;


/***/ },
/* 186 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var THREE = __webpack_require__(1);
var GeometryUtilities = (function () {
    /** Create a registry to manage geometry assets. */
    function GeometryUtilities() {
        var _this = this;
        this.defaultGeometry = new THREE.BufferGeometry();
        this.defaultGeometry.setIndex(new THREE.BufferAttribute(new Uint16Array(0), 1));
        var attributes = {
            position: new THREE.BufferAttribute(new Float32Array(0), 3),
            normal: new THREE.BufferAttribute(new Float32Array(0), 3, true),
            skinWeight: new THREE.BufferAttribute(new Float32Array(0), 4, true),
            skinIndex: new THREE.BufferAttribute(new Uint16Array(0), 4, true)
        };
        Object.keys(attributes).forEach(function (name) {
            var attribute = attributes[name];
            _this.defaultGeometry.addAttribute(name, attribute);
        });
    }
    /** Destroys the geometry utilities instance, disposing any loaded data. */
    GeometryUtilities.prototype.destroy = function () {
        if (this.defaultGeometry) {
            this.defaultGeometry.dispose();
            this.defaultGeometry = undefined;
        }
    };
    /**
     * Get a default, empty geometry instance.
     * @returns The default geometry.
     */
    GeometryUtilities.prototype.getDefaultGeometry = function () {
        return this.defaultGeometry;
    };
    return GeometryUtilities;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = GeometryUtilities;


/***/ },
/* 187 */
/***/ function(module, exports) {

"use strict";
"use strict";
var Box3DInputEvent = (function () {
    function Box3DInputEvent() {
        this.name = undefined;
        this.event = undefined;
        this.scenePercentX = 0;
        this.scenePercentY = 0;
    }
    return Box3DInputEvent;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = Box3DInputEvent;


/***/ },
/* 188 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var THREE = __webpack_require__(1);
var deepClone_1 = __webpack_require__(23);
/**
 * @class  ComponentRegistry
 * @constructor
 */
var ComponentRegistry = (function () {
    function ComponentRegistry() {
        /** The components currently attached to the connected entity. */
        this.components = [];
    }
    /** Initialize component registry. */
    ComponentRegistry.prototype.initializeComponents = function () {
        this.listenTo(this.engine, 'scriptDeleted', this.onScriptDeleted);
        this.listenTo(this, 'change:component', this.onComponentChanged);
        this.listenTo(this, 'remove:component', this.onComponentRemoved);
        this.listenTo(this, 'add:component', this.onComponentAdded);
    };
    /**
     * Return an object describing the component on this entity that was matched
     * by the predicate function.
     * @param [predicate] Function called on each descriptor to find the component. Return
     *                    true from the function to validate the descriptor.
     * @returns           Component descriptor.
     */
    ComponentRegistry.prototype.getComponentDescriptor = function (predicate) {
        var all = typeof predicate !== 'function';
        var components = this.sharedData.components;
        return deepClone_1.default(components.find(function (comp) { return all || predicate(comp); }));
    };
    /**
     * Return an object describing the previous state of the component on this entity
     * that was matched by the predicate function.
     * @param [predicate] Function called on each descriptor to find the component. Return
     *                    true from the function to validate the descriptor.
     * @returns           Previous component descriptor.
     */
    ComponentRegistry.prototype.getPreviousComponentDescriptor = function (predicate) {
        var all = typeof predicate !== 'function';
        var components = this.sharedData.previousComponents;
        return deepClone_1.default(components.find(function (comp) { return all || predicate(comp); }));
    };
    /**
     * Return an array of objects describing the components currently on this entity (that are matched
     * by the predicate function). If no predicate is defined, all will be returned.
     * @param [predicate] Function called on each descriptor to filter results. Return
     *                    true from the function to include the descriptor in the results.
     * @returns           All matching component descriptors.
     */
    ComponentRegistry.prototype.getComponentDescriptors = function (predicate) {
        var all = typeof predicate !== 'function';
        var components = this.sharedData.components;
        return components.filter(function (comp) { return all || predicate(comp); })
            .map(function (comp) { return deepClone_1.default(comp); });
    };
    /**
     * Return the descriptor of a component with the given id
     * @param id  ID of the component to find
     * @returns   Descriptor of the found component.
     */
    ComponentRegistry.prototype.getComponentDescriptorById = function (id) {
        return this.getComponentDescriptor(function (comp) { return comp.id === id; });
    };
    /**
     * Return the previous descriptor of a component with the given id
     * @param id  Component id
     * @returns   Previous descriptor of the found component.
     */
    ComponentRegistry.prototype.getPreviousComponentDescriptorById = function (id) {
        return this.getPreviousComponentDescriptor(function (comp) { return comp.id === id; });
    };
    /**
     * Adds a new component to the BaseEntity.
     * @param script            Either a string scriptId or a script asset
     * @param [attributeValues] The initial attribute values to pass into the component
     * @param [name]            The name of the new component
     * @returns                 The newly-created component.
     */
    ComponentRegistry.prototype.addComponent = function (script, attributeValues, name) {
        if (attributeValues === void 0) { attributeValues = {}; }
        if (name === void 0) { name = ''; }
        var newComponent = {
            scriptId: typeof script === 'string' ? script : script.id,
            attributes: attributeValues,
            enabled: true,
            name: name
        };
        var entityDispatcher = this.engine.entityDispatcher;
        entityDispatcher.dispatchComponentAdded(this.id, newComponent);
        return this.components[this.components.length - 1];
    };
    /**
     * Removes the given component from this entity, if it exists.
     * @param component The component object to remove.
     * @returns         True if the component was removed successfully.
     */
    ComponentRegistry.prototype.removeComponent = function (component) {
        var idxToRemove = component.getIndex();
        if (idxToRemove >= 0) {
            this.engine.entityDispatcher.dispatchComponentRemoved(this.id, idxToRemove);
            return true;
        }
        return false;
    };
    /**
     * Returns the component at the given index.
     * @param index The index of the component on this entity
     * @returns     The component at the given index. null otherwise.
     */
    ComponentRegistry.prototype.getComponentByIndex = function (index) {
        return this.components[index] || null;
    };
    /**
     * Returns first component with the provided name
     * @param name  The name of the component
     * @returns     The first component that matches the search.
     */
    ComponentRegistry.prototype.getComponentByName = function (name) {
        return this.getComponent(function (comp) { return comp.getName() === name; });
    };
    /**
     * Returns all components with the provided name
     * @param name  The name of the component
     * @returns     All components that match the search.
     */
    ComponentRegistry.prototype.getComponentsByName = function (name) {
        return this.getComponents(function (comp) { return comp.getName() === name; });
    };
    /**
     * Returns the first component found with the provided script Id
     * @param scriptId  The ID of the script asset used by the components
     * @returns         The first component matching the search.
     */
    ComponentRegistry.prototype.getComponentByScriptId = function (scriptId) {
        return this.getComponent(function (comp) { return comp.getScriptId() === scriptId; });
    };
    /**
     * Returns all components with the provided script Id
     * @param scriptId  The ID of the script asset used by the components
     * @returns         Array of all components matching the search.
     */
    ComponentRegistry.prototype.getComponentsByScriptId = function (scriptId) {
        return this.getComponents(function (comp) { return comp.getScriptId() === scriptId; });
    };
    /**
     * Returns first component with the provided script name
     * @param scriptName  The name of the script asset used by the components
     * @returns           The first component that matches the search.
     */
    ComponentRegistry.prototype.getComponentByScriptName = function (scriptName) {
        return this.getComponent(function (comp) { return comp.getScriptName() === scriptName; });
    };
    /**
     * Returns all components with the provided script name
     * @param scriptName  The name of the script asset used by the components
     * @returns           Array of all components matching the search.
     */
    ComponentRegistry.prototype.getComponentsByScriptName = function (scriptName) {
        return this.getComponents(function (comp) { return comp.getScriptName() === scriptName; });
    };
    /**
     * Return the first component attached to this entity that matches the specified filter
     * @param predicate Filter function that takes a component parameter and returns
     *                  true on match and false otherwise.
     * @returns         The component matching the filter
     */
    ComponentRegistry.prototype.getComponent = function (predicate) {
        var all = typeof predicate !== 'function';
        return this.components.find(function (comp) { return all || predicate(comp); });
    };
    /**
     * Return the component with the given ID, if there is one.
     * @param componentId Unique ID of the component
     * @returns           The component, if found, otherwise undefined.
     */
    ComponentRegistry.prototype.getComponentById = function (componentId) {
        return this.getComponent(function (comp) { return comp.getId() === componentId; });
    };
    /**
     * Return all of the components attached to this entity matching the specified filter
     * @param [predicate] Filter function that takes a component parameter and returns
     *                    true on match and false otherwise.
     * @returns           Array of components matching the filter
     */
    ComponentRegistry.prototype.getComponents = function (predicate) {
        var all = typeof predicate !== 'function';
        return this.components.filter(function (comp) { return all || predicate(comp); });
    };
    /**
     * Set the entire list of components for this entity. This will remove components
     * that are not specified, re-add components that might already exist and set the
     * component ordering to match the specified order.
     * @param componentDescriptors  Array of component descriptors of the form:
     *                              {id: <string>, scriptId: <string>, attributes: <Object>,
     *                                enabled: <boolean>}
     * @param [silent=false]        Suppress change event.
     */
    ComponentRegistry.prototype.setComponents = function (componentDescriptors, _silent) {
        var _this = this;
        if (_silent === void 0) { _silent = false; }
        var entityDispatcher = this.engine.entityDispatcher;
        for (var idx = this.sharedData.components.length; idx >= 0; idx--) {
            entityDispatcher.dispatchComponentRemoved(this.id, idx);
        }
        componentDescriptors.forEach(function (compDesc) {
            entityDispatcher.dispatchComponentAdded(_this.id, compDesc);
        });
    };
    /** Starts all components on this entity. */
    ComponentRegistry.prototype.startComponents = function () {
        var _this = this;
        this.components.forEach(function (comp) { return _this.startComponent(comp); });
    };
    /** Stops all components on the entity. */
    ComponentRegistry.prototype.stopComponents = function () {
        var _this = this;
        this.components.forEach(function (comp) { return _this.stopComponent(comp); });
    };
    /**
     * Called when a ScriptAsset has been deleted. This method will remove any
     * components that use the deleted ScriptAsset.
     * @param scriptId The ID of the deleted ScriptAsset
     */
    ComponentRegistry.prototype.onScriptDeleted = function (scriptId) {
        var _this = this;
        var comps = this.getComponentsByScriptId(scriptId);
        comps.forEach(function (comp) {
            _this.removeComponent(comp);
        });
    };
    /**
     * Called when a component on this entity has been modified.
     * @param index               Index of the component that just changed.
     * @param componentDescriptor The descriptor of the component changes.
     */
    ComponentRegistry.prototype.onComponentChanged = function (index, componentDescriptor) {
        var component = this.getComponentByIndex(index);
        if (!component) {
            throw new Error("Don't have a component at index " + index);
        }
        if (componentDescriptor.attributes) {
            this.assignAttributeValues(component, componentDescriptor.attributes);
            var changedAttributes = Object.keys(componentDescriptor.attributes);
            component.trigger('attributesChanged', changedAttributes);
        }
    };
    /**
     * Called when a component is added to this entity
     * @param componentDescriptor Descriptor for the new component
     */
    ComponentRegistry.prototype.onComponentAdded = function (componentDescriptor) {
        var component = this.createComponentObject(componentDescriptor);
        component.trigger('awake');
        this.assignAttributeValues(component);
        var scriptAsset = component.getScriptAsset();
        var changedAttributes = Object.keys(scriptAsset.getProperty('attributes'));
        component.trigger('attributesChanged', changedAttributes);
        // If the entity is already loaded when the component is created,
        // explicitly load the component.
        if (!this.isBaseUnloaded()) {
            this.startComponent(component, false);
        }
    };
    /**
     * Called when a component has been removed from this entity.
     * @param indexToRemove The index of the component to remove.
     */
    ComponentRegistry.prototype.onComponentRemoved = function (indexToRemove) {
        var component = this.components[indexToRemove];
        if (!component) {
            throw new Error("Can't find component at index " + indexToRemove + " to remove.");
        }
        this.stopComponent(component);
        this.components.splice(indexToRemove, 1);
    };
    /**
     * Translate an attribute value to a value that is assigned as a member of
     * the component. This function is called recursively for custom attributes.
     * @param obj             The object to set with the resulting member variable. This is
     *                        usually the component but, for custom attributes, it can be a
     *                        sub-object.
     * @param attributeName   Name of the attribute
     * @param attributeDef    Definition of the attribute
     * @param attributeValue  Raw value of the attribute before translation
     */
    ComponentRegistry.prototype.translateAttributeValue = function (obj, attributeName, attributeDef, attributeValue) {
        var _this = this;
        var runtime = this.engine;
        switch (attributeDef.type) {
            case 'asset':
                obj[attributeName] = runtime.getAssetById(attributeValue);
                break;
            case 'object':
                obj[attributeName] = runtime.getObjectById(attributeValue);
                break;
            case 'custom':
                obj[attributeName] = obj[attributeName] || {};
                Object.keys(attributeValue).forEach(function (key) {
                    _this.translateAttributeValue(obj[attributeName], key, attributeDef.attributes[key], attributeValue[key]);
                });
                break;
            case 'c':
                obj[attributeName] = obj[attributeName] || new THREE.Color();
                obj[attributeName].setRGB(attributeValue.r, attributeValue.g, attributeValue.b);
                break;
            case 'a':
                obj[attributeName] = obj[attributeName] || [];
                var defaultClass_1;
                // Handle arrays of different types
                switch (attributeDef.subType.type) {
                    case 'asset':
                        attributeValue.forEach(function (id, idx) {
                            obj[attributeName][idx] = runtime.getAssetById(id);
                        });
                        break;
                    case 'object':
                        attributeValue.forEach(function (id, idx) {
                            obj[attributeName][idx] = runtime.getObjectById(id);
                        });
                        break;
                    case 'custom':
                        attributeValue.forEach(function (subObj, idx) {
                            obj[attributeName][idx] = obj[attributeName] || {};
                            Object.keys(subObj).forEach(function (key) {
                                _this.translateAttributeValue(obj[attributeName][idx], key, attributeDef.subType.attributes[key], attributeValue[idx][key]);
                            });
                        });
                        break;
                    case 'v2':
                        defaultClass_1 = THREE.Vector2;
                    /* falls through */
                    case 'v3':
                        defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Vector3;
                    /* falls through */
                    case 'v4':
                        defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Vector4;
                    /* falls through */
                    case 'q':
                        defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Quaternion;
                        attributeValue.forEach(function (value, idx) {
                            obj[attributeName][idx] = obj[attributeName][idx] || new defaultClass_1();
                            obj[attributeName][idx].copy(value);
                        });
                        break;
                    default:
                        attributeValue.forEach(function (value, idx) {
                            obj[attributeName][idx] = value;
                        });
                }
                break;
            case 'v2':
                defaultClass_1 = THREE.Vector2;
            /* falls through */
            case 'v3':
                defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Vector3;
            /* falls through */
            case 'v4':
                defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Vector4;
            /* falls through */
            case 'q':
                defaultClass_1 = defaultClass_1 ? defaultClass_1 : THREE.Quaternion;
                obj[attributeName] = obj[attributeName] || new defaultClass_1();
                obj[attributeName].copy(attributeValue);
                break;
            default:
                obj[attributeName] = attributeValue;
        }
    };
    /**
     * Take raw attribute values and create all member variables from them.
     * @param component     The component to update.
     * @param [attributes]  An object with keys that are the attribute names for
     *                      only the attributes that you wish to update.
     */
    ComponentRegistry.prototype.assignAttributeValues = function (component, attributes) {
        var _this = this;
        var all = typeof attributes !== 'object';
        var scriptAsset = component.getScriptAsset();
        var scriptAttributes = scriptAsset.getProperty('attributes') || {};
        Object.keys(scriptAttributes).forEach(function (attribName) {
            if (all || attributes.hasOwnProperty(attribName)) {
                var attrDef = scriptAttributes[attribName];
                var attribValue = component.getAttribute(attrDef.name);
                _this.translateAttributeValue(component, attrDef.name, attrDef, attribValue);
            }
        });
    };
    /**
     * Create the actual component using at the index with the given descriptor
     * @param componentDesc Descriptor for the new component
     * @returns             The newly-created component
     */
    ComponentRegistry.prototype.createComponentObject = function (componentDesc) {
        var scriptId = componentDesc.scriptId;
        var scriptAsset = this.engine.getAssetById(scriptId);
        if (!scriptAsset) {
            throw new Error("Unable to find script asset for " + scriptId);
        }
        if (scriptAsset.isUnloaded()) {
            scriptAsset.load();
        }
        var component = new scriptAsset.sharedData.classConstructor();
        this.components.push(component);
        Object.assign(component, {
            id: componentDesc.id,
            name: componentDesc.name,
            scriptName: scriptAsset.getName(),
            scriptId: scriptId,
            enabled: !!componentDesc.enabled,
            entity: this
        });
        return component;
    };
    /**
     * Starts the component, which calls 'start' and binds the other predefined functions.
     * @param component             The component to load.
     * @param [assignAttribs=true]  Initialize the attributes before starting the component.
     */
    ComponentRegistry.prototype.startComponent = function (component, assignAttribs) {
        if (assignAttribs === void 0) { assignAttribs = true; }
        // First, assign the attribute values and call the 'onAttributesChanged' function
        if (assignAttribs) {
            var scriptAsset = component.getScriptAsset();
            var changedAttributes = Object.keys(scriptAsset.getProperty('attributes'));
            this.assignAttributeValues(component);
            component.trigger('attributesChanged', changedAttributes);
        }
        // We'll call onStartup because we're loading the component
        component.trigger('startup');
    };
    /**
     * Stopping a component essentially shuts it down (kills event listeners and calls
     * the onShutdown function) but it doesn't remove it from the list.
     * @param component The component to remove.
     */
    ComponentRegistry.prototype.stopComponent = function (component) {
        component.trigger('shutdown');
    };
    return ComponentRegistry;
}());
;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ComponentRegistry;


/***/ },
/* 189 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var path = __webpack_require__(243);
// Gets a require context for all of the component files in the BuiltIn folder.
var componentsContext = __webpack_require__(248);
// Creates a mapping of ComponentName (based on filename) to constructor function.
var componentExports = componentsContext.keys()
    .map(function (k) { return [k, componentsContext(k).default]; })
    .reduce(function (acc, _a) {
    var k = _a[0], m = _a[1];
    acc[path.basename(k).split('.')[0]] = m;
    return acc;
}, {});
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = componentExports;


/***/ },
/* 190 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var BaseEntity_1 = __webpack_require__(11);
var Logger_1 = __webpack_require__(3);
/**
 * @class DependencyRegistry
 * @constructor
 */
var DependencyRegistry = (function () {
    function DependencyRegistry() {
        /**
         * A mapping of id to dependency for the attached entity's direct dependencies.
         * @protected
         * @type {ObjectMap<DependencyRef>}
         */
        this.ownDependencies = {};
        /**
         * A mapping of id to dependency for all of the attached entity's dependencies.
         * @protected
         * @type {ObjectMap<DependencyRef>}
         */
        this.dependencies = {};
    }
    /**
     * Return array of dependencies referenced directly by this entity.
     * @method getOwnDependencies
     * @public
     * @return {BaseEntity[]} Dependencies, keyed by asset ID and containing reference counts.
     */
    DependencyRegistry.prototype.getOwnDependencies = function () {
        var _this = this;
        return Object.keys(this.ownDependencies).map(function (id) { return _this.engine.getEntityById(id); })
            .filter(function (entity) { return entity; });
    };
    /**
     * Return dictionary of dependencies referenced directly by this entity, keyed by ID.
     * is an object that contains the dependency's ID and reference count.
     * @method getOwnDependencyInfo
     * @private
     * @return {Object} Dependencies, Objects containing asset ID and reference counts.
     */
    DependencyRegistry.prototype.getOwnDependencyInfo = function () {
        return this.ownDependencies;
    };
    /**
     * Return an array of entities that this entity is dependent on. e.g. materials, textures,
     * geometry, animations, etc. as well as any dependencies of those entities. i.e. this list
     * contains everything needed to fully load this entity.
     * @method getDependencies
     * @public
     * @param {Function} [predicate] A function which returns 'true' or 'false'. Used to determine
     * which dependencies to return.
     * @return {BaseEntity[]} An array of entities that this entity is dependent on.
     */
    DependencyRegistry.prototype.getDependencies = function (predicate) {
        var _this = this;
        var all = typeof predicate !== 'function';
        return Object.keys(this.dependencies)
            .map(function (id) { return _this.engine.getEntityById(id); })
            .filter(function (entity) {
            return all || predicate(entity);
        });
    };
    /**
     * Return an array of entities of the given type that this entity is dependent
     * on as well as any dependencies of those entities.
     * @method getDependenciesByType
     * @public
     * @param {String} type The entity type of the dependencies to return.
     * @return {BaseEntity[]} An array of entities that this entity is dependent on.
     */
    DependencyRegistry.prototype.getDependenciesByType = function (type) {
        return this.getDependencies(function (entity) { return entity.type === type; });
    };
    /**
     * Return dictionary of all dependencies of this entity, keyed by ID.
     * Each entry is an object that contains the reference count.
     * @method getDependencyInfo
     * @private
     * @return {Object} Dependencies, Objects containing asset ID and reference counts.
     */
    DependencyRegistry.prototype.getDependencyInfo = function () {
        return this.dependencies;
    };
    /**
     * Register the given entity as being a dependency of this entity as well as the parent
     * asset, if any. A count is maintained to track the number of times a given entity is referenced
     * by this entity. This allows easy calculation of data size of an asset or individual object.
     * Registering a dependency on an object that is already a dependency of another will
     * automatically register it with that entity as well.
     * @method registerDependencyById
     * @public
     * @param  {String} entityId The id of the entity to register
     * @return {void}
     */
    DependencyRegistry.prototype.registerDependencyById = function (entityId) {
        this.registerDependency(this.engine.getEntityById(entityId));
    };
    /**
     * Register the given entity as being a dependency of this entity. A count is maintained
     * to track the number of times a given entity is referenced
     * by this entity. This allows easy calculation of data size of an asset or individual object.
     * Registering a dependency on an object that is already a dependency of another will
     * automatically register it with that entity as well.
     * @method registerDependency
     * @public
     * @param  {BaseEntity} entity The entity to register
     * @return {void}
     */
    DependencyRegistry.prototype.registerDependency = function (entity) {
        var _this = this;
        // Register the dependency with this entity
        // Register the dependency as a sub-dependency of our parent asset
        if (!entity) {
            Logger_1.default.warn('Trying to register invalid entity as a dependency.');
            return;
        }
        var dependencies = this.getOwnDependencyInfo();
        var entityId = entity.id;
        if (!dependencies[entityId]) {
            dependencies[entityId] = {
                count: 1
            };
            // Listen to:
            // A change of state on an 'own' dependency
            // A change in referenced dependencies of an 'own' dependency
            // Bind to dependency changes on this entity so that we can register or unregister
            // sub dependencies as needed.
            dependencies[entityId].onSubDependencyChange = function (newAssetId, oldAssetId) {
                if (!dependencies[entityId]) {
                    return;
                }
                for (var j = 0; j < dependencies[entityId].count; j++) {
                    if (newAssetId) {
                        _this.registerSubDependencyById(newAssetId);
                    }
                    if (oldAssetId) {
                        _this.unregisterSubDependencyById(oldAssetId);
                    }
                }
            };
            if (this instanceof BaseEntity_1.default) {
                if (!this.isUnloaded() && entity.isUnloaded()) {
                    entity.load();
                }
                // When each dependency is loaded, check if we're done and mark dependencies as
                // finished if we are done.
                this.listenTo(entity, 'loadStateChange', this.updateDependencyState);
                this.updateDependencyState(entity);
            }
            entity.on('change:dependency', dependencies[entityId].onSubDependencyChange, this);
        }
        else {
            dependencies[entityId].count++;
        }
        // Register all the current dependencies of the new entity with this entity.
        var subDependencies = entity.getDependencyInfo();
        Object.keys(subDependencies).forEach(function (id) {
            var dep = subDependencies[id];
            for (var i = 0; i < dep.count; i++) {
                _this.registerSubDependencyById(id);
            }
        });
        this.registerSubDependencyById(entityId);
    };
    /**
     * Unregister the given asset as being a dependency of this asset.
     * @method unregisterDependencyById
     * @public
     * @param  {String} entityId The id of the entity to unregister
     * @return {void}
     */
    DependencyRegistry.prototype.unregisterDependencyById = function (entityId) {
        this.unregisterDependency(this.engine.getEntityById(entityId));
    };
    /**
     * Unregister the given asset as being a dependency of this asset.
     * @method unregisterDependency
     * @public
     * @param  {BaseEntity} asset The entity to unregister
     * @return {void}
     */
    DependencyRegistry.prototype.unregisterDependency = function (entity) {
        var _this = this;
        if (!entity) {
            return;
        }
        var entityId = entity.id;
        var ownDependencies = this.getOwnDependencyInfo();
        var dependency = ownDependencies[entityId];
        if (dependency) {
            // Decrement the reference count for this material
            dependency.count--;
            // If this material is no longer referenced, remove it completely.
            if (dependency.count === 0) {
                delete ownDependencies[entityId];
                // Unbind the event callback for texture changes on this material
                entity.off('change:dependency', dependency.onSubDependencyChange, this);
                this.stopListening(entity, 'loadStateChange', this.updateDependencyState);
                // If the removal of this dependency can cause a change in state for this entity,
                // make the state change.
                if (!entity.isLoaded()) {
                    if (this.checkIfOwnDependenciesLoaded()) {
                        this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Succeeded);
                    }
                }
                else if (!entity.isUnloaded()) {
                    if (this.checkIfOwnDependenciesUnloaded() && this.getOwnDependencies().length) {
                        this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Pending);
                    }
                }
            }
            // Unregister all the current dependencies of the entity from this entity
            var dependencies_1 = entity.getDependencyInfo();
            Object.keys(dependencies_1).forEach(function (id) {
                var dep = dependencies_1[id];
                for (var i = 0; i < dep.count; i++) {
                    _this.unregisterSubDependencyById(id);
                }
            });
            this.unregisterSubDependencyById(entityId);
        }
    };
    /**
     * Load only the dependencies for this entity. These are all the textures,
     * materials, geometries, animations, etc. that are referenced by this entity.
     * This also includes dependencies of dependencies.
     * @public
     * @method loadDependencies
     * @param {Function} callback callback function
     */
    DependencyRegistry.prototype.loadDependencies = function (callback) {
        var _this = this;
        if (this instanceof BaseEntity_1.default) {
            if (typeof callback === 'function') {
                this.once('loadDependencies', callback, this);
            }
            // Only start loading the dependencies if they're not already loaded.
            if (!this.isDependenciesLoaded()) {
                this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.InProgress);
                var dependencies = this.getDependencyInfo();
                var dependencyKeys = Object.keys(dependencies);
                this.engine.loadEntities(dependencyKeys, function () {
                    if (_this.checkIfDependenciesLoaded()) {
                        _this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Succeeded);
                    }
                });
            }
        }
    };
    /**
     * Unregister all dependencies for this entity.
     * @method unregisterDependencies
     * @protected
     * @return {void}
     */
    DependencyRegistry.prototype.unregisterDependencies = function () {
        var _this = this;
        var currentDependencies = this.getDependencyInfo();
        // Unregister existing dependencies
        Object.keys(currentDependencies).forEach(function (id) {
            // It's possible that the previous dependency being unregistered also caused this
            // dependency to be unregistered (e.g. a renderTexture that uses another texture) so
            // dep may not exist anymore.
            var dep = currentDependencies[id];
            if (!dep) {
                return;
            }
            var length = dep.count;
            for (var i = 0; i < length; i++) {
                _this.unregisterDependencyById(id);
            }
        }, this);
    };
    /**
     * Go through all registered dependencies and check if they're all loaded.
     * @protected
     * @return {Boolean} True iff all registered dependencies are loaded.
     */
    DependencyRegistry.prototype.checkIfOwnDependenciesLoaded = function () {
        var dependencies = this.getOwnDependencies();
        return dependencies.every(function (dep) { return dep && dep.isLoaded(); });
    };
    /**
     * Go through all registered dependencies and check if they're all unloaded.
     * @protected
     * @return {Boolean} True iff all registered dependencies are unloaded.
     */
    DependencyRegistry.prototype.checkIfOwnDependenciesUnloaded = function () {
        var dependencies = this.getOwnDependencies();
        return dependencies.every(function (dep) { return dep && dep.isUnloaded(); });
    };
    /**
     * Go through all registered dependencies and check if they're all loaded.
     * @protected
     * @return {Boolean} True iff all registered dependencies are loaded.
     */
    DependencyRegistry.prototype.checkIfDependenciesLoaded = function () {
        var dependencies = this.getDependencies();
        return dependencies.every(function (dep) { return dep && dep.isLoaded(); });
    };
    /**
     * Register the given entity as being a sub dependency of this one. A sub dependency
     * is a dependency that is indirectly referenced by this entity (i.e. a dependency has its
     * own dependency).
     * @method registerSubDependencyById
     * @private
     * @param  {String} entityId The id of the entity to register
     * @return {void}
     */
    DependencyRegistry.prototype.registerSubDependencyById = function (entityId) {
        this.registerSubDependency(this.engine.getEntityById(entityId));
    };
    /**
     * Register the given entity as being a sub dependency of this one. A sub dependency
     * is a dependency that is indirectly referenced by this entity (i.e. a dependency has its
     * own dependency).
     * @method registerSubDependency
     * @private
     * @param  {BaseEntity} entity The entity to register
     * @return {void}
     */
    DependencyRegistry.prototype.registerSubDependency = function (entity) {
        if (!entity) {
            Logger_1.default.warn('Trying to register invalid entity as a sub-dependency.');
            return;
        }
        var entityId = entity.id;
        var dependency = this.dependencies[entityId];
        if (this instanceof BaseEntity_1.default) {
            if (!dependency) {
                this.dependencies[entityId] = { count: 1 };
            }
            else {
                dependency.count++;
            }
            // Inform entities referencing this entity as a dependency of the change
            this.trigger('change:dependency', entityId, null);
        }
    };
    /**
     * Given the state of the provided dependency, update the loading
     * state of this entity.
     * @param dependency The entity that this entity is dependent on.
     */
    DependencyRegistry.prototype.updateDependencyState = function (dependency) {
        if (dependency.isLoaded()) {
            if (this.checkIfOwnDependenciesLoaded()) {
                this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Succeeded);
                return;
            }
        }
        else if (dependency.isUnloaded()) {
            if (this.checkIfOwnDependenciesUnloaded()) {
                this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.Pending);
                return;
            }
        }
        this.setState(BaseEntity_1.StateType.Dependencies, BaseEntity_1.State.InProgress);
    };
    /**
     * Unregister the given entity as being a sub dependency of this one. A sub dependency
     * is a dependency that is indirectly referenced by this entity (i.e. a dependency has its
     * own dependency).
     * @method unregisterSubDependencyById
     * @private
     * @param  {String} entityId The id of the entity to unregister
     * @return {void}
     */
    DependencyRegistry.prototype.unregisterSubDependencyById = function (entityId) {
        this.unregisterSubDependency(this.engine.getEntityById(entityId));
    };
    /**
     * Unregister the given entity as being a sub dependency of this one. A sub dependency
     * is a dependency that is indirectly referenced by this entity (i.e. a dependency has its
     * own dependency).
     * @method unregisterSubDependency
     * @private
     * @param  {BaseEntity} entity The entity to unregister
     * @return {void}
     */
    DependencyRegistry.prototype.unregisterSubDependency = function (entity) {
        if (!entity) {
            return;
        }
        var entityId = entity.id;
        var dependency = this.dependencies[entityId];
        if (this instanceof BaseEntity_1.default) {
            if (dependency) {
                dependency.count--;
                if (dependency.count === 0) {
                    delete this.dependencies[entityId];
                }
                // Inform entities referencing this entity as a dependency of the change
                this.trigger('change:dependency', null, entityId);
            }
        }
    };
    return DependencyRegistry;
}());
;
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = DependencyRegistry;


/***/ },
/* 191 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var Logger_1 = __webpack_require__(3);
var uuid_1 = __webpack_require__(17);
var deepClone_1 = __webpack_require__(23);
var globalEvents_1 = __webpack_require__(40);
var typeGuard_1 = __webpack_require__(172);
var EntityUpdatePackage_1 = __webpack_require__(193);
/**
 * EntityDispatcher handles dispatching entity changes between running engine instances
 * and external applications. EntityDispatcher can be created and passed to a multiple engine
 * instances, allowing multiple engines to share the same entity list.
 */
var EntityDispatcher = (function () {
    function EntityDispatcher() {
        /** List of Engines currently registered with this dispatcher. */
        this.engines = [];
        /** List of all entities registered. All engines share the same list of entities. */
        this.entities = {};
    }
    /**
     * Registers a new engine instance with the EntityDispatcher. This allows the engine
     * to receive entity updates, including property changes, added entities, etc.
     * @param {Object} newEngine A reference to the engine to register.
     */
    EntityDispatcher.prototype.addEngine = function (newEngine) {
        if (!newEngine) {
            return;
        }
        if (this.engines.indexOf(newEngine) === -1) {
            var entities = this.getEntityDescriptors();
            entities.forEach(function (desc) { return newEngine.registerEntity(desc); });
            // FIXME: Using as any to bypass protected on BaseEntity (evil)
            // Should we increase the visibility of initialize? Or is this an okay
            // workaround?
            entities.forEach(function (desc) { return newEngine.getEntityById(desc.id).initialize(); });
            entities.forEach(function (desc) {
                return newEngine.getEntityById(desc.id).trigger('change:properties', desc.properties);
            });
            entities.forEach(function (desc) {
                return newEngine.trigger('entityCreated', newEngine.getEntityById(desc.id));
            });
            this.engines.push(newEngine);
        }
        else {
            Logger_1.default.warn('The engine, ' + newEngine.getName() + ', has already been registered.');
        }
    };
    /**
     * Unregisters an engine instance from the EntityDispatcher. This will cut off the engine
     * from receiving entity updates, including property changes, added entities, etc.
     * @param {Object} engine A reference to the engine to unregister.
     */
    EntityDispatcher.prototype.removeEngine = function (engine) {
        var index;
        if (!engine) {
            return;
        }
        index = this.engines.indexOf(engine);
        if (index !== -1) {
            this.engines.splice(index, 1);
        }
        else {
            Logger_1.default.warn('The engine, ' + engine.getName() + ' isn\'t currently registered.');
        }
    };
    /**
     * Adds the given entities to all registered engines.
     * @method addEntities
     * @protected
     * @param {Array} entities Array of new entity descriptors
     * @return {Array}
     */
    EntityDispatcher.prototype.addEntities = function (entityArray) {
        var _this = this;
        // Filter out duplicate entities
        var newEntities = entityArray.filter(function (entityDesc) { return !_this.entities[entityDesc.id]; });
        // Create the entity object in each engine
        newEntities.forEach(function (entityDesc) {
            entityDesc.id = _this.dispatchCreatedEntity(entityDesc.id, entityDesc.type);
            if (entityDesc.sid) {
                _this.dispatchAttributeChanged(entityDesc.id, 'sid', entityDesc.sid || '');
            }
            if (typeGuard_1.isAsset(entityDesc) && entityDesc.representations) {
                _this.dispatchAttributeChanged(entityDesc.id, 'representations', entityDesc.representations || []);
            }
            else if (typeGuard_1.isObject(entityDesc)) {
                if (entityDesc.parentId) {
                    _this.dispatchAttributeChanged(entityDesc.id, 'parentId', entityDesc.parentId || null);
                }
                if (entityDesc.prefabAssetId) {
                    _this.dispatchAttributeChanged(entityDesc.id, 'prefabAssetId', entityDesc.prefabAssetId);
                }
                if (entityDesc.prefabObjectId) {
                    _this.dispatchAttributeChanged(entityDesc.id, 'prefabObjectId', entityDesc.prefabObjectId);
                }
                if (entityDesc.prefabInstanceId) {
                    _this.dispatchAttributeChanged(entityDesc.id, 'prefabInstanceId', entityDesc.prefabInstanceId);
                }
            }
        });
        // Initialize the entity in each engine
        newEntities.forEach(function (entityDesc) { return _this.dispatchInitEntity(entityDesc.id); });
        // Set the initial properties of the entity in each engine.
        newEntities.forEach(function (entityDesc) {
            return _this.dispatchPropertiesChanged(entityDesc.id, entityDesc.properties || {});
        });
        // Add the initial components of the entity in each engine.
        newEntities.forEach(function (entityDesc) {
            if (!entityDesc.components) {
                return;
            }
            entityDesc.components.forEach(function (compDesc) {
                return _this.dispatchComponentAdded(entityDesc.id, compDesc);
            });
        });
        // Set the initial children
        newEntities.forEach(function (entityDesc) {
            if (typeGuard_1.isObject(entityDesc)) {
                _this.dispatchChildChanged(entityDesc.id, entityDesc.children || []);
            }
        });
        newEntities.forEach(function (entityDesc) {
            return _this.engines.forEach(function (engine) {
                return engine.trigger('entityCreated', engine.getEntityById(entityDesc.id));
            });
        });
        return newEntities;
    };
    /**
     * Return direct references to all entity descriptors. These are shared
     * for each entity across engine instances.
     * @method getEntityDescriptors
     * @public
     * @return {Array} Array of json descriptors for all entities.
     */
    EntityDispatcher.prototype.getEntityDescriptors = function () {
        var _this = this;
        return Object.keys(this.entities).map(function (id) { return _this.entities[id]; });
    };
    /**
     * Initialize the entity with the given ID
     * @method dispatchInitEntity
     * @public
     * @param {string} entityId ID of the entity to initialize
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchInitEntity = function (entityId) {
        // Initialize objects
        this.engines.forEach(function (engine) {
            var entity = engine.getEntityById(entityId);
            if (entity) {
                // FIXME: Using as any to bypass protected on BaseEntity (evil) see other
                // fixme in this file.
                entity.initialize();
            }
        });
    };
    /**
     * Create a new entity using the given entity description
     * @method dispatchCreatedEntity
     * @public
     * @param  {Object} jsonDescriptor Description of the entity.
     * @return {string} The unique ID for the new entity.
     */
    EntityDispatcher.prototype.dispatchCreatedEntity = function (entityId, type) {
        if (this.entities[entityId]) {
            return entityId;
        }
        // If an ID hasn't been given or the ID is already in use, generate a new one.
        var id = !entityId ? uuid_1.v4() : entityId;
        var desc = {
            id: id,
            sid: id,
            type: type,
            properties: {},
            previousProperties: {},
            components: [],
            previousComponents: []
        };
        this.entities[desc.id] = desc;
        this.fireExternalUpdate(id, desc, 'createEntity');
        // Apply changes in each engine
        // Register object
        this.engines.forEach(function (engine) { return engine.registerEntity(desc); });
        return id;
    };
    /**
     * Delete an entity from all engine instances.
     * @method dispatchDestroyedEntity
     * @public
     * @param  {String} entityId Id of the entity to delete.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchDestroyedEntity = function (entityId) {
        if (!this.entities[entityId]) {
            Logger_1.default.error('Can\'t destroy an entity with ID, ' + entityId + ', that doesn\'t exist.');
            return;
        }
        this.fireExternalUpdate(entityId, {}, 'destroyEntity');
        // Apply changes in each engine
        this.engines.forEach(function (engine) { return engine.unregisterEntityById(entityId); });
        delete this.entities[entityId];
    };
    /**
     * Change an attribute on an entity in all engine instances.
     * @param entityId The ID of the entity to change.
     * @param attrib The name of the attribute to change.
     * @param value The new value of the attribute.
     */
    EntityDispatcher.prototype.dispatchAttributeChanged = function (entityId, attrib, value) {
        if (!this.entities[entityId]) {
            return;
        }
        var json = this.entities[entityId];
        json[attrib] = value;
        this.fireExternalUpdate(entityId, json);
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            entityToChange.trigger('change:' + attrib, value);
        });
    };
    /**
     * Change a property on an entity in all engine instances.
     * @param entityId The ID of the entity to change.
     * @param property The name of the property to change.
     * @param value The new value of the property.
     * @param silent Optionally make the call silent so that it doesn't inform each engine of the change.
     */
    EntityDispatcher.prototype.dispatchPropertyChanged = function (entityId, property, value, silent) {
        var propertyDescriptor = {};
        propertyDescriptor[property] = value;
        this.dispatchPropertiesChanged(entityId, propertyDescriptor, silent);
    };
    /**
     * Change properties on an entity in all engine instances.
     * @param entityId The ID of the entity to change.
     * @param newProperties The properties to change.
     * @param silent Optionally make the call silent so that it doesn't inform each engine of the change.
     */
    EntityDispatcher.prototype.dispatchPropertiesChanged = function (entityId, newProperties, silent) {
        if (newProperties === void 0) { newProperties = {}; }
        if (!this.entities[entityId]) {
            return;
        }
        var json = this.entities[entityId];
        Object.keys(newProperties).forEach(function (property) {
            json.previousProperties[property] = deepClone_1.default(json.properties[property]);
            json.properties[property] = deepClone_1.default(newProperties[property]);
        });
        this.fireExternalUpdate(entityId, { properties: json.properties });
        if (silent) {
            return;
        }
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            if (!entityToChange) {
                return;
            }
            Object.keys(json).forEach(function (id) {
                var value = json[id];
                entityToChange.trigger('change:properties.' + id, value);
            });
            entityToChange.trigger('change:properties', newProperties);
        });
    };
    /**
     * Inform all engines that a child was added to the specified entity.
     * @method dispatchChildAdded
     * @public
     * @param {string} entityId The ID of the entity to add the child to.
     * @param {string} newChildId The ID of the new child entity
     * @param {boolean} silent Supress change event. Defaults to false.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchChildAdded = function (entityId, newChildId, silent) {
        var entityDesc = this.entities[entityId];
        if (!entityDesc) {
            return;
        }
        var children = entityDesc.children = entityDesc.children || [];
        entityDesc.previousChildren = entityDesc.children.slice();
        entityDesc.children.push(newChildId);
        this.fireExternalUpdate(entityId, { children: children });
        if (silent) {
            return;
        }
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            var childArray = [engine.getObjectById(newChildId)];
            entityToChange.trigger('change:children', childArray, []);
        });
    };
    /**
     * Inform all engines that a child was removed from the specified entity.
     * @method dispatchChildRemoved
     * @public
     * @param {string} entityId The ID of the entity to remove the child from.
     * @param {string} childToRemoveId The ID of the child entity to remove
     * @param {boolean} silent Supress change event. Defaults to false.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchChildRemoved = function (entityId, childToRemoveId, silent) {
        var entityDesc = this.entities[entityId];
        if (!entityDesc) {
            return;
        }
        var children = entityDesc.children = entityDesc.children || [];
        entityDesc.previousChildren = entityDesc.children.slice();
        var index = entityDesc.children.indexOf(childToRemoveId);
        if (index !== -1) {
            entityDesc.children.splice(index, 1);
        }
        this.fireExternalUpdate(entityId, { children: children });
        if (silent) {
            return;
        }
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            var childArray = [engine.getObjectById(childToRemoveId)];
            entityToChange.trigger('change:children', [], childArray);
        });
    };
    /**
     * Inform all engines of child entites that were added and removed from
     * the specified entity.
     * @method dispatchChildChanged
     * @public
     * @param {string} entityId The ID of the parent entity
     * @param {array} addedChildren Array of child ID's that have been added.
     * @param {array} removedChildren Array of child ID's that have been removed.
     * @param {boolean} [silent] Supress change event. Defaults to false.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchChildChanged = function (entityId, newChildren, silent) {
        var _this = this;
        if (newChildren === void 0) { newChildren = []; }
        var entityDesc = this.entities[entityId];
        if (!entityDesc) {
            return;
        }
        entityDesc.previousChildren = entityDesc.children ? entityDesc.children.slice() : [];
        var children = entityDesc.children = newChildren.slice();
        this.fireExternalUpdate(entityId, { children: children });
        if (silent) {
            return;
        }
        // Sort out a list of added and removed children to pass to each engine.
        var previousEntityMap = {};
        var newEntityMap = {};
        entityDesc.previousChildren.forEach(function (id) { return previousEntityMap[id] = _this.entities[id]; });
        children.forEach(function (id) { return newEntityMap[id] = _this.entities[id]; });
        var addedChildren = children.filter(function (id) {
            var entity = _this.entities[id];
            return entity && !previousEntityMap[id];
        });
        var removedChildren = entityDesc.previousChildren.filter(function (id) {
            var entity = _this.entities[id];
            return entity && !newEntityMap[id];
        });
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            // Translate the ID's to actual objects to pass to the engine.
            var addedObjs = addedChildren.map(function (id) { return engine.getObjectById(id); });
            var removedObjs = removedChildren.map(function (id) { return engine.getObjectById(id); });
            entityToChange.trigger('change:children', addedObjs, removedObjs);
        });
    };
    /**
     * Change a specified component with the given changes.
     * @method dispatchComponentChanged
     * @public
     * @param {string} entityId The ID of the entity that the change was made on.
     * @param {number} index The index of the component to change
     * @param {Object} componentChanges An object containing the values to change within the component
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchComponentChanged = function (entityId, index, componentChanges) {
        var entityDesc = this.entities[entityId];
        if (!entityDesc) {
            return;
        }
        var indexToChange = Math.min(Math.max(index, 0), entityDesc.components.length - 1);
        if (indexToChange < 0) {
            return;
        }
        if (!entityDesc.previousComponents) {
            entityDesc.previousComponents = [];
        }
        entityDesc.previousComponents[index] = deepClone_1.default(entityDesc.components[index]);
        var componentDesc = entityDesc.components[indexToChange];
        // Figure out changes
        var changes = deepClone_1.default(componentChanges);
        // Copy non-attributes
        Object.keys(changes).forEach(function (key) {
            if (key !== 'attributes') {
                componentDesc[key] = changes[key];
            }
        });
        // Copy attributes
        if (changes.attributes) {
            var attributes_1 = componentDesc.attributes || {};
            Object.keys(attributes_1).forEach(function (attribName) {
                // Delete the key if it has been set to undefined.
                if (changes.attributes.hasOwnProperty(attribName) &&
                    changes.attributes[attribName] === undefined) {
                    changes.attributes[attribName] = undefined;
                    delete attributes_1[attribName];
                }
            });
            Object.keys(changes.attributes).forEach(function (attribName) {
                attributes_1[attribName] = changes.attributes[attribName];
            });
        }
        this.fireExternalUpdate(entityId, { components: entityDesc.components });
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            entityToChange.trigger('change:component', indexToChange, changes);
        });
    };
    /**
     * Remove a component from the given entity and broadcast the change to all engines.
     * @method dispatchComponentRemoved
     * @public
     * @param {string} entityId The ID of the entity to remove the component from.
     * @param {number} index The index of the component in the components list.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchComponentRemoved = function (entityId, index) {
        var entityDesc = this.entities[entityId];
        if (!entityDesc && index >= entityDesc.components.length - 1) {
            return;
        }
        var indexToRemove = Math.min(Math.max(index, 0), entityDesc.components.length - 1);
        if (indexToRemove < 0) {
            return;
        }
        entityDesc.previousComponents = entityDesc.components ? entityDesc.components.slice() : [];
        entityDesc.components.splice(indexToRemove, 1);
        this.fireExternalUpdate(entityId, { components: entityDesc.components });
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            entityToChange.trigger('remove:component', indexToRemove);
        });
    };
    /**
     * Add a new component to the given entity and broadcast the change to all engines.
     * @method dispatchComponentAdded
     * @public
     * @param {string} entityId The ID of the entity to add the component to.
     * @param {Object} componentDesc Descriptor for the new component including id, attributes, etc.
     * @return {void}
     */
    EntityDispatcher.prototype.dispatchComponentAdded = function (entityId, componentDesc) {
        var entityDesc = this.entities[entityId];
        if (!entityDesc) {
            return;
        }
        entityDesc.previousComponents = entityDesc.components ? entityDesc.components.slice() : [];
        var addedComponent = deepClone_1.default(componentDesc);
        addedComponent.id = addedComponent.id || uuid_1.v4();
        addedComponent.name = addedComponent.name || 'unnamed component';
        addedComponent.attributes = addedComponent.attributes || {};
        addedComponent.enabled = addedComponent.enabled !== false ? true : false;
        entityDesc.components.push(addedComponent);
        this.fireExternalUpdate(entityId, { components: entityDesc.components });
        // Apply changes in each engine
        this.engines.forEach(function (engine) {
            var entityToChange = engine.getEntityById(entityId);
            entityToChange.trigger('add:component', addedComponent);
        });
    };
    /**
     * Fire events for entity updates intended for external apps to listen to.
     * @method fireExternalUpdate
     * @private
     * @param {String} entityId       Id of the entity that changed.
     * @param {Object} jsonDescriptor Description of what changed.
     * @param {String} [type] The type of change ('destroyEntity', 'createEntity', 'updateEntity')
     */
    EntityDispatcher.prototype.fireExternalUpdate = function (entityId, jsonDescriptor, type) {
        // TODO - create a pool of these objects to avoid allocating a new one each time?
        var updatePkg = new EntityUpdatePackage_1.default();
        updatePkg.type = type ? type : 'updateEntity';
        updatePkg.entityId = entityId;
        updatePkg.entityData = jsonDescriptor;
        globalEvents_1.default.trigger('EntityUpdates', updatePkg);
    };
    return EntityDispatcher;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EntityDispatcher;


/***/ },
/* 192 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var deepClone_1 = __webpack_require__(23);
var AnimationAsset_1 = __webpack_require__(55);
var ApplicationAsset_1 = __webpack_require__(56);
var BaseAsset_1 = __webpack_require__(7);
var BoneObject_1 = __webpack_require__(106);
var BufferAsset_1 = __webpack_require__(28);
var CameraObject_1 = __webpack_require__(107);
var DocumentAsset_1 = __webpack_require__(57);
var Engine_1 = __webpack_require__(105);
var ImageAsset_1 = __webpack_require__(29);
var LightObject_1 = __webpack_require__(108);
var MaterialAsset_1 = __webpack_require__(14);
var MeshObject_1 = __webpack_require__(47);
var MeshGeometryAsset_1 = __webpack_require__(58);
var NodeObject_1 = __webpack_require__(9);
var PrefabAsset_1 = __webpack_require__(59);
var PrimitiveGeometryAsset_1 = __webpack_require__(60);
var RenderTexture2DAsset_1 = __webpack_require__(61);
var RenderTextureCubeAsset_1 = __webpack_require__(62);
var SceneObject_1 = __webpack_require__(109);
var ScriptAsset_1 = __webpack_require__(63);
var ShaderAsset_1 = __webpack_require__(44);
var SkinAsset_1 = __webpack_require__(65);
var Texture2DAsset_1 = __webpack_require__(66);
var TextureCubeAsset_1 = __webpack_require__(67);
var VideoAsset_1 = __webpack_require__(30);
/**
 * A mixin providing entity creation, cataloging and querying capabilities.
 */
var EntityRegistry = (function () {
    function EntityRegistry() {
        /** The list of all objects registered */
        this.objects = {};
        /** The list of all assets registered */
        this.assets = {};
    }
    /**
     * Shutdown the entity registry, destroying all entities.
     */
    EntityRegistry.prototype.destroy = function () {
        var _this = this;
        this.getAssets().forEach(function (asset) { return _this.unregisterEntity(asset); });
        this.getObjects().forEach(function (object) { return _this.unregisterEntity(object); });
    };
    /**
     * Returns the first asset that is validated by the provided function.
     * @param predicate A function which returns 'true' or 'false', used to determine
     * which asset to return.
     * @returns         The first asset that matches the query
     */
    EntityRegistry.prototype.getAsset = function (predicate) {
        return this.getEntity(predicate, this.assets);
    };
    /**
     * Returns an array of assets that satisfy the given filter function.
     * @param [predicate] A function which returns 'true' or 'false'. Used to determine
     * which assets to return.
     * @returns           Array of assets that match the query
     */
    EntityRegistry.prototype.getAssets = function (predicate) {
        return this.getEntities(predicate, this.assets);
    };
    /**
     * Returns the asset with the provided Id.
     * @param assetId The ID of the asset
     * @returns       The asset or null if not found.
     */
    EntityRegistry.prototype.getAssetById = function (assetId) {
        return this.assets[assetId] || null;
    };
    /**
     * Returns the first asset with the provided name.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not built for high performance.
     * @param assetName The name of the asset
     * @returns         The asset, if found, or null if not found.
     */
    EntityRegistry.prototype.getAssetByName = function (assetName) {
        return this.getAsset(function (obj) { return obj.getName() === assetName; });
    };
    /**
     * Returns the assets with the provided name.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not built for high performance.
     * @param assetName The name of the asset
     * @returns         Array of matching assets
     */
    EntityRegistry.prototype.getAssetsByName = function (assetName) {
        return this.getAssets(function (obj) { return obj.getName() === assetName; });
    };
    /**
     * Returns the first asset with the provided type.
     * @param assetType The type of the asset
     * @returns         The first matching asset
     */
    EntityRegistry.prototype.getAssetByType = function (assetType) {
        return this.getAsset(function (obj) { return obj.type === assetType; });
    };
    /**
     * Returns the assets with the provided type.
     * @param assetType The type of the asset
     * @returns         Array of matching assets
     */
    EntityRegistry.prototype.getAssetsByType = function (assetType) {
        return this.getAssets(function (obj) { return obj.type === assetType; });
    };
    /**
     * Returns the first object that is validated by the provided function.
     * @param predicate A function which returns 'true' or 'false', used to determine
     * which object to return.
     * @returns         The first object that matches the query
     */
    EntityRegistry.prototype.getObject = function (predicate) {
        return this.getEntity(predicate, this.objects);
    };
    /**
     * Returns an array of objects that satisfy the given filter function.
     * @param [predicate] A function which returns 'true' or 'false'. Used to determine
     * which objects to return.
     * @returns           Array of objects that match the query
     */
    EntityRegistry.prototype.getObjects = function (predicate) {
        return this.getEntities(predicate, this.objects);
    };
    /**
     * Returns the object with the provided Id.
     * @param objectId  The ID of the object
     * @returns         The object or null if not found.
     */
    EntityRegistry.prototype.getObjectById = function (objectId) {
        return this.objects[objectId] || null;
    };
    /**
     * Returns the first object with the provided name.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not built for high performance.
     * @param objectName  The name of the object
     * @returns           The object, if found, or null if not found.
     */
    EntityRegistry.prototype.getObjectByName = function (objectName) {
        return this.getObject(function (obj) { return obj.getName() === objectName; });
    };
    /**
     * Returns the objects with the provided name.
     * Note: Care should be taken when calling this function often (such as every frame)
     * because it is not built for high performance.
     * @param objectName  The name of the object
     * @returns           Array of matching objects
     */
    EntityRegistry.prototype.getObjectsByName = function (objectName) {
        return this.getObjects(function (obj) { return obj.getName() === objectName; });
    };
    /**
     * Returns the first object with the provided type.
     * @param objectType  The type of the object
     * @returns           The first matching object
     */
    EntityRegistry.prototype.getObjectByType = function (objectType) {
        return this.getObject(function (obj) { return obj.type === objectType; });
    };
    /**
     * Returns the objects with the provided type.
     * @param objectType  The type of the object
     * @returns           Array of matching objects
     */
    EntityRegistry.prototype.getObjectsByType = function (objectType) {
        return this.getObjects(function (obj) { return obj.type === objectType; });
    };
    /**
     * Returns the first entity that is selected by the provided function.
     * @param predicate A function which returns 'true' or 'false'. Used to determine
     * which entity to return.
     * @param [entities]  Optional dictionary of entities, keyed by ID, to search within.
     * @returns           The first entity that matches the query
     */
    EntityRegistry.prototype.getEntity = function (predicate, entities) {
        if (!entities) {
            return this.getAsset(predicate) || this.getObject(predicate);
        }
        var entityId = Object.keys(entities).find(function (id) { return predicate(entities[id]); });
        return entities[entityId];
    };
    /**
     * Returns all entities that are selected by the provided function.
     * @param [predicate] A function which returns 'true' or 'false'. Used to determine
     * which entities to return.
     * @param [entities]  Optional dictionary of entities, keyed by ID, to search within.
     * @returns           Array of entities that matches the query
     */
    EntityRegistry.prototype.getEntities = function (predicate, entities) {
        if (!entities) {
            return this.getObjects(predicate).concat(this.getAssets(predicate));
        }
        var all = typeof predicate !== 'function';
        return Object.keys(entities)
            .filter(function (id) {
            return all || predicate(entities[id]);
        })
            .map(function (id) { return entities[id]; });
    };
    /**
     * Returns the entity with the provided Id. This includes ALL entities,
     * both assets and objects
     * @param entityId  The ID of the entity.
     * @returns         The entity or null if not found.
     */
    EntityRegistry.prototype.getEntityById = function (entityId) {
        return this.assets[entityId] || this.objects[entityId] || null;
    };
    /**
     * Returns the first entity with the provided type.
     * @param type  The type of the entity
     * @returns     The first matching entity
     */
    EntityRegistry.prototype.getEntityByType = function (type) {
        return this.getEntity(function (obj) { return obj.type === type; });
    };
    /**
     * Returns all entities with the provided type.
     * @param type  The type of the entity (e.g. 'material', 'scene', etc.)
     * @returns     An array of matching entities
     */
    EntityRegistry.prototype.getEntitiesByType = function (type) {
        return this.getEntities(function (entity) { return entity.type === type; });
    };
    /**
     * Returns the first entity with the provided name.
     * @param name  The name of the entity
     * @returns     The entity, if found, or null if not found.
     */
    EntityRegistry.prototype.getEntityByName = function (name) {
        return this.getEntity(function (obj) { return obj.getName() === name; });
    };
    /**
     * Returns all entities with the provided name.
     * @param name  The name of the entity
     * @returns     An array of matching entities
     */
    EntityRegistry.prototype.getEntitiesByName = function (name) {
        return this.getEntities(function (entity) { return entity.getName() === name; });
    };
    /**
     * Create an animation asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created animation asset.
     */
    EntityRegistry.prototype.createAnimation = function (properties, id) {
        return this.createEntityByType('animation', properties, id);
    };
    /**
     * Create an application asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created application asset.
     */
    EntityRegistry.prototype.createApplication = function (properties, id) {
        return this.createEntityByType('application', properties, id);
    };
    /**
     * Create an audio asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created audio asset.
     */
    EntityRegistry.prototype.createAudio = function (properties, id) {
        return this.createEntityByType('audio', properties, id);
    };
    /**
     * Create a bone object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created bone object.
     */
    EntityRegistry.prototype.createBone = function (properties, id) {
        return this.createEntityByType('bone', properties, id);
    };
    /**
     * Create a buffer asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created buffer asset.
     */
    EntityRegistry.prototype.createBuffer = function (properties, id) {
        return this.createEntityByType('buffer', properties, id);
    };
    /**
     * Create a camera object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created camera object.
     */
    EntityRegistry.prototype.createCamera = function (properties, id) {
        return this.createEntityByType('camera', properties, id);
    };
    /**
     * Create an image asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created image asset.
     */
    EntityRegistry.prototype.createImage = function (properties, id) {
        return this.createEntityByType('image', properties, id);
    };
    /**
     * Create a light object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created light object.
     */
    EntityRegistry.prototype.createLight = function (properties, id) {
        return this.createEntityByType('light', properties, id);
    };
    /**
     * Create a material asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created material asset.
     */
    EntityRegistry.prototype.createMaterial = function (properties, id) {
        return this.createEntityByType('material', properties, id);
    };
    /**
     * Create a mesh object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created mesh object.
     */
    EntityRegistry.prototype.createMesh = function (properties, id) {
        return this.createEntityByType('mesh', properties, id);
    };
    /**
     * Create a mesh geometry asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created mesh geometry asset.
     */
    EntityRegistry.prototype.createMeshGeometry = function (properties, id) {
        return this.createEntityByType('meshGeometry', properties, id);
    };
    /**
     * Create an empty node object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created node object.
     */
    EntityRegistry.prototype.createNode = function (properties, id) {
        return this.createEntityByType('node', properties, id);
    };
    /**
     * Create an empty scene object.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created scene object.
     */
    EntityRegistry.prototype.createScene = function (properties, id) {
        return this.createEntityByType('scene', properties, id);
    };
    /**
     * Create a prefab asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created prefab asset.
     */
    EntityRegistry.prototype.createPrefab = function (properties, id) {
        return this.createEntityByType('prefab', properties, id);
    };
    /**
     * Create a primitive geometry asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created primitive geometry asset.
     */
    EntityRegistry.prototype.createPrimitiveGeometry = function (properties, id) {
        return this.createEntityByType('primitiveGeometry', properties, id);
    };
    /**
     * Create a 2D render texture asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created render texture 2d asset.
     */
    EntityRegistry.prototype.createRenderTexture2d = function (properties, id) {
        return this.createEntityByType('renderTexture2D', properties, id);
    };
    /**
     * Create a cube render texture asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created render texture cube asset.
     */
    EntityRegistry.prototype.createRenderTextureCube = function (properties, id) {
        return this.createEntityByType('renderTextureCube', properties, id);
    };
    /**
     * Create a script asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created script asset.
     */
    EntityRegistry.prototype.createScript = function (properties, id) {
        return this.createEntityByType('script', properties, id);
    };
    /**
     * Create a shader asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created shader asset.
     */
    EntityRegistry.prototype.createShader = function (properties, id) {
        return this.createEntityByType('shader', properties, id);
    };
    /**
     * Create a skin asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created skin asset.
     */
    EntityRegistry.prototype.createSkin = function (properties, id) {
        return this.createEntityByType('skin', properties, id);
    };
    /**
     * Create a 2D texture asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created 2d texture asset.
     */
    EntityRegistry.prototype.createTexture2d = function (properties, id) {
        return this.createEntityByType('texture2D', properties, id);
    };
    /**
     * Create a cube texture asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created cube texture asset.
     */
    EntityRegistry.prototype.createTextureCube = function (properties, id) {
        return this.createEntityByType('textureCube', properties, id);
    };
    /**
     * Create a video asset.
     * @param [properties]  Initial properties for the entity.
     * @param [id]          Optional ID for the new entity.
     * @returns             The newly created video asset.
     */
    EntityRegistry.prototype.createVideo = function (properties, id) {
        return this.createEntityByType('video', properties, id);
    };
    /**
     * Create an entity with the defined type.
     * @param id    The ID for the new entity.
     * @param type  The type for the entity
     * @returns     The newly created entity.
     */
    EntityRegistry.prototype.createEntityByType = function (type, properties, id) {
        return this.createEntity({ id: id, type: type, properties: properties });
    };
    /**
     * Creates a new entity from a JSON descriptor.
     * @param entityDef Entity definition of the form:
     *                  {
     *                    id: <string>,
     *                    type: <string>,
     *                    properties: <Object>
     *                    components: <Array>
     *                  }
     * @returns         The newly created entity.
     */
    EntityRegistry.prototype.createEntity = function (entityDef) {
        var _this = this;
        var entityDesc = tslib_1.__assign({ type: 'node', properties: {}, components: [] }, deepClone_1.default(entityDef));
        var id = this.entityDispatcher.dispatchCreatedEntity(entityDef.id, entityDesc.type);
        var entity = this.getEntityById(id);
        if (entity instanceof BaseAsset_1.default) {
            this.entityDispatcher.dispatchAttributeChanged(id, 'representations', entityDesc.representations || []);
        }
        else {
            this.entityDispatcher.dispatchChildChanged(id, entityDesc.children || []);
            this.entityDispatcher.dispatchAttributeChanged(id, 'parentId', entityDesc.parentId || null);
            this.entityDispatcher.dispatchAttributeChanged(id, 'prefabAssetId', entityDesc.prefabAssetId || null);
            this.entityDispatcher.dispatchAttributeChanged(id, 'prefabObjectId', entityDesc.prefabObjectId || null);
            this.entityDispatcher.dispatchAttributeChanged(id, 'prefabInstanceId', entityDesc.prefabInstanceId || null);
        }
        this.entityDispatcher.dispatchInitEntity(id);
        this.entityDispatcher.dispatchPropertiesChanged(id, entityDesc.properties);
        entityDesc.components.forEach(function (compDesc) {
            return _this.entityDispatcher.dispatchComponentAdded(id, compDesc);
        });
        if (entityDesc.sid) {
            this.entityDispatcher.dispatchAttributeChanged(id, 'sid', entityDesc.sid || '');
        }
        if (this instanceof Engine_1.default) {
            this.trigger('entityCreated', entity);
        }
        return this.getEntityById(id);
    };
    /**
     * Deletes the asset and its hierarchy from the project.
     * Force-unloads the asset, if it is loaded.
     * @param assetId The ID of the asset to destroy
     */
    EntityRegistry.prototype.destroyAssetById = function (assetId) {
        var asset = this.getAssetById(assetId);
        this.destroyAsset(asset);
    };
    /**
     * Deletes the asset and its hierarchy from the project.
     * Force-unloads the asset, if it is loaded.
     * @param asset The BaseAsset to destroy
     */
    EntityRegistry.prototype.destroyAsset = function (asset) {
        var _this = this;
        if (!asset || !(asset instanceof BaseAsset_1.default)) {
            throw new Error('destroyAsset : You must specify a valid asset to destroy.');
        }
        asset.unload();
        if (asset instanceof PrefabAsset_1.default) {
            var rootObject = asset.getRootObject();
            if (rootObject) {
                var objects = rootObject.getDescendants();
                objects.forEach(function (obj) {
                    _this.destroyObject(obj);
                });
                rootObject.destroy();
            }
        }
        this.entityDispatcher.dispatchDestroyedEntity(asset.id);
    };
    /**
     * Deletes the object and its hierarchy from this asset.
     * @param objectId The ID of the object to destroy
     */
    EntityRegistry.prototype.destroyObjectById = function (objectId) {
        var object = this.getObjectById(objectId);
        this.destroyObject(object);
    };
    /**
     * Deletes the object and removes it from a hierarchy, if it was part of one.
     * @param object The NodeObject to destroy
     */
    EntityRegistry.prototype.destroyObject = function (object) {
        if (!object || !(object instanceof NodeObject_1.default)) {
            throw new Error('destroyObject : You must specify a valid object to destroy.');
        }
        var parent = object.getParentObject();
        if (parent) {
            parent.removeChild(object);
        }
        this.entityDispatcher.dispatchDestroyedEntity(object.id);
    };
    /**
     * This is called to remove the entity from this engine only. The entity will
     * still be available to other running engine instances.
     * @param entityId The ID of the entity to unregister.
     */
    EntityRegistry.prototype.unregisterEntityById = function (entityId) {
        this.unregisterEntity(this.getEntityById(entityId));
    };
    /**
     * This is called to remove the object from this engine only. The entity will
     * still be available to other running engine instances.
     * @param object The object to unregister.
     */
    EntityRegistry.prototype.unregisterEntity = function (entity) {
        if (!entity) {
            return;
        }
        // FIXME: Cast as any to bypass function privacy
        entity.uninitialize();
        if (this.objects[entity.id]) {
            delete this.objects[entity.id];
        }
        else {
            entity.off('load', this.onAssetLoaded, this);
            entity.off('unload', this.onAssetUnloaded, this);
            delete this.assets[entity.id];
        }
    };
    /**
     * Returns the class for the given entity type.
     * @param type  The name of the entity type. e.g. 'scene', 'material', etc.
     * @returns     A reference to the entity class
     */
    EntityRegistry.prototype.getEntityClass = function (type) {
        switch (type) {
            case 'animation':
                return AnimationAsset_1.default;
            case 'application':
                return ApplicationAsset_1.default;
            case 'bone':
                return BoneObject_1.default;
            case 'buffer':
                return BufferAsset_1.default;
            case 'camera':
                return CameraObject_1.default;
            case 'document':
                return DocumentAsset_1.default;
            case 'image':
                return ImageAsset_1.default;
            case 'light':
                return LightObject_1.default;
            case 'material':
                return MaterialAsset_1.default;
            case 'mesh':
                return MeshObject_1.default;
            case 'meshGeometry':
                return MeshGeometryAsset_1.default;
            case 'node':
                return NodeObject_1.default;
            case 'object':
                return NodeObject_1.default;
            case 'prefab':
                return PrefabAsset_1.default;
            case 'primitiveGeometry':
                return PrimitiveGeometryAsset_1.default;
            case 'renderTexture2D':
                return RenderTexture2DAsset_1.default;
            case 'renderTextureCube':
                return RenderTextureCubeAsset_1.default;
            case 'scene':
                return SceneObject_1.default;
            case 'script':
                return ScriptAsset_1.default;
            case 'shader':
                return ShaderAsset_1.default;
            case 'skin':
                return SkinAsset_1.default;
            case 'texture2D':
                return Texture2DAsset_1.default;
            case 'textureCube':
                return TextureCubeAsset_1.default;
            case 'video':
                return VideoAsset_1.default;
            default:
                return null;
        }
    };
    /**
     * Internal method for registering a new entity. This is called in each engine instance
     * after calling createEntity().
     * @param jsonDesc Descriptor of new entity
     */
    EntityRegistry.prototype.registerEntity = function (jsonDesc) {
        var newEntity = new (this.getEntityClass(jsonDesc.type))(jsonDesc);
        // Bypass type checking because `this` does not type check as Engine due to
        // mixin.
        newEntity.engine = this;
        if (newEntity instanceof BaseAsset_1.default) {
            this.assets[newEntity.id] = newEntity;
            newEntity.on('load', this.onAssetLoaded, this);
            newEntity.on('unload', this.onAssetUnloaded, this);
        }
        else {
            this.objects[newEntity.id] = newEntity;
        }
    };
    /**
     * Called when each registered asset loads and triggers an engine-wide
     * event that can be listened to.
     * @param asset The asset that just loaded.
     */
    EntityRegistry.prototype.onAssetLoaded = function (asset) {
        // Bypass type checking because `this` does not type check as RuntimeEvents
        // due to mixin.
        this.trigger('assetLoaded', asset);
    };
    /**
     * Called when each registered asset unloads and triggers an engine-wide
     * event that can be listened to.
     * @param asset The asset that just unloaded.
     */
    EntityRegistry.prototype.onAssetUnloaded = function (asset) {
        this.trigger('assetUnloaded', asset);
    };
    return EntityRegistry;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EntityRegistry;


/***/ },
/* 193 */
/***/ function(module, exports) {

"use strict";
"use strict";
var EntityUpdatePackage = (function () {
    function EntityUpdatePackage() {
        this.type = 'updateEntity';
        this.entityId = '';
        this.entityData = {};
    }
    return EntityUpdatePackage;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = EntityUpdatePackage;


/***/ },
/* 194 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var THREE = __webpack_require__(1);
var Box3DShaderParameters_1 = __webpack_require__(195);
var uberPBRVertexShader = __webpack_require__(212);
var uberPBRFragmentShader = __webpack_require__(211);
var box3DShaderPBR = {
    id: 'box3d_pbr_shader',
    type: 'shader',
    properties: {
        name: 'PBR Shader',
        vertexShader: uberPBRVertexShader,
        fragmentShader: uberPBRFragmentShader,
        features: {
            albedo: {
                displayName: 'Albedo',
                defaultEnabled: true,
                parameters: [
                    'albedoColor',
                    'albedoMap',
                    'aoMap',
                    'envMapIrradiance'
                ]
            },
            transparency: {
                displayName: 'Transparency',
                defaultEnabled: false,
                parameters: [
                    'opacity',
                    'alphaMap',
                    'blending',
                    'blendEquation',
                    'blendSrc',
                    'blendDst',
                    'useSeparateAlphaBlend',
                    'blendEquationAlpha',
                    'blendSrcAlpha',
                    'blendDstAlpha'
                ]
            },
            specular: {
                displayName: 'Specular',
                defaultEnabled: false,
                parameters: [
                    'specularColor',
                    'specularMap',
                    'glossMap',
                    'roughness',
                    'roughnessMap',
                    'reflectivity',
                    'envMapGlossVariance',
                    'envMapRadiance',
                    'envMapRadianceHalfGloss'
                ]
            },
            clearCoat: {
                displayName: 'Clear Coat',
                defaultEnabled: false,
                parameters: [
                    'clearCoat',
                    'clearCoatRoughness'
                ]
            },
            metalness: {
                displayName: 'Metalness',
                defaultEnabled: false,
                parameters: [
                    'metalness',
                    'metalnessMap'
                ]
            },
            normals: {
                displayName: 'Bump/Normals',
                defaultEnabled: false,
                parameters: [
                    'normalMap',
                    'normalScale',
                    'bumpMap',
                    'bumpScale'
                ]
            },
            emissive: {
                displayName: 'Emissive',
                defaultEnabled: false,
                parameters: [
                    'emissiveColor',
                    'emissiveMap'
                ]
            },
            rendering: {
                displayName: 'Render Parameters',
                alwaysEnabled: true,
                parameters: [
                    'fog',
                    'side',
                    'depthWrite',
                    'depthTest',
                    'depthFunc',
                    'alphaTest',
                    'polygonOffset',
                    'polygonOffsetFactor',
                    'polygonOffsetUnits'
                ]
            }
        },
        parameters: Box3DShaderParameters_1.default,
        uniforms: THREE.UniformsUtils.merge([
            THREE.UniformsLib.common,
            THREE.UniformsLib.emissivemap,
            THREE.UniformsLib.bumpmap,
            THREE.UniformsLib.normalmap,
            THREE.UniformsLib.roughnessmap,
            THREE.UniformsLib.metalnessmap,
            THREE.UniformsLib.displacementmap,
            THREE.UniformsLib.fog,
            THREE.UniformsLib.lights,
            {
                time: { value: 1.0 },
                emissive: { value: new THREE.Color(0x000000) },
                specular: { value: new THREE.Color(0x111111) },
                roughness: { value: 0 },
                metalness: { value: 0 },
                clearCoat: { value: 0 },
                clearCoatRoughness: { value: 0 },
                envMapIntensity: { value: 1 }
            }
        ])
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = box3DShaderPBR;


/***/ },
/* 195 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var THREE = __webpack_require__(1);
var shaderParameters = {
    // Diffuse
    albedoColor: {
        displayName: 'Base Albedo',
        description: 'A color to tint the material with.',
        type: 'c',
        default: { r: 1.0, g: 1.0, b: 1.0 },
        min: 0.0,
        max: 1.0,
        isUniform: true,
        uniformName: 'diffuse'
    },
    albedoMap: {
        displayName: 'Albedo Map',
        description: 'A texture that modifies the diffuse color of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        uniformName: 'map',
        enabledWhen: {
            albedoMap: {
                notEqualsDefault: true
            }
        }
    },
    // Transparency
    opacity: {
        displayName: 'Opacity',
        description: 'This option controls the total opacity of the material.',
        type: 'f',
        default: 1.0,
        min: 0.0,
        max: 1.0,
        isUniform: true,
        isRenderParam: true,
        transparency: 'LessThanOne'
    },
    alphaMap: {
        displayName: 'Alpha Map',
        description: 'A texture that stores the transparency info of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            alphaMap: {
                notEqualsDefault: true
            }
        }
    },
    // Specular
    specularColor: {
        displayName: 'Specular Color',
        description: 'A color to tint the material with.',
        type: 'c',
        default: { r: 1.0, g: 1.0, b: 1.0 },
        min: 0.0,
        max: 1.0,
        isUniform: true,
        uniformName: 'specular'
    },
    specularMap: {
        displayName: 'Specular Map',
        description: 'A texture that contains the specular color of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            specularMap: {
                notEqualsDefault: true
            }
        }
    },
    metalness: {
        displayName: 'Metalness',
        description: 'How metallic the surface appears (multiplied by the metalness texture).',
        type: 'f',
        min: 0.0,
        max: 1.0,
        default: 0.0,
        isUniform: true
    },
    metalnessMap: {
        displayName: 'Metalness Map',
        description: 'A texture that contains the metalness of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            metalnessMap: {
                notEqualsDefault: true
            }
        }
    },
    glossMap: {
        displayName: 'Gloss Map',
        description: 'A texture that stores the gloss info of the material.',
        type: 't',
        default: null,
        isUniform: true,
        enabledWhen: {
            glossMap: {
                notEqualsDefault: true
            },
            roughnessMap: {
                equalsDefault: true
            }
        }
    },
    roughness: {
        displayName: 'Roughness',
        description: 'How rough the surface appears.',
        type: 'f',
        min: 0.0,
        max: 1.0,
        default: 0.0,
        isUniform: true,
        isRenderParam: true
    },
    roughnessMap: {
        displayName: 'Roughness Map',
        description: 'A texture that stores the roughness info of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            roughnessMap: {
                notEqualsDefault: true
            }
        }
    },
    reflectivity: {
        displayName: 'Reflectivity',
        description: 'Reflectivity at normal incidence. i.e. when viewing the surface directly.',
        type: 'f',
        min: 0.0,
        max: 1.0,
        default: 0.02,
        isUniform: true,
        isRenderParam: true,
        uniformName: 'reflectivity'
    },
    normalMap: {
        displayName: 'Normal Map',
        description: '',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        derivatives: true,
        textureUsage: 'normal',
        enabledWhen: {
            normalMap: {
                notEqualsDefault: true
            }
        }
    },
    normalScale: {
        displayName: 'Normal Scale',
        description: 'blah',
        type: 'v2',
        default: { x: 1.0, y: 1.0 },
        isUniform: true,
        isRenderParam: true
    },
    bumpMap: {
        displayName: 'Bump Map',
        description: '',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        derivatives: true,
        textureUsage: 'bump',
        enabledWhen: {
            normalMap: {
                equalsDefault: true
            },
            bumpMap: {
                notEqualsDefault: true
            }
        }
    },
    bumpScale: {
        displayName: 'Bump Scale',
        description: 'blah',
        type: 'f',
        min: 0.0,
        max: 20.0,
        default: 1.0,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            normalMap: {
                equalsDefault: true
            },
            bumpMap: {
                notEqualsDefault: true
            }
        },
        displayWhen: {
            useBump: {
                equals: true
            }
        }
    },
    clearCoat: {
        displayName: 'Clear Coat',
        type: 'f',
        min: 0.0,
        max: 1.0,
        isUniform: true,
        isRenderParam: true,
        default: 0.0
    },
    clearCoatRoughness: {
        displayName: 'Clear Coat',
        type: 'f',
        min: 0.0,
        max: 1.0,
        isUniform: true,
        isRenderParam: true,
        default: 0.0
    },
    envMapRadiance: {
        displayName: 'Specular Light Map',
        description: 'A map that represents the surrounding environment. Used for' +
            ' reflections.',
        type: 't',
        default: null,
        isUniform: true,
        forceUpdate: true,
        enabledWhen: {
            envMapRadiance: {
                notEqualsDefault: true
            }
        }
    },
    envMapRadianceHalfGloss: {
        displayName: 'Specular Light Map',
        description: 'A cube-map that represents the surrounding environment. Used for' +
            ' reflections.',
        type: 't',
        textureType: 'Cube',
        default: null,
        isUniform: true,
        enabledWhen: {
            envMapIrradiance: {
                notEqualsDefault: true
            },
            envMapRadiance: {
                notEqualsDefault: true
            },
            envMapRadianceHalfGloss: {
                notEqualsDefault: true
            }
        }
    },
    envMapIrradiance: {
        displayName: 'Specular Light Map',
        description: 'A cube-map that represents the surrounding environment. Used for' +
            ' reflections.',
        type: 't',
        textureType: 'Cube',
        default: null,
        isUniform: true,
        enabledWhen: {
            envMapIrradiance: {
                notEqualsDefault: true
            }
        },
        displayWhen: {
            envMapIrradiance: {
                notEqualsDefault: true
            }
        }
    },
    envMapGlossVariance: {
        displayName: 'Environment Map Gloss Variance',
        description: 'Turn on multi-sampling of environment map based on ' +
            'varying glossiness of surface.',
        type: 'b',
        default: true,
        forceUpdate: true,
        enabledWhen: {
            envMapGlossVariance: {
                equals: true
            }
        }
    },
    emissiveColor: {
        displayName: 'Emissive Color',
        description: 'A color that represents the light emitted by the material.',
        type: 'c',
        default: { r: 0.0, g: 0.0, b: 0.0 },
        isUniform: true,
        isRenderParam: true,
        uniformName: 'emissive'
    },
    emissiveMap: {
        displayName: 'Emissive Map',
        description: 'A texture that modifies the emissive color of the material.',
        type: 't',
        default: null,
        isUniform: true,
        isRenderParam: true,
        enabledWhen: {
            emissiveMap: {
                notEqualsDefault: true
            }
        }
    },
    aoMap: {
        displayName: 'AO Map',
        description: 'The ambient occlusion of the material.',
        type: 't',
        default: null,
        isUniform: true,
        enabledWhen: {
            aoMap: {
                notEqualsDefault: true
            }
        }
    },
    side: {
        displayName: 'Cull Mode',
        description: 'This controls which side of the geometry will be visible.',
        type: 'opt',
        isRenderParam: true,
        options: {
            frontOnly: THREE.FrontSide,
            backOnly: THREE.BackSide,
            doubleSided: THREE.DoubleSide
        },
        default: 'doubleSided'
    },
    fog: {
        displayName: 'Enable Fog',
        description: 'This controls whether this material is affected by fog or not.',
        isRenderParam: true,
        forceUpdate: true,
        type: 'b',
        default: true
    },
    depthFunc: {
        displayName: 'Depth Function',
        description: '',
        isRenderParam: true,
        type: 'opt',
        options: {
            never: THREE.NeverDepth,
            always: THREE.AlwaysDepth,
            lessThan: THREE.LessDepth,
            lessThanOrEqual: THREE.LessEqualDepth,
            equal: THREE.EqualDepth,
            greaterThanOrEqual: THREE.GreaterEqualDepth,
            greaterThan: THREE.GreaterDepth,
            notEqual: THREE.NotEqualDepth
        },
        default: 'lessThanOrEqual'
    },
    depthWrite: {
        displayName: 'Enable Depth Write',
        description: 'This controls whether the depth values of a mesh rendered with this' +
            ' material are recorded.',
        isRenderParam: true,
        type: 'b',
        default: true
    },
    depthTest: {
        displayName: 'Enable Depth Test',
        description: 'This controls whether a depth check is done before this material is' +
            ' rendered so that it can be occluded.',
        isRenderParam: true,
        type: 'b',
        default: true
    },
    blending: {
        displayName: 'Blending Mode',
        description: 'This controls how the material will be blended with the color behind it.',
        isRenderParam: true,
        type: 'opt',
        options: {
            none: THREE.NoBlending,
            normal: THREE.NormalBlending,
            additive: THREE.AdditiveBlending,
            subtractive: THREE.SubtractiveBlending,
            multiplicative: THREE.MultiplyBlending,
            custom: THREE.CustomBlending
        },
        default: 'normal',
        transparency: 'GreaterThanOne'
    },
    blendEquation: {
        displayName: 'Blending Equation',
        description: 'TODO.',
        isRenderParam: true,
        type: 'opt',
        options: {
            add: THREE.AddEquation,
            subtract: THREE.SubtractEquation,
            reverseSubtract: THREE.ReverseSubtractEquation,
            minimum: THREE.MinEquation,
            maximum: THREE.MaxEquation
        },
        default: 'add',
        displayWhen: {
            blending: {
                equals: 'custom'
            }
        }
    },
    blendSrc: {
        displayName: 'Blend Source',
        description: 'TODO.',
        isRenderParam: true,
        type: 'opt',
        options: {
            zero: THREE.ZeroFactor,
            one: THREE.OneFactor,
            sourceColor: THREE.SrcColorFactor,
            oneMinusSourceColor: THREE.OneMinusSrcColorFactor,
            sourceAlpha: THREE.SrcAlphaFactor,
            oneMinusSourceAlpha: THREE.OneMinusSrcAlphaFactor,
            destinationAlpha: THREE.DstAlphaFactor,
            oneMinusDestinationAlpha: THREE.OneMinusDstAlphaFactor
        },
        default: 'sourceAlpha',
        displayWhen: {
            blending: {
                equals: 'custom'
            }
        }
    },
    blendDst: {
        displayName: 'Blend Destination',
        description: 'TODO.',
        isRenderParam: true,
        type: 'opt',
        options: {
            zero: THREE.ZeroFactor,
            one: THREE.OneFactor,
            sourceColor: THREE.SrcColorFactor,
            oneMinusSourceColor: THREE.OneMinusSrcColorFactor,
            sourceAlpha: THREE.SrcAlphaFactor,
            oneMinusSourceAlpha: THREE.OneMinusSrcAlphaFactor,
            destinationAlpha: THREE.DstAlphaFactor,
            oneMinusDestinationAlpha: THREE.OneMinusDstAlphaFactor,
            destinationColor: THREE.DstColorFactor,
            oneMinusDestinationColor: THREE.OneMinusDstColorFactor,
            sourceAlphaSaturate: THREE.SrcAlphaSaturateFactor
        },
        default: 'one',
        displayWhen: {
            blending: {
                equals: 'custom'
            }
        }
    },
    useSeparateAlphaBlend: {
        displayName: 'Separate Blend for Alpha',
        description: 'TODO',
        type: 'b',
        default: false,
        displayWhen: {
            blending: {
                equals: 'custom'
            }
        }
    },
    blendEquationAlpha: {
        displayName: 'Alpha Blend Equation',
        description: 'TODO',
        isRenderParam: true,
        type: 'opt',
        options: {
            add: THREE.AddEquation,
            subtract: THREE.SubtractEquation,
            reverseSubtract: THREE.ReverseSubtractEquation,
            minimum: THREE.MinEquation,
            maximum: THREE.MaxEquation
        },
        default: 'add',
        displayWhen: {
            blending: {
                equals: 'custom'
            },
            useSeparateAlphaBlend: {
                equals: true
            }
        },
        enabledWhen: {
            useSeparateAlphaBlend: {
                equals: true
            }
        }
    },
    blendSrcAlpha: {
        displayName: 'Alpha Blend Source',
        description: 'TODO.',
        isRenderParam: true,
        type: 'opt',
        options: {
            zero: THREE.ZeroFactor,
            one: THREE.OneFactor,
            sourceColor: THREE.SrcColorFactor,
            oneMinusSourceColor: THREE.OneMinusSrcColorFactor,
            sourceAlpha: THREE.SrcAlphaFactor,
            oneMinusSourceAlpha: THREE.OneMinusSrcAlphaFactor,
            destinationAlpha: THREE.DstAlphaFactor,
            oneMinusDestinationAlpha: THREE.OneMinusDstAlphaFactor
        },
        default: 'sourceAlpha',
        displayWhen: {
            blending: {
                equals: 'custom'
            },
            useSeparateAlphaBlend: {
                equals: true
            }
        },
        enabledWhen: {
            useSeparateAlphaBlend: {
                equals: true
            }
        }
    },
    blendDstAlpha: {
        displayName: 'Alpha Blend Destination',
        description: 'TODO.',
        isRenderParam: true,
        type: 'opt',
        options: {
            zero: THREE.ZeroFactor,
            one: THREE.OneFactor,
            sourceColor: THREE.SrcColorFactor,
            oneMinusSourceColor: THREE.OneMinusSrcColorFactor,
            sourceAlpha: THREE.SrcAlphaFactor,
            oneMinusSourceAlpha: THREE.OneMinusSrcAlphaFactor,
            destinationAlpha: THREE.DstAlphaFactor,
            oneMinusDestinationAlpha: THREE.OneMinusDstAlphaFactor,
            destinationColor: THREE.DstColorFactor,
            oneMinusDestinationColor: THREE.OneMinusDstColorFactor,
            sourceAlphaSaturate: THREE.SrcAlphaSaturateFactor
        },
        default: 'one',
        displayWhen: {
            blending: {
                equals: 'custom'
            },
            useSeparateAlphaBlend: {
                equals: true
            }
        },
        enabledWhen: {
            useSeparateAlphaBlend: {
                equals: true
            }
        }
    },
    polygonOffset: {
        displayName: 'Polygon Offset',
        description: 'Turns on rendering with polygon offsets. This can be used to work' +
            ' around z-fighting.',
        isRenderParam: true,
        type: 'b',
        default: false
    },
    polygonOffsetFactor: {
        displayName: 'Polygon Offset Factor',
        description: 'Scales the maximum Z slope, with respect to X or Y of the polygon.',
        isRenderParam: true,
        type: 'f',
        default: 1.0
    },
    polygonOffsetUnits: {
        displayName: 'Polygon Offset Units',
        description: 'Scales the minimum resolvable depth buffer value.',
        isRenderParam: true,
        type: 'f',
        default: 1.0
    },
    alphaTest: {
        displayName: 'Alpha Test',
        description: 'Pixels with an alpha value below the given value will not be rendered.' +
            ' This value will only be used when this material\'s Transparency blending mode' +
            ' is set to "Masked"',
        isRenderParam: true,
        forceUpdate: true,
        type: 'f',
        default: 0.2,
        min: 0.0,
        max: 1.0,
        step: 0.001
    }
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = shaderParameters;


/***/ },
/* 196 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
/* tslint:disable no-string-literal */
var MaterialAsset_1 = __webpack_require__(14);
var BaseTextureAsset_1 = __webpack_require__(20);
/**
 * Utilities for managing material assets
 */
var MaterialUtilities = (function () {
    /**
     * Creates an instance of MaterialUtilities.
     * @param engine The engine instance that this is connected to.
     */
    function MaterialUtilities(engine) {
        this.engine = engine;
        /** An array of standin texture definitions keyed by the StandinTexture enum. */
        this.standInTextures = [];
        this.engine = engine;
        this.engine.on('rebuildMaterials', this.rebuildAll, this);
        this.engine.on('resize', this.onResize, this);
        this.engine.on('update', this.update, this);
        this.standInTextures[MaterialAsset_1.StandInTexture.STANDIN_TEXTURE_WHITE] = {
            texture: null,
            color: [255, 255, 255]
        };
        this.standInTextures[MaterialAsset_1.StandInTexture.STANDIN_TEXTURE_WHITE_CUBE] = {
            texture: null,
            color: [255, 255, 255],
            type: 'Cube'
        };
        this.standInTextures[MaterialAsset_1.StandInTexture.STANDIN_TEXTURE_BLACK] = {
            texture: null,
            color: [0, 0, 0]
        };
        this.standInTextures[MaterialAsset_1.StandInTexture.STANDIN_TEXTURE_BLACK_CUBE] = {
            texture: null,
            color: [0, 0, 0],
            type: 'Cube'
        };
        this.standInTextures[MaterialAsset_1.StandInTexture.STANDIN_TEXTURE_NORMAL] = {
            texture: null,
            color: [127, 127, 255]
        };
    }
    /** Called to cleanup data used by the utilities */
    MaterialUtilities.prototype.destroy = function () {
        this.engine.off('rebuildMaterials', this.rebuildAll, this);
        this.engine.off('resize', this.onResize, this);
        this.engine.off('update', this.update, this);
        this.standInTextures.forEach(function (standInTexture) {
            if (standInTexture.texture) {
                standInTexture.texture.dispose();
            }
        });
    };
    /**
     * Returns a material asset to be used in place of missing assets.
     * @returns The missing material.
     */
    MaterialUtilities.prototype.getMissingMaterial = function () {
        return this.engine.getAssetById('missingMaterial');
    };
    /**
     * Returns a texture intended to be used as a placeholder while another texture loads.
     * e.g. MaterialAsset.STANDIN_TEXTURE_NORMAL results in a 1x1 normal map and can allow a
     * material to render without artifacts while a full-res normal map loads.
     * @param texEnum Texture stand-in type. MaterialAsset.STANDIN_TEXTURE_WHITE, etc.
     * @returns       THREE.DataTexture or THREE.CubeTexture
     */
    MaterialUtilities.prototype.getStandInTexture = function (texEnum) {
        if (!this.standInTextures[texEnum]) {
            return null;
        }
        if (!this.standInTextures[texEnum].texture) {
            var color = this.standInTextures[texEnum].color;
            if (this.standInTextures[texEnum].type === 'Cube') {
                this.standInTextures[texEnum].texture =
                    BaseTextureAsset_1.default.createColorTextureCube(color[0], color[1], color[2]);
            }
            else {
                this.standInTextures[texEnum].texture =
                    BaseTextureAsset_1.default.createColorTexture(color[0], color[1], color[2]);
            }
        }
        return this.standInTextures[texEnum].texture;
    };
    /**
     * Called each frame to update shared material data
     * @param delta The time elapsed since the last tick.
     */
    MaterialUtilities.prototype.update = function (delta) {
        if (MaterialAsset_1.default.timeValueInUse) {
            this.engine.needsRender = true;
        }
        MaterialAsset_1.default.sharedUniforms['time'].value = delta;
    };
    /** Called to trigger all material assets to update their corresponding three.js data. */
    MaterialUtilities.prototype.rebuildAll = function () {
        var materials = this.engine.getAssetsByType('material');
        materials.forEach(function (matAsset) {
            if (matAsset.runtimeData) {
                Object.keys(MaterialAsset_1.default.materialObjectTypes).forEach(function (matObjType) {
                    matAsset.runtimeData[matObjType].needsUpdate = true;
                });
            }
        });
    };
    /** Called when the resize event is triggered. This will update relevant material data. */
    MaterialUtilities.prototype.onResize = function () {
        var screenDimensions = MaterialAsset_1.default.sharedUniforms['screenDimensions'];
        screenDimensions.value.x = 0;
        screenDimensions.value.y = 0;
        var renderer = this.engine.getRenderer();
        if (renderer) {
            screenDimensions.value.z = renderer.getCanvasWidth();
            screenDimensions.value.w = renderer.getCanvasHeight();
        }
        else {
            screenDimensions.value.z = 128;
            screenDimensions.value.w = 128;
        }
    };
    return MaterialUtilities;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = MaterialUtilities;


/***/ },
/* 197 */
/***/ function(module, exports) {

"use strict";
/**
 * @author alteredq / http://alteredqualia.com/
 *
 * Full-screen textured quad shader
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    uniforms: {
        tDiffuse: { value: null },
        opacity: { value: 1.0 }
    },
    vertexShader: [
        'varying vec2 vUv;',
        'void main() {',
        'vUv = uv;',
        'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
        '}'
    ].join('\n'),
    fragmentShader: [
        'uniform float opacity;',
        'uniform sampler2D tDiffuse;',
        'varying vec2 vUv;',
        'void main() {',
        'vec4 texel = texture2D( tDiffuse, vUv );',
        'gl_FragColor = opacity * texel;',
        '}'
    ].join('\n')
};


/***/ },
/* 198 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var THREE = __webpack_require__(1);
/**
 * @class ShaderPass
 */
var ShaderPass = (function () {
    /**
     * Creates an instance of ShaderPass.
     * @param {ShaderPassDef} shader
     * @param {string} [textureId='tDiffuse'] The texture id.
     */
    function ShaderPass(shader, textureId) {
        if (textureId === void 0) { textureId = 'tDiffuse'; }
        /**
         * Whether or not this shader pass is enabled.
         * @type {boolean}
         */
        this.enabled = true;
        /**
         * Whether or not the buffer should be swapped.
         * @type {boolean}
         */
        this.needsSwap = true;
        /**
         * Whether or not to render to screen.
         * @type {boolean}
         */
        this.renderToScreen = false;
        /**
         * Whether or not to clear on render.
         * @type {boolean}
         */
        this.clear = false;
        this.textureId = textureId;
        this.uniforms = THREE.UniformsUtils.clone(shader.uniforms);
        this.material = new THREE.ShaderMaterial({
            blending: THREE.NormalBlending,
            transparent: true,
            uniforms: this.uniforms,
            vertexShader: shader.vertexShader,
            fragmentShader: shader.fragmentShader
        });
        this.camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);
        this.scene = new THREE.Scene();
        this.quad = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), null);
        this.scene.add(this.quad);
        this.prevViewPort = new THREE.Vector4();
    }
    /**
     * Render the pass.
     *
     * @param {THREE.WebGLRenderer} renderer
     * @param {THREE.RenderTarget} writeBuffer
     * @param {THREE.Texture} readBuffer
     * @param {number} _delta
     *
     * @memberOf ShaderPass
     */
    ShaderPass.prototype.render = function (renderer, writeBuffer, readBuffer, _delta) {
        if (this.uniforms[this.textureId]) {
            this.uniforms[this.textureId].value = readBuffer;
        }
        this.quad.material = this.material;
        if (this.renderToScreen) {
            if (this.viewPort) {
                renderer.setViewport(this.viewPort.x, this.viewPort.y, this.viewPort.width, this.viewPort.height);
            }
            if (this.clearColor || this.clearDepth) {
                renderer.clear(!!this.clearColor, !!this.clearDepth, false);
            }
            renderer.render(this.scene, this.camera);
        }
        else if (this.renderToTexture) {
            if (this.clearColor || this.clearDepth) {
                renderer.clear(this.clearColor, this.clearDepth, false);
            }
            renderer.render(this.scene, this.camera, this.renderToTexture);
        }
        else {
            renderer.render(this.scene, this.camera, writeBuffer, this.clear);
        }
    };
    /**
     * Dispose of any data which belongs to this pass.
     *
     * @memberOf ShaderPass
     */
    ShaderPass.prototype.dispose = function () {
        this.quad.geometry.dispose();
        this.quad = undefined;
        this.camera = undefined;
        this.scene = undefined;
        this.material.dispose();
        this.material = undefined;
        this.uniforms = undefined;
    };
    return ShaderPass;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ShaderPass;


/***/ },
/* 199 */
/***/ function(module, exports) {

"use strict";
/**
 * @author miibond
 *
 * Unpack HDR texture in a variety of packing formats to full, 16-bit colour
 */
"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = {
    uniforms: {
        tDiffuse: { type: 't', value: null },
        rgbmMultiplier: { type: 'f', value: 9.0 }
    },
    vertexShader: [
        'varying vec2 vUv;',
        'void main() {',
        'vUv = uv;',
        '#ifdef FLIP_Y',
        'vUv.y = 1.0 - vUv.y;',
        '#endif',
        'gl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );',
        '}'
    ].join('\n'),
    fragmentShader: [
        'uniform sampler2D tDiffuse;',
        'uniform float rgbmMultiplier;',
        // Inverse logLuvMatrix matrix, for decoding
        'const mat3 InverseLogLuvMatrix = mat3(',
        '6.0014, -2.7008, -1.7996,',
        '-1.3320,  3.1029, -5.7721,',
        '0.3008, -1.0882,  5.6268);',
        'vec3 HDRDecodeLOGLUV(in vec4 vLogLuv)',
        '{',
        // Based on http://www.xnainfo.com/content.php?content=28
        'float Le = vLogLuv.z * 255.0 + vLogLuv.w;',
        'vec3 Xp_Y_XYZp;',
        'Xp_Y_XYZp.y = exp2((Le - 127.0) / 2.0);',
        'Xp_Y_XYZp.z = Xp_Y_XYZp.y / vLogLuv.y;',
        'Xp_Y_XYZp.x = vLogLuv.x * Xp_Y_XYZp.z;',
        'vec3 vRGB = InverseLogLuvMatrix * Xp_Y_XYZp;',
        'return vRGB;',
        '}',
        'vec3 HDRDecodeRGBM( vec4 rgbm ) {',
        // Based on http://vemberaudio.se/graphics/RGBdiv8.pdf
        'return rgbmMultiplier * rgbm.rgb * rgbm.a;',
        '}',
        'vec3 HDRDecodeRGBD( vec4 rgbd ) {',
        // Based on http://vemberaudio.se/graphics/RGBdiv8.pdf
        'return rgbd.rgb / max(rgbd.a, 0.003);',
        '}',
        'vec3 HDRDecodeRGBE( vec4 rgbe ) {',
        // Based on http://www.graphics.cornell.edu/~bjw/rgbe/rgbe.c
        'float f = exp2( rgbe.w * 255.0 - (128.0 + 0.0) );',
        'return rgbe.rgb * f;',
        '}',
        'varying vec2 vUv;',
        'void main() {',
        'vec3 hdrColour;',
        '#ifdef HDR_RGBM',
        'hdrColour = HDRDecodeRGBM( texture2D( tDiffuse, vUv ) );',
        '#elif defined(HDR_RGBD)',
        'hdrColour = HDRDecodeRGBD( texture2D( tDiffuse, vUv ) );',
        '#elif defined(HDR_RGBE)',
        'hdrColour = HDRDecodeRGBE( texture2D( tDiffuse, vUv ) );',
        '#elif defined(HDR_LOGLUV)',
        'hdrColour = HDRDecodeLOGLUV( texture2D( tDiffuse, vUv ) );',
        '#else',
        'hdrColour = texture2D( tDiffuse, vUv ).xyz;',
        '#endif',
        'gl_FragColor = vec4( hdrColour, 1.0 );',
        '}'
    ].join('\n')
};


/***/ },
/* 200 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var RuntimeEvents_1 = __webpack_require__(21);
var LoadingState_1 = __webpack_require__(48);
var LoadingEvent_1 = __webpack_require__(12);
var StateTransitionError_1 = __webpack_require__(206);
var classComposer_1 = __webpack_require__(39);
exports.LoadableResourceMixins = classComposer_1.default({}, [RuntimeEvents_1.default]);
/**
 * This class encapsulates everything related to the loading of an asset.
 *
 * @class LoadableResource
 * @mixes RuntimeEvents
 */
var LoadableResource = (function (_super) {
    tslib_1.__extends(LoadableResource, _super);
    /**
     * @constructor
     * @param {String} path The path to the file to load.
     * @param {String} type The type of resource used to determine loading strategy.
     * @param {Object} params Additional options fed in to the loading strategy.
     */
    function LoadableResource(path, type, params) {
        if (params === void 0) { params = {}; }
        var _this = _super.call(this) || this;
        _this.path = path;
        _this.type = type;
        _this.params = params;
        _this.state = LoadingState_1.default.STARTING;
        _this.error = undefined;
        _this.data = undefined;
        _this.loaderData = {};
        if (!path) {
            throw new Error('Missing required `path` argument');
        }
        if (!type) {
            throw new Error('Missing required `type` argument');
        }
        return _this;
    }
    /**
     * Sets the current state of the loading process assuming it is a valid
     * transition. Otherwise an error is thrown.
     *
     * @method setState
     * @public
     * @param {LoadingState} state The new state.
     * @return {LoadingState} The new state.
     */
    LoadableResource.prototype.setState = function (state) {
        switch (state) {
            case LoadingState_1.default.STARTING:
                throw new StateTransitionError_1.default(this.state, state);
            case LoadingState_1.default.LOADING:
                if (this.state !== LoadingState_1.default.STARTING) {
                    throw new StateTransitionError_1.default(this.state, state);
                }
                break;
            case LoadingState_1.default.PROCESSING:
                if (this.state !== LoadingState_1.default.LOADING) {
                    throw new StateTransitionError_1.default(this.state, state);
                }
                break;
            case LoadingState_1.default.COMPLETE:
                if (this.state !== LoadingState_1.default.PROCESSING) {
                    throw new StateTransitionError_1.default(this.state, state);
                }
                break;
            case LoadingState_1.default.CANCELLED:
                if (this.state !== LoadingState_1.default.STARTING &&
                    this.state !== LoadingState_1.default.LOADING &&
                    this.state !== LoadingState_1.default.PROCESSING) {
                    throw new StateTransitionError_1.default(this.state, state);
                }
                break;
            case LoadingState_1.default.ERROR:
                if (this.state !== LoadingState_1.default.STARTING &&
                    this.state !== LoadingState_1.default.LOADING &&
                    this.state !== LoadingState_1.default.PROCESSING) {
                    throw new StateTransitionError_1.default(this.state, state);
                }
                break;
            default:
                throw new Error('Uknown state: ' + state);
        }
        this.state = state;
        this.trigger(LoadingEvent_1.default.STATE_CHANGE, state);
        return state;
    };
    /**
     * Sets the state to loading.
     *
     * @method setLoading
     * @public
     * @return {void}
     */
    LoadableResource.prototype.setLoading = function () {
        this.setState(LoadingState_1.default.LOADING);
    };
    /**
     * Sets the state to processing.
     *
     * @method setProcessing
     * @public
     * @return {void}
     */
    LoadableResource.prototype.setProcessing = function () {
        this.setState(LoadingState_1.default.PROCESSING);
    };
    /**
     * Sets the state to complete.
     *
     * @method setComplete
     * @public
     * @param {Mixed} data The data which has been loaded and processed.
     * @return {void}
     */
    LoadableResource.prototype.setComplete = function (data) {
        this.setState(LoadingState_1.default.COMPLETE);
        this.data = data;
        this.trigger(LoadingEvent_1.default.LOAD, data);
        this.done();
    };
    /**
     * Sets the state to error.
     *
     * @method setError
     * @public
     * @param {Error} error The exception which caused this error.
     * @return {void}
     */
    LoadableResource.prototype.setError = function (error) {
        this.setState(LoadingState_1.default.ERROR);
        this.error = error;
        this.trigger(LoadingEvent_1.default.ERROR, error);
        this.done();
    };
    /**
     * Sets the state to cancelled.
     *
     * @method setCancelled
     * @public
     * @return {void}
     */
    LoadableResource.prototype.setCancelled = function () {
        this.setState(LoadingState_1.default.CANCELLED);
        this.trigger(LoadingEvent_1.default.CANCEL);
        this.done();
    };
    /**
     * Checks whether or not the loading has been cancelled.
     *
     * @method isCancelled
     * @public
     * @return {Boolean}
     */
    LoadableResource.prototype.isCancelled = function () {
        return this.state === LoadingState_1.default.CANCELLED;
    };
    /**
     * Called on completion with any status (complete, error, cancelled)
     * @method done
     * @private
     * @return {void}
     */
    LoadableResource.prototype.done = function () {
        this.trigger(LoadingEvent_1.default.DONE, this.state);
        this.off();
    };
    return LoadableResource;
}(exports.LoadableResourceMixins));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = LoadableResource;


/***/ },
/* 201 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var common_1 = __webpack_require__(31);
/**
 * Takes the loaded data from the XHR object and converts it into data which can
 * be used by the runtime.
 * In the case of buffers we simply pass the loaded XHR response to the asset.
 * @function processBuffer
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @return {Promise}                   A promise which will allow for continuation of the
 *                                     processing.
 */
var processBuffer = function (resource) {
    resource.setProcessing();
    resource.setComplete(resource.loaderData.xhr.response);
    return Promise.resolve(resource);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A promise chain which trakes a LoadableResource instance and performs a
 * series of actions to load and produce data for a BufferAsset.
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @param  {Function} configureXhr     A function which returns a Promise to resolve an configured
 *                                     XMLHttpRequest object.
 * @return {Promise}                   Returns the tail of the promise chaina.
 */
exports.default = function (resource, configureXhr) {
    return common_1.makeXhr(configureXhr)(resource)
        .then(common_1.unlessCancelled(common_1.setResponseType('arraybuffer')))
        .then(common_1.unlessCancelled(common_1.loadXhr))
        .then(common_1.unlessCancelled(common_1.requireStatus(function (s) { return s === 200; })))
        .then(common_1.unlessCancelled(processBuffer))
        .catch(common_1.handleError(resource));
};


/***/ },
/* 202 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var Box3DShim = __webpack_require__(214);
var typeGuard_1 = __webpack_require__(172);
var common_1 = __webpack_require__(31);
/**
 * Takes the loaded data from the XHR object and converts it into data which can
 * be used by the runtime.
 * In the case of entities we need to run the loaded entities through the box3d shim
 * in order to ensure that they are converted to the current version.
 * @function processEntities
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @return {Promise}                   A promise which will allow for continuation of the
 *                                     processing.
 */
var processEntities = function (resource) {
    resource.setProcessing();
    // Handle parsing response for IE11 compatibility since return value is a string in that case.
    var json = typeof resource.loaderData.xhr.response === 'string' ?
        JSON.parse(resource.loaderData.xhr.response) : resource.loaderData.xhr.response;
    var queryIndex = resource.path.indexOf('?');
    var fromIndex = queryIndex >= 0 ? queryIndex : resource.path.length;
    var baseUrl = resource.path.slice(0, resource.path.lastIndexOf('/', fromIndex) + 1);
    // Make sure the major version is 4 or less.
    if (json === undefined || json.version === undefined || json.version.major > 4) {
        return Promise.reject(new Error('Unsupported data version'));
    }
    // The absolute pattern should match URLs like:
    //
    //   * http://example.com
    //   * HTTP://EXAMPLE.COM
    //   * https://www.example.com
    //   * ftp://example.com/file.txt
    //   * //cdn.example.com/lib.js
    //
    // but should not match URLs like:
    //
    //   * /myFolder/test.txt
    //   * test
    var absolutePattern = new RegExp(/^(?:[a-z]+:)?\/\//i);
    // The domain relative pattern should match URLs like: /myFolder/test.txt
    var domainRelativePattern = new RegExp(/^\//);
    // This predicate should match URLs that are not absolute and not
    // domain-relative.
    var isFileRelative = function (url) {
        return !url.match(absolutePattern) && !url.match(domainRelativePattern);
    };
    // Translate the entities with Box3DShim.
    var entities = Box3DShim.mapEntities(json.entities, json.version);
    // Prefix all "src" properties with baseUrl.
    entities.forEach(function (entity) {
        // Prefix image representation "src" properties:
        if (typeGuard_1.isAsset(entity) && entity.representations) {
            entity.representations.forEach(function (representation) {
                if (representation.src && isFileRelative(representation.src)) {
                    representation.src = baseUrl + representation.src;
                }
            });
        }
        // Prefix buffer entity "src" properties:
        if (entity.type === 'buffer') {
            var props = entity.properties;
            if (props.src && isFileRelative(props.src)) {
                props.src = baseUrl + props.src;
            }
        }
    });
    resource.setComplete(entities);
    return Promise.resolve(resource);
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A promise chain which takes a LoadableResource instance and performs a
 * series of actions to load and produce data for a BufferAsset.
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @param  {Function} configureXhr     A function which returns a Promise to resolve an configured
 *                                     XMLHttpRequest object.
 * @return {Promise}                   Returns the tail of the promise chain.
 */
exports.default = function (resource, configureXhr) {
    return common_1.makeXhr(configureXhr)(resource)
        .then(common_1.unlessCancelled(common_1.setResponseType('json')))
        .then(common_1.unlessCancelled(common_1.loadXhr))
        .then(common_1.unlessCancelled(common_1.requireStatus(function (s) { return s === 200; })))
        .then(common_1.unlessCancelled(processEntities))
        .catch(common_1.handleError(resource));
};


/***/ },
/* 203 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var common_1 = __webpack_require__(31);
/**
 * Takes the loaded data from the XHR object and converts it into data which can
 * be used by the runtime.
 * @function processImage
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @return {Promise}                   A promise which will allow for continuation of the
 *                                     processing
 */
var processImage = function (resource) {
    return new Promise(function (resolve) {
        resource.setProcessing();
        if (resource.loaderData.xhr.response instanceof Blob) {
            var url = URL.createObjectURL(resource.loaderData.xhr.response);
            var img_1 = new Image();
            img_1.onload = function () {
                resource.setComplete(img_1);
                resolve(resource);
            };
            img_1.src = url;
        }
        else {
            resource.setComplete(resource.loaderData.xhr.response);
            resolve(resource);
        }
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A promise chain which trakes a LoadableResource instance and performs a
 * series of actions to load and produce data for an ImageAsset.
 * @param  {LoadableResource} resource An object describing the resource which is being loaded
 *                                     as well as containing any required state for the load.
 * @param  {Function} configureXhr     A function which returns a Promise to resolve an configured
 *                                     XMLHttpRequest object.
 * @return {Promise}                   Returns the tail of the promise chain
 */
exports.default = function (resource, configureXhr) {
    return common_1.makeXhr(configureXhr)(resource)
        .then(common_1.unlessCancelled(common_1.setResponseType('blob')))
        .then(common_1.unlessCancelled(common_1.loadXhr))
        .then(common_1.unlessCancelled(common_1.requireStatus(function (s) { return s === 200; })))
        .then(common_1.unlessCancelled(processImage))
        .catch(common_1.handleError(resource));
};


/***/ },
/* 204 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var common_1 = __webpack_require__(31);
/**
 * Takes the loaded data from the XHR object and converts it into data which can
 * be used by the runtime.
 * @function processVideo
 * @param  {LoadableResource} resource The LoadableResource instance which is being loaded
 * @return {Promise}                   A promise which will allow for continuation of the
 *                                     processing
 */
var processVideo = function (resource) {
    return new Promise(function (resolve, reject) {
        resource.setProcessing();
        var url = URL.createObjectURL(resource.loaderData.xhr.response);
        var video = document.createElement('video');
        video.addEventListener('loadeddata', function () {
            resource.setComplete(video);
            resolve(resource);
        });
        video.addEventListener('error', function () { return reject(new Error('Failed to load video')); });
        video.src = url;
        video.load();
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * A promise chain which trakes a LoadableResource instance and performs a
 * series of actions to load and produce data for an VideoAsset.
 * @param  {LoadableResource} resource An object describing the resource which is being loaded
 *                                     as well as containing any required state for the load.
 * @param  {Function} configureXhr     A function which returns a Promise to resolve an configured
 *                                     XMLHttpRequest object.
 * @return {Promise}                   Returns the tail of the promise chain
 */
exports.default = function (resource, configureXhr) {
    return common_1.makeXhr(configureXhr)(resource)
        .then(common_1.unlessCancelled(common_1.setResponseType('blob')))
        .then(common_1.unlessCancelled(common_1.loadXhr))
        .then(common_1.unlessCancelled(common_1.requireStatus(function (s) { return s === 200; })))
        .then(common_1.unlessCancelled(processVideo))
        .catch(common_1.handleError(resource));
};


/***/ },
/* 205 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var Logger_1 = __webpack_require__(3);
var LoadingEvent_1 = __webpack_require__(12);
var BaseEntity_1 = __webpack_require__(11);
/**
 * ResourceLifecycle manages the lifecycle of loading resources for assets
 * including keeping track of currently loading assets and cancelling them at
 * engine shutdown.
 * @mixin ResourceLifecycle
 */
var ResourceLifecycle = (function () {
    function ResourceLifecycle() {
        /**
         * An array of LoadableResources loaded by this object.
         * @private
         * @type {LoadableResource[]}
         */
        this.loadingResources = [];
    }
    /**
     * Loads a resource
     * @param {String} path The path to the resource
     * @param {String} type The type @see LoadingType.js
     * @param {Function} callback A function which will be called on completion
     *                            including Success, Error and Cancellation
     * @param {Object} params Any additional data for the loading process
     * @returns {LoadableResource}
     */
    ResourceLifecycle.prototype.loadResource = function (path, type, callback, params) {
        var _this = this;
        if (params === void 0) { params = {}; }
        var resource = this.engine.resourceLoader.load(path, type, params);
        this.loadingResources.push(resource);
        resource.on(LoadingEvent_1.default.ERROR, function (err) {
            Logger_1.default.error(_this.engine.getName() +
                (" - ResourceLifecycle: Error loading " + _this.type + ",") +
                (_this.getName() + ", " + err.toString()));
            _this.setState(BaseEntity_1.StateType.Base, BaseEntity_1.State.Failed);
        });
        resource.on(LoadingEvent_1.default.DONE, function () {
            _this.loadingResources = _this.loadingResources.filter(function (l) { return l !== resource; });
            if (typeof callback === 'function') {
                callback();
            }
        });
        return resource;
    };
    /**
     * Aborts any requests currently being tracked
     * @method abortRequests
     * @returns {void}
     */
    ResourceLifecycle.prototype.abortRequests = function () {
        this.loadingResources.forEach(function (resource) { return resource.setCancelled(); });
    };
    return ResourceLifecycle;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = ResourceLifecycle;


/***/ },
/* 206 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var tslib_1 = __webpack_require__(0);
var LoadingState_1 = __webpack_require__(48);
/**
 * A custom error which captures failures in state transition.
 *
 * @class StateTransitionError
 */
var StateTransitionError = (function (_super) {
    tslib_1.__extends(StateTransitionError, _super);
    /**
     * @constructor
     * @param {String} from The initial state
     * @param {String} to The target state
     */
    function StateTransitionError(from, to) {
        var _this = _super.call(this, "Illegal state transition \"" + LoadingState_1.default[from] + "\" -> \"" + LoadingState_1.default[to] + "\"") || this;
        _this.from = from;
        _this.to = to;
        return _this;
    }
    return StateTransitionError;
}(Error));
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = StateTransitionError;


/***/ },
/* 207 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
var LoadableResource_1 = __webpack_require__(200);
var prioritizedConcurrentPromiseQueue_1 = __webpack_require__(209);
var bufferLoader_1 = __webpack_require__(201);
var imageLoader_1 = __webpack_require__(203);
var videoLoader_1 = __webpack_require__(204);
var entitiesLoader_1 = __webpack_require__(202);
var LoadingEvent_1 = __webpack_require__(12);
var LoadingType_1 = __webpack_require__(18);
var maxConcurrentDownloads = 4;
/**
 * Given a resource, resolve a Promise with an XHR object configured to request
 * via GET to the resource's path.
 * @param path      The path of the asset
 * @param _params   An optional map of parameters which can be used by the loading
 *                  process.
 * @returns         A promise with the configured XHR.
 */
var defaultXhrPromise = function (path, _params) {
    var xhr = new XMLHttpRequest();
    xhr.open('GET', path);
    return Promise.resolve(xhr);
};
var defaultStrategies = [];
defaultStrategies[LoadingType_1.default.BUFFER] = bufferLoader_1.default;
defaultStrategies[LoadingType_1.default.IMAGE] = imageLoader_1.default;
defaultStrategies[LoadingType_1.default.VIDEO] = videoLoader_1.default;
defaultStrategies[LoadingType_1.default.ENTITIES] = entitiesLoader_1.default;
/**
 * This loader specializes in loading data over XHR. It can be configured with
 * a custom function `xhrPromise` which can be used to handle tasks such as
 * path rewriting and authentication concerns.
 */
var XhrResourceLoader = (function () {
    /**
     * @constructor
     * @param xhrPromise  A function which returns a function which resolves
     *                    to a configured XMLHttpRequest object. This function
     *                    should accept a LoadableResource as its sole
     *                    parameter. eg:
     *                    xhrPromise(loadbleResource) => Promise.resolve([configured xhr object]);
     *                    Defaults to a simple XHR object configured with path only.
     * @param strategies  A mapping of Strategy name => Strategy function, for this
     *                    option it's best to use the default value.
     */
    function XhrResourceLoader(xhrPromise, strategies) {
        if (xhrPromise === void 0) { xhrPromise = defaultXhrPromise; }
        if (strategies === void 0) { strategies = defaultStrategies; }
        this.xhrPromise = xhrPromise;
        this.strategies = strategies;
        /**
         * A collection of loading resources used to ensure that the same resource
         * is not being downloaded twice.
         */
        this.resources = {};
        if (!xhrPromise) {
            throw new Error('Must provide argument `xhrPromise`!');
        }
        if (!strategies) {
            throw new Error('Must provide argument `strategies`!');
        }
        this.queue = prioritizedConcurrentPromiseQueue_1.default(maxConcurrentDownloads);
    }
    /** Shuts down the queue and any other necessary cleanup. */
    XhrResourceLoader.prototype.destroy = function () {
        this.queue.destroy();
    };
    /**
     * Loads a resource by specified path, type and parameters.
     *
     * @param path    The path to the resource which will be loaded.
     * @param type    The `LoadingType` to be used for this path.
     * @param params  Any additional parameters to pass along to the loader.
     * @returns       The LoadableResource instance for tracking this load.
     */
    XhrResourceLoader.prototype.load = function (path, type, params) {
        var _this = this;
        if (!this.strategies[type]) {
            throw new Error('Unsupported type: ' + type);
        }
        if (this.resources[path]) {
            return this.resources[path];
        }
        var resource = this.resources[path] = new LoadableResource_1.default(path, type, params);
        this.queue.add(function () { return new Promise(function (resolve) {
            var done = function () {
                delete _this.resources[path];
                resource.off(LoadingEvent_1.default.LOAD, done);
                resource.off(LoadingEvent_1.default.ERROR, done);
                resource.off(LoadingEvent_1.default.CANCEL, done);
                resolve(resource);
            };
            resource.once(LoadingEvent_1.default.LOAD, done);
            resource.once(LoadingEvent_1.default.ERROR, done);
            resource.once(LoadingEvent_1.default.CANCEL, done);
            _this.strategies[type](resource, _this.xhrPromise);
        }); }, params.priority);
        return resource;
    };
    return XhrResourceLoader;
}());
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = XhrResourceLoader;


/***/ },
/* 208 */
/***/ function(module, exports) {

"use strict";
"use strict";
/**
 * Converts a camel case string into an upper-snake-case string eg
 * 'FOO_BAR_BAZ'
 * @param {string} str The input string
 * @returns {string}
 */
function unCamelCase(str) {
    return str
        .replace(/([a-z])([A-Z])/g, '$1_$2')
        .replace(/([A-Z]+)([A-Z])([a-z])/, '$1_$2$3')
        .toUpperCase();
}
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Converts a string name into a name suitable for use as a define.
 * @param name  The input string
 * @returns     A string suitable for use as a define.
 */
exports.default = function (name) {
    var friendlyStr = typeof name === 'string' ? name : '';
    friendlyStr = friendlyStr.replace(/_([a-z])/gi, function (_m, w) {
        return '_' + w.toUpperCase();
    });
    friendlyStr = friendlyStr.replace(/\s+/g, '_');
    // Find where a number follows a letter and insert an underscore
    friendlyStr = friendlyStr.replace(/([a-z])([0-9])/g, '$1_$2');
    // Find where a letter follows a number and insert an underscore
    // friendlyStr = friendlyStr.replace(/([0-9])([A-z])/g, '$1_$2');
    friendlyStr = unCamelCase(friendlyStr);
    return friendlyStr;
};


/***/ },
/* 209 */
/***/ function(module, exports) {

"use strict";
"use strict";
// The default maximum concurrency level
var defaultMaxConcurrencySetting = 4;
// The default priority level
var defaultPrioritySetting = 5;
;
/**
 * Creates a queue which runs functions which produce promises.
 * @param   {Number} [maxConcurrency=DEFAULT_MAX_CONCURRENCY]
 *                The number of concurrent promises to execute
 * @param   {Number} [defaultPriority=DEFAULT_PRIORITY]
 *                The default priority
 * @returns {Object} Returns a module with the following two functions:
 *                    add: (fn, priority) => void
 *                    shutdown: () => void
 */
var prioritizedConcurrentPromiseQueue = function (maxConcurrency, defaultPriority) {
    if (maxConcurrency === void 0) { maxConcurrency = defaultMaxConcurrencySetting; }
    if (defaultPriority === void 0) { defaultPriority = defaultPrioritySetting; }
    // A list of functions waiting to be executed.
    var queued = [];
    // A list of functions which are currently being executed.
    var executing = [];
    // Whether or not the queue is currently running.
    var running = true;
    /**
     * De-queues and starts a promise.
     * @private
     */
    var dequeue = function () {
        var _loop_1 = function () {
            var f = queued.pop();
            executing.push(f);
            f.fn().then(function () {
                var idx = executing.indexOf(f);
                if (idx >= 0) {
                    executing.splice(idx, 1);
                    dequeue();
                }
            });
        };
        while (queued.length > 0 && executing.length < maxConcurrency) {
            _loop_1();
        }
    };
    /**
     * Used to sort the promise queue.
     * @param   {Object} a An object containing a `priority` property.
     * @param   {Object} b An object containing a `priority` property.
     * @returns {Number} The difference between priority B and priority A
     */
    var sortFn = function (a, b) { return b.priority - a.priority; };
    return {
        /**
         * Adds a function to the queue.
         *
         * @method
         * @param {Function} fn A function which takes zero arguments and produces a Promise.
         * @param {Number} priority A number which represents the priority of this promise.
         */
        add: function (fn, priority) {
            if (priority === void 0) { priority = defaultPriority; }
            if (priority < 0) {
                throw new Error('Invalid priority ' + priority);
            }
            if (!running) {
                throw new Error('Queue is not running, cannot accept new promises');
            }
            queued.push({ fn: fn, priority: priority });
            queued.sort(sortFn);
            setTimeout(dequeue(), 0);
        },
        /**
         * Shuts down the queue.
         *
         * @method
         */
        destroy: function () {
            running = false;
            executing.splice(0, executing.length);
            queued.splice(0, queued.length);
        }
    };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = prioritizedConcurrentPromiseQueue;


/***/ },
/* 210 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
"use strict";
/* This file was generated with box3d-component-generator at Fri Jan 13 2017 17:13:36 GMT-0800 (PST) */
/* tslint:disable */
/* eslint:disable */
var AudioListener_1 = __webpack_require__(68);
var AudioSource_1 = __webpack_require__(69);
var BoundingBoxRenderer_1 = __webpack_require__(70);
var CubeMapCapture_1 = __webpack_require__(71);
var Curve_1 = __webpack_require__(72);
var DebugConsoleDisplay_1 = __webpack_require__(73);
var DebugPerformance_1 = __webpack_require__(74);
var DebugTextureViewer_1 = __webpack_require__(75);
var DynamicOptimizer_1 = __webpack_require__(76);
var EventHandler_1 = __webpack_require__(77);
var Exploder_1 = __webpack_require__(78);
var FreeCamera_1 = __webpack_require__(79);
var Fullscreen_1 = __webpack_require__(80);
var GamepadInput_1 = __webpack_require__(81);
var InputController_1 = __webpack_require__(82);
var KeyframeAnimation_1 = __webpack_require__(83);
var LightEnvironment_1 = __webpack_require__(84);
var LookAtTarget_1 = __webpack_require__(85);
var MaterialCapture_1 = __webpack_require__(86);
var NormalMapGenerator_1 = __webpack_require__(87);
var ObjectAnimator_1 = __webpack_require__(88);
var ObjectPicker_1 = __webpack_require__(89);
var OrbitCameraController_1 = __webpack_require__(90);
var PanoramaToCubeMap_1 = __webpack_require__(91);
var PreviewAxisRotation_1 = __webpack_require__(92);
var PreviewCameraFocus_1 = __webpack_require__(93);
var ReflectionCapturePlane_1 = __webpack_require__(94);
var Renderer_1 = __webpack_require__(96);
var RenderModes_1 = __webpack_require__(95);
var RenderView_1 = __webpack_require__(45);
var Rotate_1 = __webpack_require__(97);
var SimplexNoiseGenerator_1 = __webpack_require__(98);
var Skybox_1 = __webpack_require__(99);
var TextRenderer_1 = __webpack_require__(100);
var VrCameraController_1 = __webpack_require__(101);
var VrHandController_1 = __webpack_require__(46);
var VrHandControllerAnimator_1 = __webpack_require__(102);
var VrPresenter_1 = __webpack_require__(103);
var VrRenderView_1 = __webpack_require__(104);
Object.defineProperty(exports, "__esModule", { value: true });
exports.default = [
    [{
            id: "audio_listener",
            sid: "Audio Listener",
            properties: {
                name: "Audio Listener",
                description: "Audio listener for 3D, positional sound effects",
                category: "Audio"
            }
        }, AudioListener_1.default],
    [{
            id: "audio_source",
            sid: "Audio Source",
            properties: {
                name: "Audio Source",
                description: "Controls playback of audio assets",
                attributes: {
                    gain: {
                        name: "gain",
                        type: "f",
                        description: "Volume control",
                        default: 1,
                        min: 0,
                        max: 100
                    },
                    autoPlay: {
                        name: "autoPlay",
                        type: "b",
                        description: "Play the audio once loaded",
                        default: true
                    },
                    loop: {
                        name: "loop",
                        type: "b",
                        description: "Continuously replay the audio",
                        default: true
                    },
                    preload: {
                        name: "preload",
                        type: "b",
                        description: "Load the audio when the component is initialized",
                        default: true
                    },
                    positional: {
                        name: "positional",
                        type: "b",
                        description: "Enable/disable 3D, positional audio effects",
                        default: false
                    },
                    stream: {
                        name: "stream",
                        type: "b",
                        description: "Stream the audio",
                        default: false
                    },
                    asset: {
                        name: "asset",
                        type: "asset",
                        description: "Audio or video asset",
                        default: null,
                        filter: {
                            audio: true,
                            video: true
                        }
                    }
                },
                events: {
                    playAudio: {
                        scope: "local",
                        name: "playAudio",
                        action: true,
                        category: "Audio",
                        parameters: [
                            {
                                name: "offset",
                                type: "f",
                                description: "Defined in seconds",
                                default: 0
                            }
                        ]
                    },
                    pauseAudio: {
                        scope: "local",
                        name: "pauseAudio",
                        action: true,
                        category: "Audio",
                        parameters: []
                    },
                    stopAudio: {
                        scope: "local",
                        name: "stopAudio",
                        action: true,
                        category: "Audio",
                        parameters: []
                    },
                    toggleAudio: {
                        scope: "local",
                        name: "toggleAudio",
                        action: true,
                        category: "Audio",
                        parameters: []
                    }
                },
                category: "Audio"
            }
        }, AudioSource_1.default],
    [{
            id: "bounding_box_renderer",
            sid: "BoundingBox Renderer",
            properties: {
                name: "BoundingBox Renderer",
                attributes: {
                    recursive: {
                        name: "recursive",
                        type: "b",
                        default: true,
                        description: "Automatically render bounding boxes for all meshes in the hierarchy"
                    }
                },
                filter: [
                    "object"
                ],
                category: "Rendering"
            }
        }, BoundingBoxRenderer_1.default],
    [{
            id: "cubemap_capture",
            sid: "Cube-Map Capture",
            properties: {
                name: "Cube-Map Capture",
                attributes: {
                    captureTexture: {
                        name: "captureTexture",
                        type: "asset",
                        description: "The RenderTextureCube to render the reflection to.",
                        filter: {
                            renderTextureCube: true
                        },
                        default: null
                    },
                    near: {
                        name: "near",
                        type: "f",
                        description: "The closest distance to this object to render. Adjust this to avoid   rendering local geometry to the texture.",
                        default: 0.01
                    },
                    far: {
                        name: "far",
                        type: "f",
                        description: "The furthest distance from this object to render.",
                        default: 16
                    },
                    updateFrameInterval: {
                        name: "updateFrameInterval",
                        type: "i",
                        description: "The number of frames to skip in between updates of the reflection.   Default is 0.",
                        default: 0
                    },
                    renderPosX: {
                        name: "renderPosX",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    renderPosY: {
                        name: "renderPosY",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    renderNegZ: {
                        name: "renderNegZ",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    renderNegX: {
                        name: "renderNegX",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    renderNegY: {
                        name: "renderNegY",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    renderPosZ: {
                        name: "renderPosZ",
                        type: "b",
                        description: "Render this side of the cube.",
                        default: true
                    },
                    debugView: {
                        name: "debugView",
                        type: "b",
                        description: "Render the camera helpers on the cube capture.",
                        default: false
                    }
                },
                filter: [
                    "Object"
                ],
                category: "Rendering"
            }
        }, CubeMapCapture_1.default],
    [{
            id: "curve_component",
            sid: "Curve",
            properties: {
                name: "Curve",
                description: "Creates a spline curve that can be used for various things, including making objects follow it. Add controls points to shape the curve.",
                attributes: {
                    controlPoints: {
                        name: "controlPoints",
                        type: "a",
                        subType: {
                            type: "object"
                        },
                        description: "The list of objects that define the curve shape."
                    },
                    closed: {
                        name: "closed",
                        type: "b",
                        description: "If toggled, the start and end of the curve will be smoothly joined.",
                        default: false
                    }
                },
                filter: [
                    "object"
                ],
                category: "General"
            }
        }, Curve_1.default],
    [{
            id: "debug_console_display",
            sid: "Debug Console Display",
            properties: {
                name: "Debug Console Display",
                filter: [
                    "Application"
                ],
                category: "Debug"
            }
        }, DebugConsoleDisplay_1.default],
    [{
            id: "debug_performance",
            sid: "Debug Performance",
            properties: {
                name: "Debug Performance",
                filter: [
                    "Application"
                ],
                category: "Debug"
            }
        }, DebugPerformance_1.default],
    [{
            id: "debug_texture_viewer",
            sid: "Debug Texture Viewer",
            properties: {
                name: "Debug Texture Viewer",
                attributes: {
                    viewportLeft: {
                        name: "viewportLeft",
                        type: "s",
                        description: "Left position of the viewport to be rendered by this camera.",
                        default: "25%"
                    },
                    viewportBottom: {
                        name: "viewportBottom",
                        type: "s",
                        description: "Bottom position of the viewport to be rendered by this camera.",
                        default: "0px"
                    },
                    viewportWidth: {
                        name: "viewportWidth",
                        type: "s",
                        description: "Width of the viewport to be rendered by this camera.",
                        default: "50%"
                    },
                    viewportHeight: {
                        name: "viewportHeight",
                        type: "s",
                        description: "Height of the viewport to be rendered by this camera.",
                        default: "50%"
                    },
                    renderGroup: {
                        name: "renderGroup",
                        type: "i",
                        description: "Render passes are done in order, based on the 'render group' value. Lower numbers render first.",
                        default: 9
                    }
                },
                filter: [
                    "Application"
                ],
                category: "Debug"
            }
        }, DebugTextureViewer_1.default],
    [{
            id: "dynamic_optimizer",
            sid: "Dynamic Performance Optimizer",
            properties: {
                name: "Dynamic Performance Optimizer",
                attributes: {
                    frameTimeThreshold: {
                        name: "frameTimeThreshold",
                        type: "f",
                        description: "The average time that a frame can take to render before the optimizer drops a   quality level. Default threshold is 30 FPS = 1000 ms / 30 frames",
                        default: 33.333333333333
                    },
                    testInterval: {
                        name: "testInterval",
                        type: "f",
                        description: "The amount of elapsed time (in ms) to average the frame time over.   i.e. an optimization decision can be made every time this interval elapses.",
                        default: 2000
                    }
                },
                filter: [
                    "Application"
                ],
                category: "Rendering"
            }
        }, DynamicOptimizer_1.default],
    [{
            id: "event_handler_component",
            sid: "Event Handler",
            properties: {
                name: "Event Handler",
                attributes: {
                    listen: {
                        name: "listen",
                        type: "event",
                        description: "The event to listen for. When this event is captured, all of the defined trigger events will be fired."
                    },
                    triggers: {
                        name: "triggers",
                        type: "a",
                        subType: {
                            type: "event"
                        },
                        description: "Fire each of these events in response to the captured listen event."
                    }
                },
                category: "Interaction"
            }
        }, EventHandler_1.default],
    [{
            id: "exploder_component",
            sid: "Exploder",
            properties: {
                name: "Exploder",
                description: "Explodes your objects and their hierarchies into different formations.               Great for showing off parts in a model!",
                attributes: {
                    time: {
                        name: "time",
                        type: "f",
                        default: 1.5,
                        description: "The amount of time to explode and contract the child meshes"
                    },
                    scale: {
                        name: "scale",
                        type: "v3",
                        default: {
                            x: 2,
                            y: 2,
                            z: 2
                        },
                        description: "The scale of the explosion"
                    },
                    formation: {
                        name: "formation",
                        type: "dd",
                        description: "Formation to use when exploding the hierarchy of this object.",
                        default: "Scale",
                        options: {
                            Circle: "Circle",
                            "Square Grid": "Grid",
                            "Scale Out": "Scale"
                        }
                    }
                },
                events: {
                    playExplode: {
                        scope: "local",
                        name: "playExplode",
                        action: true,
                        category: "Exploder",
                        parameters: []
                    },
                    playContract: {
                        scope: "local",
                        name: "playContract",
                        action: true,
                        category: "Exploder",
                        parameters: []
                    },
                    toggleExploder: {
                        scope: "local",
                        name: "toggleExploder",
                        action: true,
                        category: "Exploder",
                        parameters: []
                    },
                    resetExploder: {
                        scope: "local",
                        name: "resetExploder",
                        action: true,
                        category: "Exploder",
                        parameters: []
                    },
                    useCircleExplode: {
                        scope: "local",
                        name: "useCircleExplode",
                        action: true,
                        category: "Exploder",
                        parameters: [
                            {
                                name: "Scale",
                                type: "v3",
                                description: "The scale to apply to the explosion",
                                default: {
                                    x: 1,
                                    y: 1,
                                    z: 1
                                }
                            }
                        ]
                    },
                    useGridExplode: {
                        scope: "local",
                        name: "useGridExplode",
                        action: true,
                        category: "Exploder",
                        parameters: [
                            {
                                name: "Scale",
                                type: "v3",
                                description: "The scale to apply to the explosion",
                                default: {
                                    x: 1,
                                    y: 1,
                                    z: 1
                                }
                            }
                        ]
                    },
                    useScaleOutExplode: {
                        scope: "local",
                        name: "useScaleOutExplode",
                        action: true,
                        category: "Exploder",
                        parameters: [
                            {
                                name: "Scale",
                                type: "v3",
                                description: "The scale to apply to the explosion",
                                default: {
                                    x: 2,
                                    y: 2,
                                    z: 2
                                }
                            }
                        ]
                    },
                    beginExplode: {
                        scope: "other",
                        name: "beginExplode",
                        action: false,
                        category: "Exploder",
                        parameters: []
                    },
                    endExplode: {
                        scope: "other",
                        name: "endExplode",
                        action: false,
                        category: "Exploder",
                        parameters: []
                    },
                    beginContract: {
                        scope: "other",
                        name: "beginContract",
                        action: false,
                        category: "Exploder",
                        parameters: []
                    },
                    endContract: {
                        scope: "other",
                        name: "endContract",
                        action: false,
                        category: "Exploder",
                        parameters: []
                    }
                },
                filter: [
                    "object"
                ],
                category: "Animation"
            }
        }, Exploder_1.default],
    [{
            id: "free_camera_controller",
            sid: "Free Camera Controller",
            properties: {
                name: "Free Camera Controller",
                attributes: {
                    inertialDamping: {
                        name: "inertialDamping",
                        type: "f",
                        default: 0.2,
                        min: 0,
                        max: 1
                    },
                    usePointerLock: {
                        name: "usePointerLock",
                        type: "b",
                        description: "",
                        default: false
                    },
                    invertX: {
                        name: "invertX",
                        type: "b",
                        default: false
                    },
                    invertY: {
                        name: "invertY",
                        type: "b",
                        default: false
                    },
                    invertZoom: {
                        name: "invertZoom",
                        type: "b",
                        default: false
                    },
                    lookSpeed: {
                        name: "lookSpeed",
                        type: "f",
                        default: 1,
                        min: 0.0001,
                        max: 1000
                    },
                    movementSpeed: {
                        name: "movementSpeed",
                        type: "f",
                        default: 3,
                        max: 1000,
                        min: 0.01
                    },
                    pitchAngleBounds: {
                        name: "pitchAngleBounds",
                        type: "v2",
                        default: {
                            max: 75,
                            min: -75
                        },
                        max: {
                            max: 90,
                            min: 90
                        },
                        min: {
                            max: -90,
                            min: -90.01
                        }
                    },
                    enablePan: {
                        name: "enablePan",
                        type: "b",
                        default: true
                    },
                    enableZoom: {
                        name: "enableZoom",
                        type: "b",
                        default: true
                    }
                },
                events: {
                    enableFreeCameraController: {
                        scope: "local",
                        name: "enableFreeCameraController",
                        parameters: []
                    },
                    disableFreeCameraController: {
                        scope: "local",
                        name: "disableFreeCameraController",
                        parameters: []
                    },
                    toggleFreeCameraController: {
                        scope: "local",
                        name: "toggleFreeCameraController",
                        parameters: []
                    }
                },
                filter: [
                    "camera"
                ],
                category: "Camera-Controllers"
            }
        }, FreeCamera_1.default],
    [{
            id: "fullscreen_script",
            sid: "Fullscreen",
            properties: {
                name: "Fullscreen",
                description: "ses fullscreen API to make your app fullscreen! This will fullscreen the canvas' parent element, so your UI can be fullscreened as well! If a selector is provided, then we will fullscreen that element instead.",
                events: {
                    toggleFullscreen: {
                        scope: "local",
                        name: "toggleFullscreen",
                        action: true,
                        category: "Rendering",
                        parameters: []
                    }
                },
                filter: [
                    "application"
                ],
                category: "Rendering"
            }
        }, Fullscreen_1.default],
    [{
            id: "gamepad_input_controller",
            sid: "Gamepad Input Controller",
            properties: {
                name: "Gamepad Input Controller",
                filter: [
                    "application"
                ],
                category: "Input"
            }
        }, GamepadInput_1.default],
    [{
            id: "input_controller_component",
            sid: "Input Controller",
            properties: {
                name: "Input Controller",
                attributes: {
                    mouseEvents: {
                        name: "mouseEvents",
                        type: "custom",
                        attributes: {
                            enable: {
                                type: "b",
                                default: true,
                                description: "Enable mouse events?"
                            },
                            scroll: {
                                type: "b",
                                default: true,
                                description: "Listen to scroll events?"
                            },
                            scroll_preventDefault: {
                                type: "b",
                                default: false,
                                description: "Prevent default scroll behaviour?"
                            },
                            move: {
                                type: "b",
                                default: true,
                                description: "Listen to mouse move events?"
                            },
                            down: {
                                type: "b",
                                default: true,
                                description: "Listen to mouse down event?"
                            },
                            down_preventDefault: {
                                type: "b",
                                default: false,
                                description: "Prevent default mouse down behaviour?"
                            },
                            up: {
                                type: "b",
                                default: true,
                                description: "Listen to mouse up event?"
                            },
                            double_click: {
                                type: "b",
                                default: true,
                                description: "Listen to double click event?"
                            },
                            leave: {
                                type: "b",
                                default: true,
                                description: "Listen to mouse leave event"
                            },
                            contextMenu: {
                                type: "b",
                                default: true,
                                description: "Listen for the context menu event? (ie, right click)"
                            },
                            contextMenu_preventDefault: {
                                type: "b",
                                default: true,
                                description: "Prevent context menu default behaviour (ie, the context menu popping open)"
                            },
                            dragBufferDistance: {
                                type: "f",
                                default: 12,
                                name: "Drag Buffer Distance",
                                description: "The distance from initial click that you need to move your mouse before a drag event is fired, in pixels"
                            },
                            eventHandler: {
                                type: "b",
                                default: true,
                                description: "Events fired from the mouse are picked up by the Event Handler"
                            }
                        }
                    },
                    touchEvents: {
                        name: "touchEvents",
                        type: "custom",
                        attributes: {
                            enable: {
                                type: "b",
                                default: true,
                                description: "Enable touch events?"
                            },
                            start: {
                                type: "b",
                                default: true,
                                description: "Listen for Touch Start"
                            },
                            start_preventDefault: {
                                type: "b",
                                default: true,
                                description: "Prevent default behaviour of touch start event"
                            },
                            end: {
                                type: "b",
                                default: true,
                                description: "Listen for touch end event"
                            },
                            doubleTap: {
                                type: "b",
                                default: true,
                                description: "Listen for a touch double tap event"
                            },
                            cancel: {
                                type: "b",
                                default: true,
                                description: "Listen for touch cancel event"
                            },
                            leave: {
                                type: "b",
                                default: true,
                                description: "Listen for touch leave event"
                            },
                            move: {
                                type: "b",
                                default: true,
                                description: "Listen for touch move event"
                            },
                            move_preventDefault: {
                                type: "b",
                                default: true,
                                description: "Prevent default move behaviour (ie, dragging the window)"
                            },
                            dragBufferDistance: {
                                type: "f",
                                default: 12,
                                name: "Drag Buffer Distance",
                                description: "The distance from initial touch down that you need to move your finger before a drag event is fired, in pixels"
                            },
                            eventHandler: {
                                type: "b",
                                default: true,
                                description: "Events fired from the touches are picked up by the Event Handler"
                            }
                        }
                    },
                    keyEvents: {
                        name: "keyEvents",
                        type: "custom",
                        attributes: {
                            enable: {
                                type: "b",
                                default: true,
                                description: "Enable keyboard events"
                            },
                            down: {
                                type: "b",
                                default: true,
                                description: "Listen to key down events"
                            },
                            up: {
                                type: "b",
                                default: true,
                                description: "Listen to key up events"
                            },
                            preventDefault: {
                                type: "b",
                                default: false,
                                description: "Prevent default keypress behaviour"
                            },
                            eventHandler: {
                                type: "b",
                                default: true,
                                description: "Events fired from the keys are picked up by the Event Handler"
                            }
                        }
                    }
                },
                events: {
                    mouse_down_left: {
                        scope: "global",
                        name: "mouse_down_left",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    mouse_down_right: {
                        scope: "global",
                        name: "mouse_down_right",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    mouse_down_middle: {
                        scope: "global",
                        name: "mouse_down_middle",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    mouse_up_left: {
                        scope: "global",
                        name: "mouse_up_left",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    mouse_up_right: {
                        scope: "global",
                        name: "mouse_up_right",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    mouse_up_middle: {
                        scope: "global",
                        name: "mouse_up_middle",
                        action: false,
                        category: "Input - Mouse",
                        parameters: []
                    },
                    keypress_a: {
                        scope: "global",
                        name: "keypress_a",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_b: {
                        scope: "global",
                        name: "keypress_b",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_c: {
                        scope: "global",
                        name: "keypress_c",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_d: {
                        scope: "global",
                        name: "keypress_d",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_f: {
                        scope: "global",
                        name: "keypress_f",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_g: {
                        scope: "global",
                        name: "keypress_g",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_e: {
                        scope: "global",
                        name: "keypress_e",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_h: {
                        scope: "global",
                        name: "keypress_h",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_i: {
                        scope: "global",
                        name: "keypress_i",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_j: {
                        scope: "global",
                        name: "keypress_j",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_k: {
                        scope: "global",
                        name: "keypress_k",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_l: {
                        scope: "global",
                        name: "keypress_l",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_m: {
                        scope: "global",
                        name: "keypress_m",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_n: {
                        scope: "global",
                        name: "keypress_n",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_o: {
                        scope: "global",
                        name: "keypress_o",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_p: {
                        scope: "global",
                        name: "keypress_p",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_q: {
                        scope: "global",
                        name: "keypress_q",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_r: {
                        scope: "global",
                        name: "keypress_r",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_s: {
                        scope: "global",
                        name: "keypress_s",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_t: {
                        scope: "global",
                        name: "keypress_t",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_u: {
                        scope: "global",
                        name: "keypress_u",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_v: {
                        scope: "global",
                        name: "keypress_v",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_w: {
                        scope: "global",
                        name: "keypress_w",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_x: {
                        scope: "global",
                        name: "keypress_x",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_y: {
                        scope: "global",
                        name: "keypress_y",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_z: {
                        scope: "global",
                        name: "keypress_z",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_up_arrow: {
                        scope: "global",
                        name: "keypress_up_arrow",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_down_arrow: {
                        scope: "global",
                        name: "keypress_down_arrow",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_left_arrow: {
                        scope: "global",
                        name: "keypress_left_arrow",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_right_arrow: {
                        scope: "global",
                        name: "keypress_right_arrow",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    keypress_space: {
                        scope: "global",
                        name: "keypress_space",
                        action: false,
                        category: "Input - Keys",
                        parameters: []
                    },
                    touch_start: {
                        scope: "global",
                        name: "touch_start",
                        action: false,
                        category: "Input - Touch",
                        parameters: []
                    },
                    touch_end: {
                        scope: "global",
                        name: "touch_end",
                        action: false,
                        category: "Input - Touch",
                        parameters: []
                    }
                },
                filter: [
                    "application"
                ],
                category: "Input"
            }
        }, InputController_1.default],
    [{
            id: "animation",
            sid: "Animation",
            properties: {
                name: "Animation",
                attributes: {
                    autoPlay: {
                        name: "autoPlay",
                        type: "b",
                        description: "Play the animation once loaded",
                        default: true
                    },
                    loop: {
                        name: "loop",
                        type: "b",
                        description: "Continuously replay the animation",
                        default: true
                    },
                    speed: {
                        name: "speed",
                        type: "f",
                        description: "Playback speed",
                        default: 1,
                        min: 0,
                        max: 100
                    },
                    startTime: {
                        name: "startTime",
                        type: "f",
                        description: "Begin playback at this time offset",
                        default: 0,
                        min: 0
                    },
                    weight: {
                        name: "weight",
                        type: "f",
                        description: "Blending weight",
                        default: 1,
                        min: 0,
                        max: 1
                    },
                    asset: {
                        name: "asset",
                        type: "asset",
                        description: "Animation asset",
                        default: null,
                        filter: {
                            animation: true
                        }
                    },
                    clipId: {
                        name: "clipId",
                        type: "i",
                        description: "The animation clip ID",
                        default: null
                    }
                },
                events: {
                    playAnimation: {
                        scope: "local",
                        name: "playAnimation",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "asset",
                                type: "asset",
                                description: "The animation asset to play.",
                                default: null,
                                filter: {
                                    animation: true
                                }
                            },
                            {
                                name: "clipId",
                                type: "s",
                                description: "The ID of the clip to play.",
                                default: null
                            },
                            {
                                name: "loop",
                                type: "b",
                                description: "Continuously replay the animation.",
                                default: true
                            },
                            {
                                name: "speed",
                                type: "f",
                                description: "Playback speed.",
                                default: 1,
                                min: 0,
                                max: 100
                            },
                            {
                                name: "startTime",
                                type: "f",
                                description: "Begin playback at this time offset.",
                                default: 0,
                                min: 0
                            }
                        ]
                    },
                    pauseAnimation: {
                        scope: "local",
                        name: "pauseAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    stopAnimation: {
                        scope: "local",
                        name: "stopAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    toggleAnimation: {
                        scope: "local",
                        name: "toggleAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    animationLoaded: {
                        scope: "local",
                        name: "animationLoaded",
                        action: false,
                        category: "Animation",
                        parameters: []
                    },
                    endAnimation: {
                        scope: "local",
                        name: "endAnimation",
                        action: false,
                        category: "Animation",
                        parameters: []
                    }
                },
                filter: [
                    "object"
                ],
                category: "Animation"
            }
        }, KeyframeAnimation_1.default],
    [{
            id: "light_environment_component",
            sid: "Light Environment",
            properties: {
                name: "Light Environment",
                attributes: {
                    irradianceMap: {
                        name: "irradianceMap",
                        type: "asset",
                        filter: {
                            renderTexture2D: true,
                            texture2D: true
                        }
                    },
                    radianceMapHalfGloss: {
                        name: "radianceMapHalfGloss",
                        type: "asset",
                        filter: {
                            renderTexture2D: true,
                            texture2D: true
                        }
                    },
                    radianceMap: {
                        name: "radianceMap",
                        type: "asset",
                        filter: {
                            renderTexture2D: true,
                            texture2D: true
                        }
                    },
                    useSceneLighting: {
                        name: "useSceneLighting",
                        type: "b",
                        default: true
                    }
                },
                filter: [
                    "scene"
                ],
                category: "Rendering"
            }
        }, LightEnvironment_1.default],
    [{
            id: "lookat_component",
            sid: "Look At Target",
            properties: {
                name: "Look At Target",
                description: "A component that automatically points the object at a target. This can be used for billboarding an object to the camera, making a character look at another, etc.",
                attributes: {
                    target: {
                        name: "target",
                        type: "object",
                        description: "The object that you want this object to point towards. e.g. for billboarding, this would be the camera used to render the scene."
                    },
                    local: {
                        name: "local",
                        type: "b",
                        description: "If toggled, whatever rotation you have already applied to this object will be taken into account.",
                        default: false
                    },
                    showPreview: {
                        name: "showPreview",
                        type: "b",
                        description: "Run the lookAt in the editor.",
                        default: true
                    }
                },
                filter: [
                    "Object"
                ],
                category: "General"
            }
        }, LookAtTarget_1.default],
    [{
            id: "material_capture",
            sid: "Material Capture",
            properties: {
                name: "Material Capture",
                description: "A component that captures an image of a rendered material as a spherical map, complete with lighting. This image can then be applied (with a sphere map projection) to a mesh to achieve convincing material shading (although the mesh will appear with the same lighting from all directions).",
                attributes: {
                    captureTexture: {
                        name: "captureTexture",
                        type: "asset",
                        description: "",
                        filter: {
                            renderTexture2D: true
                        },
                        default: null
                    }
                },
                filter: [
                    "material"
                ],
                category: "Rendering"
            }
        }, MaterialCapture_1.default],
    [{
            id: "normal_map_generator_component",
            sid: "Normal Map Generator",
            properties: {
                name: "Normal Map Generator",
                attributes: {
                    bumpTexture: {
                        name: "bumpTexture",
                        type: "asset",
                        filter: {
                            renderTexture2D: true,
                            texture2D: true
                        }
                    },
                    smoothness: {
                        name: "smoothness",
                        type: "f",
                        slider: true,
                        default: 0.25,
                        min: 0.0001,
                        max: 1
                    },
                    spread: {
                        name: "spread",
                        type: "f",
                        slider: true,
                        default: 4,
                        min: 1,
                        max: 10
                    },
                    autoLoad: {
                        name: "autoLoad",
                        type: "b",
                        default: true
                    }
                },
                events: {
                    renderNormalMap: {
                        scope: "local",
                        name: "renderNormalMap",
                        action: true,
                        category: "Rendering",
                        parameters: []
                    }
                },
                filter: [
                    "renderTexture2D"
                ],
                category: "Rendering"
            }
        }, NormalMapGenerator_1.default],
    [{
            id: "object_animator_component",
            sid: "Object Animator",
            properties: {
                name: "Object Animator",
                events: {
                    playAnimateAlongCurve: {
                        scope: "local",
                        name: "playAnimateAlongCurve",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "curve",
                                type: "object",
                                componentFilter: {
                                    Curve: true
                                }
                            },
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Time to animate to object. Defined in seconds",
                                default: 3
                            },
                            {
                                name: "easeIn",
                                type: "f",
                                description: "The percentage of animation time spent speeding up.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "easeOut",
                                type: "f",
                                description: "The percentage of animation time spent slowing down.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "orientation",
                                description: "Orient the object following the curve to either the direction of the curve or to the objects defining the curve.",
                                type: "opt",
                                default: "toCurve",
                                options: {
                                    None: "None",
                                    "To Curve": "toCurve",
                                    "To Nodes": "toNode"
                                }
                            },
                            {
                                name: "loop",
                                type: "b",
                                description: "",
                                default: false
                            }
                        ]
                    },
                    playAnimateToObject: {
                        scope: "local",
                        name: "playAnimateToObject",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "object",
                                type: "object",
                                default: null
                            },
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Total time that the animation will take. Defined in seconds",
                                default: 3
                            },
                            {
                                name: "easeIn",
                                type: "f",
                                description: "The percentage of animation time spent speeding up.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "easeOut",
                                type: "f",
                                description: "The percentage of animation time spent slowing down.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "update orientation",
                                type: "b",
                                default: true
                            }
                        ]
                    },
                    playAnimateTranslation: {
                        scope: "local",
                        name: "playAnimateTranslation",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Time to animate. Defined in seconds",
                                default: 3
                            },
                            {
                                name: "easeIn",
                                type: "f",
                                description: "The percentage of animation time spent speeding up.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "easeOut",
                                type: "f",
                                description: "The percentage of animation time spent slowing down.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "velocity",
                                description: "",
                                type: "v3",
                                default: {
                                    x: 0,
                                    y: 0,
                                    z: 1
                                },
                                min: -1,
                                max: 1
                            },
                            {
                                name: "objectUsage",
                                type: "opt",
                                description: "Specify what part of the animation the current object's position represents.",
                                default: "beginning",
                                options: {
                                    Beginning: "beginning",
                                    Middle: "middle",
                                    End: "end"
                                }
                            }
                        ]
                    },
                    playAnimateRotation: {
                        scope: "local",
                        name: "playAnimateRotation",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Time to animate to object. Defined in seconds",
                                default: 3
                            },
                            {
                                name: "easeIn",
                                type: "f",
                                description: "The percentage of animation time spent speeding up.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "easeOut",
                                type: "f",
                                description: "The percentage of animation time spent slowing down.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "angularVelocity",
                                description: "",
                                type: "v3",
                                default: {
                                    x: 0,
                                    y: 0,
                                    z: 1
                                },
                                min: -100,
                                max: 100
                            },
                            {
                                name: "objectUsage",
                                type: "opt",
                                description: "Specify what part of the animation the current object's rotation represents.",
                                default: "beginning",
                                options: {
                                    Beginning: "beginning",
                                    Middle: "middle",
                                    End: "end"
                                }
                            },
                            {
                                name: "axisOrder",
                                type: "opt",
                                description: "Specify the axis order that the angular velocity will be applied in.",
                                default: "YXZ",
                                options: {
                                    XYZ: "XYZ",
                                    YXZ: "YXZ",
                                    ZXY: "ZXY",
                                    XZY: "XZY",
                                    YZX: "YZX",
                                    ZYX: "ZYX"
                                }
                            }
                        ]
                    },
                    playAnimateScale: {
                        scope: "local",
                        name: "playAnimateScale",
                        action: true,
                        category: "Animation",
                        parameters: [
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Time to animate to object. Defined in seconds",
                                default: 3
                            },
                            {
                                name: "easeIn",
                                type: "f",
                                description: "The percentage of animation time spent speeding up.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "easeOut",
                                type: "f",
                                description: "The percentage of animation time spent slowing down.",
                                default: 0.25,
                                min: 0,
                                max: 1
                            },
                            {
                                name: "velocity",
                                description: "",
                                type: "v3",
                                default: {
                                    x: 0,
                                    y: 0,
                                    z: 1
                                },
                                min: -10,
                                max: 10
                            },
                            {
                                name: "objectUsage",
                                type: "opt",
                                description: "Specify what part of the animation the current object's scale represents.",
                                default: "beginning",
                                options: {
                                    Beginning: "beginning",
                                    Middle: "middle",
                                    End: "end"
                                }
                            }
                        ]
                    },
                    pauseCurveAnimation: {
                        scope: "local",
                        name: "pauseCurveAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    stopCurveAnimation: {
                        scope: "local",
                        name: "stopCurveAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    unpauseCurveAnimation: {
                        scope: "local",
                        name: "unpauseCurveAnimation",
                        action: true,
                        category: "Animation",
                        parameters: []
                    },
                    endAnimateAlongCurve: {
                        scope: "local",
                        name: "endAnimateAlongCurve",
                        action: false,
                        category: "Animation",
                        parameters: []
                    },
                    endAnimateToObject: {
                        scope: "local",
                        name: "endAnimateToObject",
                        action: false,
                        category: "Animation",
                        parameters: []
                    },
                    endAnimateTranslation: {
                        scope: "lcoal",
                        name: "endAnimateTranslation",
                        action: false,
                        category: "Animation",
                        parameters: []
                    }
                },
                filter: [
                    "Object"
                ],
                category: "Animation"
            }
        }, ObjectAnimator_1.default],
    [{
            id: "object_picker",
            sid: "Object Picker",
            properties: {
                name: "Object Picker",
                attributes: {
                    pickTrigger: {
                        name: "pickTrigger",
                        type: "dd",
                        description: "What mouse action will trigger the pick?",
                        default: "leftMouseClick",
                        options: {
                            "Left Mouse Click": "leftMouseClick",
                            "Middle Mouse Click": "middleMouseClick",
                            "Right Mouse Click": "rightMouseClick",
                            "Left Mouse Down": "leftMouseDown",
                            "Middle Mouse Down": "middleMouseDown",
                            "Right Mouse Down": "rightMouseDown",
                            "Left Mouse Up": "leftMouseUp",
                            "Middle Mouse Up": "middleMouseUp",
                            "Right Mouse Up": "rightMouseUp"
                        }
                    },
                    enableHoverByDefault: {
                        name: "enableHoverByDefault",
                        type: "b",
                        default: false,
                        advanced: true,
                        description: "Enable hover detection when mouse cursor is over a mesh. Note that this has a potential performance impact."
                    },
                    hoverFrameSkip: {
                        name: "hoverFrameSkip",
                        type: "i",
                        description: "Skip this many frames inbetween hover checks.",
                        default: 1,
                        min: 0,
                        max: 60
                    }
                },
                events: {
                    pick: {
                        scope: "other",
                        name: "pick",
                        action: false,
                        category: "General",
                        parameters: []
                    },
                    beginHover: {
                        scope: "other",
                        name: "beginHover",
                        action: false,
                        category: "General",
                        parameters: []
                    },
                    endHover: {
                        scope: "other",
                        name: "endHover",
                        action: false,
                        category: "General",
                        parameters: []
                    }
                },
                filter: [
                    "Scene"
                ],
                category: "General"
            }
        }, ObjectPicker_1.default],
    [{
            id: "orbit_camera_controller",
            sid: "Orbit Camera Controller",
            properties: {
                name: "Orbit Camera Controller",
                description: "A controller that allows a camera to easily orbit a target object.",
                attributes: {
                    targetObject: {
                        name: "targetObject",
                        type: "object",
                        default: null,
                        description: "The object that the camera orbit point will be relative to."
                    },
                    targetOffset: {
                        name: "targetOffset",
                        type: "v3",
                        default: {
                            x: 0,
                            y: 0,
                            z: 0
                        },
                        description: "An offset relative to the target object. This will allow you to target a specific point on an object."
                    },
                    inertialDamping: {
                        name: "inertialDamping",
                        type: "f",
                        default: 0.2,
                        description: "How quickly the camera stops moving when input stops.",
                        min: 0,
                        max: 1
                    },
                    invertX: {
                        name: "invertX",
                        type: "b",
                        default: false,
                        description: "Reverse the default direction that the camera moves horizontally."
                    },
                    invertY: {
                        name: "invertY",
                        type: "b",
                        default: false,
                        description: "Reverse the default direction that the camera moves vertically."
                    },
                    invertZoom: {
                        name: "invertZoom",
                        type: "b",
                        default: false,
                        description: "Reverse the default direction that the camera moves when zooming."
                    },
                    lookSpeed: {
                        name: "lookSpeed",
                        type: "f",
                        description: "The speed that the camera orbits the target",
                        default: 1,
                        max: 1000,
                        min: 0.0001
                    },
                    movementSpeed: {
                        name: "movementSpeed",
                        type: "f",
                        description: "The speed that the camera moves when panning",
                        default: 8,
                        max: 2000,
                        min: 0.1
                    },
                    autoOrbit: {
                        name: "autoOrbit",
                        type: "b",
                        default: false,
                        description: "Automatically orbit the camera when the user is not controlling it."
                    },
                    autoOrbitSpeed: {
                        name: "autoOrbitSpeed",
                        type: "f",
                        description: "The speed of the automatic orbit.",
                        default: 1,
                        max: 1000,
                        min: -1000
                    },
                    autoOrbitDelay: {
                        name: "autoOrbitDelay",
                        type: "f",
                        description: "The period of time with no mouse input before the auto-orbit starts (in seconds).",
                        default: 1,
                        max: 1000,
                        min: 0.0001
                    },
                    orbitDistanceMin: {
                        name: "orbitDistanceMin",
                        type: "f",
                        description: "The closest that the camera is allowed to get to the target.",
                        default: 0.1,
                        max: 1000,
                        min: 0.001
                    },
                    orbitDistanceMax: {
                        name: "orbitDistanceMax",
                        type: "f",
                        description: "The furthest that the camera is allowed to get from the target.",
                        default: 50,
                        max: 100000,
                        min: 1
                    },
                    pitchAngleBounds: {
                        name: "pitchAngleBounds",
                        type: "v2",
                        description: "Allows you to set how far the camera can pitch (tilt) from horizontal. Defined in degrees with horizontal being 0.",
                        default: {
                            x: 75,
                            y: -75
                        },
                        max: {
                            x: 90,
                            y: 90
                        },
                        min: {
                            x: -90,
                            y: -90.001
                        }
                    },
                    enablePan: {
                        name: "enablePan",
                        type: "b",
                        default: true,
                        description: "Allow the user to pan side-to-side and up and down with the camera."
                    },
                    enableZoom: {
                        name: "enableZoom",
                        type: "b",
                        default: true,
                        description: "Allow the user to zoom in and out with the camera."
                    },
                    interpolation: {
                        name: "interpolation",
                        type: "b",
                        default: true,
                        description: "When enabled, the camera will smoothly interpolate toward its desired state. e.g. If something else moves the camera, interpolation will cause the camera to smoothly focus on the target again. Otherwise, it will snap back."
                    },
                    interpSpeed: {
                        name: "interpSpeed",
                        type: "f",
                        description: "The speed at which the orbiting camera locks on to its target, if set to point away from it.",
                        default: 0.5,
                        max: 10,
                        min: 0.01
                    },
                    usePointerLock: {
                        name: "usePointerLock",
                        type: "b",
                        default: false,
                        description: "The mouse cursor will be hidden during camera control and won't move. Requires the user to accept pointer lock message in web browser."
                    },
                    useKeyboard: {
                        name: "useKeyboard",
                        type: "b",
                        default: true,
                        description: "Allow the camera to be controlled via keyboard input. This allows for movement with W,A,S,D/arrow keys as well as modifiers."
                    }
                },
                events: {
                    enableOrbitCameraController: {
                        scope: "local",
                        name: "enableOrbitCameraController",
                        action: true,
                        category: "Orbit Camera",
                        parameters: []
                    },
                    disableOrbitCameraController: {
                        scope: "local",
                        name: "disableOrbitCameraController",
                        action: true,
                        category: "Orbit Camera",
                        parameters: []
                    },
                    toggleOrbitCameraController: {
                        scope: "local",
                        name: "toggleOrbitCameraController",
                        action: true,
                        category: "Orbit Camera",
                        parameters: []
                    },
                    resetOrbitCameraController: {
                        scope: "local",
                        name: "resetOrbitCameraController",
                        action: true,
                        category: "Orbit Camera",
                        parameters: []
                    },
                    setOrbitDistance: {
                        scope: "local",
                        name: "setOrbitDistance",
                        action: true,
                        category: "Orbit Camera",
                        parameters: [
                            {
                                name: "newDistance",
                                type: "f",
                                description: "The new distance that the camera will orbit at.",
                                default: 1
                            }
                        ]
                    },
                    setTarget: {
                        scope: "local",
                        name: "setTarget",
                        description: "Sets the camera to orbit the given object",
                        action: true,
                        category: "Orbit Camera",
                        parameters: [
                            {
                                name: "newTarget",
                                type: "object",
                                description: "The new target that the camera will orbit.",
                                default: null
                            },
                            {
                                name: "center",
                                type: "b",
                                description: "Whether or not to target the center of the object. If false, the camera will orbit the origin of the object.",
                                default: true
                            }
                        ]
                    },
                    focusOnTarget: {
                        scope: "local",
                        name: "focusOnTarget",
                        description: "Look at the center of the current target and zoom so that the object nicely fills the field of view.",
                        action: true,
                        category: "Orbit Camera",
                        parameters: []
                    }
                },
                filter: [
                    "camera"
                ],
                category: "Camera Controllers"
            }
        }, OrbitCameraController_1.default],
    [{
            id: "panorama_to_cubemap_script",
            sid: "Panorama To Cube Map",
            properties: {
                name: "Panorama To Cube Map",
                description: "Converts a panorama to a cube map.",
                attributes: {
                    inputTexture: {
                        name: "inputTexture",
                        type: "asset",
                        default: null,
                        filter: {
                            texture2D: true,
                            renderTexture2D: true
                        },
                        description: "The texture to convert to a cube map."
                    }
                },
                filter: [
                    "renderTextureCube"
                ],
                category: "Rendering"
            }
        }, PanoramaToCubeMap_1.default],
    [{
            id: "preview_axis_rotation",
            sid: "Preview Axis Rotation",
            properties: {
                name: "Preview Axis Rotation",
                description: "Set the rotation of any axis.",
                attributes: {
                    speed: {
                        name: "speed",
                        type: "f",
                        description: "The speed that we rotate the object, if a transition is triggered",
                        default: 0.4,
                        max: 100,
                        min: 0.1
                    }
                },
                filter: [
                    "object"
                ],
                category: "User Defined"
            }
        }, PreviewAxisRotation_1.default],
    [{
            id: "preview_camera_focus",
            sid: "Preview Camera Focus",
            properties: {
                name: "Preview Camera Focus",
                description: "A controller that allows a camera to easily orbit a target object.",
                attributes: {
                    speed: {
                        name: "speed",
                        type: "f",
                        description: "The speed that we move to focus on the target",
                        default: 0.8,
                        max: 100,
                        min: 0.1
                    }
                },
                filter: [
                    "camera"
                ],
                category: "Camera Controllers"
            }
        }, PreviewCameraFocus_1.default],
    [{
            id: "reflection_capture_planar",
            sid: "Reflection Capture Plane",
            properties: {
                name: "Reflection Capture Plane",
                attributes: {
                    captureTexture: {
                        name: "captureTexture",
                        type: "asset",
                        description: "The RenderTexture2D to render the reflection to.",
                        filter: {
                            renderTexture2D: true
                        }
                    },
                    clipBias: {
                        name: "clipBias",
                        type: "f",
                        description: "Pushes the rendered scene forward or backwards to adjust clipping with reflection plane.",
                        default: 0.01
                    },
                    updateFrameInterval: {
                        name: "updateFrameInterval",
                        type: "i",
                        description: "The number of frames to skip in between updates of the reflection. Default is 0.",
                        default: 0
                    }
                },
                filter: [
                    "Object"
                ],
                category: "Rendering"
            }
        }, ReflectionCapturePlane_1.default],
    [{
            id: "box3d_renderer",
            sid: "Renderer",
            properties: {
                name: "Renderer",
                attributes: {
                    antialias: {
                        name: "antialias",
                        type: "b",
                        description: "Enable or disable anti aliasing of the rendered scene.",
                        default: true
                    },
                    preserveDrawingBuffer: {
                        name: "preserveDrawingBuffer",
                        type: "b",
                        description: "Tells the browser to preserve drawing buffers between frames so that they are available to be read by the application.",
                        default: true
                    },
                    precision: {
                        name: "precision",
                        type: "dd",
                        description: "The default floating point and integer precision to be used by the GPU.",
                        default: "mediump",
                        options: {
                            Low: "lowp",
                            Medium: "mediump",
                            High: "highp"
                        }
                    },
                    autoClear: {
                        name: "autoClear",
                        type: "b",
                        description: "Automatically clear the render target before each render.",
                        default: false
                    },
                    devicePixelRatio: {
                        name: "devicePixelRatio",
                        type: "dd",
                        default: 0,
                        options: {
                            "Device Default": 0,
                            One: 1,
                            Two: 2
                        },
                        description: "Override the default pixel ratio of the system. Higher values will cause rendering at higher resolution while lower values will force rendering at lower resolutions. You can also set this to use the device default (mobile devices usually have values greater than 1)."
                    },
                    shadowsEnabled: {
                        name: "shadowsEnabled",
                        type: "b",
                        description: "Enable or disable rendering of shadows.",
                        default: true
                    },
                    shadowsEnabledMobile: {
                        name: "shadowsEnabledMobile",
                        type: "b",
                        description: "Enable or disable rendering of shadows on mobile devices.",
                        default: false
                    },
                    shadowType: {
                        name: "shadowType",
                        type: "dd",
                        options: {
                            "Soft PCF": 2,
                            PCF: 1,
                            "No Filtering": 0
                        },
                        default: 2
                    },
                    shadowReverseSided: {
                        name: "shadowReverseSided",
                        type: "b",
                        description: "Render shadows with reverse side of mesh.",
                        default: false
                    },
                    maxTextureSize2d: {
                        name: "maxTextureSize2d",
                        type: "i",
                        description: "Clamp the maximum allowed dimension of a 2d texture.",
                        default: 32768,
                        min: 1024,
                        max: 32768
                    },
                    maxTextureSizeCube: {
                        name: "maxTextureSizeCube",
                        type: "i",
                        description: "Clamp the maximum allowed dimension of a cube texture.",
                        default: 32768,
                        min: 512,
                        max: 32768
                    },
                    clearColor: {
                        name: "clearColor",
                        type: "c",
                        description: "When the render target is cleared, this colour will be used",
                        default: {
                            r: 0,
                            g: 0,
                            b: 0
                        }
                    },
                    clearAlpha: {
                        name: "clearAlpha",
                        type: "f",
                        description: "When the render target is cleared, this value will be used to clear the transparency",
                        default: 0,
                        min: 0,
                        max: 1,
                        step: 0.001
                    },
                    renderOnDemand: {
                        name: "renderOnDemand",
                        type: "b",
                        description: "When this is enabled, rendering will only happen when requested instead of every frame.",
                        default: true
                    },
                    logarithmicDepthBuffer: {
                        name: "logarithmicDepthBuffer",
                        type: "b",
                        description: "Use logarithmic z values while rendering.",
                        default: false
                    }
                },
                filter: [
                    "application"
                ],
                category: "Rendering"
            }
        }, Renderer_1.default],
    [{
            id: "render_modes",
            sid: "Render Modes",
            properties: {
                name: "Render Modes",
                attributes: {
                    renderMode: {
                        name: "renderMode",
                        type: "s",
                        description: "How to render the scene",
                        default: "Lit"
                    },
                    shapeTexture: {
                        name: "shapeTexture",
                        type: "asset",
                        description: "",
                        filter: {
                            texture2D: true,
                            renderTexture2D: true
                        },
                        default: null
                    },
                    skeletonsVisible: {
                        name: "skeletonsVisible",
                        type: "b",
                        description: "Render skeletons in the scene",
                        default: false
                    },
                    wireframesVisible: {
                        name: "wireframesVisible",
                        type: "b",
                        description: "Render mesh wireframes",
                        default: false
                    }
                },
                events: {
                    resetSkeletons: {
                        scope: "local",
                        name: "resetSkeletons",
                        action: true,
                        category: "Rendering",
                        parameters: []
                    },
                    setRenderMode: {
                        scope: "local",
                        name: "setRenderMode",
                        action: true,
                        category: "Rendering",
                        parameters: [
                            {
                                name: "renderMode",
                                type: "s",
                                description: "One of \"Lit\", \"Unlit\", etc.",
                                default: "Lit"
                            }
                        ]
                    },
                    setSkeletonsVisible: {
                        scope: "local",
                        name: "setSkeletonsVisible",
                        action: true,
                        category: "Rendering",
                        parameters: [
                            {
                                name: "visible",
                                type: "b",
                                description: "Whether or not skeletons are visible.",
                                default: false
                            }
                        ]
                    },
                    setWireframesVisible: {
                        scope: "local",
                        name: "setWireframesVisible",
                        action: true,
                        category: "Rendering",
                        parameters: [
                            {
                                name: "visible",
                                type: "b",
                                description: "Whether or not wireframes are visible.",
                                default: false
                            }
                        ]
                    }
                },
                filter: [
                    "Application"
                ],
                category: "Rendering"
            }
        }, RenderModes_1.default],
    [{
            id: "render_view_component",
            sid: "Render View",
            properties: {
                name: "Render View",
                attributes: {
                    viewportLeft: {
                        name: "viewportLeft",
                        type: "s",
                        description: "Left position of the viewport to be rendered by this camera.",
                        default: "0px"
                    },
                    viewportBottom: {
                        name: "viewportBottom",
                        type: "s",
                        description: "Bottom position of the viewport to be rendered by this camera.",
                        default: "0px"
                    },
                    viewportWidth: {
                        name: "viewportWidth",
                        type: "s",
                        description: "Width of the viewport to be rendered by this camera.",
                        default: "100%"
                    },
                    viewportHeight: {
                        name: "viewportHeight",
                        type: "s",
                        description: "Height of the viewport to be rendered by this camera.",
                        default: "100%"
                    },
                    renderGroup: {
                        name: "renderGroup",
                        type: "i",
                        description: "Render passes are done in order, based on the 'render group' value. Lower numbers render first.",
                        default: 0
                    },
                    renderLayer: {
                        name: "renderLayer",
                        type: "i",
                        description: ".",
                        default: 0,
                        min: 0
                    },
                    clearColor: {
                        name: "clearColor",
                        type: "b",
                        description: "Enable/disable color buffer clearing",
                        default: false,
                        advanced: false
                    },
                    clearDepth: {
                        name: "clearDepth",
                        type: "b",
                        description: "Enable/disable depth buffer clearing",
                        default: true,
                        advanced: false
                    },
                    renderTarget: {
                        name: "renderTarget",
                        type: "asset",
                        description: "The render texture asset to use as a render target.",
                        filter: {
                            renderTexture2D: true
                        },
                        default: null,
                        advanced: false
                    },
                    enablePreRenderFunctions: {
                        name: "enablePreRenderFunctions",
                        type: "b",
                        description: "Run pre-render functions with this view. These include things like real-time reflections, which need to be rendered for each view separately.",
                        default: true,
                        advanced: true
                    },
                    enableShadows: {
                        name: "enableShadows",
                        type: "b",
                        description: "Render shadows for this view.",
                        default: true,
                        advanced: true
                    }
                },
                events: {
                    enableRenderView: {
                        scope: "local",
                        name: "enableRenderView",
                        category: "Rendering",
                        parameters: [
                            {
                                name: "fade",
                                type: "f",
                                description: "Defined in seconds",
                                default: 0
                            }
                        ]
                    },
                    setViewport: {
                        scope: "local",
                        name: "setViewport",
                        category: "Rendering",
                        parameters: [
                            {
                                name: "viewportLeft",
                                description: "Left position of the viewport to be rendered by this camera.",
                                type: "s",
                                default: "0px"
                            },
                            {
                                name: "viewportBottom",
                                description: "Bottom position of the viewport to be rendered by this camera.",
                                type: "s",
                                default: "0px"
                            },
                            {
                                name: "viewportWidth",
                                description: "Width of the viewport to be rendered by this camera.",
                                type: "s",
                                default: "100%"
                            },
                            {
                                name: "viewportHeight",
                                description: "Height of the viewport to be rendered by this camera.",
                                type: "s",
                                default: "100%"
                            },
                            {
                                name: "animationTime",
                                type: "f",
                                description: "Animate the change in viewport over this many seconds.",
                                default: 0
                            }
                        ]
                    },
                    disableRenderView: {
                        scope: "local",
                        name: "disableRenderView",
                        category: "Rendering",
                        parameters: [
                            {
                                name: "fade",
                                type: "f",
                                description: "Defined in seconds",
                                default: 0
                            }
                        ]
                    },
                    toggleRenderView: {
                        scope: "local",
                        name: "toggleRenderView",
                        category: "Rendering",
                        parameters: [
                            {
                                name: "fade",
                                type: "f",
                                description: "Defined in seconds",
                                default: 0
                            }
                        ]
                    }
                },
                filter: [
                    "camera"
                ],
                category: "Rendering"
            }
        }, RenderView_1.default],
    [{
            id: "rotate_component",
            sid: "Rotate",
            properties: {
                name: "Rotate",
                description: "A simple component to rotate an object.",
                attributes: {
                    autoRotate: {
                        name: "autoRotate",
                        type: "b",
                        description: "Automatically start the rotation upon load.",
                        default: true
                    },
                    previewRotation: {
                        name: "previewRotation",
                        type: "b",
                        description: "Show the rotation in the editor.",
                        default: true
                    },
                    rotation: {
                        name: "rotation",
                        type: "v3",
                        description: "Amount of rotation per second about the x, y and z axes.",
                        default: {
                            x: 0,
                            y: 0.5,
                            z: 0
                        }
                    },
                    local: {
                        name: "local",
                        type: "b",
                        description: "Rotate relative to the local quaternion of the object. If false, the rotation will be relative to the world.",
                        default: false
                    }
                },
                events: {
                    startRotate: {
                        scope: "local",
                        name: "startRotate",
                        action: true,
                        category: "Rotate",
                        parameters: []
                    },
                    stopRotate: {
                        scope: "local",
                        name: "stopRotate",
                        action: true,
                        category: "Rotate",
                        parameters: []
                    },
                    toggleRotate: {
                        scope: "local",
                        name: "toggleRotate",
                        action: true,
                        category: "Rotate",
                        parameters: []
                    }
                },
                filter: [
                    "object"
                ],
                category: "Animation"
            }
        }, Rotate_1.default],
    [{
            id: "simplex_noise_component",
            sid: "Simplex Noise Generator",
            properties: {
                name: "Simplex Noise Generator",
                attributes: {
                    layerAmplitude: {
                        name: "layerAmplitude",
                        type: "v4",
                        default: {
                            x: 0.5,
                            y: 0.4,
                            z: 0.3,
                            w: 0.125
                        }
                    },
                    layerScale: {
                        name: "layerScale",
                        type: "v4",
                        default: {
                            x: 0.5,
                            y: 2,
                            z: 3,
                            w: 4
                        }
                    },
                    scale: {
                        name: "scale",
                        type: "v2",
                        default: {
                            x: 1,
                            y: 1
                        }
                    },
                    offset: {
                        name: "offset",
                        type: "v2",
                        default: {
                            x: 0,
                            y: 0
                        }
                    },
                    autoLoad: {
                        name: "autoLoad",
                        type: "b",
                        default: true
                    }
                },
                events: {
                    renderNoise: {
                        scope: "local",
                        name: "renderNoise",
                        action: true,
                        category: "Rendering",
                        parameters: []
                    },
                    changeNoiseValues: {
                        scope: "local",
                        name: "changeNoiseValues",
                        action: true,
                        category: "Rendering",
                        parameters: [
                            {
                                name: "layerAmplitude",
                                type: "v4",
                                description: "",
                                default: {
                                    x: 0.5,
                                    y: 0.4,
                                    z: 0.3,
                                    w: 0.125
                                }
                            },
                            {
                                name: "layerScale",
                                type: "v4",
                                description: "",
                                default: {
                                    x: 0.5,
                                    y: 2,
                                    z: 3,
                                    w: 4
                                }
                            },
                            {
                                name: "scale",
                                type: "v2",
                                description: "",
                                default: {
                                    x: 1,
                                    y: 1
                                }
                            },
                            {
                                name: "offset",
                                type: "v2",
                                description: "",
                                default: {
                                    x: 0,
                                    y: 0
                                }
                            }
                        ]
                    }
                },
                filter: [
                    "renderTexture2D"
                ],
                category: "Rendering"
            }
        }, SimplexNoiseGenerator_1.default],
    [{
            id: "skybox_renderer",
            sid: "Skybox",
            properties: {
                name: "Skybox",
                attributes: {
                    skyboxTexture: {
                        name: "skyboxTexture",
                        type: "asset",
                        description: "The texture asset to use.",
                        filter: {
                            textureCube: true,
                            texture2D: true,
                            renderTexture2D: true,
                            renderTextureCube: true
                        },
                        default: null
                    },
                    stereoEnabled: {
                        name: "stereoEnabled",
                        type: "b",
                        default: false
                    },
                    size: {
                        name: "size",
                        type: "f",
                        default: 1000,
                        min: 1,
                        max: 1000000
                    }
                },
                filter: [
                    "scene"
                ],
                category: "Rendering"
            }
        }, Skybox_1.default],
    [{
            id: "text_renderer_component",
            sid: "Text Renderer",
            properties: {
                name: "Text Renderer",
                description: "Render the desired text to the texture we are attached to",
                attributes: {
                    text: {
                        name: "text",
                        type: "s",
                        default: "My Text",
                        description: "Text you want to display"
                    },
                    fontColor: {
                        name: "fontColor",
                        type: "c",
                        default: {
                            r: 1,
                            g: 1,
                            b: 1
                        },
                        description: "Color of the text"
                    },
                    fontFamily: {
                        name: "fontFamily",
                        type: "s",
                        default: "Calibri",
                        description: "Font family to render"
                    },
                    pointSize: {
                        name: "pointSize",
                        type: "i",
                        default: 48,
                        description: "Font size",
                        min: 2,
                        max: 100
                    }
                },
                filter: [
                    "renderTexture2D"
                ],
                category: "Text"
            }
        }, TextRenderer_1.default],
    [{
            id: "vr_camera_controller",
            sid: "VR Camera Controller",
            properties: {
                name: "VR Camera Controller",
                filter: [
                    "camera"
                ],
                category: "Camera"
            }
        }, VrCameraController_1.default],
    [{
            id: "vr_hand_controller",
            sid: "VR Hand Controller",
            properties: {
                name: "VR Hand Controller",
                attributes: {
                    handPreference: {
                        name: "handPreference",
                        type: "i",
                        default: 0
                    }
                },
                filter: [
                    "object"
                ],
                category: "Input"
            }
        }, VrHandController_1.default],
    [{
            id: "vr_hand_controller_animator",
            sid: "VR Hand Controller Animator",
            properties: {
                name: "VR Hand Controller Animator",
                attributes: {
                    buttonMeshes: {
                        name: "buttonMeshes",
                        type: "a",
                        subType: {
                            type: "object"
                        },
                        default: []
                    },
                    buttonPressOffset: {
                        name: "buttonPressOffset",
                        type: "a",
                        subType: {
                            type: "v3",
                            default: {
                                x: 0,
                                y: 0,
                                z: 0
                            }
                        }
                    },
                    buttonPressRotation: {
                        name: "buttonPressRotation",
                        type: "a",
                        subType: {
                            type: "q",
                            default: {
                                x: 0,
                                y: 0,
                                z: 0,
                                w: 1
                            }
                        }
                    },
                    axisMeshes: {
                        name: "axisMeshes",
                        type: "a",
                        subType: {
                            type: "object"
                        },
                        default: []
                    },
                    axisPivot: {
                        name: "axisPivot",
                        type: "a",
                        subType: {
                            type: "v3",
                            default: {
                                x: 0,
                                y: 0,
                                z: 0
                            }
                        }
                    },
                    axisRotation: {
                        name: "axisRotation",
                        type: "a",
                        subType: {
                            type: "v3",
                            default: {
                                x: 0,
                                y: 0,
                                z: 0
                            }
                        }
                    }
                },
                filter: [
                    "object"
                ],
                category: "Input"
            }
        }, VrHandControllerAnimator_1.default],
    [{
            id: "vr_presenter_component",
            sid: "VR Presenter",
            properties: {
                name: "VR Presenter",
                filter: [
                    "application"
                ],
                category: "VR"
            }
        }, VrPresenter_1.default],
    [{
            id: "vr_render_view_component",
            sid: "VR Render View",
            properties: {
                name: "VR Render View",
                attributes: {
                    viewportLeft: {
                        name: "viewportLeft",
                        type: "s",
                        description: "Left position of the viewport to be rendered by this camera.",
                        default: "0px"
                    },
                    viewportBottom: {
                        name: "viewportBottom",
                        type: "s",
                        description: "Bottom position of the viewport to be rendered by this camera.",
                        default: "0px"
                    },
                    viewportWidth: {
                        name: "viewportWidth",
                        type: "s",
                        description: "Width of the viewport to be rendered by this camera.",
                        default: "100%"
                    },
                    viewportHeight: {
                        name: "viewportHeight",
                        type: "s",
                        description: "Height of the viewport to be rendered by this camera.",
                        default: "100%"
                    },
                    renderGroup: {
                        name: "renderGroup",
                        type: "i",
                        description: "Render passes are done in order, based on the 'render group' value. Lower numbers render first.",
                        default: 0
                    },
                    renderLayer: {
                        name: "renderLayer",
                        type: "i",
                        description: ".",
                        default: 0,
                        min: 0
                    },
                    clearColor: {
                        name: "clearColor",
                        type: "b",
                        description: "Enable/disable color buffer clearing",
                        default: false,
                        advanced: false
                    },
                    clearDepth: {
                        name: "clearDepth",
                        type: "b",
                        description: "Enable/disable depth buffer clearing",
                        default: true,
                        advanced: false
                    },
                    renderTarget: {
                        name: "renderTarget",
                        type: "asset",
                        description: "The render texture asset to use as a render target.",
                        filter: {
                            renderTexture2D: true
                        },
                        default: null,
                        advanced: false
                    },
                    enablePreRenderFunctions: {
                        name: "enablePreRenderFunctions",
                        type: "b",
                        description: "Run pre-render functions with this view. These include things like real-time reflections, which need to be rendered for each view separately.",
                        default: true,
                        advanced: true
                    },
                    enableShadows: {
                        name: "enableShadows",
                        type: "b",
                        description: "Render shadows for this view.",
                        default: true,
                        advanced: true
                    }
                },
                filter: [
                    "camera"
                ],
                category: "Rendering"
            }
        }, VrRenderView_1.default]
];


/***/ },
/* 211 */
/***/ function(module, exports) {

module.exports = "#define PHYSICAL\n\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\nuniform vec3 specular;\nuniform vec4 screenDimensions;\n\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n#include <packing>\n#include <color_pars_fragment>\n//Removed chunk from physical material <uv_pars_fragment>\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined(GLOSS_MAP) || defined(AO_MAP)\n\tvarying vec2 vUv;\n#endif\n//Removed chunk from physical material <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n//Removed chunk from physical material <aomap_pars_fragment>\n#ifdef AO_MAP\n\tuniform sampler2D aoMap;\n#endif\n//Removed chunk from physical material <lightmap_pars_fragment>\n#ifdef EMISSIVE\n#include <emissivemap_pars_fragment>\n#endif\n\n#if defined(GLOSS_MAP) && !defined(ROUGHNESS_MAP)\n\tuniform sampler2D glossMap;\n#endif\n\n#if defined(ENV_MAP_RADIANCE) || defined(ENV_MAP_IRRADIANCE)\n//Removed chunk from physical material <envmap_pars_fragment>\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n\tuniform float flipEnvMap;\n\tuniform float refractionRatio;\n\n\t// This code assumes that all environment maps are of the same type (cube or 2D)\n\t// and use the same sampling transform (e.g. equirectangular projection, etc.\n\t// It is allowed that either irradiance or radiance maps can exist by themselves\n\t// but the radianceHalfGloss can only exist if the other two do.\n\t#if defined(ENV_MAP_RADIANCE_TYPE_CUBE) || defined(ENV_MAP_IRRADIANCE_TYPE_CUBE)\n\t\t#define SAMPLER_TYPE samplerCube\n\t#else\n\t\t#define SAMPLER_TYPE sampler2D\n\t#endif\n\n\t#ifdef ENV_MAP_RADIANCE\n\t\tuniform SAMPLER_TYPE envMapRadiance;\n\t#endif\n\t#if defined(ENV_MAP_RADIANCE_HALF_GLOSS) && defined(ENV_MAP_RADIANCE) && defined(ENV_MAP_IRRADIANCE)\n\t\tuniform SAMPLER_TYPE envMapRadianceHalfGloss;\n\t#endif\n\t#ifdef ENV_MAP_IRRADIANCE\n\t\tuniform SAMPLER_TYPE envMapIrradiance;\n\t#endif\n#endif\n\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <lights_pars>\n#include <lights_physical_pars_fragment>\n\n#undef MAXIMUM_SPECULAR_COEFFICIENT\n#define MAXIMUM_SPECULAR_COEFFICIENT 1.0\n\n\n// Overriding to remove weird reciprocal of PI factor.\nvoid RE_IndirectDiffuse_BoxPBR( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * material.diffuseColor;\n}\n\n// ref: https://www.unrealengine.com/blog/physically-based-shading-on-mobile - environmentBRDF for GGX on mobile\nfloat BRDF_Specular_GGX_Environment_NonMetal( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\n\tconst vec2 c0 = vec2(-1.0, -0.0275);\n\tconst vec2 c1 = vec2(1.0, 0.0425);\n\tvec2 r = roughness * c0 + c1;\n\treturn min( r.x * r.x, exp2( -9.28 * dotNV ) ) * r.x + r.y;\n}\n\nvoid RE_IndirectSpecular_BoxPBR( const in vec3 radiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight, out float fresnel ) {\n\n\t#ifdef CLEAR_COAT\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\n\t#if defined(METALNESS)\n\t\tfresnel = 0.0;\n\t\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#else\n\t\tfresnel = BRDF_Specular_GGX_Environment_NonMetal( geometry, material.specularColor, material.specularRoughness );\n\t\treflectedLight.indirectSpecular += ( 1.0 - clearCoatDHR ) * radiance * fresnel;\n\t#endif\n\n\n\t#ifdef CLEAR_COAT\n\t\tfresnel += BRDF_Specular_GGX_Environment_NonMetal( geometry, vec3( 1.0 ), material.clearCoatRoughness );\n\t\tfresnel = clamp(fresnel, 0.0, 1.0);\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * fresnel;\n\t#endif\n\n}\n\n#undef RE_IndirectDiffuse\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BoxPBR\n#undef RE_IndirectSpecular\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_BoxPBR\n\n#if defined(ENV_MAP_IRRADIANCE)\nvec3 getBox3DLightProbeIndirectIrradiance( /*const in SpecularLightProbe specularLightProbe,*/ const in GeometricContext geometry ) {\n\n\t#include <normal_flip>\n\n\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\n\t#ifdef ENV_MAP_IRRADIANCE_TYPE_CUBE\n\n\t\tvec3 queryVec = flipNormal * vec3( worldNormal.x, worldNormal.yz );\n\t\tvec4 envMapColor = textureCube( envMapIrradiance, queryVec );\n\n\t#elif defined( ENV_MAP_IRRADIANCE_TYPE_CUBE_UV )\n\n\t\tvec3 queryVec = flipNormal * vec3( worldNormal.x, worldNormal.yz );\n\t\tvec4 envMapColor = textureCubeUV( queryVec, 1.0 );\n\n\t#else\n\n\t\tvec4 envMapColor = vec4( 0.0 );\n\n\t#endif\n\t#ifdef ENV_MAP_IRRADIANCE_ENCODING_SRGB\n\t\tenvMapColor.rgb = sRGBToLinear( envMapColor ).rgb;\n\t#endif\n\n\treturn envMapColor.rgb * envMapIntensity;\n\n}\n#endif\n\n#if defined(ENV_MAP_RADIANCE)\n\n\t#if defined(ENV_MAP_IRRADIANCE) && defined(ENV_MAP_RADIANCE_HALF_GLOSS)\n\t\tvec3 getReflectionFromRoughness(in vec3 refRadiance, in vec3 refRadianceHalf, in vec3 refIrradiance, in float roughness) {\n\t\t\tfloat interp = roughness * 2.0;\n\t\t\treturn mix(mix(refRadiance, refRadianceHalf, min(interp, 1.0)), refIrradiance, max(interp - 1.0, 0.0));\n\t\t}\n\t#else\n\t\tvec3 getReflectionFromRoughness(in vec3 refRadiance, in vec3 refIrradiance, in float roughness) {\n\t\t\tfloat interp = min(roughness * 1.5, 1.0);\n\t\t\treturn mix(refRadiance, refIrradiance, interp);\n\t\t}\n\t#endif\n\n\tvec3 getBox3DLightProbeIndirectRadiance( const in GeometricContext geometry, const in float roughness ) {\n\n\t\t#ifdef ENV_MAP_RADIANCE_MODE_REFLECTION\n\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\n\t\t#else\n\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\n\t\t#endif\n\n\t\t#include <normal_flip>\n\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\n\t\tvec3 envMapColor = vec3(0.0);\n\t\tfloat radianceBias = roughness * float(ENV_MAP_RADIANCE_NUM_MIPS) * 0.5;\n\t\tvec4 envMapColorRadiance = vec4(0.0);\n\n\t\t#ifdef ENV_MAP_RADIANCE_HALF_GLOSS\n\t\t\tfloat halfGlossBias = max((roughness - 0.5) * float(ENV_MAP_RADIANCE_HALF_GLOSS_NUM_MIPS), 0.0);\n\t\t#endif\n\n\t\t// Sample the environment map(s)\n\t\t#ifdef ENV_MAP_RADIANCE_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = flipNormal * vec3( reflectVec.x, reflectVec.yz );\n\t\t\t#define ENV_MAP_SAMPLE_FUNCTION textureCube\n\t\t#else // PLANAR REFLECTION\n\t\t\tvec2 queryReflectVec = vec2(-1.0, 1.0) * (gl_FragCoord.xy - screenDimensions.xy) / screenDimensions.zw;\n\t\t\t#define ENV_MAP_SAMPLE_FUNCTION texture2D\n\t\t#endif\n\n\t\t// Sample env maps\n\t\tenvMapColorRadiance.rgb = ENV_MAP_SAMPLE_FUNCTION( envMapRadiance, queryReflectVec, radianceBias ).rgb;\n\n\t\t#ifdef ENV_MAP_GLOSS_VARIANCE\n\t\t\t#ifdef ENV_MAP_RADIANCE_HALF_GLOSS\n\t\t\t\tvec4 envMapColorRadianceHalf = ENV_MAP_SAMPLE_FUNCTION( envMapRadianceHalfGloss, queryReflectVec, halfGlossBias );\n\t\t\t#endif\n\t\t\t#ifdef ENV_MAP_IRRADIANCE\n\t\t\t\tvec4 envMapColorIrradiance = ENV_MAP_SAMPLE_FUNCTION( envMapIrradiance, queryReflectVec );\n\t\t\t#endif\n\t\t#endif\n\n\t\t// Blend depending on which env maps are defined.\n\t\t#ifdef ENV_MAP_RADIANCE_ENCODING_SRGB\n\t\t\tenvMapColorRadiance.rgb = sRGBToLinear( envMapColorRadiance ).rgb;\n\t\t#endif\n\n\t\t#ifdef ENV_MAP_GLOSS_VARIANCE\n\n\t\t\t#if defined(ENV_MAP_IRRADIANCE_ENCODING_SRGB)\n\t\t\t\tenvMapColorIrradiance.rgb = sRGBToLinear(envMapColorIrradiance).rgb;\n\t\t\t#endif\n\n\t\t\t#if defined(ENV_MAP_RADIANCE_HALF_GLOSS) && defined(ENV_MAP_IRRADIANCE)\n\t\t\t\t#if defined(ENV_MAP_RADIANCE_HALF_GLOSS_ENCODING_SRGB)\n\t\t\t\t\tenvMapColorRadianceHalf.rgb = sRGBToLinear( envMapColorRadianceHalf ).rgb;\n\t\t\t\t#endif\n\t\t\t\tenvMapColor = getReflectionFromRoughness(envMapColorRadiance.rgb, envMapColorRadianceHalf.rgb, envMapColorIrradiance.rgb, roughness);\n\t\t\t#elif defined(ENV_MAP_IRRADIANCE)\n\t\t\t\tenvMapColor = getReflectionFromRoughness(envMapColorRadiance.rgb, envMapColorIrradiance.rgb, roughness);\n\t\t\t#else\n\t\t\t\tenvMapColor = envMapColorRadiance.rgb;\n\t\t\t#endif\n\t\t#else\n\t\t\tenvMapColor = envMapColorRadiance.rgb;\n\t\t#endif\n\n\t\treturn envMapColor.rgb * envMapIntensity;\n\n}\n#endif\n\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\n\nvoid main() {\n\n\t#include <clipping_planes_fragment>\n\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#ifndef METALNESS\n\t\tmetalnessFactor = 0.0;\n\t#endif\n\n\t#include <normal_flip>\n\t#if !defined(NORMALS)\n\t\t#undef USE_NORMALMAP\n\t#endif\n\t#include <normal_fragment>\n\n\t#ifdef EMISSIVE\n\t\t#include <emissivemap_fragment>\n\t#endif\n\n\t// accumulation\n\t// Removed chunk from physical material <lights_physical_fragment>\n\tPhysicalMaterial material;\n\tmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\n\tmaterial.specularRoughness = clamp( roughnessFactor, 0.00, 1.0 );\n\t#ifdef METALNESS\n\t\tfloat reflectivityF0 = mix(DEFAULT_SPECULAR_COEFFICIENT, MAXIMUM_SPECULAR_COEFFICIENT, metalnessFactor);\n\t\tmaterial.specularColor = mix( vec3(reflectivityF0), diffuseColor.rgb, metalnessFactor );\n\t#else\n\t\tmaterial.specularColor = specular;\n\t#endif\n\tmaterial.clearCoat = saturate( clearCoat ); // Burley clearcoat model\n\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n\n\t// Sample gloss map and modify specular roughness\n\t#if defined(GLOSS_MAP) && !defined(ROUGHNESS_MAP)\n\t\tvec4 texelGloss = texture2D( glossMap, vUv );\n\t\tmaterial.specularRoughness = min(material.specularRoughness + 1.0 - texelGloss.r, 1.0);\n\t#endif\n\n\tGeometricContext geometry;\n\n\tgeometry.position = - vViewPosition;\n\tgeometry.normal = normal;\n\tgeometry.viewDir = normalize( vViewPosition );\n\n\tIncidentLight directLight;\n\n\t#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\t\tPointLight pointLight;\n\n\t\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\n\t\t\tpointLight = pointLights[ i ];\n\n\t\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\n\t\t\t#ifdef USE_SHADOWMAP\n\t\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ] ) : 1.0;\n\t\t\t#endif\n\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t}\n\n\t#endif\n\n\t#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\n\t\tSpotLight spotLight;\n\n\t\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\n\t\t\tspotLight = spotLights[ i ];\n\n\t\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\n\t\t\t#ifdef USE_SHADOWMAP\n\t\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t\t#endif\n\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t}\n\n\t#endif\n\n\t#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\n\t\tDirectionalLight directionalLight;\n\n\t\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\n\t\t\tdirectionalLight = directionalLights[ i ];\n\n\t\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\n\t\t\t#ifdef USE_SHADOWMAP\n\t\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t\t#endif\n\n\t\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\n\t\t}\n\n\t#endif\n\n\t#if defined( RE_IndirectDiffuse )\n\n\t\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\n\t\t#ifdef USE_LIGHTMAP\n\n\t\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\n\t\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\n\t\t\t\tlightMapIrradiance *= PI; // factor of PI should not be present; included here to prevent breakage\n\n\t\t\t#endif\n\n\t\t\tirradiance += lightMapIrradiance;\n\n\t\t#endif\n\n\t\t#if ( NUM_HEMI_LIGHTS > 0 )\n\n\t\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\n\t\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\n\t\t\t}\n\n\t\t#endif\n\n\t\t#if defined(ENV_MAP_IRRADIANCE)\n\n\t\t\tirradiance += getBox3DLightProbeIndirectIrradiance( /*lightProbe,*/ geometry );\n\n\t\t#endif\n\n\t\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n\n\t#endif\n\n\t#if defined(ENV_MAP_RADIANCE) && defined( RE_IndirectSpecular )\n\n\t\tvec3 radiance = getBox3DLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, material.specularRoughness );\n\t\t#ifdef CLEAR_COAT\n\t\t\tvec3 clearCoatRadiance = getBox3DLightProbeIndirectRadiance( /*specularLightProbe,*/ geometry, material.clearCoatRoughness );\n\t\t#else\n\t\t\tvec3 clearCoatRadiance = vec3( 0.0 );\n\t\t#endif\n\t\tfloat fresnel = 0.0;\n\t\tRE_IndirectSpecular( radiance, clearCoatRadiance, geometry, material, reflectedLight, fresnel );\n\t\tdiffuseColor.a += 2.0 * fresnel; // The factor of 2 is just a rough guess and not based on anything...\n\t\tdiffuseColor.a = min(diffuseColor.a, 1.0);\n\n\t#endif\n\n\t#if defined(AO_MAP)\n\t\t//Removed chunk <aomap_fragment> Overriding so that we can use vUv instead of vUv2\n\t\tfloat ambientOcclusion = texture2D( aoMap, vUv ).r;\n\t\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t\t#endif\n\t#endif\n\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\n}"

/***/ },
/* 212 */
/***/ function(module, exports) {

module.exports = "#define PHYSICAL\n\nvarying vec3 vViewPosition;\n\n#ifndef FLAT_SHADED\n\n\tvarying vec3 vNormal;\n\n#endif\n\n#include <common>\n// Removed chunk from physical material <uv_pars_vertex>\n#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined( GLOSS_MAP ) || defined(AO_MAP)\n\tvarying vec2 vUv;\n\tuniform vec4 offsetRepeat;\n#endif\n// Removed chunk from physical material <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\n\nvoid main() {\n\n\t// Removed chunk from physical material <uv_vertex>\n\t#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP ) || defined( GLOSS_MAP ) || defined(AO_MAP)\n\t\tvUv = uv;\n\t\tvUv.y = 1.0 - vUv.y;\n\t#endif\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\n#ifndef FLAT_SHADED // Normal computed with derivatives when FLAT_SHADED\n\n\tvNormal = normalize( transformedNormal );\n\n#endif\n\n\t#include <begin_vertex>\n\t#include <displacementmap_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\n\tvViewPosition = - mvPosition.xyz;\n\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\n}"

/***/ },
/* 213 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(global) {var require;var require;(function(f){if(true){module.exports=f()}else if(typeof define==="function"&&define.amd){define([],f)}else{var g;if(typeof window!=="undefined"){g=window}else if(typeof global!=="undefined"){g=global}else if(typeof self!=="undefined"){g=self}else{g=this}g.Ajv = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require=="function"&&require;if(!u&&a)return require(o,!0);if(i)return i(o,!0);var f=new Error("Cannot find module '"+o+"'");throw f.code="MODULE_NOT_FOUND",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require=="function"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){
'use strict';

module.exports = {
  setup: setupAsync,
  compile: compileAsync
};


var util = require('./compile/util');

var ASYNC = {
  '*': checkGenerators,
  'co*': checkGenerators,
  'es7': checkAsyncFunction
};

var TRANSPILE = {
  'nodent': getNodent,
  'regenerator': getRegenerator
};

var MODES = [
  { async: 'co*' },
  { async: 'es7', transpile: 'nodent' },
  { async: 'co*', transpile: 'regenerator' }
];


var regenerator, nodent;


function setupAsync(opts, required) {
  if (required !== false) required = true;
  var async = opts.async
    , transpile = opts.transpile
    , check;

  switch (typeof transpile) {
    case 'string':
      var get = TRANSPILE[transpile];
      if (!get) throw new Error('bad transpiler: ' + transpile);
      return (opts._transpileFunc = get(opts, required));
    case 'undefined':
    case 'boolean':
      if (typeof async == 'string') {
        check = ASYNC[async];
        if (!check) throw new Error('bad async mode: ' + async);
        return (opts.transpile = check(opts, required));
      }

      for (var i=0; i<MODES.length; i++) {
        var _opts = MODES[i];
        if (setupAsync(_opts, false)) {
          util.copy(_opts, opts);
          return opts.transpile;
        }
      }
      /* istanbul ignore next */
      throw new Error('generators, nodent and regenerator are not available');
    case 'function':
      return (opts._transpileFunc = opts.transpile);
    default:
      throw new Error('bad transpiler: ' + transpile);
  }
}


function checkGenerators(opts, required) {
  /* jshint evil: true */
  try {
    (new Function('(function*(){})()'))();
    return true;
  } catch(e) {
    /* istanbul ignore next */
    if (required) throw new Error('generators not supported');
  }
}


function checkAsyncFunction(opts, required) {
  /* jshint evil: true */
  try {
    (new Function('(async function(){})()'))();
    /* istanbul ignore next */
    return true;
  } catch(e) {
    if (required) throw new Error('es7 async functions not supported');
  }
}


function getRegenerator(opts, required) {
  try {
    if (!regenerator) {
      var name = 'regenerator';
      regenerator = require(name);
      regenerator.runtime();
    }
    if (!opts.async || opts.async === true)
      opts.async = 'es7';
    return regeneratorTranspile;
  } catch(e) {
    /* istanbul ignore next */
    if (required) throw new Error('regenerator not available');
  }
}


function regeneratorTranspile(code) {
  return regenerator.compile(code).code;
}


function getNodent(opts, required) {
  /* jshint evil: true */
  try {
    if (!nodent) {
      var name = 'nodent';
      nodent = require(name)({ log: false, dontInstallRequireHook: true });
    }
    if (opts.async != 'es7') {
      if (opts.async && opts.async !== true) console.warn('nodent transpiles only es7 async functions');
      opts.async = 'es7';
    }
    return nodentTranspile;
  } catch(e) {
    /* istanbul ignore next */
    if (required) throw new Error('nodent not available');
  }
}


function nodentTranspile(code) {
  return nodent.compile(code, '', { promises: true, sourcemap: false }).code;
}


/**
 * Creates validating function for passed schema with asynchronous loading of missing schemas.
 * `loadSchema` option should be a function that accepts schema uri and node-style callback.
 * @this  Ajv
 * @param {Object}   schema schema object
 * @param {Function} callback node-style callback, it is always called with 2 parameters: error (or null) and validating function.
 */
function compileAsync(schema, callback) {
  /* eslint no-shadow: 0 */
  /* jshint validthis: true */
  var schemaObj;
  var self = this;
  try {
    schemaObj = this._addSchema(schema);
  } catch(e) {
    setTimeout(function() { callback(e); });
    return;
  }
  if (schemaObj.validate) {
    setTimeout(function() { callback(null, schemaObj.validate); });
  } else {
    if (typeof this._opts.loadSchema != 'function')
      throw new Error('options.loadSchema should be a function');
    _compileAsync(schema, callback, true);
  }


  function _compileAsync(schema, callback, firstCall) {
    var validate;
    try { validate = self.compile(schema); }
    catch(e) {
      if (e.missingSchema) loadMissingSchema(e);
      else deferCallback(e);
      return;
    }
    deferCallback(null, validate);

    function loadMissingSchema(e) {
      var ref = e.missingSchema;
      if (self._refs[ref] || self._schemas[ref])
        return callback(new Error('Schema ' + ref + ' is loaded but ' + e.missingRef + ' cannot be resolved'));
      var _callbacks = self._loadingSchemas[ref];
      if (_callbacks) {
        if (typeof _callbacks == 'function')
          self._loadingSchemas[ref] = [_callbacks, schemaLoaded];
        else
          _callbacks[_callbacks.length] = schemaLoaded;
      } else {
        self._loadingSchemas[ref] = schemaLoaded;
        self._opts.loadSchema(ref, function (err, sch) {
          var _callbacks = self._loadingSchemas[ref];
          delete self._loadingSchemas[ref];
          if (typeof _callbacks == 'function') {
            _callbacks(err, sch);
          } else {
            for (var i=0; i<_callbacks.length; i++)
              _callbacks[i](err, sch);
          }
        });
      }

      function schemaLoaded(err, sch) {
        if (err) return callback(err);
        if (!(self._refs[ref] || self._schemas[ref])) {
          try {
            self.addSchema(sch, ref);
          } catch(e) {
            callback(e);
            return;
          }
        }
        _compileAsync(schema, callback);
      }
    }

    function deferCallback(err, validate) {
      if (firstCall) setTimeout(function() { callback(err, validate); });
      else return callback(err, validate);
    }
  }
}

},{"./compile/util":11}],2:[function(require,module,exports){
'use strict';


var Cache = module.exports = function Cache() {
  this._cache = {};
};


Cache.prototype.put = function Cache_put(key, value) {
  this._cache[key] = value;
};


Cache.prototype.get = function Cache_get(key) {
  return this._cache[key];
};


Cache.prototype.del = function Cache_del(key) {
  delete this._cache[key];
};


Cache.prototype.clear = function Cache_clear() {
  this._cache = {};
};

},{}],3:[function(require,module,exports){
'use strict';

//all requires must be explicit because browserify won't work with dynamic requires
module.exports = {
  '$ref': require('../dotjs/ref'),
  allOf: require('../dotjs/allOf'),
  anyOf: require('../dotjs/anyOf'),
  dependencies: require('../dotjs/dependencies'),
  'enum': require('../dotjs/enum'),
  format: require('../dotjs/format'),
  items: require('../dotjs/items'),
  maximum: require('../dotjs/_limit'),
  minimum: require('../dotjs/_limit'),
  maxItems: require('../dotjs/_limitItems'),
  minItems: require('../dotjs/_limitItems'),
  maxLength: require('../dotjs/_limitLength'),
  minLength: require('../dotjs/_limitLength'),
  maxProperties: require('../dotjs/_limitProperties'),
  minProperties: require('../dotjs/_limitProperties'),
  multipleOf: require('../dotjs/multipleOf'),
  not: require('../dotjs/not'),
  oneOf: require('../dotjs/oneOf'),
  pattern: require('../dotjs/pattern'),
  properties: require('../dotjs/properties'),
  required: require('../dotjs/required'),
  uniqueItems: require('../dotjs/uniqueItems'),
  validate: require('../dotjs/validate')
};

},{"../dotjs/_limit":14,"../dotjs/_limitItems":15,"../dotjs/_limitLength":16,"../dotjs/_limitProperties":17,"../dotjs/allOf":18,"../dotjs/anyOf":19,"../dotjs/dependencies":22,"../dotjs/enum":23,"../dotjs/format":24,"../dotjs/items":25,"../dotjs/multipleOf":26,"../dotjs/not":27,"../dotjs/oneOf":28,"../dotjs/pattern":29,"../dotjs/properties":31,"../dotjs/ref":32,"../dotjs/required":33,"../dotjs/uniqueItems":35,"../dotjs/validate":36}],4:[function(require,module,exports){
'use strict';

/*eslint complexity: 0*/

module.exports = function equal(a, b) {
  if (a === b) return true;

  var arrA = Array.isArray(a)
    , arrB = Array.isArray(b)
    , i;

  if (arrA && arrB) {
    if (a.length != b.length) return false;
    for (i = 0; i < a.length; i++)
      if (!equal(a[i], b[i])) return false;
    return true;
  }

  if (arrA != arrB) return false;

  if (a && b && typeof a === 'object' && typeof b === 'object') {
    var keys = Object.keys(a);
    if (keys.length !== Object.keys(b).length) return false;

    var dateA = a instanceof Date
      , dateB = b instanceof Date;
    if (dateA && dateB) return a.getTime() == b.getTime();
    if (dateA != dateB) return false;

    var regexpA = a instanceof RegExp
      , regexpB = b instanceof RegExp;
    if (regexpA && regexpB) return a.toString() == b.toString();
    if (regexpA != regexpB) return false;

    for (i = 0; i < keys.length; i++)
      if (!Object.prototype.hasOwnProperty.call(b, keys[i])) return false;

    for (i = 0; i < keys.length; i++)
      if(!equal(a[keys[i]], b[keys[i]])) return false;

    return true;
  }

  return false;
};

},{}],5:[function(require,module,exports){
'use strict';

var util = require('./util');

var DATE = /^\d\d\d\d-(\d\d)-(\d\d)$/;
var DAYS = [0,31,29,31,30,31,30,31,31,30,31,30,31];
var TIME = /^(\d\d):(\d\d):(\d\d)(\.\d+)?(z|[+-]\d\d:\d\d)?$/i;
var HOSTNAME = /^[0-9a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?(\.[0-9a-z](?:(?:[-0-9a-z]{0,61})?[0-9a-z])?)*$/i;
var URI = /^(?:[a-z][a-z0-9+\-.]*:)?(?:\/?\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:]|%[0-9a-f]{2})*@)?(?:\[(?:(?:(?:(?:[0-9a-f]{1,4}:){6}|::(?:[0-9a-f]{1,4}:){5}|(?:[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){4}|(?:(?:[0-9a-f]{1,4}:){0,1}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){3}|(?:(?:[0-9a-f]{1,4}:){0,2}[0-9a-f]{1,4})?::(?:[0-9a-f]{1,4}:){2}|(?:(?:[0-9a-f]{1,4}:){0,3}[0-9a-f]{1,4})?::[0-9a-f]{1,4}:|(?:(?:[0-9a-f]{1,4}:){0,4}[0-9a-f]{1,4})?::)(?:[0-9a-f]{1,4}:[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?))|(?:(?:[0-9a-f]{1,4}:){0,5}[0-9a-f]{1,4})?::[0-9a-f]{1,4}|(?:(?:[0-9a-f]{1,4}:){0,6}[0-9a-f]{1,4})?::)|[Vv][0-9a-f]+\.[a-z0-9\-._~!$&'()*+,;=:]+)\]|(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)|(?:[a-z0-9\-._~!$&'()*+,;=]|%[0-9a-f]{2})*)(?::\d*)?(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*|\/(?:(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)?|(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})+(?:\/(?:[a-z0-9\-._~!$&'()*+,;=:@]|%[0-9a-f]{2})*)*)(?:\?(?:[a-z0-9\-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*)?(?:\#(?:[a-z0-9\-._~!$&'()*+,;=:@\/?]|%[0-9a-f]{2})*)?$/i;
var UUID = /^(?:urn\:uuid\:)?[0-9a-f]{8}-(?:[0-9a-f]{4}-){3}[0-9a-f]{12}$/i;
var JSON_POINTER = /^(?:\/(?:[^~\/]|~0|~1)*)*$|^\#(?:\/(?:[a-z0-9_\-\.!$&'()*+,;:=@]|%[0-9a-f]{2}|~0|~1)*)*$/i;
var RELATIVE_JSON_POINTER = /^(?:0|[1-9][0-9]*)(?:\#|(?:\/(?:[^~\/]|~0|~1)*)*)$/;


module.exports = formats;

function formats(mode) {
  mode = mode == 'full' ? 'full' : 'fast';
  var formatDefs = util.copy(formats[mode]);
  for (var fName in formats.compare) {
    formatDefs[fName] = {
      validate: formatDefs[fName],
      compare: formats.compare[fName]
    };
  }
  return formatDefs;
}


formats.fast = {
  // date: http://tools.ietf.org/html/rfc3339#section-5.6
  date: /^\d\d\d\d-[0-1]\d-[0-3]\d$/,
  // date-time: http://tools.ietf.org/html/rfc3339#section-5.6
  time: /^[0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)?$/i,
  'date-time': /^\d\d\d\d-[0-1]\d-[0-3]\d[t\s][0-2]\d:[0-5]\d:[0-5]\d(?:\.\d+)?(?:z|[+-]\d\d:\d\d)$/i,
  // uri: https://github.com/mafintosh/is-my-json-valid/blob/master/formats.js
  uri: /^(?:[a-z][a-z0-9+-.]*)?(?:\:|\/)\/?[^\s]*$/i,
  // email (sources from jsen validator):
  // http://stackoverflow.com/questions/201323/using-a-regular-expression-to-validate-an-email-address#answer-8829363
  // http://www.w3.org/TR/html5/forms.html#valid-e-mail-address (search for 'willful violation')
  email: /^[a-z0-9.!#$%&'*+\/=?^_`{|}~-]+@[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?(?:\.[a-z0-9](?:[a-z0-9-]{0,61}[a-z0-9])?)*$/i,
  hostname: HOSTNAME,
  // optimized https://www.safaribooksonline.com/library/view/regular-expressions-cookbook/9780596802837/ch07s16.html
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  // optimized http://stackoverflow.com/questions/53497/regular-expression-that-matches-valid-ipv6-addresses
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  // uuid: http://tools.ietf.org/html/rfc4122
  uuid: UUID,
  // JSON-pointer: https://tools.ietf.org/html/rfc6901
  // uri fragment: https://tools.ietf.org/html/rfc3986#appendix-A
  'json-pointer': JSON_POINTER,
  // relative JSON-pointer: http://tools.ietf.org/html/draft-luff-relative-json-pointer-00
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.full = {
  date: date,
  time: time,
  'date-time': date_time,
  uri: uri,
  email: /^[a-z0-9!#$%&'*+\/=?^_`{|}~-]+(?:\.[a-z0-9!#$%&''*+\/=?^_`{|}~-]+)*@(?:[a-z0-9](?:[a-z0-9-]*[a-z0-9])?\.)+[a-z0-9](?:[a-z0-9-]*[a-z0-9])?$/i,
  hostname: hostname,
  ipv4: /^(?:(?:25[0-5]|2[0-4]\d|[01]?\d\d?)\.){3}(?:25[0-5]|2[0-4]\d|[01]?\d\d?)$/,
  ipv6: /^\s*(?:(?:(?:[0-9a-f]{1,4}:){7}(?:[0-9a-f]{1,4}|:))|(?:(?:[0-9a-f]{1,4}:){6}(?::[0-9a-f]{1,4}|(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){5}(?:(?:(?::[0-9a-f]{1,4}){1,2})|:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3})|:))|(?:(?:[0-9a-f]{1,4}:){4}(?:(?:(?::[0-9a-f]{1,4}){1,3})|(?:(?::[0-9a-f]{1,4})?:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){3}(?:(?:(?::[0-9a-f]{1,4}){1,4})|(?:(?::[0-9a-f]{1,4}){0,2}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){2}(?:(?:(?::[0-9a-f]{1,4}){1,5})|(?:(?::[0-9a-f]{1,4}){0,3}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?:(?:[0-9a-f]{1,4}:){1}(?:(?:(?::[0-9a-f]{1,4}){1,6})|(?:(?::[0-9a-f]{1,4}){0,4}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:))|(?::(?:(?:(?::[0-9a-f]{1,4}){1,7})|(?:(?::[0-9a-f]{1,4}){0,5}:(?:(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)(?:\.(?:25[0-5]|2[0-4]\d|1\d\d|[1-9]?\d)){3}))|:)))(?:%.+)?\s*$/i,
  regex: regex,
  uuid: UUID,
  'json-pointer': JSON_POINTER,
  'relative-json-pointer': RELATIVE_JSON_POINTER
};


formats.compare = {
  date: compareDate,
  time: compareTime,
  'date-time': compareDateTime
};


function date(str) {
  // full-date from http://tools.ietf.org/html/rfc3339#section-5.6
  var matches = str.match(DATE);
  if (!matches) return false;

  var month = +matches[1];
  var day = +matches[2];
  return month >= 1 && month <= 12 && day >= 1 && day <= DAYS[month];
}


function time(str, full) {
  var matches = str.match(TIME);
  if (!matches) return false;

  var hour = matches[1];
  var minute = matches[2];
  var second = matches[3];
  var timeZone = matches[5];
  return hour <= 23 && minute <= 59 && second <= 59 && (!full || timeZone);
}


var DATE_TIME_SEPARATOR = /t|\s/i;
function date_time(str) {
  // http://tools.ietf.org/html/rfc3339#section-5.6
  var dateTime = str.split(DATE_TIME_SEPARATOR);
  return dateTime.length == 2 && date(dateTime[0]) && time(dateTime[1], true);
}


function hostname(str) {
  // https://tools.ietf.org/html/rfc1034#section-3.5
  // https://tools.ietf.org/html/rfc1123#section-2
  return str.length <= 255 && HOSTNAME.test(str);
}


var NOT_URI_FRAGMENT = /\/|\:/;
function uri(str) {
  // http://jmrware.com/articles/2009/uri_regexp/URI_regex.html + optional protocol + required "."
  return NOT_URI_FRAGMENT.test(str) && URI.test(str);
}


function regex(str) {
  try {
    new RegExp(str);
    return true;
  } catch(e) {
    return false;
  }
}


function compareDate(d1, d2) {
  if (!(d1 && d2)) return;
  if (d1 > d2) return 1;
  if (d1 < d2) return -1;
  if (d1 === d2) return 0;
}


function compareTime(t1, t2) {
  if (!(t1 && t2)) return;
  t1 = t1.match(TIME);
  t2 = t2.match(TIME);
  if (!(t1 && t2)) return;
  t1 = t1[1] + t1[2] + t1[3] + (t1[4]||'');
  t2 = t2[1] + t2[2] + t2[3] + (t2[4]||'');
  if (t1 > t2) return 1;
  if (t1 < t2) return -1;
  if (t1 === t2) return 0;
}


function compareDateTime(dt1, dt2) {
  if (!(dt1 && dt2)) return;
  dt1 = dt1.split(DATE_TIME_SEPARATOR);
  dt2 = dt2.split(DATE_TIME_SEPARATOR);
  var res = compareDate(dt1[0], dt2[0]);
  if (res === undefined) return;
  return res || compareTime(dt1[1], dt2[1]);
}

},{"./util":11}],6:[function(require,module,exports){
'use strict';

var resolve = require('./resolve')
  , util = require('./util')
  , stableStringify = require('json-stable-stringify')
  , async = require('../async');

var beautify;

function loadBeautify(){
  if (beautify === undefined) {
    var name = 'js-beautify';
    try { beautify = require(name).js_beautify; }
    catch(e) { beautify = false; }
  }
}

var validateGenerator = require('../dotjs/validate');

/**
 * Functions below are used inside compiled validations function
 */

var co = require('co');
var ucs2length = util.ucs2length;
var equal = require('./equal');

// this error is thrown by async schemas to return validation errors via exception
var ValidationError = require('./validation_error');

module.exports = compile;


/**
 * Compiles schema to validation function
 * @this   Ajv
 * @param  {Object} schema schema object
 * @param  {Object} root object with information about the root schema for this schema
 * @param  {Object} localRefs the hash of local references inside the schema (created by resolve.id), used for inline resolution
 * @param  {String} baseId base ID for IDs in the schema
 * @return {Function} validation function
 */
function compile(schema, root, localRefs, baseId) {
  /* jshint validthis: true, evil: true */
  /* eslint no-shadow: 0 */
  var self = this
    , opts = this._opts
    , refVal = [ undefined ]
    , refs = {}
    , patterns = []
    , patternsHash = {}
    , defaults = []
    , defaultsHash = {}
    , customRules = []
    , keepSourceCode = opts.sourceCode !== false;

  root = root || { schema: schema, refVal: refVal, refs: refs };

  var c = checkCompiling.call(this, schema, root, baseId);
  var compilation = this._compilations[c.index];
  if (c.compiling) return (compilation.callValidate = callValidate);

  var formats = this._formats;
  var RULES = this.RULES;

  try {
    var v = localCompile(schema, root, localRefs, baseId);
    compilation.validate = v;
    var cv = compilation.callValidate;
    if (cv) {
      cv.schema = v.schema;
      cv.errors = null;
      cv.refs = v.refs;
      cv.refVal = v.refVal;
      cv.root = v.root;
      cv.$async = v.$async;
      if (keepSourceCode) cv.sourceCode = v.sourceCode;
    }
    return v;
  } finally {
    endCompiling.call(this, schema, root, baseId);
  }

  function callValidate() {
    var validate = compilation.validate;
    var result = validate.apply(null, arguments);
    callValidate.errors = validate.errors;
    return result;
  }

  function localCompile(_schema, _root, localRefs, baseId) {
    var isRoot = !_root || (_root && _root.schema == _schema);
    if (_root.schema != root.schema)
      return compile.call(self, _schema, _root, localRefs, baseId);

    var $async = _schema.$async === true;
    if ($async && !opts.transpile) async.setup(opts);

    var sourceCode = validateGenerator({
      isTop: true,
      schema: _schema,
      isRoot: isRoot,
      baseId: baseId,
      root: _root,
      schemaPath: '',
      errSchemaPath: '#',
      errorPath: '""',
      RULES: RULES,
      validate: validateGenerator,
      util: util,
      resolve: resolve,
      resolveRef: resolveRef,
      usePattern: usePattern,
      useDefault: useDefault,
      useCustomRule: useCustomRule,
      opts: opts,
      formats: formats,
      self: self
    });

    sourceCode = vars(refVal, refValCode) + vars(patterns, patternCode)
                   + vars(defaults, defaultCode) + vars(customRules, customRuleCode)
                   + sourceCode;

    if (opts.beautify) {
      loadBeautify();
      /* istanbul ignore else */
      if (beautify) sourceCode = beautify(sourceCode, opts.beautify);
      else console.error('"npm install js-beautify" to use beautify option');
    }
    // console.log('\n\n\n *** \n', sourceCode);
    var validate, validateCode
      , transpile = opts._transpileFunc;
    try {
      validateCode = $async && transpile
                      ? transpile(sourceCode)
                      : sourceCode;

      var makeValidate = new Function(
        'self',
        'RULES',
        'formats',
        'root',
        'refVal',
        'defaults',
        'customRules',
        'co',
        'equal',
        'ucs2length',
        'ValidationError',
        validateCode
      );

      validate = makeValidate(
        self,
        RULES,
        formats,
        root,
        refVal,
        defaults,
        customRules,
        co,
        equal,
        ucs2length,
        ValidationError
      );

      refVal[0] = validate;
    } catch(e) {
      console.error('Error compiling schema, function code:', validateCode);
      throw e;
    }

    validate.schema = _schema;
    validate.errors = null;
    validate.refs = refs;
    validate.refVal = refVal;
    validate.root = isRoot ? validate : _root;
    if ($async) validate.$async = true;
    if (keepSourceCode) validate.sourceCode = sourceCode;
    if (opts.sourceCode === true) {
      validate.source = {
        patterns: patterns,
        defaults: defaults
      };
    }

    return validate;
  }

  function resolveRef(baseId, ref, isRoot) {
    ref = resolve.url(baseId, ref);
    var refIndex = refs[ref];
    var _refVal, refCode;
    if (refIndex !== undefined) {
      _refVal = refVal[refIndex];
      refCode = 'refVal[' + refIndex + ']';
      return resolvedRef(_refVal, refCode);
    }
    if (!isRoot && root.refs) {
      var rootRefId = root.refs[ref];
      if (rootRefId !== undefined) {
        _refVal = root.refVal[rootRefId];
        refCode = addLocalRef(ref, _refVal);
        return resolvedRef(_refVal, refCode);
      }
    }

    refCode = addLocalRef(ref);
    var v = resolve.call(self, localCompile, root, ref);
    if (!v) {
      var localSchema = localRefs && localRefs[ref];
      if (localSchema) {
        v = resolve.inlineRef(localSchema, opts.inlineRefs)
            ? localSchema
            : compile.call(self, localSchema, root, localRefs, baseId);
      }
    }

    if (v) {
      replaceLocalRef(ref, v);
      return resolvedRef(v, refCode);
    }
  }

  function addLocalRef(ref, v) {
    var refId = refVal.length;
    refVal[refId] = v;
    refs[ref] = refId;
    return 'refVal' + refId;
  }

  function replaceLocalRef(ref, v) {
    var refId = refs[ref];
    refVal[refId] = v;
  }

  function resolvedRef(refVal, code) {
    return typeof refVal == 'object'
            ? { code: code, schema: refVal, inline: true }
            : { code: code, $async: refVal && refVal.$async };
  }

  function usePattern(regexStr) {
    var index = patternsHash[regexStr];
    if (index === undefined) {
      index = patternsHash[regexStr] = patterns.length;
      patterns[index] = regexStr;
    }
    return 'pattern' + index;
  }

  function useDefault(value) {
    switch (typeof value) {
      case 'boolean':
      case 'number':
        return '' + value;
      case 'string':
        return util.toQuotedString(value);
      case 'object':
        if (value === null) return 'null';
        var valueStr = stableStringify(value);
        var index = defaultsHash[valueStr];
        if (index === undefined) {
          index = defaultsHash[valueStr] = defaults.length;
          defaults[index] = value;
        }
        return 'default' + index;
    }
  }

  function useCustomRule(rule, schema, parentSchema, it) {
    var validateSchema = rule.definition.validateSchema;
    if (validateSchema && self._opts.validateSchema !== false) {
      var valid = validateSchema(schema);
      if (!valid) {
        var message = 'keyword schema is invalid: ' + self.errorsText(validateSchema.errors);
        if (self._opts.validateSchema == 'log') console.error(message);
        else throw new Error(message);
      }
    }

    var compile = rule.definition.compile
      , inline = rule.definition.inline
      , macro = rule.definition.macro;

    var validate;
    if (compile) {
      validate = compile.call(self, schema, parentSchema, it);
    } else if (macro) {
      validate = macro.call(self, schema, parentSchema, it);
      if (opts.validateSchema !== false) self.validateSchema(validate, true);
    } else if (inline) {
      validate = inline.call(self, it, rule.keyword, schema, parentSchema);
    } else {
      validate = rule.definition.validate;
    }

    var index = customRules.length;
    customRules[index] = validate;

    return {
      code: 'customRule' + index,
      validate: validate
    };
  }
}


/**
 * Checks if the schema is currently compiled
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Object} object with properties "index" (compilation index) and "compiling" (boolean)
 */
function checkCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var index = compIndex.call(this, schema, root, baseId);
  if (index >= 0) return { index: index, compiling: true };
  index = this._compilations.length;
  this._compilations[index] = {
    schema: schema,
    root: root,
    baseId: baseId
  };
  return { index: index, compiling: false };
}


/**
 * Removes the schema from the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 */
function endCompiling(schema, root, baseId) {
  /* jshint validthis: true */
  var i = compIndex.call(this, schema, root, baseId);
  if (i >= 0) this._compilations.splice(i, 1);
}


/**
 * Index of schema compilation in the currently compiled list
 * @this   Ajv
 * @param  {Object} schema schema to compile
 * @param  {Object} root root object
 * @param  {String} baseId base schema ID
 * @return {Integer} compilation index
 */
function compIndex(schema, root, baseId) {
  /* jshint validthis: true */
  for (var i=0; i<this._compilations.length; i++) {
    var c = this._compilations[i];
    if (c.schema == schema && c.root == root && c.baseId == baseId) return i;
  }
  return -1;
}


function patternCode(i, patterns) {
  return 'var pattern' + i + ' = new RegExp(' + util.toQuotedString(patterns[i]) + ');';
}


function defaultCode(i) {
  return 'var default' + i + ' = defaults[' + i + '];';
}


function refValCode(i, refVal) {
  return refVal[i] ? 'var refVal' + i + ' = refVal[' + i + '];' : '';
}


function customRuleCode(i) {
  return 'var customRule' + i + ' = customRules[' + i + '];';
}


function vars(arr, statement) {
  if (!arr.length) return '';
  var code = '';
  for (var i=0; i<arr.length; i++)
    code += statement(i, arr);
  return code;
}

},{"../async":1,"../dotjs/validate":36,"./equal":4,"./resolve":7,"./util":11,"./validation_error":12,"co":47,"json-stable-stringify":48}],7:[function(require,module,exports){
'use strict';

var url = require('url')
  , equal = require('./equal')
  , util = require('./util')
  , SchemaObject = require('./schema_obj');

module.exports = resolve;

resolve.normalizeId = normalizeId;
resolve.fullPath = getFullPath;
resolve.url = resolveUrl;
resolve.ids = resolveIds;
resolve.inlineRef = inlineRef;
resolve.schema = resolveSchema;

/**
 * [resolve and compile the references ($ref)]
 * @this   Ajv
 * @param  {Function} compile reference to schema compilation funciton (localCompile)
 * @param  {Object} root object with information about the root schema for the current schema
 * @param  {String} ref reference to resolve
 * @return {Object|Function} schema object (if the schema can be inlined) or validation function
 */
function resolve(compile, root, ref) {
  /* jshint validthis: true */
  var refVal = this._refs[ref];
  if (typeof refVal == 'string') {
    if (this._refs[refVal]) refVal = this._refs[refVal];
    else return resolve.call(this, compile, root, refVal);
  }

  refVal = refVal || this._schemas[ref];
  if (refVal instanceof SchemaObject) {
    return inlineRef(refVal.schema, this._opts.inlineRefs)
            ? refVal.schema
            : refVal.validate || this._compile(refVal);
  }

  var res = resolveSchema.call(this, root, ref);
  var schema, v, baseId;
  if (res) {
    schema = res.schema;
    root = res.root;
    baseId = res.baseId;
  }

  if (schema instanceof SchemaObject) {
    v = schema.validate || compile.call(this, schema.schema, root, undefined, baseId);
  } else if (schema) {
    v = inlineRef(schema, this._opts.inlineRefs)
        ? schema
        : compile.call(this, schema, root, undefined, baseId);
  }

  return v;
}


/**
 * Resolve schema, its root and baseId
 * @this Ajv
 * @param  {Object} root root object with properties schema, refVal, refs
 * @param  {String} ref  reference to resolve
 * @return {Object} object with properties schema, root, baseId
 */
function resolveSchema(root, ref) {
  /* jshint validthis: true */
  var p = url.parse(ref, false, true)
    , refPath = _getFullPath(p)
    , baseId = getFullPath(root.schema.id);
  if (refPath !== baseId) {
    var id = normalizeId(refPath);
    var refVal = this._refs[id];
    if (typeof refVal == 'string') {
      return resolveRecursive.call(this, root, refVal, p);
    } else if (refVal instanceof SchemaObject) {
      if (!refVal.validate) this._compile(refVal);
      root = refVal;
    } else {
      refVal = this._schemas[id];
      if (refVal instanceof SchemaObject) {
        if (!refVal.validate) this._compile(refVal);
        if (id == normalizeId(ref))
          return { schema: refVal, root: root, baseId: baseId };
        root = refVal;
      } else {
        return;
      }
    }
    if (!root.schema) return;
    baseId = getFullPath(root.schema.id);
  }
  return getJsonPointer.call(this, p, baseId, root.schema, root);
}


/* @this Ajv */
function resolveRecursive(root, ref, parsedRef) {
  /* jshint validthis: true */
  var res = resolveSchema.call(this, root, ref);
  if (res) {
    var schema = res.schema;
    var baseId = res.baseId;
    root = res.root;
    if (schema.id) baseId = resolveUrl(baseId, schema.id);
    return getJsonPointer.call(this, parsedRef, baseId, schema, root);
  }
}


var PREVENT_SCOPE_CHANGE = util.toHash(['properties', 'patternProperties', 'enum', 'dependencies', 'definitions']);
/* @this Ajv */
function getJsonPointer(parsedRef, baseId, schema, root) {
  /* jshint validthis: true */
  parsedRef.hash = parsedRef.hash || '';
  if (parsedRef.hash.slice(0,2) != '#/') return;
  var parts = parsedRef.hash.split('/');

  for (var i = 1; i < parts.length; i++) {
    var part = parts[i];
    if (part) {
      part = util.unescapeFragment(part);
      schema = schema[part];
      if (!schema) break;
      if (schema.id && !PREVENT_SCOPE_CHANGE[part]) baseId = resolveUrl(baseId, schema.id);
      if (schema.$ref) {
        var $ref = resolveUrl(baseId, schema.$ref);
        var res = resolveSchema.call(this, root, $ref);
        if (res) {
          schema = res.schema;
          root = res.root;
          baseId = res.baseId;
        }
      }
    }
  }
  if (schema && schema != root.schema)
    return { schema: schema, root: root, baseId: baseId };
}


var SIMPLE_INLINED = util.toHash([
  'type', 'format', 'pattern',
  'maxLength', 'minLength',
  'maxProperties', 'minProperties',
  'maxItems', 'minItems',
  'maximum', 'minimum',
  'uniqueItems', 'multipleOf',
  'required', 'enum'
]);
function inlineRef(schema, limit) {
  if (limit === false) return false;
  if (limit === undefined || limit === true) return checkNoRef(schema);
  else if (limit) return countKeys(schema) <= limit;
}


function checkNoRef(schema) {
  var item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return false;
      item = schema[key];
      if (typeof item == 'object' && !checkNoRef(item)) return false;
    }
  }
  return true;
}


function countKeys(schema) {
  var count = 0, item;
  if (Array.isArray(schema)) {
    for (var i=0; i<schema.length; i++) {
      item = schema[i];
      if (typeof item == 'object') count += countKeys(item);
      if (count == Infinity) return Infinity;
    }
  } else {
    for (var key in schema) {
      if (key == '$ref') return Infinity;
      if (SIMPLE_INLINED[key]) {
        count++;
      } else {
        item = schema[key];
        if (typeof item == 'object') count += countKeys(item) + 1;
        if (count == Infinity) return Infinity;
      }
    }
  }
  return count;
}


function getFullPath(id, normalize) {
  if (normalize !== false) id = normalizeId(id);
  var p = url.parse(id, false, true);
  return _getFullPath(p);
}


function _getFullPath(p) {
  var protocolSeparator = p.protocol || p.href.slice(0,2) == '//' ? '//' : '';
  return (p.protocol||'') + protocolSeparator + (p.host||'') + (p.path||'')  + '#';
}


var TRAILING_SLASH_HASH = /#\/?$/;
function normalizeId(id) {
  return id ? id.replace(TRAILING_SLASH_HASH, '') : '';
}


function resolveUrl(baseId, id) {
  id = normalizeId(id);
  return url.resolve(baseId, id);
}


/* @this Ajv */
function resolveIds(schema) {
  /* eslint no-shadow: 0 */
  /* jshint validthis: true */
  var id = normalizeId(schema.id);
  var localRefs = {};
  _resolveIds.call(this, schema, getFullPath(id, false), id);
  return localRefs;

  /* @this Ajv */
  function _resolveIds(schema, fullPath, baseId) {
    /* jshint validthis: true */
    if (Array.isArray(schema)) {
      for (var i=0; i<schema.length; i++)
        _resolveIds.call(this, schema[i], fullPath+'/'+i, baseId);
    } else if (schema && typeof schema == 'object') {
      if (typeof schema.id == 'string') {
        var id = baseId = baseId
                          ? url.resolve(baseId, schema.id)
                          : schema.id;
        id = normalizeId(id);

        var refVal = this._refs[id];
        if (typeof refVal == 'string') refVal = this._refs[refVal];
        if (refVal && refVal.schema) {
          if (!equal(schema, refVal.schema))
            throw new Error('id "' + id + '" resolves to more than one schema');
        } else if (id != normalizeId(fullPath)) {
          if (id[0] == '#') {
            if (localRefs[id] && !equal(schema, localRefs[id]))
              throw new Error('id "' + id + '" resolves to more than one schema');
            localRefs[id] = schema;
          } else {
            this._refs[id] = fullPath;
          }
        }
      }
      for (var key in schema)
        _resolveIds.call(this, schema[key], fullPath+'/'+util.escapeFragment(key), baseId);
    }
  }
}

},{"./equal":4,"./schema_obj":9,"./util":11,"url":45}],8:[function(require,module,exports){
'use strict';

var ruleModules = require('./_rules')
  , toHash = require('./util').toHash;

module.exports = function rules() {
  var RULES = [
    { type: 'number',
      rules: [ 'maximum', 'minimum', 'multipleOf'] },
    { type: 'string',
      rules: [ 'maxLength', 'minLength', 'pattern', 'format' ] },
    { type: 'array',
      rules: [ 'maxItems', 'minItems', 'uniqueItems', 'items' ] },
    { type: 'object',
      rules: [ 'maxProperties', 'minProperties', 'required', 'dependencies', 'properties' ] },
    { rules: [ '$ref', 'enum', 'not', 'anyOf', 'oneOf', 'allOf' ] }
  ];

  var ALL = [ 'type', 'additionalProperties', 'patternProperties' ];
  var KEYWORDS = [ 'additionalItems', '$schema', 'id', 'title', 'description', 'default' ];
  var TYPES = [ 'number', 'integer', 'string', 'array', 'object', 'boolean', 'null' ];
  RULES.all = toHash(ALL);

  RULES.forEach(function (group) {
    group.rules = group.rules.map(function (keyword) {
      ALL.push(keyword);
      var rule = RULES.all[keyword] = {
        keyword: keyword,
        code: ruleModules[keyword]
      };
      return rule;
    });
  });

  RULES.keywords = toHash(ALL.concat(KEYWORDS));
  RULES.types = toHash(TYPES);
  RULES.custom = {};

  return RULES;
};

},{"./_rules":3,"./util":11}],9:[function(require,module,exports){
'use strict';

var util = require('./util');

module.exports = SchemaObject;

function SchemaObject(obj) {
  util.copy(obj, this);
}

},{"./util":11}],10:[function(require,module,exports){
'use strict';

// https://mathiasbynens.be/notes/javascript-encoding
// https://github.com/bestiejs/punycode.js - punycode.ucs2.decode
module.exports = function ucs2length(str) {
  var length = 0
    , len = str.length
    , pos = 0
    , value;
  while (pos < len) {
    length++;
    value = str.charCodeAt(pos++);
    if (value >= 0xD800 && value <= 0xDBFF && pos < len) {
      // high surrogate, and there is a next character
      value = str.charCodeAt(pos);
      if ((value & 0xFC00) == 0xDC00) pos++; // low surrogate
    }
  }
  return length;
};

},{}],11:[function(require,module,exports){
'use strict';


module.exports = {
  copy: copy,
  checkDataType: checkDataType,
  checkDataTypes: checkDataTypes,
  coerceToTypes: coerceToTypes,
  toHash: toHash,
  getProperty: getProperty,
  escapeQuotes: escapeQuotes,
  ucs2length: require('./ucs2length'),
  varOccurences: varOccurences,
  varReplace: varReplace,
  cleanUpCode: cleanUpCode,
  cleanUpVarErrors: cleanUpVarErrors,
  schemaHasRules: schemaHasRules,
  schemaHasRulesExcept: schemaHasRulesExcept,
  stableStringify: require('json-stable-stringify'),
  toQuotedString: toQuotedString,
  getPathExpr: getPathExpr,
  getPath: getPath,
  getData: getData,
  unescapeFragment: unescapeFragment,
  escapeFragment: escapeFragment,
  escapeJsonPointer: escapeJsonPointer
};


function copy(o, to) {
  to = to || {};
  for (var key in o) to[key] = o[key];
  return to;
}


function checkDataType(dataType, data, negate) {
  var EQUAL = negate ? ' !== ' : ' === '
    , AND = negate ? ' || ' : ' && '
    , OK = negate ? '!' : ''
    , NOT = negate ? '' : '!';
  switch (dataType) {
    case 'null': return data + EQUAL + 'null';
    case 'array': return OK + 'Array.isArray(' + data + ')';
    case 'object': return '(' + OK + data + AND +
                          'typeof ' + data + EQUAL + '"object"' + AND +
                          NOT + 'Array.isArray(' + data + '))';
    case 'integer': return '(typeof ' + data + EQUAL + '"number"' + AND +
                           NOT + '(' + data + ' % 1)' +
                           AND + data + EQUAL + data + ')';
    default: return 'typeof ' + data + EQUAL + '"' + dataType + '"';
  }
}


function checkDataTypes(dataTypes, data) {
  switch (dataTypes.length) {
    case 1: return checkDataType(dataTypes[0], data, true);
    default:
      var code = '';
      var types = toHash(dataTypes);
      if (types.array && types.object) {
        code = types.null ? '(': '(!' + data + ' || ';
        code += 'typeof ' + data + ' !== "object")';
        delete types.null;
        delete types.array;
        delete types.object;
      }
      if (types.number) delete types.integer;
      for (var t in types)
        code += (code ? ' && ' : '' ) + checkDataType(t, data, true);

      return code;
  }
}


var COERCE_TO_TYPES = toHash([ 'string', 'number', 'integer', 'boolean', 'null' ]);
function coerceToTypes(optionCoerceTypes, dataTypes) {
  if (Array.isArray(dataTypes)) {
    var types = [];
    for (var i=0; i<dataTypes.length; i++) {
      var t = dataTypes[i];
      if (COERCE_TO_TYPES[t]) types[types.length] = t;
      else if (optionCoerceTypes === 'array' && t === 'array') types[types.length] = t;
    }
    if (types.length) return types;
  } else if (COERCE_TO_TYPES[dataTypes]) {
    return [dataTypes];
  } else if (optionCoerceTypes === 'array' && dataTypes === 'array') {
    return ['array'];
  }
}


function toHash(arr) {
  var hash = {};
  for (var i=0; i<arr.length; i++) hash[arr[i]] = true;
  return hash;
}


var IDENTIFIER = /^[a-z$_][a-z$_0-9]*$/i;
var SINGLE_QUOTE = /'|\\/g;
function getProperty(key) {
  return typeof key == 'number'
          ? '[' + key + ']'
          : IDENTIFIER.test(key)
            ? '.' + key
            : "['" + escapeQuotes(key) + "']";
}


function escapeQuotes(str) {
  return str.replace(SINGLE_QUOTE, '\\$&')
            .replace(/\n/g, '\\n')
            .replace(/\r/g, '\\r')
            .replace(/\f/g, '\\f')
            .replace(/\t/g, '\\t');
}


function varOccurences(str, dataVar) {
  dataVar += '[^0-9]';
  var matches = str.match(new RegExp(dataVar, 'g'));
  return matches ? matches.length : 0;
}


function varReplace(str, dataVar, expr) {
  dataVar += '([^0-9])';
  expr = expr.replace(/\$/g, '$$$$');
  return str.replace(new RegExp(dataVar, 'g'), expr + '$1');
}


var EMPTY_ELSE = /else\s*{\s*}/g
  , EMPTY_IF_NO_ELSE = /if\s*\([^)]+\)\s*\{\s*\}(?!\s*else)/g
  , EMPTY_IF_WITH_ELSE = /if\s*\(([^)]+)\)\s*\{\s*\}\s*else(?!\s*if)/g;
function cleanUpCode(out) {
  return out.replace(EMPTY_ELSE, '')
            .replace(EMPTY_IF_NO_ELSE, '')
            .replace(EMPTY_IF_WITH_ELSE, 'if (!($1))');
}


var ERRORS_REGEXP = /[^v\.]errors/g
  , REMOVE_ERRORS = /var errors = 0;|var vErrors = null;|validate.errors = vErrors;/g
  , REMOVE_ERRORS_ASYNC = /var errors = 0;|var vErrors = null;/g
  , RETURN_VALID = 'return errors === 0;'
  , RETURN_TRUE = 'validate.errors = null; return true;'
  , RETURN_ASYNC = /if \(errors === 0\) return true;\s*else throw new ValidationError\(vErrors\);/
  , RETURN_TRUE_ASYNC = 'return true;';

function cleanUpVarErrors(out, async) {
  var matches = out.match(ERRORS_REGEXP);
  if (!matches || matches.length !== 2) return out;
  return async
          ? out.replace(REMOVE_ERRORS_ASYNC, '')
               .replace(RETURN_ASYNC, RETURN_TRUE_ASYNC)
          : out.replace(REMOVE_ERRORS, '')
               .replace(RETURN_VALID, RETURN_TRUE);
}


function schemaHasRules(schema, rules) {
  for (var key in schema) if (rules[key]) return true;
}


function schemaHasRulesExcept(schema, rules, exceptKeyword) {
  for (var key in schema) if (key != exceptKeyword && rules[key]) return true;
}


function toQuotedString(str) {
  return '\'' + escapeQuotes(str) + '\'';
}


function getPathExpr(currentPath, expr, jsonPointers, isNumber) {
  var path = jsonPointers // false by default
              ? '\'/\' + ' + expr + (isNumber ? '' : '.replace(/~/g, \'~0\').replace(/\\//g, \'~1\')')
              : (isNumber ? '\'[\' + ' + expr + ' + \']\'' : '\'[\\\'\' + ' + expr + ' + \'\\\']\'');
  return joinPaths(currentPath, path);
}


function getPath(currentPath, prop, jsonPointers) {
  var path = jsonPointers // false by default
              ? toQuotedString('/' + escapeJsonPointer(prop))
              : toQuotedString(getProperty(prop));
  return joinPaths(currentPath, path);
}


var JSON_POINTER = /^\/(?:[^~]|~0|~1)*$/;
var RELATIVE_JSON_POINTER = /^([0-9]+)(#|\/(?:[^~]|~0|~1)*)?$/;
function getData($data, lvl, paths) {
  var up, jsonPointer, data, matches;
  if ($data === '') return 'rootData';
  if ($data[0] == '/') {
    if (!JSON_POINTER.test($data)) throw new Error('Invalid JSON-pointer: ' + $data);
    jsonPointer = $data;
    data = 'rootData';
  } else {
    matches = $data.match(RELATIVE_JSON_POINTER);
    if (!matches) throw new Error('Invalid JSON-pointer: ' + $data);
    up = +matches[1];
    jsonPointer = matches[2];
    if (jsonPointer == '#') {
      if (up >= lvl) throw new Error('Cannot access property/index ' + up + ' levels up, current level is ' + lvl);
      return paths[lvl - up];
    }

    if (up > lvl) throw new Error('Cannot access data ' + up + ' levels up, current level is ' + lvl);
    data = 'data' + ((lvl - up) || '');
    if (!jsonPointer) return data;
  }

  var expr = data;
  var segments = jsonPointer.split('/');
  for (var i=0; i<segments.length; i++) {
    var segment = segments[i];
    if (segment) {
      data += getProperty(unescapeJsonPointer(segment));
      expr += ' && ' + data;
    }
  }
  return expr;
}


function joinPaths (a, b) {
  if (a == '""') return b;
  return (a + ' + ' + b).replace(/' \+ '/g, '');
}


function unescapeFragment(str) {
  return unescapeJsonPointer(decodeURIComponent(str));
}


function escapeFragment(str) {
  return encodeURIComponent(escapeJsonPointer(str));
}


function escapeJsonPointer(str) {
  return str.replace(/~/g, '~0').replace(/\//g, '~1');
}


function unescapeJsonPointer(str) {
  return str.replace(/~1/g, '/').replace(/~0/g, '~');
}

},{"./ucs2length":10,"json-stable-stringify":48}],12:[function(require,module,exports){
'use strict';

module.exports = ValidationError;


function ValidationError(errors) {
  this.message = 'validation failed';
  this.errors = errors;
  this.ajv = this.validation = true;
}


ValidationError.prototype = Object.create(Error.prototype);
ValidationError.prototype.constructor = ValidationError;

},{}],13:[function(require,module,exports){
'use strict';
module.exports = function generate__formatLimit(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  out += 'var ' + ($valid) + ' = undefined;';
  if (it.opts.format === false) {
    out += ' ' + ($valid) + ' = true; ';
    return out;
  }
  var $schemaFormat = it.schema.format,
    $isDataFormat = it.opts.v5 && $schemaFormat.$data,
    $closingBraces = '';
  if ($isDataFormat) {
    var $schemaValueFormat = it.util.getData($schemaFormat.$data, $dataLvl, it.dataPathArr),
      $format = 'format' + $lvl,
      $compare = 'compare' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValueFormat) + '] , ' + ($compare) + ' = ' + ($format) + ' && ' + ($format) + '.compare;';
  } else {
    var $format = it.formats[$schemaFormat];
    if (!($format && $format.compare)) {
      out += '  ' + ($valid) + ' = true; ';
      return out;
    }
    var $compare = 'formats' + it.util.getProperty($schemaFormat) + '.compare';
  }
  var $isMax = $keyword == 'formatMaximum',
    $exclusiveKeyword = 'formatExclusive' + ($isMax ? 'Maximum' : 'Minimum'),
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.v5 && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $result = 'result' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' if (typeof ' + ($schemaValueExcl) + ' != \'boolean\' && ' + ($schemaValueExcl) + ' !== undefined) { ' + ($valid) + ' = false; ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_formatExclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' }  ';
    if ($breakOnError) {
      $closingBraces += '}';
      out += ' else { ';
    }
    if ($isData) {
      out += ' if (' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'string\') ' + ($valid) + ' = false; else { ';
      $closingBraces += '}';
    }
    if ($isDataFormat) {
      out += ' if (!' + ($compare) + ') ' + ($valid) + ' = true; else { ';
      $closingBraces += '}';
    }
    out += ' var ' + ($result) + ' = ' + ($compare) + '(' + ($data) + ',  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += ' ); if (' + ($result) + ' === undefined) ' + ($valid) + ' = false; var ' + ($exclusive) + ' = ' + ($schemaValueExcl) + ' === true; if (' + ($valid) + ' === undefined) { ' + ($valid) + ' = ' + ($exclusive) + ' ? ' + ($result) + ' ' + ($op) + ' 0 : ' + ($result) + ' ' + ($op) + '= 0; } if (!' + ($valid) + ') var op' + ($lvl) + ' = ' + ($exclusive) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\';';
  } else {
    var $exclusive = $schemaExcl === true,
      $opStr = $op;
    if (!$exclusive) $opStr += '=';
    var $opExpr = '\'' + $opStr + '\'';
    if ($isData) {
      out += ' if (' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'string\') ' + ($valid) + ' = false; else { ';
      $closingBraces += '}';
    }
    if ($isDataFormat) {
      out += ' if (!' + ($compare) + ') ' + ($valid) + ' = true; else { ';
      $closingBraces += '}';
    }
    out += ' var ' + ($result) + ' = ' + ($compare) + '(' + ($data) + ',  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += ' ); if (' + ($result) + ' === undefined) ' + ($valid) + ' = false; if (' + ($valid) + ' === undefined) ' + ($valid) + ' = ' + ($result) + ' ' + ($op);
    if (!$exclusive) {
      out += '=';
    }
    out += ' 0;';
  }
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_formatLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += ' , exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '}';
  return out;
}

},{}],14:[function(require,module,exports){
'use strict';
module.exports = function generate__limit(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $isMax = $keyword == 'maximum',
    $exclusiveKeyword = $isMax ? 'exclusiveMaximum' : 'exclusiveMinimum',
    $schemaExcl = it.schema[$exclusiveKeyword],
    $isDataExcl = it.opts.v5 && $schemaExcl && $schemaExcl.$data,
    $op = $isMax ? '<' : '>',
    $notOp = $isMax ? '>' : '<';
  if ($isDataExcl) {
    var $schemaValueExcl = it.util.getData($schemaExcl.$data, $dataLvl, it.dataPathArr),
      $exclusive = 'exclusive' + $lvl,
      $opExpr = 'op' + $lvl,
      $opStr = '\' + ' + $opExpr + ' + \'';
    out += ' var schemaExcl' + ($lvl) + ' = ' + ($schemaValueExcl) + '; ';
    $schemaValueExcl = 'schemaExcl' + $lvl;
    out += ' var exclusive' + ($lvl) + '; if (typeof ' + ($schemaValueExcl) + ' != \'boolean\' && typeof ' + ($schemaValueExcl) + ' != \'undefined\') { ';
    var $errorKeyword = $exclusiveKeyword;
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || '_exclusiveLimit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'' + ($exclusiveKeyword) + ' should be boolean\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else if( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ((exclusive' + ($lvl) + ' = ' + ($schemaValueExcl) + ' === true) ? ' + ($data) + ' ' + ($notOp) + '= ' + ($schemaValue) + ' : ' + ($data) + ' ' + ($notOp) + ' ' + ($schemaValue) + ') || ' + ($data) + ' !== ' + ($data) + ') { var op' + ($lvl) + ' = exclusive' + ($lvl) + ' ? \'' + ($op) + '\' : \'' + ($op) + '=\';';
  } else {
    var $exclusive = $schemaExcl === true,
      $opStr = $op;
    if (!$exclusive) $opStr += '=';
    var $opExpr = '\'' + $opStr + '\'';
    out += ' if ( ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
    }
    out += ' ' + ($data) + ' ' + ($notOp);
    if ($exclusive) {
      out += '=';
    }
    out += ' ' + ($schemaValue) + ' || ' + ($data) + ' !== ' + ($data) + ') {';
  }
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limit') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { comparison: ' + ($opExpr) + ', limit: ' + ($schemaValue) + ', exclusive: ' + ($exclusive) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be ' + ($opStr) + ' ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schema) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],15:[function(require,module,exports){
'use strict';
module.exports = function generate__limitItems(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxItems' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' ' + ($data) + '.length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxItems') {
        out += 'more';
      } else {
        out += 'less';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' items\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],16:[function(require,module,exports){
'use strict';
module.exports = function generate__limitLength(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxLength' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  if (it.opts.unicode === false) {
    out += ' ' + ($data) + '.length ';
  } else {
    out += ' ucs2length(' + ($data) + ') ';
  }
  out += ' ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitLength') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT be ';
      if ($keyword == 'maxLength') {
        out += 'longer';
      } else {
        out += 'shorter';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' characters\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],17:[function(require,module,exports){
'use strict';
module.exports = function generate__limitProperties(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $op = $keyword == 'maxProperties' ? '>' : '<';
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'number\') || ';
  }
  out += ' Object.keys(' + ($data) + ').length ' + ($op) + ' ' + ($schemaValue) + ') { ';
  var $errorKeyword = $keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || '_limitProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should NOT have ';
      if ($keyword == 'maxProperties') {
        out += 'more';
      } else {
        out += 'less';
      }
      out += ' than ';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + ($schema);
      }
      out += ' properties\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],18:[function(require,module,exports){
'use strict';
module.exports = function generate_allOf(it, $keyword) {
  var out = ' ';
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $currentBaseId = $it.baseId,
    $allSchemasEmpty = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $allSchemasEmpty = false;
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if ($breakOnError) {
    if ($allSchemasEmpty) {
      out += ' if (true) { ';
    } else {
      out += ' ' + ($closingBraces.slice(0, -1)) + ' ';
    }
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],19:[function(require,module,exports){
'use strict';
module.exports = function generate_anyOf(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $noEmptySchema = $schema.every(function($sch) {
    return it.util.schemaHasRules($sch, it.RULES.all);
  });
  if ($noEmptySchema) {
    var $currentBaseId = $it.baseId;
    out += ' var ' + ($errs) + ' = errors; var ' + ($valid) + ' = false;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        out += ' ' + ($valid) + ' = ' + ($valid) + ' || ' + ($nextValid) + '; if (!' + ($valid) + ') { ';
        $closingBraces += '}';
      }
    }
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($closingBraces) + ' if (!' + ($valid) + ') {  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'anyOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should match some schema in anyOf\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
    out = it.util.cleanUpCode(out);
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}

},{}],20:[function(require,module,exports){
'use strict';
module.exports = function generate_constant(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (!$isData) {
    out += ' var schema' + ($lvl) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ' = equal(' + ($data) + ', schema' + ($lvl) + '); if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'constant') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to constant\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  return out;
}

},{}],21:[function(require,module,exports){
'use strict';
module.exports = function generate_custom(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $rule = this,
    $definition = 'definition' + $lvl,
    $rDef = $rule.definition,
    $validate = $rDef.validate,
    $compile, $inline, $macro, $ruleValidate, $validateCode;
  if ($isData && $rDef.$data) {
    $validateCode = 'keywordValidate' + $lvl;
    var $validateSchema = $rDef.validateSchema;
    out += ' var ' + ($definition) + ' = RULES.custom[\'' + ($keyword) + '\'].definition; var ' + ($validateCode) + ' = ' + ($definition) + '.validate;';
  } else {
    $ruleValidate = it.useCustomRule($rule, $schema, it.schema, it);
    $schemaValue = 'validate.schema' + $schemaPath;
    $validateCode = $ruleValidate.code;
    $compile = $rDef.compile;
    $inline = $rDef.inline;
    $macro = $rDef.macro;
  }
  var $ruleErrs = $validateCode + '.errors',
    $i = 'i' + $lvl,
    $ruleErr = 'ruleErr' + $lvl,
    $asyncKeyword = $rDef.async;
  if ($asyncKeyword && !it.async) throw new Error('async keyword in sync schema');
  if (!($inline || $macro)) {
    out += '' + ($ruleErrs) + ' = null;';
  }
  out += 'var ' + ($errs) + ' = errors;var valid' + ($lvl) + ';';
  if ($inline && $rDef.statements) {
    out += ' ' + ($ruleValidate.validate);
  } else if ($macro) {
    var $it = it.util.copy(it);
    $it.level++;
    var $nextValid = 'valid' + $it.level;
    $it.schema = $ruleValidate.validate;
    $it.schemaPath = '';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    var $code = it.validate($it).replace(/validate\.schema/g, $validateCode);
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' ' + ($code);
  } else if (!$inline) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    out += '  ' + ($validateCode) + '.call( ';
    if (it.opts.passContext) {
      out += 'this';
    } else {
      out += 'self';
    }
    if ($compile || $rDef.schema === false) {
      out += ' , ' + ($data) + ' ';
    } else {
      out += ' , ' + ($schemaValue) + ' , ' + ($data) + ' , validate.schema' + (it.schemaPath) + ' ';
    }
    out += ' , (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    if ($dataLvl) {
      out += ' , data' + (($dataLvl - 1) || '') + ' , ' + (it.dataPathArr[$dataLvl]) + ' ';
    } else {
      out += ' , parentData , parentDataProperty ';
    }
    out += ' , rootData )  ';
    var def_callRuleValidate = out;
    out = $$outStack.pop();
    if ($rDef.errors !== false) {
      if ($asyncKeyword) {
        $ruleErrs = 'customErrors' + $lvl;
        out += ' var ' + ($ruleErrs) + ' = null; try { valid' + ($lvl) + ' = ' + (it.yieldAwait) + (def_callRuleValidate) + '; } catch (e) { valid' + ($lvl) + ' = false; if (e instanceof ValidationError) ' + ($ruleErrs) + ' = e.errors; else throw e; } ';
      } else {
        out += ' ' + ($validateCode) + '.errors = null; ';
      }
    }
  }
  out += 'if (';
  if ($validateSchema) {
    out += ' !' + ($definition) + '.validateSchema(' + ($schemaValue) + ') || ';
  }
  out += ' ! ';
  if ($inline) {
    if ($rDef.statements) {
      out += ' valid' + ($lvl) + ' ';
    } else {
      out += ' (' + ($ruleValidate.validate) + ') ';
    }
  } else if ($macro) {
    out += ' ' + ($nextValid) + ' ';
  } else {
    if ($asyncKeyword) {
      if ($rDef.errors === false) {
        out += ' (' + (it.yieldAwait) + (def_callRuleValidate) + ') ';
      } else {
        out += ' valid' + ($lvl) + ' ';
      }
    } else {
      out += ' ' + (def_callRuleValidate) + ' ';
    }
  }
  out += ') { ';
  $errorKeyword = $rule.keyword;
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = '';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  var def_customError = out;
  out = $$outStack.pop();
  if ($inline) {
    if ($rDef.errors) {
      if ($rDef.errors != 'full') {
        out += '  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) { ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; } if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } ';
      }
    } else {
      if ($rDef.errors === false) {
        out += ' ' + (def_customError) + ' ';
      } else {
        out += ' if (' + ($errs) + ' == errors) { ' + (def_customError) + ' } else {  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + ']; if (' + ($ruleErr) + '.dataPath === undefined) { ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + '; } if (' + ($ruleErr) + '.schemaPath === undefined) { ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '"; } ';
        if (it.opts.verbose) {
          out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
        }
        out += ' } } ';
      }
    }
  } else if ($macro) {
    out += '   var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'custom') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { keyword: \'' + ($rule.keyword) + '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should pass "' + ($rule.keyword) + '" keyword validation\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError(vErrors); ';
      } else {
        out += ' validate.errors = vErrors; return false; ';
      }
    }
  } else {
    if ($rDef.errors === false) {
      out += ' ' + (def_customError) + ' ';
    } else {
      out += ' if (Array.isArray(' + ($ruleErrs) + ')) { if (vErrors === null) vErrors = ' + ($ruleErrs) + '; else vErrors = vErrors.concat(' + ($ruleErrs) + '); errors = vErrors.length;  for (var ' + ($i) + '=' + ($errs) + '; ' + ($i) + '<errors; ' + ($i) + '++) { var ' + ($ruleErr) + ' = vErrors[' + ($i) + '];  ' + ($ruleErr) + '.dataPath = (dataPath || \'\') + ' + (it.errorPath) + ';   ' + ($ruleErr) + '.schemaPath = "' + ($errSchemaPath) + '";  ';
      if (it.opts.verbose) {
        out += ' ' + ($ruleErr) + '.schema = ' + ($schemaValue) + '; ' + ($ruleErr) + '.data = ' + ($data) + '; ';
      }
      out += ' } } else { ' + (def_customError) + ' } ';
    }
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],22:[function(require,module,exports){
'use strict';
module.exports = function generate_dependencies(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $schemaDeps = {},
    $propertyDeps = {};
  for ($property in $schema) {
    var $sch = $schema[$property];
    var $deps = Array.isArray($sch) ? $propertyDeps : $schemaDeps;
    $deps[$property] = $sch;
  }
  out += 'var ' + ($errs) + ' = errors;';
  var $currentErrorPath = it.errorPath;
  out += 'var missing' + ($lvl) + ';';
  for (var $property in $propertyDeps) {
    $deps = $propertyDeps[$property];
    out += ' if (' + ($data) + (it.util.getProperty($property)) + ' !== undefined ';
    if ($breakOnError) {
      out += ' && ( ';
      var arr1 = $deps;
      if (arr1) {
        var _$property, $i = -1,
          l1 = arr1.length - 1;
        while ($i < l1) {
          _$property = arr1[$i += 1];
          if ($i) {
            out += ' || ';
          }
          var $prop = it.util.getProperty(_$property);
          out += ' ( ' + ($data) + ($prop) + ' === undefined && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? _$property : $prop)) + ') ) ';
        }
      }
      out += ')) {  ';
      var $propertyPath = 'missing' + $lvl,
        $missingProperty = '\' + ' + $propertyPath + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
      }
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should have ';
          if ($deps.length == 1) {
            out += 'property ' + (it.util.escapeQuotes($deps[0]));
          } else {
            out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
          }
          out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
    } else {
      out += ' ) { ';
      var arr2 = $deps;
      if (arr2) {
        var $reqProperty, i2 = -1,
          l2 = arr2.length - 1;
        while (i2 < l2) {
          $reqProperty = arr2[i2 += 1];
          var $prop = it.util.getProperty($reqProperty),
            $missingProperty = it.util.escapeQuotes($reqProperty);
          if (it.opts._errorDataPathProperty) {
            it.errorPath = it.util.getPath($currentErrorPath, $reqProperty, it.opts.jsonPointers);
          }
          out += ' if (' + ($data) + ($prop) + ' === undefined) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'dependencies') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { property: \'' + (it.util.escapeQuotes($property)) + '\', missingProperty: \'' + ($missingProperty) + '\', depsCount: ' + ($deps.length) + ', deps: \'' + (it.util.escapeQuotes($deps.length == 1 ? $deps[0] : $deps.join(", "))) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should have ';
              if ($deps.length == 1) {
                out += 'property ' + (it.util.escapeQuotes($deps[0]));
              } else {
                out += 'properties ' + (it.util.escapeQuotes($deps.join(", ")));
              }
              out += ' when property ' + (it.util.escapeQuotes($property)) + ' is present\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
        }
      }
    }
    out += ' }   ';
    if ($breakOnError) {
      $closingBraces += '}';
      out += ' else { ';
    }
  }
  it.errorPath = $currentErrorPath;
  var $currentBaseId = $it.baseId;
  for (var $property in $schemaDeps) {
    var $sch = $schemaDeps[$property];
    if (it.util.schemaHasRules($sch, it.RULES.all)) {
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '[\'' + ($property) + '\'] !== undefined) { ';
      $it.schema = $sch;
      $it.schemaPath = $schemaPath + it.util.getProperty($property);
      $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($property);
      out += '  ' + (it.validate($it)) + ' ';
      $it.baseId = $currentBaseId;
      out += ' }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  }
  if ($breakOnError) {
    out += '   ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],23:[function(require,module,exports){
'use strict';
module.exports = function generate_enum(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $i = 'i' + $lvl,
    $vSchema = 'schema' + $lvl;
  if (!$isData) {
    out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + ';';
  }
  out += 'var ' + ($valid) + ';';
  if ($isData) {
    out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
  }
  out += '' + ($valid) + ' = false;for (var ' + ($i) + '=0; ' + ($i) + '<' + ($vSchema) + '.length; ' + ($i) + '++) if (equal(' + ($data) + ', ' + ($vSchema) + '[' + ($i) + '])) { ' + ($valid) + ' = true; break; }';
  if ($isData) {
    out += '  }  ';
  }
  out += ' if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'enum') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { allowedValues: schema' + ($lvl) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be equal to one of the allowed values\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' }';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],24:[function(require,module,exports){
'use strict';
module.exports = function generate_format(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  if (it.opts.format === false) {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
    return out;
  }
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $unknownFormats = it.opts.unknownFormats,
    $allowUnknown = Array.isArray($unknownFormats);
  if ($isData) {
    var $format = 'format' + $lvl;
    out += ' var ' + ($format) + ' = formats[' + ($schemaValue) + ']; var isObject' + ($lvl) + ' = typeof ' + ($format) + ' == \'object\' && !(' + ($format) + ' instanceof RegExp) && ' + ($format) + '.validate; if (isObject' + ($lvl) + ') { ';
    if (it.async) {
      out += ' var async' + ($lvl) + ' = ' + ($format) + '.async; ';
    }
    out += ' ' + ($format) + ' = ' + ($format) + '.validate; } if (  ';
    if ($isData) {
      out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
    }
    out += ' (';
    if ($unknownFormats === true || $allowUnknown) {
      out += ' (' + ($schemaValue) + ' && !' + ($format) + ' ';
      if ($allowUnknown) {
        out += ' && self._opts.unknownFormats.indexOf(' + ($schemaValue) + ') == -1 ';
      }
      out += ') || ';
    }
    out += ' (' + ($format) + ' && !(typeof ' + ($format) + ' == \'function\' ? ';
    if (it.async) {
      out += ' (async' + ($lvl) + ' ? ' + (it.yieldAwait) + ' ' + ($format) + '(' + ($data) + ') : ' + ($format) + '(' + ($data) + ')) ';
    } else {
      out += ' ' + ($format) + '(' + ($data) + ') ';
    }
    out += ' : ' + ($format) + '.test(' + ($data) + '))))) {';
  } else {
    var $format = it.formats[$schema];
    if (!$format) {
      if ($unknownFormats === true || ($allowUnknown && $unknownFormats.indexOf($schema) == -1)) {
        throw new Error('unknown format "' + $schema + '" is used in schema at path "' + it.errSchemaPath + '"');
      } else {
        if (!$allowUnknown) {
          console.warn('unknown format "' + $schema + '" ignored in schema at path "' + it.errSchemaPath + '"');
          if ($unknownFormats !== 'ignore') console.warn('In the next major version it will throw exception. See option unknownFormats for more information');
        }
        if ($breakOnError) {
          out += ' if (true) { ';
        }
        return out;
      }
    }
    var $isObject = typeof $format == 'object' && !($format instanceof RegExp) && $format.validate;
    if ($isObject) {
      var $async = $format.async === true;
      $format = $format.validate;
    }
    if ($async) {
      if (!it.async) throw new Error('async format in sync schema');
      var $formatRef = 'formats' + it.util.getProperty($schema) + '.validate';
      out += ' if (!(' + (it.yieldAwait) + ' ' + ($formatRef) + '(' + ($data) + '))) { ';
    } else {
      out += ' if (! ';
      var $formatRef = 'formats' + it.util.getProperty($schema);
      if ($isObject) $formatRef += '.validate';
      if (typeof $format == 'function') {
        out += ' ' + ($formatRef) + '(' + ($data) + ') ';
      } else {
        out += ' ' + ($formatRef) + '.test(' + ($data) + ') ';
      }
      out += ') { ';
    }
  }
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'format') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { format:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match format "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += ' } ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],25:[function(require,module,exports){
'use strict';
module.exports = function generate_items(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $idx = 'i' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt,
    $currentBaseId = it.baseId;
  out += 'var ' + ($errs) + ' = errors;var ' + ($valid) + ';';
  if (Array.isArray($schema)) {
    var $additionalItems = it.schema.additionalItems;
    if ($additionalItems === false) {
      out += ' ' + ($valid) + ' = ' + ($data) + '.length <= ' + ($schema.length) + '; ';
      var $currErrSchemaPath = $errSchemaPath;
      $errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += '  if (!' + ($valid) + ') {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'additionalItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { limit: ' + ($schema.length) + ' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should NOT have more than ' + ($schema.length) + ' items\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } ';
      $errSchemaPath = $currErrSchemaPath;
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
    var arr1 = $schema;
    if (arr1) {
      var $sch, $i = -1,
        l1 = arr1.length - 1;
      while ($i < l1) {
        $sch = arr1[$i += 1];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($i) + ') { ';
          var $passData = $data + '[' + $i + ']';
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + '[' + $i + ']';
          $it.errSchemaPath = $errSchemaPath + '/' + $i;
          $it.errorPath = it.util.getPathExpr(it.errorPath, $i, it.opts.jsonPointers, true);
          $it.dataPathArr[$dataNxt] = $i;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
        }
      }
    }
    if (typeof $additionalItems == 'object' && it.util.schemaHasRules($additionalItems, it.RULES.all)) {
      $it.schema = $additionalItems;
      $it.schemaPath = it.schemaPath + '.additionalItems';
      $it.errSchemaPath = it.errSchemaPath + '/additionalItems';
      out += ' ' + ($nextValid) + ' = true; if (' + ($data) + '.length > ' + ($schema.length) + ') {  for (var ' + ($idx) + ' = ' + ($schema.length) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
      $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
      var $passData = $data + '[' + $idx + ']';
      $it.dataPathArr[$dataNxt] = $idx;
      var $code = it.validate($it);
      $it.baseId = $currentBaseId;
      if (it.util.varOccurences($code, $nextData) < 2) {
        out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
      } else {
        out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
      }
      if ($breakOnError) {
        out += ' if (!' + ($nextValid) + ') break; ';
      }
      out += ' } }  ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
        $closingBraces += '}';
      }
    }
  } else if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += '  for (var ' + ($idx) + ' = ' + (0) + '; ' + ($idx) + ' < ' + ($data) + '.length; ' + ($idx) + '++) { ';
    $it.errorPath = it.util.getPathExpr(it.errorPath, $idx, it.opts.jsonPointers, true);
    var $passData = $data + '[' + $idx + ']';
    $it.dataPathArr[$dataNxt] = $idx;
    var $code = it.validate($it);
    $it.baseId = $currentBaseId;
    if (it.util.varOccurences($code, $nextData) < 2) {
      out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
    } else {
      out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
    }
    if ($breakOnError) {
      out += ' if (!' + ($nextValid) + ') break; ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],26:[function(require,module,exports){
'use strict';
module.exports = function generate_multipleOf(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  out += 'var division' + ($lvl) + ';if (';
  if ($isData) {
    out += ' ' + ($schemaValue) + ' !== undefined && ( typeof ' + ($schemaValue) + ' != \'number\' || ';
  }
  out += ' (division' + ($lvl) + ' = ' + ($data) + ' / ' + ($schemaValue) + ', ';
  if (it.opts.multipleOfPrecision) {
    out += ' Math.abs(Math.round(division' + ($lvl) + ') - division' + ($lvl) + ') > 1e-' + (it.opts.multipleOfPrecision) + ' ';
  } else {
    out += ' division' + ($lvl) + ' !== parseInt(division' + ($lvl) + ') ';
  }
  out += ' ) ';
  if ($isData) {
    out += '  )  ';
  }
  out += ' ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'multipleOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { multipleOf: ' + ($schemaValue) + ' } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should be multiple of ';
      if ($isData) {
        out += '\' + ' + ($schemaValue);
      } else {
        out += '' + ($schema) + '\'';
      }
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + ($schema);
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],27:[function(require,module,exports){
'use strict';
module.exports = function generate_not(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  if (it.util.schemaHasRules($schema, it.RULES.all)) {
    $it.schema = $schema;
    $it.schemaPath = $schemaPath;
    $it.errSchemaPath = $errSchemaPath;
    out += ' var ' + ($errs) + ' = errors;  ';
    var $wasComposite = it.compositeRule;
    it.compositeRule = $it.compositeRule = true;
    $it.createErrors = false;
    var $allErrorsOption;
    if ($it.opts.allErrors) {
      $allErrorsOption = $it.opts.allErrors;
      $it.opts.allErrors = false;
    }
    out += ' ' + (it.validate($it)) + ' ';
    $it.createErrors = true;
    if ($allErrorsOption) $it.opts.allErrors = $allErrorsOption;
    it.compositeRule = $it.compositeRule = $wasComposite;
    out += ' if (' + ($nextValid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } ';
    if (it.opts.allErrors) {
      out += ' } ';
    }
  } else {
    out += '  var err =   '; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'not') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT be valid\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    if ($breakOnError) {
      out += ' if (false) { ';
    }
  }
  return out;
}

},{}],28:[function(require,module,exports){
'use strict';
module.exports = function generate_oneOf(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  out += 'var ' + ($errs) + ' = errors;var prevValid' + ($lvl) + ' = false;var ' + ($valid) + ' = false;';
  var $currentBaseId = $it.baseId;
  var $wasComposite = it.compositeRule;
  it.compositeRule = $it.compositeRule = true;
  var arr1 = $schema;
  if (arr1) {
    var $sch, $i = -1,
      l1 = arr1.length - 1;
    while ($i < l1) {
      $sch = arr1[$i += 1];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = $schemaPath + '[' + $i + ']';
        $it.errSchemaPath = $errSchemaPath + '/' + $i;
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
      } else {
        out += ' var ' + ($nextValid) + ' = true; ';
      }
      if ($i) {
        out += ' if (' + ($nextValid) + ' && prevValid' + ($lvl) + ') ' + ($valid) + ' = false; else { ';
        $closingBraces += '}';
      }
      out += ' if (' + ($nextValid) + ') ' + ($valid) + ' = prevValid' + ($lvl) + ' = true;';
    }
  }
  it.compositeRule = $it.compositeRule = $wasComposite;
  out += '' + ($closingBraces) + 'if (!' + ($valid) + ') {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'oneOf') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: {} ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match exactly one schema in oneOf\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; }';
  if (it.opts.allErrors) {
    out += ' } ';
  }
  return out;
}

},{}],29:[function(require,module,exports){
'use strict';
module.exports = function generate_pattern(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $regexp = $isData ? '(new RegExp(' + $schemaValue + '))' : it.usePattern($schema);
  out += 'if ( ';
  if ($isData) {
    out += ' (' + ($schemaValue) + ' !== undefined && typeof ' + ($schemaValue) + ' != \'string\') || ';
  }
  out += ' !' + ($regexp) + '.test(' + ($data) + ') ) {   ';
  var $$outStack = $$outStack || [];
  $$outStack.push(out);
  out = ''; /* istanbul ignore else */
  if (it.createErrors !== false) {
    out += ' { keyword: \'' + ($errorKeyword || 'pattern') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { pattern:  ';
    if ($isData) {
      out += '' + ($schemaValue);
    } else {
      out += '' + (it.util.toQuotedString($schema));
    }
    out += '  } ';
    if (it.opts.messages !== false) {
      out += ' , message: \'should match pattern "';
      if ($isData) {
        out += '\' + ' + ($schemaValue) + ' + \'';
      } else {
        out += '' + (it.util.escapeQuotes($schema));
      }
      out += '"\' ';
    }
    if (it.opts.verbose) {
      out += ' , schema:  ';
      if ($isData) {
        out += 'validate.schema' + ($schemaPath);
      } else {
        out += '' + (it.util.toQuotedString($schema));
      }
      out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
    }
    out += ' } ';
  } else {
    out += ' {} ';
  }
  var __err = out;
  out = $$outStack.pop();
  if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
    if (it.async) {
      out += ' throw new ValidationError([' + (__err) + ']); ';
    } else {
      out += ' validate.errors = [' + (__err) + ']; return false; ';
    }
  } else {
    out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
  }
  out += '} ';
  if ($breakOnError) {
    out += ' else { ';
  }
  return out;
}

},{}],30:[function(require,module,exports){
'use strict';
module.exports = function generate_patternRequired(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $key = 'key' + $lvl,
    $matched = 'patternMatched' + $lvl,
    $closingBraces = '',
    $ownProperties = it.opts.ownProperties;
  out += 'var ' + ($valid) + ' = true;';
  var arr1 = $schema;
  if (arr1) {
    var $pProperty, i1 = -1,
      l1 = arr1.length - 1;
    while (i1 < l1) {
      $pProperty = arr1[i1 += 1];
      out += ' var ' + ($matched) + ' = false; for (var ' + ($key) + ' in ' + ($data) + ') {  ';
      if ($ownProperties) {
        out += ' if (!Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($key) + ')) continue; ';
      }
      out += ' ' + ($matched) + ' = ' + (it.usePattern($pProperty)) + '.test(' + ($key) + '); if (' + ($matched) + ') break; } ';
      var $missingPattern = it.util.escapeQuotes($pProperty);
      out += ' if (!' + ($matched) + ') { ' + ($valid) + ' = false;  var err =   '; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'patternRequired') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingPattern: \'' + ($missingPattern) + '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should have property matching pattern \\\'' + ($missingPattern) + '\\\'\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; }   ';
      if ($breakOnError) {
        $closingBraces += '}';
        out += ' else { ';
      }
    }
  }
  out += '' + ($closingBraces);
  return out;
}

},{}],31:[function(require,module,exports){
'use strict';
module.exports = function generate_properties(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $key = 'key' + $lvl,
    $dataNxt = $it.dataLevel = it.dataLevel + 1,
    $nextData = 'data' + $dataNxt;
  var $schemaKeys = Object.keys($schema || {}),
    $pProperties = it.schema.patternProperties || {},
    $pPropertyKeys = Object.keys($pProperties),
    $aProperties = it.schema.additionalProperties,
    $someProperties = $schemaKeys.length || $pPropertyKeys.length,
    $noAdditional = $aProperties === false,
    $additionalIsSchema = typeof $aProperties == 'object' && Object.keys($aProperties).length,
    $removeAdditional = it.opts.removeAdditional,
    $checkAdditional = $noAdditional || $additionalIsSchema || $removeAdditional,
    $ownProperties = it.opts.ownProperties,
    $currentBaseId = it.baseId;
  var $required = it.schema.required;
  if ($required && !(it.opts.v5 && $required.$data) && $required.length < it.opts.loopRequired) var $requiredHash = it.util.toHash($required);
  if (it.opts.v5) {
    var $pgProperties = it.schema.patternGroups || {},
      $pgPropertyKeys = Object.keys($pgProperties);
  }
  out += 'var ' + ($errs) + ' = errors;var ' + ($nextValid) + ' = true;';
  if ($checkAdditional) {
    out += ' for (var ' + ($key) + ' in ' + ($data) + ') {  ';
    if ($ownProperties) {
      out += ' if (!Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($key) + ')) continue; ';
    }
    if ($someProperties) {
      out += ' var isAdditional' + ($lvl) + ' = !(false ';
      if ($schemaKeys.length) {
        if ($schemaKeys.length > 5) {
          out += ' || validate.schema' + ($schemaPath) + '[' + ($key) + '] ';
        } else {
          var arr1 = $schemaKeys;
          if (arr1) {
            var $propertyKey, i1 = -1,
              l1 = arr1.length - 1;
            while (i1 < l1) {
              $propertyKey = arr1[i1 += 1];
              out += ' || ' + ($key) + ' == ' + (it.util.toQuotedString($propertyKey)) + ' ';
            }
          }
        }
      }
      if ($pPropertyKeys.length) {
        var arr2 = $pPropertyKeys;
        if (arr2) {
          var $pProperty, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            $pProperty = arr2[$i += 1];
            out += ' || ' + (it.usePattern($pProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      if (it.opts.v5 && $pgPropertyKeys && $pgPropertyKeys.length) {
        var arr3 = $pgPropertyKeys;
        if (arr3) {
          var $pgProperty, $i = -1,
            l3 = arr3.length - 1;
          while ($i < l3) {
            $pgProperty = arr3[$i += 1];
            out += ' || ' + (it.usePattern($pgProperty)) + '.test(' + ($key) + ') ';
          }
        }
      }
      out += ' ); if (isAdditional' + ($lvl) + ') { ';
    }
    if ($removeAdditional == 'all') {
      out += ' delete ' + ($data) + '[' + ($key) + ']; ';
    } else {
      var $currentErrorPath = it.errorPath;
      var $additionalProperty = '\' + ' + $key + ' + \'';
      if (it.opts._errorDataPathProperty) {
        it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
      }
      if ($noAdditional) {
        if ($removeAdditional) {
          out += ' delete ' + ($data) + '[' + ($key) + ']; ';
        } else {
          out += ' ' + ($nextValid) + ' = false; ';
          var $currErrSchemaPath = $errSchemaPath;
          $errSchemaPath = it.errSchemaPath + '/additionalProperties';
          var $$outStack = $$outStack || [];
          $$outStack.push(out);
          out = ''; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'additionalProperties') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { additionalProperty: \'' + ($additionalProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'should NOT have additional properties\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: false , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          var __err = out;
          out = $$outStack.pop();
          if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
            if (it.async) {
              out += ' throw new ValidationError([' + (__err) + ']); ';
            } else {
              out += ' validate.errors = [' + (__err) + ']; return false; ';
            }
          } else {
            out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
          }
          $errSchemaPath = $currErrSchemaPath;
          if ($breakOnError) {
            out += ' break; ';
          }
        }
      } else if ($additionalIsSchema) {
        if ($removeAdditional == 'failing') {
          out += ' var ' + ($errs) + ' = errors;  ';
          var $wasComposite = it.compositeRule;
          it.compositeRule = $it.compositeRule = true;
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          out += ' if (!' + ($nextValid) + ') { errors = ' + ($errs) + '; if (validate.errors !== null) { if (errors) validate.errors.length = errors; else validate.errors = null; } delete ' + ($data) + '[' + ($key) + ']; }  ';
          it.compositeRule = $it.compositeRule = $wasComposite;
        } else {
          $it.schema = $aProperties;
          $it.schemaPath = it.schemaPath + '.additionalProperties';
          $it.errSchemaPath = it.errSchemaPath + '/additionalProperties';
          $it.errorPath = it.opts._errorDataPathProperty ? it.errorPath : it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
        }
      }
      it.errorPath = $currentErrorPath;
    }
    if ($someProperties) {
      out += ' } ';
    }
    out += ' }  ';
    if ($breakOnError) {
      out += ' if (' + ($nextValid) + ') { ';
      $closingBraces += '}';
    }
  }
  var $useDefaults = it.opts.useDefaults && !it.compositeRule;
  if ($schemaKeys.length) {
    var arr4 = $schemaKeys;
    if (arr4) {
      var $propertyKey, i4 = -1,
        l4 = arr4.length - 1;
      while (i4 < l4) {
        $propertyKey = arr4[i4 += 1];
        var $sch = $schema[$propertyKey];
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          var $prop = it.util.getProperty($propertyKey),
            $passData = $data + $prop,
            $hasDefault = $useDefaults && $sch.default !== undefined;
          $it.schema = $sch;
          $it.schemaPath = $schemaPath + $prop;
          $it.errSchemaPath = $errSchemaPath + '/' + it.util.escapeFragment($propertyKey);
          $it.errorPath = it.util.getPath(it.errorPath, $propertyKey, it.opts.jsonPointers);
          $it.dataPathArr[$dataNxt] = it.util.toQuotedString($propertyKey);
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            $code = it.util.varReplace($code, $nextData, $passData);
            var $useData = $passData;
          } else {
            var $useData = $nextData;
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ';
          }
          if ($hasDefault) {
            out += ' ' + ($code) + ' ';
          } else {
            if ($requiredHash && $requiredHash[$propertyKey]) {
              out += ' if (' + ($useData) + ' === undefined) { ' + ($nextValid) + ' = false; ';
              var $currentErrorPath = it.errorPath,
                $currErrSchemaPath = $errSchemaPath,
                $missingProperty = it.util.escapeQuotes($propertyKey);
              if (it.opts._errorDataPathProperty) {
                it.errorPath = it.util.getPath($currentErrorPath, $propertyKey, it.opts.jsonPointers);
              }
              $errSchemaPath = it.errSchemaPath + '/required';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'';
                  if (it.opts._errorDataPathProperty) {
                    out += 'is a required property';
                  } else {
                    out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              $errSchemaPath = $currErrSchemaPath;
              it.errorPath = $currentErrorPath;
              out += ' } else { ';
            } else {
              if ($breakOnError) {
                out += ' if (' + ($useData) + ' === undefined) { ' + ($nextValid) + ' = true; } else { ';
              } else {
                out += ' if (' + ($useData) + ' !== undefined) { ';
              }
            }
            out += ' ' + ($code) + ' } ';
          }
        }
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  var arr5 = $pPropertyKeys;
  if (arr5) {
    var $pProperty, i5 = -1,
      l5 = arr5.length - 1;
    while (i5 < l5) {
      $pProperty = arr5[i5 += 1];
      var $sch = $pProperties[$pProperty];
      if (it.util.schemaHasRules($sch, it.RULES.all)) {
        $it.schema = $sch;
        $it.schemaPath = it.schemaPath + '.patternProperties' + it.util.getProperty($pProperty);
        $it.errSchemaPath = it.errSchemaPath + '/patternProperties/' + it.util.escapeFragment($pProperty);
        out += ' for (var ' + ($key) + ' in ' + ($data) + ') {  ';
        if ($ownProperties) {
          out += ' if (!Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($key) + ')) continue; ';
        }
        out += ' if (' + (it.usePattern($pProperty)) + '.test(' + ($key) + ')) { ';
        $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
        var $passData = $data + '[' + $key + ']';
        $it.dataPathArr[$dataNxt] = $key;
        var $code = it.validate($it);
        $it.baseId = $currentBaseId;
        if (it.util.varOccurences($code, $nextData) < 2) {
          out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
        } else {
          out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
        }
        if ($breakOnError) {
          out += ' if (!' + ($nextValid) + ') break; ';
        }
        out += ' } ';
        if ($breakOnError) {
          out += ' else ' + ($nextValid) + ' = true; ';
        }
        out += ' }  ';
        if ($breakOnError) {
          out += ' if (' + ($nextValid) + ') { ';
          $closingBraces += '}';
        }
      }
    }
  }
  if (it.opts.v5) {
    var arr6 = $pgPropertyKeys;
    if (arr6) {
      var $pgProperty, i6 = -1,
        l6 = arr6.length - 1;
      while (i6 < l6) {
        $pgProperty = arr6[i6 += 1];
        var $pgSchema = $pgProperties[$pgProperty],
          $sch = $pgSchema.schema;
        if (it.util.schemaHasRules($sch, it.RULES.all)) {
          $it.schema = $sch;
          $it.schemaPath = it.schemaPath + '.patternGroups' + it.util.getProperty($pgProperty) + '.schema';
          $it.errSchemaPath = it.errSchemaPath + '/patternGroups/' + it.util.escapeFragment($pgProperty) + '/schema';
          out += ' var pgPropCount' + ($lvl) + ' = 0; for (var ' + ($key) + ' in ' + ($data) + ') {  ';
          if ($ownProperties) {
            out += ' if (!Object.prototype.hasOwnProperty.call(' + ($data) + ', ' + ($key) + ')) continue; ';
          }
          out += ' if (' + (it.usePattern($pgProperty)) + '.test(' + ($key) + ')) { pgPropCount' + ($lvl) + '++; ';
          $it.errorPath = it.util.getPathExpr(it.errorPath, $key, it.opts.jsonPointers);
          var $passData = $data + '[' + $key + ']';
          $it.dataPathArr[$dataNxt] = $key;
          var $code = it.validate($it);
          $it.baseId = $currentBaseId;
          if (it.util.varOccurences($code, $nextData) < 2) {
            out += ' ' + (it.util.varReplace($code, $nextData, $passData)) + ' ';
          } else {
            out += ' var ' + ($nextData) + ' = ' + ($passData) + '; ' + ($code) + ' ';
          }
          if ($breakOnError) {
            out += ' if (!' + ($nextValid) + ') break; ';
          }
          out += ' } ';
          if ($breakOnError) {
            out += ' else ' + ($nextValid) + ' = true; ';
          }
          out += ' }  ';
          if ($breakOnError) {
            out += ' if (' + ($nextValid) + ') { ';
            $closingBraces += '}';
          }
          var $pgMin = $pgSchema.minimum,
            $pgMax = $pgSchema.maximum;
          if ($pgMin !== undefined || $pgMax !== undefined) {
            out += ' var ' + ($valid) + ' = true; ';
            var $currErrSchemaPath = $errSchemaPath;
            if ($pgMin !== undefined) {
              var $limit = $pgMin,
                $reason = 'minimum',
                $moreOrLess = 'less';
              out += ' ' + ($valid) + ' = pgPropCount' + ($lvl) + ' >= ' + ($pgMin) + '; ';
              $errSchemaPath = it.errSchemaPath + '/patternGroups/minimum';
              out += '  if (!' + ($valid) + ') {   ';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'patternGroups') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { reason: \'' + ($reason) + '\', limit: ' + ($limit) + ', pattern: \'' + (it.util.escapeQuotes($pgProperty)) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should NOT have ' + ($moreOrLess) + ' than ' + ($limit) + ' properties matching pattern "' + (it.util.escapeQuotes($pgProperty)) + '"\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
              if ($pgMax !== undefined) {
                out += ' else ';
              }
            }
            if ($pgMax !== undefined) {
              var $limit = $pgMax,
                $reason = 'maximum',
                $moreOrLess = 'more';
              out += ' ' + ($valid) + ' = pgPropCount' + ($lvl) + ' <= ' + ($pgMax) + '; ';
              $errSchemaPath = it.errSchemaPath + '/patternGroups/maximum';
              out += '  if (!' + ($valid) + ') {   ';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'patternGroups') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { reason: \'' + ($reason) + '\', limit: ' + ($limit) + ', pattern: \'' + (it.util.escapeQuotes($pgProperty)) + '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should NOT have ' + ($moreOrLess) + ' than ' + ($limit) + ' properties matching pattern "' + (it.util.escapeQuotes($pgProperty)) + '"\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
            $errSchemaPath = $currErrSchemaPath;
            if ($breakOnError) {
              out += ' if (' + ($valid) + ') { ';
              $closingBraces += '}';
            }
          }
        }
      }
    }
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces) + ' if (' + ($errs) + ' == errors) {';
  }
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],32:[function(require,module,exports){
'use strict';
module.exports = function generate_ref(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $async, $refCode;
  if ($schema == '#' || $schema == '#/') {
    if (it.isRoot) {
      $async = it.async;
      $refCode = 'validate';
    } else {
      $async = it.root.schema.$async === true;
      $refCode = 'root.refVal[0]';
    }
  } else {
    var $refVal = it.resolveRef(it.baseId, $schema, it.isRoot);
    if ($refVal === undefined) {
      var $message = 'can\'t resolve reference ' + $schema + ' from id ' + it.baseId;
      if (it.opts.missingRefs == 'fail') {
        console.log($message);
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || '$ref') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { ref: \'' + (it.util.escapeQuotes($schema)) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'can\\\'t resolve reference ' + (it.util.escapeQuotes($schema)) + '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: ' + (it.util.toQuotedString($schema)) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        if ($breakOnError) {
          out += ' if (false) { ';
        }
      } else if (it.opts.missingRefs == 'ignore') {
        console.log($message);
        if ($breakOnError) {
          out += ' if (true) { ';
        }
      } else {
        var $error = new Error($message);
        $error.missingRef = it.resolve.url(it.baseId, $schema);
        $error.missingSchema = it.resolve.normalizeId(it.resolve.fullPath($error.missingRef));
        throw $error;
      }
    } else if ($refVal.inline) {
      var $it = it.util.copy(it);
      $it.level++;
      var $nextValid = 'valid' + $it.level;
      $it.schema = $refVal.schema;
      $it.schemaPath = '';
      $it.errSchemaPath = $schema;
      var $code = it.validate($it).replace(/validate\.schema/g, $refVal.code);
      out += ' ' + ($code) + ' ';
      if ($breakOnError) {
        out += ' if (' + ($nextValid) + ') { ';
      }
    } else {
      $async = $refVal.$async === true;
      $refCode = $refVal.code;
    }
  }
  if ($refCode) {
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = '';
    if (it.opts.passContext) {
      out += ' ' + ($refCode) + '.call(this, ';
    } else {
      out += ' ' + ($refCode) + '( ';
    }
    out += ' ' + ($data) + ', (dataPath || \'\')';
    if (it.errorPath != '""') {
      out += ' + ' + (it.errorPath);
    }
    if ($dataLvl) {
      out += ' , data' + (($dataLvl - 1) || '') + ' , ' + (it.dataPathArr[$dataLvl]) + ' ';
    } else {
      out += ' , parentData , parentDataProperty ';
    }
    out += ', rootData)  ';
    var __callValidate = out;
    out = $$outStack.pop();
    if ($async) {
      if (!it.async) throw new Error('async schema referenced by sync schema');
      out += ' try { ';
      if ($breakOnError) {
        out += 'var ' + ($valid) + ' =';
      }
      out += ' ' + (it.yieldAwait) + ' ' + (__callValidate) + '; } catch (e) { if (!(e instanceof ValidationError)) throw e; if (vErrors === null) vErrors = e.errors; else vErrors = vErrors.concat(e.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' if (' + ($valid) + ') { ';
      }
    } else {
      out += ' if (!' + (__callValidate) + ') { if (vErrors === null) vErrors = ' + ($refCode) + '.errors; else vErrors = vErrors.concat(' + ($refCode) + '.errors); errors = vErrors.length; } ';
      if ($breakOnError) {
        out += ' else { ';
      }
    }
  }
  return out;
}

},{}],33:[function(require,module,exports){
'use strict';
module.exports = function generate_required(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  var $vSchema = 'schema' + $lvl;
  if (!$isData) {
    if ($schema.length < it.opts.loopRequired && it.schema.properties && Object.keys(it.schema.properties).length) {
      var $required = [];
      var arr1 = $schema;
      if (arr1) {
        var $property, i1 = -1,
          l1 = arr1.length - 1;
        while (i1 < l1) {
          $property = arr1[i1 += 1];
          var $propertySch = it.schema.properties[$property];
          if (!($propertySch && it.util.schemaHasRules($propertySch, it.RULES.all))) {
            $required[$required.length] = $property;
          }
        }
      }
    } else {
      var $required = $schema;
    }
  }
  if ($isData || $required.length) {
    var $currentErrorPath = it.errorPath,
      $loopRequired = $isData || $required.length >= it.opts.loopRequired;
    if ($breakOnError) {
      out += ' var missing' + ($lvl) + '; ';
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        out += ' var ' + ($valid) + ' = true; ';
        if ($isData) {
          out += ' if (schema' + ($lvl) + ' === undefined) ' + ($valid) + ' = true; else if (!Array.isArray(schema' + ($lvl) + ')) ' + ($valid) + ' = false; else {';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { ' + ($valid) + ' = ' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] !== undefined; if (!' + ($valid) + ') break; } ';
        if ($isData) {
          out += '  }  ';
        }
        out += '  if (!' + ($valid) + ') {   ';
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      } else {
        out += ' if ( ';
        var arr2 = $required;
        if (arr2) {
          var _$property, $i = -1,
            l2 = arr2.length - 1;
          while ($i < l2) {
            _$property = arr2[$i += 1];
            if ($i) {
              out += ' || ';
            }
            var $prop = it.util.getProperty(_$property);
            out += ' ( ' + ($data) + ($prop) + ' === undefined && (missing' + ($lvl) + ' = ' + (it.util.toQuotedString(it.opts.jsonPointers ? _$property : $prop)) + ') ) ';
          }
        }
        out += ') {  ';
        var $propertyPath = 'missing' + $lvl,
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.opts.jsonPointers ? it.util.getPathExpr($currentErrorPath, $propertyPath, true) : $currentErrorPath + ' + ' + $propertyPath;
        }
        var $$outStack = $$outStack || [];
        $$outStack.push(out);
        out = ''; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        var __err = out;
        out = $$outStack.pop();
        if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
          if (it.async) {
            out += ' throw new ValidationError([' + (__err) + ']); ';
          } else {
            out += ' validate.errors = [' + (__err) + ']; return false; ';
          }
        } else {
          out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
        }
        out += ' } else { ';
      }
    } else {
      if ($loopRequired) {
        if (!$isData) {
          out += ' var ' + ($vSchema) + ' = validate.schema' + ($schemaPath) + '; ';
        }
        var $i = 'i' + $lvl,
          $propertyPath = 'schema' + $lvl + '[' + $i + ']',
          $missingProperty = '\' + ' + $propertyPath + ' + \'';
        if (it.opts._errorDataPathProperty) {
          it.errorPath = it.util.getPathExpr($currentErrorPath, $propertyPath, it.opts.jsonPointers);
        }
        if ($isData) {
          out += ' if (' + ($vSchema) + ' && !Array.isArray(' + ($vSchema) + ')) {  var err =   '; /* istanbul ignore else */
          if (it.createErrors !== false) {
            out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
            if (it.opts.messages !== false) {
              out += ' , message: \'';
              if (it.opts._errorDataPathProperty) {
                out += 'is a required property';
              } else {
                out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
              }
              out += '\' ';
            }
            if (it.opts.verbose) {
              out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
            }
            out += ' } ';
          } else {
            out += ' {} ';
          }
          out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } else if (' + ($vSchema) + ' !== undefined) { ';
        }
        out += ' for (var ' + ($i) + ' = 0; ' + ($i) + ' < ' + ($vSchema) + '.length; ' + ($i) + '++) { if (' + ($data) + '[' + ($vSchema) + '[' + ($i) + ']] === undefined) {  var err =   '; /* istanbul ignore else */
        if (it.createErrors !== false) {
          out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
          if (it.opts.messages !== false) {
            out += ' , message: \'';
            if (it.opts._errorDataPathProperty) {
              out += 'is a required property';
            } else {
              out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
            }
            out += '\' ';
          }
          if (it.opts.verbose) {
            out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
          }
          out += ' } ';
        } else {
          out += ' {} ';
        }
        out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } } ';
        if ($isData) {
          out += '  }  ';
        }
      } else {
        var arr3 = $required;
        if (arr3) {
          var $reqProperty, i3 = -1,
            l3 = arr3.length - 1;
          while (i3 < l3) {
            $reqProperty = arr3[i3 += 1];
            var $prop = it.util.getProperty($reqProperty),
              $missingProperty = it.util.escapeQuotes($reqProperty);
            if (it.opts._errorDataPathProperty) {
              it.errorPath = it.util.getPath($currentErrorPath, $reqProperty, it.opts.jsonPointers);
            }
            out += ' if (' + ($data) + ($prop) + ' === undefined) {  var err =   '; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'required') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { missingProperty: \'' + ($missingProperty) + '\' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'';
                if (it.opts._errorDataPathProperty) {
                  out += 'is a required property';
                } else {
                  out += 'should have required property \\\'' + ($missingProperty) + '\\\'';
                }
                out += '\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            out += ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; } ';
          }
        }
      }
    }
    it.errorPath = $currentErrorPath;
  } else if ($breakOnError) {
    out += ' if (true) {';
  }
  return out;
}

},{}],34:[function(require,module,exports){
'use strict';
module.exports = function generate_switch(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $errs = 'errs__' + $lvl;
  var $it = it.util.copy(it);
  var $closingBraces = '';
  $it.level++;
  var $nextValid = 'valid' + $it.level;
  var $ifPassed = 'ifPassed' + it.level,
    $currentBaseId = $it.baseId,
    $shouldContinue;
  out += 'var ' + ($ifPassed) + ';';
  var arr1 = $schema;
  if (arr1) {
    var $sch, $caseIndex = -1,
      l1 = arr1.length - 1;
    while ($caseIndex < l1) {
      $sch = arr1[$caseIndex += 1];
      if ($caseIndex && !$shouldContinue) {
        out += ' if (!' + ($ifPassed) + ') { ';
        $closingBraces += '}';
      }
      if ($sch.if && it.util.schemaHasRules($sch.if, it.RULES.all)) {
        out += ' var ' + ($errs) + ' = errors;   ';
        var $wasComposite = it.compositeRule;
        it.compositeRule = $it.compositeRule = true;
        $it.createErrors = false;
        $it.schema = $sch.if;
        $it.schemaPath = $schemaPath + '[' + $caseIndex + '].if';
        $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/if';
        out += '  ' + (it.validate($it)) + ' ';
        $it.baseId = $currentBaseId;
        $it.createErrors = true;
        it.compositeRule = $it.compositeRule = $wasComposite;
        out += ' ' + ($ifPassed) + ' = ' + ($nextValid) + '; if (' + ($ifPassed) + ') {  ';
        if (typeof $sch.then == 'boolean') {
          if ($sch.then === false) {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'switch') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { caseIndex: ' + ($caseIndex) + ' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should pass "switch" keyword validation\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
          }
          out += ' var ' + ($nextValid) + ' = ' + ($sch.then) + '; ';
        } else {
          $it.schema = $sch.then;
          $it.schemaPath = $schemaPath + '[' + $caseIndex + '].then';
          $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/then';
          out += '  ' + (it.validate($it)) + ' ';
          $it.baseId = $currentBaseId;
        }
        out += '  } else {  errors = ' + ($errs) + '; if (vErrors !== null) { if (' + ($errs) + ') vErrors.length = ' + ($errs) + '; else vErrors = null; } } ';
      } else {
        out += ' ' + ($ifPassed) + ' = true;  ';
        if (typeof $sch.then == 'boolean') {
          if ($sch.then === false) {
            var $$outStack = $$outStack || [];
            $$outStack.push(out);
            out = ''; /* istanbul ignore else */
            if (it.createErrors !== false) {
              out += ' { keyword: \'' + ($errorKeyword || 'switch') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { caseIndex: ' + ($caseIndex) + ' } ';
              if (it.opts.messages !== false) {
                out += ' , message: \'should pass "switch" keyword validation\' ';
              }
              if (it.opts.verbose) {
                out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
              }
              out += ' } ';
            } else {
              out += ' {} ';
            }
            var __err = out;
            out = $$outStack.pop();
            if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
              if (it.async) {
                out += ' throw new ValidationError([' + (__err) + ']); ';
              } else {
                out += ' validate.errors = [' + (__err) + ']; return false; ';
              }
            } else {
              out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
            }
          }
          out += ' var ' + ($nextValid) + ' = ' + ($sch.then) + '; ';
        } else {
          $it.schema = $sch.then;
          $it.schemaPath = $schemaPath + '[' + $caseIndex + '].then';
          $it.errSchemaPath = $errSchemaPath + '/' + $caseIndex + '/then';
          out += '  ' + (it.validate($it)) + ' ';
          $it.baseId = $currentBaseId;
        }
      }
      $shouldContinue = $sch.continue
    }
  }
  out += '' + ($closingBraces) + 'var ' + ($valid) + ' = ' + ($nextValid) + '; ';
  out = it.util.cleanUpCode(out);
  return out;
}

},{}],35:[function(require,module,exports){
'use strict';
module.exports = function generate_uniqueItems(it, $keyword) {
  var out = ' ';
  var $lvl = it.level;
  var $dataLvl = it.dataLevel;
  var $schema = it.schema[$keyword];
  var $schemaPath = it.schemaPath + it.util.getProperty($keyword);
  var $errSchemaPath = it.errSchemaPath + '/' + $keyword;
  var $breakOnError = !it.opts.allErrors;
  var $errorKeyword;
  var $data = 'data' + ($dataLvl || '');
  var $valid = 'valid' + $lvl;
  var $isData = it.opts.v5 && $schema && $schema.$data,
    $schemaValue;
  if ($isData) {
    out += ' var schema' + ($lvl) + ' = ' + (it.util.getData($schema.$data, $dataLvl, it.dataPathArr)) + '; ';
    $schemaValue = 'schema' + $lvl;
  } else {
    $schemaValue = $schema;
  }
  if (($schema || $isData) && it.opts.uniqueItems !== false) {
    if ($isData) {
      out += ' var ' + ($valid) + '; if (' + ($schemaValue) + ' === false || ' + ($schemaValue) + ' === undefined) ' + ($valid) + ' = true; else if (typeof ' + ($schemaValue) + ' != \'boolean\') ' + ($valid) + ' = false; else { ';
    }
    out += ' var ' + ($valid) + ' = true; if (' + ($data) + '.length > 1) { var i = ' + ($data) + '.length, j; outer: for (;i--;) { for (j = i; j--;) { if (equal(' + ($data) + '[i], ' + ($data) + '[j])) { ' + ($valid) + ' = false; break outer; } } } } ';
    if ($isData) {
      out += '  }  ';
    }
    out += ' if (!' + ($valid) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'uniqueItems') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { i: i, j: j } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should NOT have duplicate items (items ## \' + j + \' and \' + i + \' are identical)\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema:  ';
        if ($isData) {
          out += 'validate.schema' + ($schemaPath);
        } else {
          out += '' + ($schema);
        }
        out += '         , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' } ';
    if ($breakOnError) {
      out += ' else { ';
    }
  } else {
    if ($breakOnError) {
      out += ' if (true) { ';
    }
  }
  return out;
}

},{}],36:[function(require,module,exports){
'use strict';
module.exports = function generate_validate(it, $keyword) {
  var out = '';
  var $async = it.schema.$async === true;
  if (it.isTop) {
    var $top = it.isTop,
      $lvl = it.level = 0,
      $dataLvl = it.dataLevel = 0,
      $data = 'data';
    it.rootId = it.resolve.fullPath(it.root.schema.id);
    it.baseId = it.baseId || it.rootId;
    if ($async) {
      it.async = true;
      var $es7 = it.opts.async == 'es7';
      it.yieldAwait = $es7 ? 'await' : 'yield';
    }
    delete it.isTop;
    it.dataPathArr = [undefined];
    out += ' var validate = ';
    if ($async) {
      if ($es7) {
        out += ' (async function ';
      } else {
        if (it.opts.async == 'co*') {
          out += 'co.wrap';
        }
        out += '(function* ';
      }
    } else {
      out += ' (function ';
    }
    out += ' (data, dataPath, parentData, parentDataProperty, rootData) { \'use strict\'; var vErrors = null; ';
    out += ' var errors = 0;     ';
    out += ' if (rootData === undefined) rootData = data;';
  } else {
    var $lvl = it.level,
      $dataLvl = it.dataLevel,
      $data = 'data' + ($dataLvl || '');
    if (it.schema.id) it.baseId = it.resolve.url(it.baseId, it.schema.id);
    if ($async && !it.async) throw new Error('async schema in sync schema');
    out += ' var errs_' + ($lvl) + ' = errors;';
  }
  var $valid = 'valid' + $lvl,
    $breakOnError = !it.opts.allErrors,
    $closingBraces1 = '',
    $closingBraces2 = '',
    $errorKeyword;
  var $typeSchema = it.schema.type,
    $typeIsArray = Array.isArray($typeSchema);
  if ($typeSchema && it.opts.coerceTypes) {
    var $coerceToTypes = it.util.coerceToTypes(it.opts.coerceTypes, $typeSchema);
    if ($coerceToTypes) {
      var $schemaPath = it.schemaPath + '.type',
        $errSchemaPath = it.errSchemaPath + '/type',
        $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
      out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') {  ';
      var $dataType = 'dataType' + $lvl,
        $coerced = 'coerced' + $lvl;
      out += ' var ' + ($dataType) + ' = typeof ' + ($data) + '; ';
      if (it.opts.coerceTypes == 'array') {
        out += ' if (' + ($dataType) + ' == \'object\' && Array.isArray(' + ($data) + ')) ' + ($dataType) + ' = \'array\'; ';
      }
      out += ' var ' + ($coerced) + ' = undefined; ';
      var $bracesCoercion = '';
      var arr1 = $coerceToTypes;
      if (arr1) {
        var $type, $i = -1,
          l1 = arr1.length - 1;
        while ($i < l1) {
          $type = arr1[$i += 1];
          if ($i) {
            out += ' if (' + ($coerced) + ' === undefined) { ';
            $bracesCoercion += '}';
          }
          if (it.opts.coerceTypes == 'array' && $type != 'array') {
            out += ' if (' + ($dataType) + ' == \'array\' && ' + ($data) + '.length == 1) { ' + ($coerced) + ' = ' + ($data) + ' = ' + ($data) + '[0]; ' + ($dataType) + ' = typeof ' + ($data) + ';  } ';
          }
          if ($type == 'string') {
            out += ' if (' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\') ' + ($coerced) + ' = \'\' + ' + ($data) + '; else if (' + ($data) + ' === null) ' + ($coerced) + ' = \'\'; ';
          } else if ($type == 'number' || $type == 'integer') {
            out += ' if (' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' === null || (' + ($dataType) + ' == \'string\' && ' + ($data) + ' && ' + ($data) + ' == +' + ($data) + ' ';
            if ($type == 'integer') {
              out += ' && !(' + ($data) + ' % 1)';
            }
            out += ')) ' + ($coerced) + ' = +' + ($data) + '; ';
          } else if ($type == 'boolean') {
            out += ' if (' + ($data) + ' === \'false\' || ' + ($data) + ' === 0 || ' + ($data) + ' === null) ' + ($coerced) + ' = false; else if (' + ($data) + ' === \'true\' || ' + ($data) + ' === 1) ' + ($coerced) + ' = true; ';
          } else if ($type == 'null') {
            out += ' if (' + ($data) + ' === \'\' || ' + ($data) + ' === 0 || ' + ($data) + ' === false) ' + ($coerced) + ' = null; ';
          } else if (it.opts.coerceTypes == 'array' && $type == 'array') {
            out += ' if (' + ($dataType) + ' == \'string\' || ' + ($dataType) + ' == \'number\' || ' + ($dataType) + ' == \'boolean\' || ' + ($data) + ' == null) ' + ($coerced) + ' = [' + ($data) + ']; ';
          }
        }
      }
      out += ' ' + ($bracesCoercion) + ' if (' + ($coerced) + ' === undefined) {   ';
      var $$outStack = $$outStack || [];
      $$outStack.push(out);
      out = ''; /* istanbul ignore else */
      if (it.createErrors !== false) {
        out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
        if ($typeIsArray) {
          out += '' + ($typeSchema.join(","));
        } else {
          out += '' + ($typeSchema);
        }
        out += '\' } ';
        if (it.opts.messages !== false) {
          out += ' , message: \'should be ';
          if ($typeIsArray) {
            out += '' + ($typeSchema.join(","));
          } else {
            out += '' + ($typeSchema);
          }
          out += '\' ';
        }
        if (it.opts.verbose) {
          out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
        }
        out += ' } ';
      } else {
        out += ' {} ';
      }
      var __err = out;
      out = $$outStack.pop();
      if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
        if (it.async) {
          out += ' throw new ValidationError([' + (__err) + ']); ';
        } else {
          out += ' validate.errors = [' + (__err) + ']; return false; ';
        }
      } else {
        out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
      }
      out += ' } else { ';
      if ($dataLvl) {
        var $parentData = 'data' + (($dataLvl - 1) || ''),
          $dataProperty = it.dataPathArr[$dataLvl];
        out += ' ' + ($data) + ' = ' + ($parentData) + '[' + ($dataProperty) + '] = ' + ($coerced) + '; ';
      } else {
        out += ' data = ' + ($coerced) + '; if (parentData !== undefined) parentData[parentDataProperty] = ' + ($coerced) + '; ';
      }
      out += ' } } ';
    }
  }
  var $refKeywords;
  if (it.schema.$ref && ($refKeywords = it.util.schemaHasRulesExcept(it.schema, it.RULES.all, '$ref'))) {
    if (it.opts.extendRefs == 'fail') {
      throw new Error('$ref: validation keywords used in schema at path "' + it.errSchemaPath + '"');
    } else if (it.opts.extendRefs == 'ignore') {
      $refKeywords = false;
      console.log('$ref: keywords ignored in schema at path "' + it.errSchemaPath + '"');
    } else if (it.opts.extendRefs !== true) {
      console.log('$ref: all keywords used in schema at path "' + it.errSchemaPath + '". It will change in the next major version, see issue #260. Use option { extendRefs: true } to keep current behaviour');
    }
  }
  if (it.schema.$ref && !$refKeywords) {
    out += ' ' + (it.RULES.all.$ref.code(it, '$ref')) + ' ';
    if ($breakOnError) {
      out += ' } if (errors === ';
      if ($top) {
        out += '0';
      } else {
        out += 'errs_' + ($lvl);
      }
      out += ') { ';
      $closingBraces2 += '}';
    }
  } else {
    var arr2 = it.RULES;
    if (arr2) {
      var $rulesGroup, i2 = -1,
        l2 = arr2.length - 1;
      while (i2 < l2) {
        $rulesGroup = arr2[i2 += 1];
        if ($shouldUseGroup($rulesGroup)) {
          if ($rulesGroup.type) {
            out += ' if (' + (it.util.checkDataType($rulesGroup.type, $data)) + ') { ';
          }
          if (it.opts.useDefaults && !it.compositeRule) {
            if ($rulesGroup.type == 'object' && it.schema.properties) {
              var $schema = it.schema.properties,
                $schemaKeys = Object.keys($schema);
              var arr3 = $schemaKeys;
              if (arr3) {
                var $propertyKey, i3 = -1,
                  l3 = arr3.length - 1;
                while (i3 < l3) {
                  $propertyKey = arr3[i3 += 1];
                  var $sch = $schema[$propertyKey];
                  if ($sch.default !== undefined) {
                    var $passData = $data + it.util.getProperty($propertyKey);
                    out += '  if (' + ($passData) + ' === undefined) ' + ($passData) + ' = ';
                    if (it.opts.useDefaults == 'shared') {
                      out += ' ' + (it.useDefault($sch.default)) + ' ';
                    } else {
                      out += ' ' + (JSON.stringify($sch.default)) + ' ';
                    }
                    out += '; ';
                  }
                }
              }
            } else if ($rulesGroup.type == 'array' && Array.isArray(it.schema.items)) {
              var arr4 = it.schema.items;
              if (arr4) {
                var $sch, $i = -1,
                  l4 = arr4.length - 1;
                while ($i < l4) {
                  $sch = arr4[$i += 1];
                  if ($sch.default !== undefined) {
                    var $passData = $data + '[' + $i + ']';
                    out += '  if (' + ($passData) + ' === undefined) ' + ($passData) + ' = ';
                    if (it.opts.useDefaults == 'shared') {
                      out += ' ' + (it.useDefault($sch.default)) + ' ';
                    } else {
                      out += ' ' + (JSON.stringify($sch.default)) + ' ';
                    }
                    out += '; ';
                  }
                }
              }
            }
          }
          var arr5 = $rulesGroup.rules;
          if (arr5) {
            var $rule, i5 = -1,
              l5 = arr5.length - 1;
            while (i5 < l5) {
              $rule = arr5[i5 += 1];
              if ($shouldUseRule($rule)) {
                out += ' ' + ($rule.code(it, $rule.keyword)) + ' ';
                if ($breakOnError) {
                  $closingBraces1 += '}';
                }
              }
            }
          }
          if ($breakOnError) {
            out += ' ' + ($closingBraces1) + ' ';
            $closingBraces1 = '';
          }
          if ($rulesGroup.type) {
            out += ' } ';
            if ($typeSchema && $typeSchema === $rulesGroup.type) {
              var $typeChecked = true;
              out += ' else { ';
              var $schemaPath = it.schemaPath + '.type',
                $errSchemaPath = it.errSchemaPath + '/type';
              var $$outStack = $$outStack || [];
              $$outStack.push(out);
              out = ''; /* istanbul ignore else */
              if (it.createErrors !== false) {
                out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
                if ($typeIsArray) {
                  out += '' + ($typeSchema.join(","));
                } else {
                  out += '' + ($typeSchema);
                }
                out += '\' } ';
                if (it.opts.messages !== false) {
                  out += ' , message: \'should be ';
                  if ($typeIsArray) {
                    out += '' + ($typeSchema.join(","));
                  } else {
                    out += '' + ($typeSchema);
                  }
                  out += '\' ';
                }
                if (it.opts.verbose) {
                  out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
                }
                out += ' } ';
              } else {
                out += ' {} ';
              }
              var __err = out;
              out = $$outStack.pop();
              if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
                if (it.async) {
                  out += ' throw new ValidationError([' + (__err) + ']); ';
                } else {
                  out += ' validate.errors = [' + (__err) + ']; return false; ';
                }
              } else {
                out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
              }
              out += ' } ';
            }
          }
          if ($breakOnError) {
            out += ' if (errors === ';
            if ($top) {
              out += '0';
            } else {
              out += 'errs_' + ($lvl);
            }
            out += ') { ';
            $closingBraces2 += '}';
          }
        }
      }
    }
  }
  if ($typeSchema && !$typeChecked && !(it.opts.coerceTypes && $coerceToTypes)) {
    var $schemaPath = it.schemaPath + '.type',
      $errSchemaPath = it.errSchemaPath + '/type',
      $method = $typeIsArray ? 'checkDataTypes' : 'checkDataType';
    out += ' if (' + (it.util[$method]($typeSchema, $data, true)) + ') {   ';
    var $$outStack = $$outStack || [];
    $$outStack.push(out);
    out = ''; /* istanbul ignore else */
    if (it.createErrors !== false) {
      out += ' { keyword: \'' + ($errorKeyword || 'type') + '\' , dataPath: (dataPath || \'\') + ' + (it.errorPath) + ' , schemaPath: ' + (it.util.toQuotedString($errSchemaPath)) + ' , params: { type: \'';
      if ($typeIsArray) {
        out += '' + ($typeSchema.join(","));
      } else {
        out += '' + ($typeSchema);
      }
      out += '\' } ';
      if (it.opts.messages !== false) {
        out += ' , message: \'should be ';
        if ($typeIsArray) {
          out += '' + ($typeSchema.join(","));
        } else {
          out += '' + ($typeSchema);
        }
        out += '\' ';
      }
      if (it.opts.verbose) {
        out += ' , schema: validate.schema' + ($schemaPath) + ' , parentSchema: validate.schema' + (it.schemaPath) + ' , data: ' + ($data) + ' ';
      }
      out += ' } ';
    } else {
      out += ' {} ';
    }
    var __err = out;
    out = $$outStack.pop();
    if (!it.compositeRule && $breakOnError) { /* istanbul ignore if */
      if (it.async) {
        out += ' throw new ValidationError([' + (__err) + ']); ';
      } else {
        out += ' validate.errors = [' + (__err) + ']; return false; ';
      }
    } else {
      out += ' var err = ' + (__err) + ';  if (vErrors === null) vErrors = [err]; else vErrors.push(err); errors++; ';
    }
    out += ' }';
  }
  if ($breakOnError) {
    out += ' ' + ($closingBraces2) + ' ';
  }
  if ($top) {
    if ($async) {
      out += ' if (errors === 0) return true;           ';
      out += ' else throw new ValidationError(vErrors); ';
    } else {
      out += ' validate.errors = vErrors; ';
      out += ' return errors === 0;       ';
    }
    out += ' }); return validate;';
  } else {
    out += ' var ' + ($valid) + ' = errors === errs_' + ($lvl) + ';';
  }
  out = it.util.cleanUpCode(out);
  if ($top && $breakOnError) {
    out = it.util.cleanUpVarErrors(out, $async);
  }

  function $shouldUseGroup($rulesGroup) {
    for (var i = 0; i < $rulesGroup.rules.length; i++)
      if ($shouldUseRule($rulesGroup.rules[i])) return true;
  }

  function $shouldUseRule($rule) {
    return it.schema[$rule.keyword] !== undefined || ($rule.keyword == 'properties' && (it.schema.additionalProperties === false || typeof it.schema.additionalProperties == 'object' || (it.schema.patternProperties && Object.keys(it.schema.patternProperties).length) || (it.opts.v5 && it.schema.patternGroups && Object.keys(it.schema.patternGroups).length)));
  }
  return out;
}

},{}],37:[function(require,module,exports){
'use strict';

var IDENTIFIER = /^[a-z_$][a-z0-9_$\-]*$/i;
var customRuleCode = require('./dotjs/custom');

module.exports = {
  add: addKeyword,
  get: getKeyword,
  remove: removeKeyword
};

/**
 * Define custom keyword
 * @this  Ajv
 * @param {String} keyword custom keyword, should be unique (including different from all standard, custom and macro keywords).
 * @param {Object} definition keyword definition object with properties `type` (type(s) which the keyword applies to), `validate` or `compile`.
 */
function addKeyword(keyword, definition) {
  /* jshint validthis: true */
  /* eslint no-shadow: 0 */
  var RULES = this.RULES;

  if (RULES.keywords[keyword])
    throw new Error('Keyword ' + keyword + ' is already defined');

  if (!IDENTIFIER.test(keyword))
    throw new Error('Keyword ' + keyword + ' is not a valid identifier');

  if (definition) {
    var dataType = definition.type;
    if (Array.isArray(dataType)) {
      var i, len = dataType.length;
      for (i=0; i<len; i++) checkDataType(dataType[i]);
      for (i=0; i<len; i++) _addRule(keyword, dataType[i], definition);
    } else {
      if (dataType) checkDataType(dataType);
      _addRule(keyword, dataType, definition);
    }

    var $data = definition.$data === true && this._opts.v5;
    if ($data && !definition.validate)
      throw new Error('$data support: "validate" function is not defined');

    var metaSchema = definition.metaSchema;
    if (metaSchema) {
      if ($data) {
        metaSchema = {
          anyOf: [
            metaSchema,
            { '$ref': 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#/definitions/$data' }
          ]
        };
      }
      definition.validateSchema = this.compile(metaSchema, true);
    }
  }

  RULES.keywords[keyword] = RULES.all[keyword] = true;


  function _addRule(keyword, dataType, definition) {
    var ruleGroup;
    for (var i=0; i<RULES.length; i++) {
      var rg = RULES[i];
      if (rg.type == dataType) {
        ruleGroup = rg;
        break;
      }
    }

    if (!ruleGroup) {
      ruleGroup = { type: dataType, rules: [] };
      RULES.push(ruleGroup);
    }

    var rule = {
      keyword: keyword,
      definition: definition,
      custom: true,
      code: customRuleCode
    };
    ruleGroup.rules.push(rule);
    RULES.custom[keyword] = rule;
  }


  function checkDataType(dataType) {
    if (!RULES.types[dataType]) throw new Error('Unknown type ' + dataType);
  }
}


/**
 * Get keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 * @return {Object|Boolean} custom keyword definition, `true` if it is a predefined keyword, `false` otherwise.
 */
function getKeyword(keyword) {
  /* jshint validthis: true */
  var rule = this.RULES.custom[keyword];
  return rule ? rule.definition : this.RULES.keywords[keyword] || false;
}


/**
 * Remove keyword
 * @this  Ajv
 * @param {String} keyword pre-defined or custom keyword.
 */
function removeKeyword(keyword) {
  /* jshint validthis: true */
  var RULES = this.RULES;
  delete RULES.keywords[keyword];
  delete RULES.all[keyword];
  delete RULES.custom[keyword];
  for (var i=0; i<RULES.length; i++) {
    var rules = RULES[i].rules;
    for (var j=0; j<rules.length; j++) {
      if (rules[j].keyword == keyword) {
        rules.splice(j, 1);
        break;
      }
    }
  }
}

},{"./dotjs/custom":21}],38:[function(require,module,exports){
module.exports={
    "id": "http://json-schema.org/draft-04/schema#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "Core schema meta-schema",
    "definitions": {
        "schemaArray": {
            "type": "array",
            "minItems": 1,
            "items": { "$ref": "#" }
        },
        "positiveInteger": {
            "type": "integer",
            "minimum": 0
        },
        "positiveIntegerDefault0": {
            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]
        },
        "simpleTypes": {
            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]
        },
        "stringArray": {
            "type": "array",
            "items": { "type": "string" },
            "minItems": 1,
            "uniqueItems": true
        }
    },
    "type": "object",
    "properties": {
        "id": {
            "type": "string",
            "format": "uri"
        },
        "$schema": {
            "type": "string",
            "format": "uri"
        },
        "title": {
            "type": "string"
        },
        "description": {
            "type": "string"
        },
        "default": {},
        "multipleOf": {
            "type": "number",
            "minimum": 0,
            "exclusiveMinimum": true
        },
        "maximum": {
            "type": "number"
        },
        "exclusiveMaximum": {
            "type": "boolean",
            "default": false
        },
        "minimum": {
            "type": "number"
        },
        "exclusiveMinimum": {
            "type": "boolean",
            "default": false
        },
        "maxLength": { "$ref": "#/definitions/positiveInteger" },
        "minLength": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "pattern": {
            "type": "string",
            "format": "regex"
        },
        "additionalItems": {
            "anyOf": [
                { "type": "boolean" },
                { "$ref": "#" }
            ],
            "default": {}
        },
        "items": {
            "anyOf": [
                { "$ref": "#" },
                { "$ref": "#/definitions/schemaArray" }
            ],
            "default": {}
        },
        "maxItems": { "$ref": "#/definitions/positiveInteger" },
        "minItems": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "uniqueItems": {
            "type": "boolean",
            "default": false
        },
        "maxProperties": { "$ref": "#/definitions/positiveInteger" },
        "minProperties": { "$ref": "#/definitions/positiveIntegerDefault0" },
        "required": { "$ref": "#/definitions/stringArray" },
        "additionalProperties": {
            "anyOf": [
                { "type": "boolean" },
                { "$ref": "#" }
            ],
            "default": {}
        },
        "definitions": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "properties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "patternProperties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "dependencies": {
            "type": "object",
            "additionalProperties": {
                "anyOf": [
                    { "$ref": "#" },
                    { "$ref": "#/definitions/stringArray" }
                ]
            }
        },
        "enum": {
            "type": "array",
            "minItems": 1,
            "uniqueItems": true
        },
        "type": {
            "anyOf": [
                { "$ref": "#/definitions/simpleTypes" },
                {
                    "type": "array",
                    "items": { "$ref": "#/definitions/simpleTypes" },
                    "minItems": 1,
                    "uniqueItems": true
                }
            ]
        },
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" }
    },
    "dependencies": {
        "exclusiveMaximum": [ "maximum" ],
        "exclusiveMinimum": [ "minimum" ]
    },
    "default": {}
}

},{}],39:[function(require,module,exports){
module.exports={
    "id": "https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json#",
    "$schema": "http://json-schema.org/draft-04/schema#",
    "description": "Core schema meta-schema (v5 proposals)",
    "definitions": {
        "schemaArray": {
            "type": "array",
            "minItems": 1,
            "items": { "$ref": "#" }
        },
        "positiveInteger": {
            "type": "integer",
            "minimum": 0
        },
        "positiveIntegerDefault0": {
            "allOf": [ { "$ref": "#/definitions/positiveInteger" }, { "default": 0 } ]
        },
        "simpleTypes": {
            "enum": [ "array", "boolean", "integer", "null", "number", "object", "string" ]
        },
        "stringArray": {
            "type": "array",
            "items": { "type": "string" },
            "minItems": 1,
            "uniqueItems": true
        },
        "$data": {
            "type": "object",
            "required": [ "$data" ],
            "properties": {
                "$data": {
                    "type": "string",
                    "anyOf": [
                        { "format": "relative-json-pointer" }, 
                        { "format": "json-pointer" }
                    ]
                }
            },
            "additionalProperties": false
        }
    },
    "type": "object",
    "properties": {
        "id": {
            "type": "string",
            "format": "uri"
        },
        "$schema": {
            "type": "string",
            "format": "uri"
        },
        "title": {
            "type": "string"
        },
        "description": {
            "type": "string"
        },
        "default": {},
        "multipleOf": {
            "anyOf": [
                {
                    "type": "number",
                    "minimum": 0,
                    "exclusiveMinimum": true
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "maximum": {
            "anyOf": [
                { "type": "number" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "exclusiveMaximum": {
            "anyOf": [
                {
                    "type": "boolean",
                    "default": false
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "minimum": {
            "anyOf": [
                { "type": "number" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "exclusiveMinimum": {
            "anyOf": [
                {
                    "type": "boolean",
                    "default": false
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "maxLength": {
            "anyOf": [
                { "$ref": "#/definitions/positiveInteger" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "minLength": {
            "anyOf": [
                { "$ref": "#/definitions/positiveIntegerDefault0" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "pattern": {
            "anyOf": [
                {
                    "type": "string",
                    "format": "regex"
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "additionalItems": {
            "anyOf": [
                { "type": "boolean" },
                { "$ref": "#" },
                { "$ref": "#/definitions/$data" }
            ],
            "default": {}
        },
        "items": {
            "anyOf": [
                { "$ref": "#" },
                { "$ref": "#/definitions/schemaArray" }
            ],
            "default": {}
        },
        "maxItems": {
            "anyOf": [
                { "$ref": "#/definitions/positiveInteger" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "minItems": {
            "anyOf": [
                { "$ref": "#/definitions/positiveIntegerDefault0" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "uniqueItems": {
            "anyOf": [
                {
                    "type": "boolean",
                    "default": false
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "maxProperties": {
            "anyOf": [
                { "$ref": "#/definitions/positiveInteger" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "minProperties": {
            "anyOf": [
                { "$ref": "#/definitions/positiveIntegerDefault0" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "required": {
            "anyOf": [
                { "$ref": "#/definitions/stringArray" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "additionalProperties": {
            "anyOf": [
                { "type": "boolean" },
                { "$ref": "#" },
                { "$ref": "#/definitions/$data" }
            ],
            "default": {}
        },
        "definitions": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "properties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "patternProperties": {
            "type": "object",
            "additionalProperties": { "$ref": "#" },
            "default": {}
        },
        "dependencies": {
            "type": "object",
            "additionalProperties": {
                "anyOf": [
                    { "$ref": "#" },
                    { "$ref": "#/definitions/stringArray" }
                ]
            }
        },
        "enum": {
            "anyOf": [
                {
                    "type": "array",
                    "minItems": 1,
                    "uniqueItems": true
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "type": {
            "anyOf": [
                { "$ref": "#/definitions/simpleTypes" },
                {
                    "type": "array",
                    "items": { "$ref": "#/definitions/simpleTypes" },
                    "minItems": 1,
                    "uniqueItems": true
                }
            ]
        },
        "allOf": { "$ref": "#/definitions/schemaArray" },
        "anyOf": { "$ref": "#/definitions/schemaArray" },
        "oneOf": { "$ref": "#/definitions/schemaArray" },
        "not": { "$ref": "#" },
        "format": {
            "anyOf": [
                { "type": "string" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "formatMaximum": {
            "anyOf": [
                { "type": "string" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "formatMinimum": {
            "anyOf": [
                { "type": "string" },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "formatExclusiveMaximum": {
            "anyOf": [
                {
                    "type": "boolean",
                    "default": false
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "formatExclusiveMinimum": {
            "anyOf": [
                {
                    "type": "boolean",
                    "default": false
                },
                { "$ref": "#/definitions/$data" }
            ]
        },
        "constant": {
            "anyOf": [
                {},
                { "$ref": "#/definitions/$data" }
            ]
        },
        "contains": { "$ref": "#" },
        "patternGroups": {
            "type": "object",
            "additionalProperties": {
                "type": "object",
                "required": [ "schema" ],
                "properties": {
                    "maximum": {
                        "anyOf": [
                            { "$ref": "#/definitions/positiveInteger" },
                            { "$ref": "#/definitions/$data" }
                        ]
                    },
                    "minimum": {
                        "anyOf": [
                            { "$ref": "#/definitions/positiveIntegerDefault0" },
                            { "$ref": "#/definitions/$data" }
                        ]
                    },
                    "schema": { "$ref": "#" }
                },
                "additionalProperties": false
            },
            "default": {}
        },
        "switch": {
            "type": "array",
            "items": {
                "required": [ "then" ],
                "properties": {
                    "if": { "$ref": "#" },
                    "then": {
                        "anyOf": [
                            { "type": "boolean" },
                            { "$ref": "#" }
                        ]
                    },
                    "continue": { "type": "boolean" }
                },
                "additionalProperties": false,
                "dependencies": {
                    "continue": [ "if" ]
                }
            }
        }
    },
    "dependencies": {
        "exclusiveMaximum": [ "maximum" ],
        "exclusiveMinimum": [ "minimum" ],
        "formatMaximum": [ "format" ],
        "formatMinimum": [ "format" ],
        "formatExclusiveMaximum": [ "formatMaximum" ],
        "formatExclusiveMinimum": [ "formatMinimum" ]
    },
    "default": {}
}

},{}],40:[function(require,module,exports){
'use strict';

var META_SCHEMA_ID = 'https://raw.githubusercontent.com/epoberezkin/ajv/master/lib/refs/json-schema-v5.json';

module.exports = {
  enable: enableV5,
  META_SCHEMA_ID: META_SCHEMA_ID
};


function enableV5(ajv) {
  var inlineFunctions = {
    'switch': require('./dotjs/switch'),
    'constant': require('./dotjs/constant'),
    '_formatLimit': require('./dotjs/_formatLimit'),
    'patternRequired': require('./dotjs/patternRequired')
  };

  if (ajv._opts.meta !== false) {
    var metaSchema = require('./refs/json-schema-v5.json');
    ajv.addMetaSchema(metaSchema, META_SCHEMA_ID);
  }
  _addKeyword('constant');
  ajv.addKeyword('contains', { type: 'array', macro: containsMacro });

  _addKeyword('formatMaximum', 'string', inlineFunctions._formatLimit);
  _addKeyword('formatMinimum', 'string', inlineFunctions._formatLimit);
  ajv.addKeyword('formatExclusiveMaximum');
  ajv.addKeyword('formatExclusiveMinimum');

  ajv.addKeyword('patternGroups'); // implemented in properties.jst
  _addKeyword('patternRequired', 'object');
  _addKeyword('switch');


  function _addKeyword(keyword, types, inlineFunc) {
    var definition = {
      inline: inlineFunc || inlineFunctions[keyword],
      statements: true,
      errors: 'full'
    };
    if (types) definition.type = types;
    ajv.addKeyword(keyword, definition);
  }
}


function containsMacro(schema) {
  return {
    not: { items: { not: schema } }
  };
}

},{"./dotjs/_formatLimit":13,"./dotjs/constant":20,"./dotjs/patternRequired":30,"./dotjs/switch":34,"./refs/json-schema-v5.json":39}],41:[function(require,module,exports){
(function (global){
/*! https://mths.be/punycode v1.4.1 by @mathias */
;(function(root) {

	/** Detect free variables */
	var freeExports = typeof exports == 'object' && exports &&
		!exports.nodeType && exports;
	var freeModule = typeof module == 'object' && module &&
		!module.nodeType && module;
	var freeGlobal = typeof global == 'object' && global;
	if (
		freeGlobal.global === freeGlobal ||
		freeGlobal.window === freeGlobal ||
		freeGlobal.self === freeGlobal
	) {
		root = freeGlobal;
	}

	/**
	 * The `punycode` object.
	 * @name punycode
	 * @type Object
	 */
	var punycode,

	/** Highest positive signed 32-bit float value */
	maxInt = 2147483647, // aka. 0x7FFFFFFF or 2^31-1

	/** Bootstring parameters */
	base = 36,
	tMin = 1,
	tMax = 26,
	skew = 38,
	damp = 700,
	initialBias = 72,
	initialN = 128, // 0x80
	delimiter = '-', // '\x2D'

	/** Regular expressions */
	regexPunycode = /^xn--/,
	regexNonASCII = /[^\x20-\x7E]/, // unprintable ASCII chars + non-ASCII chars
	regexSeparators = /[\x2E\u3002\uFF0E\uFF61]/g, // RFC 3490 separators

	/** Error messages */
	errors = {
		'overflow': 'Overflow: input needs wider integers to process',
		'not-basic': 'Illegal input >= 0x80 (not a basic code point)',
		'invalid-input': 'Invalid input'
	},

	/** Convenience shortcuts */
	baseMinusTMin = base - tMin,
	floor = Math.floor,
	stringFromCharCode = String.fromCharCode,

	/** Temporary variable */
	key;

	/*--------------------------------------------------------------------------*/

	/**
	 * A generic error utility function.
	 * @private
	 * @param {String} type The error type.
	 * @returns {Error} Throws a `RangeError` with the applicable error message.
	 */
	function error(type) {
		throw new RangeError(errors[type]);
	}

	/**
	 * A generic `Array#map` utility function.
	 * @private
	 * @param {Array} array The array to iterate over.
	 * @param {Function} callback The function that gets called for every array
	 * item.
	 * @returns {Array} A new array of values returned by the callback function.
	 */
	function map(array, fn) {
		var length = array.length;
		var result = [];
		while (length--) {
			result[length] = fn(array[length]);
		}
		return result;
	}

	/**
	 * A simple `Array#map`-like wrapper to work with domain name strings or email
	 * addresses.
	 * @private
	 * @param {String} domain The domain name or email address.
	 * @param {Function} callback The function that gets called for every
	 * character.
	 * @returns {Array} A new string of characters returned by the callback
	 * function.
	 */
	function mapDomain(string, fn) {
		var parts = string.split('@');
		var result = '';
		if (parts.length > 1) {
			// In email addresses, only the domain name should be punycoded. Leave
			// the local part (i.e. everything up to `@`) intact.
			result = parts[0] + '@';
			string = parts[1];
		}
		// Avoid `split(regex)` for IE8 compatibility. See #17.
		string = string.replace(regexSeparators, '\x2E');
		var labels = string.split('.');
		var encoded = map(labels, fn).join('.');
		return result + encoded;
	}

	/**
	 * Creates an array containing the numeric code points of each Unicode
	 * character in the string. While JavaScript uses UCS-2 internally,
	 * this function will convert a pair of surrogate halves (each of which
	 * UCS-2 exposes as separate characters) into a single code point,
	 * matching UTF-16.
	 * @see `punycode.ucs2.encode`
	 * @see <https://mathiasbynens.be/notes/javascript-encoding>
	 * @memberOf punycode.ucs2
	 * @name decode
	 * @param {String} string The Unicode input string (UCS-2).
	 * @returns {Array} The new array of code points.
	 */
	function ucs2decode(string) {
		var output = [],
		    counter = 0,
		    length = string.length,
		    value,
		    extra;
		while (counter < length) {
			value = string.charCodeAt(counter++);
			if (value >= 0xD800 && value <= 0xDBFF && counter < length) {
				// high surrogate, and there is a next character
				extra = string.charCodeAt(counter++);
				if ((extra & 0xFC00) == 0xDC00) { // low surrogate
					output.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);
				} else {
					// unmatched surrogate; only append this code unit, in case the next
					// code unit is the high surrogate of a surrogate pair
					output.push(value);
					counter--;
				}
			} else {
				output.push(value);
			}
		}
		return output;
	}

	/**
	 * Creates a string based on an array of numeric code points.
	 * @see `punycode.ucs2.decode`
	 * @memberOf punycode.ucs2
	 * @name encode
	 * @param {Array} codePoints The array of numeric code points.
	 * @returns {String} The new Unicode string (UCS-2).
	 */
	function ucs2encode(array) {
		return map(array, function(value) {
			var output = '';
			if (value > 0xFFFF) {
				value -= 0x10000;
				output += stringFromCharCode(value >>> 10 & 0x3FF | 0xD800);
				value = 0xDC00 | value & 0x3FF;
			}
			output += stringFromCharCode(value);
			return output;
		}).join('');
	}

	/**
	 * Converts a basic code point into a digit/integer.
	 * @see `digitToBasic()`
	 * @private
	 * @param {Number} codePoint The basic numeric code point value.
	 * @returns {Number} The numeric value of a basic code point (for use in
	 * representing integers) in the range `0` to `base - 1`, or `base` if
	 * the code point does not represent a value.
	 */
	function basicToDigit(codePoint) {
		if (codePoint - 48 < 10) {
			return codePoint - 22;
		}
		if (codePoint - 65 < 26) {
			return codePoint - 65;
		}
		if (codePoint - 97 < 26) {
			return codePoint - 97;
		}
		return base;
	}

	/**
	 * Converts a digit/integer into a basic code point.
	 * @see `basicToDigit()`
	 * @private
	 * @param {Number} digit The numeric value of a basic code point.
	 * @returns {Number} The basic code point whose value (when used for
	 * representing integers) is `digit`, which needs to be in the range
	 * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is
	 * used; else, the lowercase form is used. The behavior is undefined
	 * if `flag` is non-zero and `digit` has no uppercase form.
	 */
	function digitToBasic(digit, flag) {
		//  0..25 map to ASCII a..z or A..Z
		// 26..35 map to ASCII 0..9
		return digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);
	}

	/**
	 * Bias adaptation function as per section 3.4 of RFC 3492.
	 * https://tools.ietf.org/html/rfc3492#section-3.4
	 * @private
	 */
	function adapt(delta, numPoints, firstTime) {
		var k = 0;
		delta = firstTime ? floor(delta / damp) : delta >> 1;
		delta += floor(delta / numPoints);
		for (/* no initialization */; delta > baseMinusTMin * tMax >> 1; k += base) {
			delta = floor(delta / baseMinusTMin);
		}
		return floor(k + (baseMinusTMin + 1) * delta / (delta + skew));
	}

	/**
	 * Converts a Punycode string of ASCII-only symbols to a string of Unicode
	 * symbols.
	 * @memberOf punycode
	 * @param {String} input The Punycode string of ASCII-only symbols.
	 * @returns {String} The resulting string of Unicode symbols.
	 */
	function decode(input) {
		// Don't use UCS-2
		var output = [],
		    inputLength = input.length,
		    out,
		    i = 0,
		    n = initialN,
		    bias = initialBias,
		    basic,
		    j,
		    index,
		    oldi,
		    w,
		    k,
		    digit,
		    t,
		    /** Cached calculation results */
		    baseMinusT;

		// Handle the basic code points: let `basic` be the number of input code
		// points before the last delimiter, or `0` if there is none, then copy
		// the first basic code points to the output.

		basic = input.lastIndexOf(delimiter);
		if (basic < 0) {
			basic = 0;
		}

		for (j = 0; j < basic; ++j) {
			// if it's not a basic code point
			if (input.charCodeAt(j) >= 0x80) {
				error('not-basic');
			}
			output.push(input.charCodeAt(j));
		}

		// Main decoding loop: start just after the last delimiter if any basic code
		// points were copied; start at the beginning otherwise.

		for (index = basic > 0 ? basic + 1 : 0; index < inputLength; /* no final expression */) {

			// `index` is the index of the next character to be consumed.
			// Decode a generalized variable-length integer into `delta`,
			// which gets added to `i`. The overflow checking is easier
			// if we increase `i` as we go, then subtract off its starting
			// value at the end to obtain `delta`.
			for (oldi = i, w = 1, k = base; /* no condition */; k += base) {

				if (index >= inputLength) {
					error('invalid-input');
				}

				digit = basicToDigit(input.charCodeAt(index++));

				if (digit >= base || digit > floor((maxInt - i) / w)) {
					error('overflow');
				}

				i += digit * w;
				t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);

				if (digit < t) {
					break;
				}

				baseMinusT = base - t;
				if (w > floor(maxInt / baseMinusT)) {
					error('overflow');
				}

				w *= baseMinusT;

			}

			out = output.length + 1;
			bias = adapt(i - oldi, out, oldi == 0);

			// `i` was supposed to wrap around from `out` to `0`,
			// incrementing `n` each time, so we'll fix that now:
			if (floor(i / out) > maxInt - n) {
				error('overflow');
			}

			n += floor(i / out);
			i %= out;

			// Insert `n` at position `i` of the output
			output.splice(i++, 0, n);

		}

		return ucs2encode(output);
	}

	/**
	 * Converts a string of Unicode symbols (e.g. a domain name label) to a
	 * Punycode string of ASCII-only symbols.
	 * @memberOf punycode
	 * @param {String} input The string of Unicode symbols.
	 * @returns {String} The resulting Punycode string of ASCII-only symbols.
	 */
	function encode(input) {
		var n,
		    delta,
		    handledCPCount,
		    basicLength,
		    bias,
		    j,
		    m,
		    q,
		    k,
		    t,
		    currentValue,
		    output = [],
		    /** `inputLength` will hold the number of code points in `input`. */
		    inputLength,
		    /** Cached calculation results */
		    handledCPCountPlusOne,
		    baseMinusT,
		    qMinusT;

		// Convert the input in UCS-2 to Unicode
		input = ucs2decode(input);

		// Cache the length
		inputLength = input.length;

		// Initialize the state
		n = initialN;
		delta = 0;
		bias = initialBias;

		// Handle the basic code points
		for (j = 0; j < inputLength; ++j) {
			currentValue = input[j];
			if (currentValue < 0x80) {
				output.push(stringFromCharCode(currentValue));
			}
		}

		handledCPCount = basicLength = output.length;

		// `handledCPCount` is the number of code points that have been handled;
		// `basicLength` is the number of basic code points.

		// Finish the basic string - if it is not empty - with a delimiter
		if (basicLength) {
			output.push(delimiter);
		}

		// Main encoding loop:
		while (handledCPCount < inputLength) {

			// All non-basic code points < n have been handled already. Find the next
			// larger one:
			for (m = maxInt, j = 0; j < inputLength; ++j) {
				currentValue = input[j];
				if (currentValue >= n && currentValue < m) {
					m = currentValue;
				}
			}

			// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,
			// but guard against overflow
			handledCPCountPlusOne = handledCPCount + 1;
			if (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {
				error('overflow');
			}

			delta += (m - n) * handledCPCountPlusOne;
			n = m;

			for (j = 0; j < inputLength; ++j) {
				currentValue = input[j];

				if (currentValue < n && ++delta > maxInt) {
					error('overflow');
				}

				if (currentValue == n) {
					// Represent delta as a generalized variable-length integer
					for (q = delta, k = base; /* no condition */; k += base) {
						t = k <= bias ? tMin : (k >= bias + tMax ? tMax : k - bias);
						if (q < t) {
							break;
						}
						qMinusT = q - t;
						baseMinusT = base - t;
						output.push(
							stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0))
						);
						q = floor(qMinusT / baseMinusT);
					}

					output.push(stringFromCharCode(digitToBasic(q, 0)));
					bias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);
					delta = 0;
					++handledCPCount;
				}
			}

			++delta;
			++n;

		}
		return output.join('');
	}

	/**
	 * Converts a Punycode string representing a domain name or an email address
	 * to Unicode. Only the Punycoded parts of the input will be converted, i.e.
	 * it doesn't matter if you call it on a string that has already been
	 * converted to Unicode.
	 * @memberOf punycode
	 * @param {String} input The Punycoded domain name or email address to
	 * convert to Unicode.
	 * @returns {String} The Unicode representation of the given Punycode
	 * string.
	 */
	function toUnicode(input) {
		return mapDomain(input, function(string) {
			return regexPunycode.test(string)
				? decode(string.slice(4).toLowerCase())
				: string;
		});
	}

	/**
	 * Converts a Unicode string representing a domain name or an email address to
	 * Punycode. Only the non-ASCII parts of the domain name will be converted,
	 * i.e. it doesn't matter if you call it with a domain that's already in
	 * ASCII.
	 * @memberOf punycode
	 * @param {String} input The domain name or email address to convert, as a
	 * Unicode string.
	 * @returns {String} The Punycode representation of the given domain name or
	 * email address.
	 */
	function toASCII(input) {
		return mapDomain(input, function(string) {
			return regexNonASCII.test(string)
				? 'xn--' + encode(string)
				: string;
		});
	}

	/*--------------------------------------------------------------------------*/

	/** Define the public API */
	punycode = {
		/**
		 * A string representing the current Punycode.js version number.
		 * @memberOf punycode
		 * @type String
		 */
		'version': '1.4.1',
		/**
		 * An object of methods to convert from JavaScript's internal character
		 * representation (UCS-2) to Unicode code points, and back.
		 * @see <https://mathiasbynens.be/notes/javascript-encoding>
		 * @memberOf punycode
		 * @type Object
		 */
		'ucs2': {
			'decode': ucs2decode,
			'encode': ucs2encode
		},
		'decode': decode,
		'encode': encode,
		'toASCII': toASCII,
		'toUnicode': toUnicode
	};

	/** Expose `punycode` */
	// Some AMD build optimizers, like r.js, check for specific condition patterns
	// like the following:
	if (
		typeof define == 'function' &&
		typeof define.amd == 'object' &&
		define.amd
	) {
		define('punycode', function() {
			return punycode;
		});
	} else if (freeExports && freeModule) {
		if (module.exports == freeExports) {
			// in Node.js, io.js, or RingoJS v0.8.0+
			freeModule.exports = punycode;
		} else {
			// in Narwhal or RingoJS v0.7.0-
			for (key in punycode) {
				punycode.hasOwnProperty(key) && (freeExports[key] = punycode[key]);
			}
		}
	} else {
		// in Rhino or a web browser
		root.punycode = punycode;
	}

}(this));

}).call(this,typeof global !== "undefined" ? global : typeof self !== "undefined" ? self : typeof window !== "undefined" ? window : {})
},{}],42:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

// If obj.hasOwnProperty has been overridden, then calling
// obj.hasOwnProperty(prop) will break.
// See: https://github.com/joyent/node/issues/1707
function hasOwnProperty(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
}

module.exports = function(qs, sep, eq, options) {
  sep = sep || '&';
  eq = eq || '=';
  var obj = {};

  if (typeof qs !== 'string' || qs.length === 0) {
    return obj;
  }

  var regexp = /\+/g;
  qs = qs.split(sep);

  var maxKeys = 1000;
  if (options && typeof options.maxKeys === 'number') {
    maxKeys = options.maxKeys;
  }

  var len = qs.length;
  // maxKeys <= 0 means that we should not limit keys count
  if (maxKeys > 0 && len > maxKeys) {
    len = maxKeys;
  }

  for (var i = 0; i < len; ++i) {
    var x = qs[i].replace(regexp, '%20'),
        idx = x.indexOf(eq),
        kstr, vstr, k, v;

    if (idx >= 0) {
      kstr = x.substr(0, idx);
      vstr = x.substr(idx + 1);
    } else {
      kstr = x;
      vstr = '';
    }

    k = decodeURIComponent(kstr);
    v = decodeURIComponent(vstr);

    if (!hasOwnProperty(obj, k)) {
      obj[k] = v;
    } else if (isArray(obj[k])) {
      obj[k].push(v);
    } else {
      obj[k] = [obj[k], v];
    }
  }

  return obj;
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

},{}],43:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var stringifyPrimitive = function(v) {
  switch (typeof v) {
    case 'string':
      return v;

    case 'boolean':
      return v ? 'true' : 'false';

    case 'number':
      return isFinite(v) ? v : '';

    default:
      return '';
  }
};

module.exports = function(obj, sep, eq, name) {
  sep = sep || '&';
  eq = eq || '=';
  if (obj === null) {
    obj = undefined;
  }

  if (typeof obj === 'object') {
    return map(objectKeys(obj), function(k) {
      var ks = encodeURIComponent(stringifyPrimitive(k)) + eq;
      if (isArray(obj[k])) {
        return map(obj[k], function(v) {
          return ks + encodeURIComponent(stringifyPrimitive(v));
        }).join(sep);
      } else {
        return ks + encodeURIComponent(stringifyPrimitive(obj[k]));
      }
    }).join(sep);

  }

  if (!name) return '';
  return encodeURIComponent(stringifyPrimitive(name)) + eq +
         encodeURIComponent(stringifyPrimitive(obj));
};

var isArray = Array.isArray || function (xs) {
  return Object.prototype.toString.call(xs) === '[object Array]';
};

function map (xs, f) {
  if (xs.map) return xs.map(f);
  var res = [];
  for (var i = 0; i < xs.length; i++) {
    res.push(f(xs[i], i));
  }
  return res;
}

var objectKeys = Object.keys || function (obj) {
  var res = [];
  for (var key in obj) {
    if (Object.prototype.hasOwnProperty.call(obj, key)) res.push(key);
  }
  return res;
};

},{}],44:[function(require,module,exports){
'use strict';

exports.decode = exports.parse = require('./decode');
exports.encode = exports.stringify = require('./encode');

},{"./decode":42,"./encode":43}],45:[function(require,module,exports){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

'use strict';

var punycode = require('punycode');
var util = require('./util');

exports.parse = urlParse;
exports.resolve = urlResolve;
exports.resolveObject = urlResolveObject;
exports.format = urlFormat;

exports.Url = Url;

function Url() {
  this.protocol = null;
  this.slashes = null;
  this.auth = null;
  this.host = null;
  this.port = null;
  this.hostname = null;
  this.hash = null;
  this.search = null;
  this.query = null;
  this.pathname = null;
  this.path = null;
  this.href = null;
}

// Reference: RFC 3986, RFC 1808, RFC 2396

// define these here so at least they only have to be
// compiled once on the first module load.
var protocolPattern = /^([a-z0-9.+-]+:)/i,
    portPattern = /:[0-9]*$/,

    // Special case for a simple path URL
    simplePathPattern = /^(\/\/?(?!\/)[^\?\s]*)(\?[^\s]*)?$/,

    // RFC 2396: characters reserved for delimiting URLs.
    // We actually just auto-escape these.
    delims = ['<', '>', '"', '`', ' ', '\r', '\n', '\t'],

    // RFC 2396: characters not allowed for various reasons.
    unwise = ['{', '}', '|', '\\', '^', '`'].concat(delims),

    // Allowed by RFCs, but cause of XSS attacks.  Always escape these.
    autoEscape = ['\''].concat(unwise),
    // Characters that are never ever allowed in a hostname.
    // Note that any invalid chars are also handled, but these
    // are the ones that are *expected* to be seen, so we fast-path
    // them.
    nonHostChars = ['%', '/', '?', ';', '#'].concat(autoEscape),
    hostEndingChars = ['/', '?', '#'],
    hostnameMaxLen = 255,
    hostnamePartPattern = /^[+a-z0-9A-Z_-]{0,63}$/,
    hostnamePartStart = /^([+a-z0-9A-Z_-]{0,63})(.*)$/,
    // protocols that can allow "unsafe" and "unwise" chars.
    unsafeProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that never have a hostname.
    hostlessProtocol = {
      'javascript': true,
      'javascript:': true
    },
    // protocols that always contain a // bit.
    slashedProtocol = {
      'http': true,
      'https': true,
      'ftp': true,
      'gopher': true,
      'file': true,
      'http:': true,
      'https:': true,
      'ftp:': true,
      'gopher:': true,
      'file:': true
    },
    querystring = require('querystring');

function urlParse(url, parseQueryString, slashesDenoteHost) {
  if (url && util.isObject(url) && url instanceof Url) return url;

  var u = new Url;
  u.parse(url, parseQueryString, slashesDenoteHost);
  return u;
}

Url.prototype.parse = function(url, parseQueryString, slashesDenoteHost) {
  if (!util.isString(url)) {
    throw new TypeError("Parameter 'url' must be a string, not " + typeof url);
  }

  // Copy chrome, IE, opera backslash-handling behavior.
  // Back slashes before the query string get converted to forward slashes
  // See: https://code.google.com/p/chromium/issues/detail?id=25916
  var queryIndex = url.indexOf('?'),
      splitter =
          (queryIndex !== -1 && queryIndex < url.indexOf('#')) ? '?' : '#',
      uSplit = url.split(splitter),
      slashRegex = /\\/g;
  uSplit[0] = uSplit[0].replace(slashRegex, '/');
  url = uSplit.join(splitter);

  var rest = url;

  // trim before proceeding.
  // This is to support parse stuff like "  http://foo.com  \n"
  rest = rest.trim();

  if (!slashesDenoteHost && url.split('#').length === 1) {
    // Try fast path regexp
    var simplePath = simplePathPattern.exec(rest);
    if (simplePath) {
      this.path = rest;
      this.href = rest;
      this.pathname = simplePath[1];
      if (simplePath[2]) {
        this.search = simplePath[2];
        if (parseQueryString) {
          this.query = querystring.parse(this.search.substr(1));
        } else {
          this.query = this.search.substr(1);
        }
      } else if (parseQueryString) {
        this.search = '';
        this.query = {};
      }
      return this;
    }
  }

  var proto = protocolPattern.exec(rest);
  if (proto) {
    proto = proto[0];
    var lowerProto = proto.toLowerCase();
    this.protocol = lowerProto;
    rest = rest.substr(proto.length);
  }

  // figure out if it's got a host
  // user@server is *always* interpreted as a hostname, and url
  // resolution will treat //foo/bar as host=foo,path=bar because that's
  // how the browser resolves relative URLs.
  if (slashesDenoteHost || proto || rest.match(/^\/\/[^@\/]+@[^@\/]+/)) {
    var slashes = rest.substr(0, 2) === '//';
    if (slashes && !(proto && hostlessProtocol[proto])) {
      rest = rest.substr(2);
      this.slashes = true;
    }
  }

  if (!hostlessProtocol[proto] &&
      (slashes || (proto && !slashedProtocol[proto]))) {

    // there's a hostname.
    // the first instance of /, ?, ;, or # ends the host.
    //
    // If there is an @ in the hostname, then non-host chars *are* allowed
    // to the left of the last @ sign, unless some host-ending character
    // comes *before* the @-sign.
    // URLs are obnoxious.
    //
    // ex:
    // http://a@b@c/ => user:a@b host:c
    // http://a@b?@c => user:a host:c path:/?@c

    // v0.12 TODO(isaacs): This is not quite how Chrome does things.
    // Review our test case against browsers more comprehensively.

    // find the first instance of any hostEndingChars
    var hostEnd = -1;
    for (var i = 0; i < hostEndingChars.length; i++) {
      var hec = rest.indexOf(hostEndingChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }

    // at this point, either we have an explicit point where the
    // auth portion cannot go past, or the last @ char is the decider.
    var auth, atSign;
    if (hostEnd === -1) {
      // atSign can be anywhere.
      atSign = rest.lastIndexOf('@');
    } else {
      // atSign must be in auth portion.
      // http://a@b/c@d => host:b auth:a path:/c@d
      atSign = rest.lastIndexOf('@', hostEnd);
    }

    // Now we have a portion which is definitely the auth.
    // Pull that off.
    if (atSign !== -1) {
      auth = rest.slice(0, atSign);
      rest = rest.slice(atSign + 1);
      this.auth = decodeURIComponent(auth);
    }

    // the host is the remaining to the left of the first non-host char
    hostEnd = -1;
    for (var i = 0; i < nonHostChars.length; i++) {
      var hec = rest.indexOf(nonHostChars[i]);
      if (hec !== -1 && (hostEnd === -1 || hec < hostEnd))
        hostEnd = hec;
    }
    // if we still have not hit it, then the entire thing is a host.
    if (hostEnd === -1)
      hostEnd = rest.length;

    this.host = rest.slice(0, hostEnd);
    rest = rest.slice(hostEnd);

    // pull out port.
    this.parseHost();

    // we've indicated that there is a hostname,
    // so even if it's empty, it has to be present.
    this.hostname = this.hostname || '';

    // if hostname begins with [ and ends with ]
    // assume that it's an IPv6 address.
    var ipv6Hostname = this.hostname[0] === '[' &&
        this.hostname[this.hostname.length - 1] === ']';

    // validate a little.
    if (!ipv6Hostname) {
      var hostparts = this.hostname.split(/\./);
      for (var i = 0, l = hostparts.length; i < l; i++) {
        var part = hostparts[i];
        if (!part) continue;
        if (!part.match(hostnamePartPattern)) {
          var newpart = '';
          for (var j = 0, k = part.length; j < k; j++) {
            if (part.charCodeAt(j) > 127) {
              // we replace non-ASCII char with a temporary placeholder
              // we need this to make sure size of hostname is not
              // broken by replacing non-ASCII by nothing
              newpart += 'x';
            } else {
              newpart += part[j];
            }
          }
          // we test again with ASCII char only
          if (!newpart.match(hostnamePartPattern)) {
            var validParts = hostparts.slice(0, i);
            var notHost = hostparts.slice(i + 1);
            var bit = part.match(hostnamePartStart);
            if (bit) {
              validParts.push(bit[1]);
              notHost.unshift(bit[2]);
            }
            if (notHost.length) {
              rest = '/' + notHost.join('.') + rest;
            }
            this.hostname = validParts.join('.');
            break;
          }
        }
      }
    }

    if (this.hostname.length > hostnameMaxLen) {
      this.hostname = '';
    } else {
      // hostnames are always lower case.
      this.hostname = this.hostname.toLowerCase();
    }

    if (!ipv6Hostname) {
      // IDNA Support: Returns a punycoded representation of "domain".
      // It only converts parts of the domain name that
      // have non-ASCII characters, i.e. it doesn't matter if
      // you call it with a domain that already is ASCII-only.
      this.hostname = punycode.toASCII(this.hostname);
    }

    var p = this.port ? ':' + this.port : '';
    var h = this.hostname || '';
    this.host = h + p;
    this.href += this.host;

    // strip [ and ] from the hostname
    // the host field still retains them, though
    if (ipv6Hostname) {
      this.hostname = this.hostname.substr(1, this.hostname.length - 2);
      if (rest[0] !== '/') {
        rest = '/' + rest;
      }
    }
  }

  // now rest is set to the post-host stuff.
  // chop off any delim chars.
  if (!unsafeProtocol[lowerProto]) {

    // First, make 100% sure that any "autoEscape" chars get
    // escaped, even if encodeURIComponent doesn't think they
    // need to be.
    for (var i = 0, l = autoEscape.length; i < l; i++) {
      var ae = autoEscape[i];
      if (rest.indexOf(ae) === -1)
        continue;
      var esc = encodeURIComponent(ae);
      if (esc === ae) {
        esc = escape(ae);
      }
      rest = rest.split(ae).join(esc);
    }
  }


  // chop off from the tail first.
  var hash = rest.indexOf('#');
  if (hash !== -1) {
    // got a fragment string.
    this.hash = rest.substr(hash);
    rest = rest.slice(0, hash);
  }
  var qm = rest.indexOf('?');
  if (qm !== -1) {
    this.search = rest.substr(qm);
    this.query = rest.substr(qm + 1);
    if (parseQueryString) {
      this.query = querystring.parse(this.query);
    }
    rest = rest.slice(0, qm);
  } else if (parseQueryString) {
    // no query string, but parseQueryString still requested
    this.search = '';
    this.query = {};
  }
  if (rest) this.pathname = rest;
  if (slashedProtocol[lowerProto] &&
      this.hostname && !this.pathname) {
    this.pathname = '/';
  }

  //to support http.request
  if (this.pathname || this.search) {
    var p = this.pathname || '';
    var s = this.search || '';
    this.path = p + s;
  }

  // finally, reconstruct the href based on what has been validated.
  this.href = this.format();
  return this;
};

// format a parsed object into a url string
function urlFormat(obj) {
  // ensure it's an object, and not a string url.
  // If it's an obj, this is a no-op.
  // this way, you can call url_format() on strings
  // to clean up potentially wonky urls.
  if (util.isString(obj)) obj = urlParse(obj);
  if (!(obj instanceof Url)) return Url.prototype.format.call(obj);
  return obj.format();
}

Url.prototype.format = function() {
  var auth = this.auth || '';
  if (auth) {
    auth = encodeURIComponent(auth);
    auth = auth.replace(/%3A/i, ':');
    auth += '@';
  }

  var protocol = this.protocol || '',
      pathname = this.pathname || '',
      hash = this.hash || '',
      host = false,
      query = '';

  if (this.host) {
    host = auth + this.host;
  } else if (this.hostname) {
    host = auth + (this.hostname.indexOf(':') === -1 ?
        this.hostname :
        '[' + this.hostname + ']');
    if (this.port) {
      host += ':' + this.port;
    }
  }

  if (this.query &&
      util.isObject(this.query) &&
      Object.keys(this.query).length) {
    query = querystring.stringify(this.query);
  }

  var search = this.search || (query && ('?' + query)) || '';

  if (protocol && protocol.substr(-1) !== ':') protocol += ':';

  // only the slashedProtocols get the //.  Not mailto:, xmpp:, etc.
  // unless they had them to begin with.
  if (this.slashes ||
      (!protocol || slashedProtocol[protocol]) && host !== false) {
    host = '//' + (host || '');
    if (pathname && pathname.charAt(0) !== '/') pathname = '/' + pathname;
  } else if (!host) {
    host = '';
  }

  if (hash && hash.charAt(0) !== '#') hash = '#' + hash;
  if (search && search.charAt(0) !== '?') search = '?' + search;

  pathname = pathname.replace(/[?#]/g, function(match) {
    return encodeURIComponent(match);
  });
  search = search.replace('#', '%23');

  return protocol + host + pathname + search + hash;
};

function urlResolve(source, relative) {
  return urlParse(source, false, true).resolve(relative);
}

Url.prototype.resolve = function(relative) {
  return this.resolveObject(urlParse(relative, false, true)).format();
};

function urlResolveObject(source, relative) {
  if (!source) return relative;
  return urlParse(source, false, true).resolveObject(relative);
}

Url.prototype.resolveObject = function(relative) {
  if (util.isString(relative)) {
    var rel = new Url();
    rel.parse(relative, false, true);
    relative = rel;
  }

  var result = new Url();
  var tkeys = Object.keys(this);
  for (var tk = 0; tk < tkeys.length; tk++) {
    var tkey = tkeys[tk];
    result[tkey] = this[tkey];
  }

  // hash is always overridden, no matter what.
  // even href="" will remove it.
  result.hash = relative.hash;

  // if the relative url is empty, then there's nothing left to do here.
  if (relative.href === '') {
    result.href = result.format();
    return result;
  }

  // hrefs like //foo/bar always cut to the protocol.
  if (relative.slashes && !relative.protocol) {
    // take everything except the protocol from relative
    var rkeys = Object.keys(relative);
    for (var rk = 0; rk < rkeys.length; rk++) {
      var rkey = rkeys[rk];
      if (rkey !== 'protocol')
        result[rkey] = relative[rkey];
    }

    //urlParse appends trailing / to urls like http://www.example.com
    if (slashedProtocol[result.protocol] &&
        result.hostname && !result.pathname) {
      result.path = result.pathname = '/';
    }

    result.href = result.format();
    return result;
  }

  if (relative.protocol && relative.protocol !== result.protocol) {
    // if it's a known url protocol, then changing
    // the protocol does weird things
    // first, if it's not file:, then we MUST have a host,
    // and if there was a path
    // to begin with, then we MUST have a path.
    // if it is file:, then the host is dropped,
    // because that's known to be hostless.
    // anything else is assumed to be absolute.
    if (!slashedProtocol[relative.protocol]) {
      var keys = Object.keys(relative);
      for (var v = 0; v < keys.length; v++) {
        var k = keys[v];
        result[k] = relative[k];
      }
      result.href = result.format();
      return result;
    }

    result.protocol = relative.protocol;
    if (!relative.host && !hostlessProtocol[relative.protocol]) {
      var relPath = (relative.pathname || '').split('/');
      while (relPath.length && !(relative.host = relPath.shift()));
      if (!relative.host) relative.host = '';
      if (!relative.hostname) relative.hostname = '';
      if (relPath[0] !== '') relPath.unshift('');
      if (relPath.length < 2) relPath.unshift('');
      result.pathname = relPath.join('/');
    } else {
      result.pathname = relative.pathname;
    }
    result.search = relative.search;
    result.query = relative.query;
    result.host = relative.host || '';
    result.auth = relative.auth;
    result.hostname = relative.hostname || relative.host;
    result.port = relative.port;
    // to support http.request
    if (result.pathname || result.search) {
      var p = result.pathname || '';
      var s = result.search || '';
      result.path = p + s;
    }
    result.slashes = result.slashes || relative.slashes;
    result.href = result.format();
    return result;
  }

  var isSourceAbs = (result.pathname && result.pathname.charAt(0) === '/'),
      isRelAbs = (
          relative.host ||
          relative.pathname && relative.pathname.charAt(0) === '/'
      ),
      mustEndAbs = (isRelAbs || isSourceAbs ||
                    (result.host && relative.pathname)),
      removeAllDots = mustEndAbs,
      srcPath = result.pathname && result.pathname.split('/') || [],
      relPath = relative.pathname && relative.pathname.split('/') || [],
      psychotic = result.protocol && !slashedProtocol[result.protocol];

  // if the url is a non-slashed url, then relative
  // links like ../.. should be able
  // to crawl up to the hostname, as well.  This is strange.
  // result.protocol has already been set by now.
  // Later on, put the first path part into the host field.
  if (psychotic) {
    result.hostname = '';
    result.port = null;
    if (result.host) {
      if (srcPath[0] === '') srcPath[0] = result.host;
      else srcPath.unshift(result.host);
    }
    result.host = '';
    if (relative.protocol) {
      relative.hostname = null;
      relative.port = null;
      if (relative.host) {
        if (relPath[0] === '') relPath[0] = relative.host;
        else relPath.unshift(relative.host);
      }
      relative.host = null;
    }
    mustEndAbs = mustEndAbs && (relPath[0] === '' || srcPath[0] === '');
  }

  if (isRelAbs) {
    // it's absolute.
    result.host = (relative.host || relative.host === '') ?
                  relative.host : result.host;
    result.hostname = (relative.hostname || relative.hostname === '') ?
                      relative.hostname : result.hostname;
    result.search = relative.search;
    result.query = relative.query;
    srcPath = relPath;
    // fall through to the dot-handling below.
  } else if (relPath.length) {
    // it's relative
    // throw away the existing file, and take the new path instead.
    if (!srcPath) srcPath = [];
    srcPath.pop();
    srcPath = srcPath.concat(relPath);
    result.search = relative.search;
    result.query = relative.query;
  } else if (!util.isNullOrUndefined(relative.search)) {
    // just pull out the search.
    // like href='?foo'.
    // Put this after the other two cases because it simplifies the booleans
    if (psychotic) {
      result.hostname = result.host = srcPath.shift();
      //occationaly the auth can get stuck only in host
      //this especially happens in cases like
      //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
      var authInHost = result.host && result.host.indexOf('@') > 0 ?
                       result.host.split('@') : false;
      if (authInHost) {
        result.auth = authInHost.shift();
        result.host = result.hostname = authInHost.shift();
      }
    }
    result.search = relative.search;
    result.query = relative.query;
    //to support http.request
    if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
      result.path = (result.pathname ? result.pathname : '') +
                    (result.search ? result.search : '');
    }
    result.href = result.format();
    return result;
  }

  if (!srcPath.length) {
    // no path at all.  easy.
    // we've already handled the other stuff above.
    result.pathname = null;
    //to support http.request
    if (result.search) {
      result.path = '/' + result.search;
    } else {
      result.path = null;
    }
    result.href = result.format();
    return result;
  }

  // if a url ENDs in . or .., then it must get a trailing slash.
  // however, if it ends in anything else non-slashy,
  // then it must NOT get a trailing slash.
  var last = srcPath.slice(-1)[0];
  var hasTrailingSlash = (
      (result.host || relative.host || srcPath.length > 1) &&
      (last === '.' || last === '..') || last === '');

  // strip single dots, resolve double dots to parent dir
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = srcPath.length; i >= 0; i--) {
    last = srcPath[i];
    if (last === '.') {
      srcPath.splice(i, 1);
    } else if (last === '..') {
      srcPath.splice(i, 1);
      up++;
    } else if (up) {
      srcPath.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (!mustEndAbs && !removeAllDots) {
    for (; up--; up) {
      srcPath.unshift('..');
    }
  }

  if (mustEndAbs && srcPath[0] !== '' &&
      (!srcPath[0] || srcPath[0].charAt(0) !== '/')) {
    srcPath.unshift('');
  }

  if (hasTrailingSlash && (srcPath.join('/').substr(-1) !== '/')) {
    srcPath.push('');
  }

  var isAbsolute = srcPath[0] === '' ||
      (srcPath[0] && srcPath[0].charAt(0) === '/');

  // put the host back
  if (psychotic) {
    result.hostname = result.host = isAbsolute ? '' :
                                    srcPath.length ? srcPath.shift() : '';
    //occationaly the auth can get stuck only in host
    //this especially happens in cases like
    //url.resolveObject('mailto:local1@domain1', 'local2@domain2')
    var authInHost = result.host && result.host.indexOf('@') > 0 ?
                     result.host.split('@') : false;
    if (authInHost) {
      result.auth = authInHost.shift();
      result.host = result.hostname = authInHost.shift();
    }
  }

  mustEndAbs = mustEndAbs || (result.host && srcPath.length);

  if (mustEndAbs && !isAbsolute) {
    srcPath.unshift('');
  }

  if (!srcPath.length) {
    result.pathname = null;
    result.path = null;
  } else {
    result.pathname = srcPath.join('/');
  }

  //to support request.http
  if (!util.isNull(result.pathname) || !util.isNull(result.search)) {
    result.path = (result.pathname ? result.pathname : '') +
                  (result.search ? result.search : '');
  }
  result.auth = relative.auth || result.auth;
  result.slashes = result.slashes || relative.slashes;
  result.href = result.format();
  return result;
};

Url.prototype.parseHost = function() {
  var host = this.host;
  var port = portPattern.exec(host);
  if (port) {
    port = port[0];
    if (port !== ':') {
      this.port = port.substr(1);
    }
    host = host.substr(0, host.length - port.length);
  }
  if (host) this.hostname = host;
};

},{"./util":46,"punycode":41,"querystring":44}],46:[function(require,module,exports){
'use strict';

module.exports = {
  isString: function(arg) {
    return typeof(arg) === 'string';
  },
  isObject: function(arg) {
    return typeof(arg) === 'object' && arg !== null;
  },
  isNull: function(arg) {
    return arg === null;
  },
  isNullOrUndefined: function(arg) {
    return arg == null;
  }
};

},{}],47:[function(require,module,exports){

/**
 * slice() reference.
 */

var slice = Array.prototype.slice;

/**
 * Expose `co`.
 */

module.exports = co['default'] = co.co = co;

/**
 * Wrap the given generator `fn` into a
 * function that returns a promise.
 * This is a separate function so that
 * every `co()` call doesn't create a new,
 * unnecessary closure.
 *
 * @param {GeneratorFunction} fn
 * @return {Function}
 * @api public
 */

co.wrap = function (fn) {
  createPromise.__generatorFunction__ = fn;
  return createPromise;
  function createPromise() {
    return co.call(this, fn.apply(this, arguments));
  }
};

/**
 * Execute the generator function or a generator
 * and return a promise.
 *
 * @param {Function} fn
 * @return {Promise}
 * @api public
 */

function co(gen) {
  var ctx = this;
  var args = slice.call(arguments, 1)

  // we wrap everything in a promise to avoid promise chaining,
  // which leads to memory leak errors.
  // see https://github.com/tj/co/issues/180
  return new Promise(function(resolve, reject) {
    if (typeof gen === 'function') gen = gen.apply(ctx, args);
    if (!gen || typeof gen.next !== 'function') return resolve(gen);

    onFulfilled();

    /**
     * @param {Mixed} res
     * @return {Promise}
     * @api private
     */

    function onFulfilled(res) {
      var ret;
      try {
        ret = gen.next(res);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    /**
     * @param {Error} err
     * @return {Promise}
     * @api private
     */

    function onRejected(err) {
      var ret;
      try {
        ret = gen.throw(err);
      } catch (e) {
        return reject(e);
      }
      next(ret);
    }

    /**
     * Get the next value in the generator,
     * return a promise.
     *
     * @param {Object} ret
     * @return {Promise}
     * @api private
     */

    function next(ret) {
      if (ret.done) return resolve(ret.value);
      var value = toPromise.call(ctx, ret.value);
      if (value && isPromise(value)) return value.then(onFulfilled, onRejected);
      return onRejected(new TypeError('You may only yield a function, promise, generator, array, or object, '
        + 'but the following object was passed: "' + String(ret.value) + '"'));
    }
  });
}

/**
 * Convert a `yield`ed value into a promise.
 *
 * @param {Mixed} obj
 * @return {Promise}
 * @api private
 */

function toPromise(obj) {
  if (!obj) return obj;
  if (isPromise(obj)) return obj;
  if (isGeneratorFunction(obj) || isGenerator(obj)) return co.call(this, obj);
  if ('function' == typeof obj) return thunkToPromise.call(this, obj);
  if (Array.isArray(obj)) return arrayToPromise.call(this, obj);
  if (isObject(obj)) return objectToPromise.call(this, obj);
  return obj;
}

/**
 * Convert a thunk to a promise.
 *
 * @param {Function}
 * @return {Promise}
 * @api private
 */

function thunkToPromise(fn) {
  var ctx = this;
  return new Promise(function (resolve, reject) {
    fn.call(ctx, function (err, res) {
      if (err) return reject(err);
      if (arguments.length > 2) res = slice.call(arguments, 1);
      resolve(res);
    });
  });
}

/**
 * Convert an array of "yieldables" to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param {Array} obj
 * @return {Promise}
 * @api private
 */

function arrayToPromise(obj) {
  return Promise.all(obj.map(toPromise, this));
}

/**
 * Convert an object of "yieldables" to a promise.
 * Uses `Promise.all()` internally.
 *
 * @param {Object} obj
 * @return {Promise}
 * @api private
 */

function objectToPromise(obj){
  var results = new obj.constructor();
  var keys = Object.keys(obj);
  var promises = [];
  for (var i = 0; i < keys.length; i++) {
    var key = keys[i];
    var promise = toPromise.call(this, obj[key]);
    if (promise && isPromise(promise)) defer(promise, key);
    else results[key] = obj[key];
  }
  return Promise.all(promises).then(function () {
    return results;
  });

  function defer(promise, key) {
    // predefine the key in the result
    results[key] = undefined;
    promises.push(promise.then(function (res) {
      results[key] = res;
    }));
  }
}

/**
 * Check if `obj` is a promise.
 *
 * @param {Object} obj
 * @return {Boolean}
 * @api private
 */

function isPromise(obj) {
  return 'function' == typeof obj.then;
}

/**
 * Check if `obj` is a generator.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */

function isGenerator(obj) {
  return 'function' == typeof obj.next && 'function' == typeof obj.throw;
}

/**
 * Check if `obj` is a generator function.
 *
 * @param {Mixed} obj
 * @return {Boolean}
 * @api private
 */
function isGeneratorFunction(obj) {
  var constructor = obj.constructor;
  if (!constructor) return false;
  if ('GeneratorFunction' === constructor.name || 'GeneratorFunction' === constructor.displayName) return true;
  return isGenerator(constructor.prototype);
}

/**
 * Check for plain object.
 *
 * @param {Mixed} val
 * @return {Boolean}
 * @api private
 */

function isObject(val) {
  return Object == val.constructor;
}

},{}],48:[function(require,module,exports){
var json = typeof JSON !== 'undefined' ? JSON : require('jsonify');

module.exports = function (obj, opts) {
    if (!opts) opts = {};
    if (typeof opts === 'function') opts = { cmp: opts };
    var space = opts.space || '';
    if (typeof space === 'number') space = Array(space+1).join(' ');
    var cycles = (typeof opts.cycles === 'boolean') ? opts.cycles : false;
    var replacer = opts.replacer || function(key, value) { return value; };

    var cmp = opts.cmp && (function (f) {
        return function (node) {
            return function (a, b) {
                var aobj = { key: a, value: node[a] };
                var bobj = { key: b, value: node[b] };
                return f(aobj, bobj);
            };
        };
    })(opts.cmp);

    var seen = [];
    return (function stringify (parent, key, node, level) {
        var indent = space ? ('\n' + new Array(level + 1).join(space)) : '';
        var colonSeparator = space ? ': ' : ':';

        if (node && node.toJSON && typeof node.toJSON === 'function') {
            node = node.toJSON();
        }

        node = replacer.call(parent, key, node);

        if (node === undefined) {
            return;
        }
        if (typeof node !== 'object' || node === null) {
            return json.stringify(node);
        }
        if (isArray(node)) {
            var out = [];
            for (var i = 0; i < node.length; i++) {
                var item = stringify(node, i, node[i], level+1) || json.stringify(null);
                out.push(indent + space + item);
            }
            return '[' + out.join(',') + indent + ']';
        }
        else {
            if (seen.indexOf(node) !== -1) {
                if (cycles) return json.stringify('__cycle__');
                throw new TypeError('Converting circular structure to JSON');
            }
            else seen.push(node);

            var keys = objectKeys(node).sort(cmp && cmp(node));
            var out = [];
            for (var i = 0; i < keys.length; i++) {
                var key = keys[i];
                var value = stringify(node, key, node[key], level+1);

                if(!value) continue;

                var keyValue = json.stringify(key)
                    + colonSeparator
                    + value;
                ;
                out.push(indent + space + keyValue);
            }
            seen.splice(seen.indexOf(node), 1);
            return '{' + out.join(',') + indent + '}';
        }
    })({ '': obj }, '', obj, 0);
};

var isArray = Array.isArray || function (x) {
    return {}.toString.call(x) === '[object Array]';
};

var objectKeys = Object.keys || function (obj) {
    var has = Object.prototype.hasOwnProperty || function () { return true };
    var keys = [];
    for (var key in obj) {
        if (has.call(obj, key)) keys.push(key);
    }
    return keys;
};

},{"jsonify":49}],49:[function(require,module,exports){
exports.parse = require('./lib/parse');
exports.stringify = require('./lib/stringify');

},{"./lib/parse":50,"./lib/stringify":51}],50:[function(require,module,exports){
var at, // The index of the current character
    ch, // The current character
    escapee = {
        '"':  '"',
        '\\': '\\',
        '/':  '/',
        b:    '\b',
        f:    '\f',
        n:    '\n',
        r:    '\r',
        t:    '\t'
    },
    text,

    error = function (m) {
        // Call error when something is wrong.
        throw {
            name:    'SyntaxError',
            message: m,
            at:      at,
            text:    text
        };
    },
    
    next = function (c) {
        // If a c parameter is provided, verify that it matches the current character.
        if (c && c !== ch) {
            error("Expected '" + c + "' instead of '" + ch + "'");
        }
        
        // Get the next character. When there are no more characters,
        // return the empty string.
        
        ch = text.charAt(at);
        at += 1;
        return ch;
    },
    
    number = function () {
        // Parse a number value.
        var number,
            string = '';
        
        if (ch === '-') {
            string = '-';
            next('-');
        }
        while (ch >= '0' && ch <= '9') {
            string += ch;
            next();
        }
        if (ch === '.') {
            string += '.';
            while (next() && ch >= '0' && ch <= '9') {
                string += ch;
            }
        }
        if (ch === 'e' || ch === 'E') {
            string += ch;
            next();
            if (ch === '-' || ch === '+') {
                string += ch;
                next();
            }
            while (ch >= '0' && ch <= '9') {
                string += ch;
                next();
            }
        }
        number = +string;
        if (!isFinite(number)) {
            error("Bad number");
        } else {
            return number;
        }
    },
    
    string = function () {
        // Parse a string value.
        var hex,
            i,
            string = '',
            uffff;
        
        // When parsing for string values, we must look for " and \ characters.
        if (ch === '"') {
            while (next()) {
                if (ch === '"') {
                    next();
                    return string;
                } else if (ch === '\\') {
                    next();
                    if (ch === 'u') {
                        uffff = 0;
                        for (i = 0; i < 4; i += 1) {
                            hex = parseInt(next(), 16);
                            if (!isFinite(hex)) {
                                break;
                            }
                            uffff = uffff * 16 + hex;
                        }
                        string += String.fromCharCode(uffff);
                    } else if (typeof escapee[ch] === 'string') {
                        string += escapee[ch];
                    } else {
                        break;
                    }
                } else {
                    string += ch;
                }
            }
        }
        error("Bad string");
    },

    white = function () {

// Skip whitespace.

        while (ch && ch <= ' ') {
            next();
        }
    },

    word = function () {

// true, false, or null.

        switch (ch) {
        case 't':
            next('t');
            next('r');
            next('u');
            next('e');
            return true;
        case 'f':
            next('f');
            next('a');
            next('l');
            next('s');
            next('e');
            return false;
        case 'n':
            next('n');
            next('u');
            next('l');
            next('l');
            return null;
        }
        error("Unexpected '" + ch + "'");
    },

    value,  // Place holder for the value function.

    array = function () {

// Parse an array value.

        var array = [];

        if (ch === '[') {
            next('[');
            white();
            if (ch === ']') {
                next(']');
                return array;   // empty array
            }
            while (ch) {
                array.push(value());
                white();
                if (ch === ']') {
                    next(']');
                    return array;
                }
                next(',');
                white();
            }
        }
        error("Bad array");
    },

    object = function () {

// Parse an object value.

        var key,
            object = {};

        if (ch === '{') {
            next('{');
            white();
            if (ch === '}') {
                next('}');
                return object;   // empty object
            }
            while (ch) {
                key = string();
                white();
                next(':');
                if (Object.hasOwnProperty.call(object, key)) {
                    error('Duplicate key "' + key + '"');
                }
                object[key] = value();
                white();
                if (ch === '}') {
                    next('}');
                    return object;
                }
                next(',');
                white();
            }
        }
        error("Bad object");
    };

value = function () {

// Parse a JSON value. It could be an object, an array, a string, a number,
// or a word.

    white();
    switch (ch) {
    case '{':
        return object();
    case '[':
        return array();
    case '"':
        return string();
    case '-':
        return number();
    default:
        return ch >= '0' && ch <= '9' ? number() : word();
    }
};

// Return the json_parse function. It will have access to all of the above
// functions and variables.

module.exports = function (source, reviver) {
    var result;
    
    text = source;
    at = 0;
    ch = ' ';
    result = value();
    white();
    if (ch) {
        error("Syntax error");
    }

    // If there is a reviver function, we recursively walk the new structure,
    // passing each name/value pair to the reviver function for possible
    // transformation, starting with a temporary root object that holds the result
    // in an empty key. If there is not a reviver function, we simply return the
    // result.

    return typeof reviver === 'function' ? (function walk(holder, key) {
        var k, v, value = holder[key];
        if (value && typeof value === 'object') {
            for (k in value) {
                if (Object.prototype.hasOwnProperty.call(value, k)) {
                    v = walk(value, k);
                    if (v !== undefined) {
                        value[k] = v;
                    } else {
                        delete value[k];
                    }
                }
            }
        }
        return reviver.call(holder, key, value);
    }({'': result}, '')) : result;
};

},{}],51:[function(require,module,exports){
var cx = /[\u0000\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    escapable = /[\\\"\x00-\x1f\x7f-\x9f\u00ad\u0600-\u0604\u070f\u17b4\u17b5\u200c-\u200f\u2028-\u202f\u2060-\u206f\ufeff\ufff0-\uffff]/g,
    gap,
    indent,
    meta = {    // table of character substitutions
        '\b': '\\b',
        '\t': '\\t',
        '\n': '\\n',
        '\f': '\\f',
        '\r': '\\r',
        '"' : '\\"',
        '\\': '\\\\'
    },
    rep;

function quote(string) {
    // If the string contains no control characters, no quote characters, and no
    // backslash characters, then we can safely slap some quotes around it.
    // Otherwise we must also replace the offending characters with safe escape
    // sequences.
    
    escapable.lastIndex = 0;
    return escapable.test(string) ? '"' + string.replace(escapable, function (a) {
        var c = meta[a];
        return typeof c === 'string' ? c :
            '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"' : '"' + string + '"';
}

function str(key, holder) {
    // Produce a string from holder[key].
    var i,          // The loop counter.
        k,          // The member key.
        v,          // The member value.
        length,
        mind = gap,
        partial,
        value = holder[key];
    
    // If the value has a toJSON method, call it to obtain a replacement value.
    if (value && typeof value === 'object' &&
            typeof value.toJSON === 'function') {
        value = value.toJSON(key);
    }
    
    // If we were called with a replacer function, then call the replacer to
    // obtain a replacement value.
    if (typeof rep === 'function') {
        value = rep.call(holder, key, value);
    }
    
    // What happens next depends on the value's type.
    switch (typeof value) {
        case 'string':
            return quote(value);
        
        case 'number':
            // JSON numbers must be finite. Encode non-finite numbers as null.
            return isFinite(value) ? String(value) : 'null';
        
        case 'boolean':
        case 'null':
            // If the value is a boolean or null, convert it to a string. Note:
            // typeof null does not produce 'null'. The case is included here in
            // the remote chance that this gets fixed someday.
            return String(value);
            
        case 'object':
            if (!value) return 'null';
            gap += indent;
            partial = [];
            
            // Array.isArray
            if (Object.prototype.toString.apply(value) === '[object Array]') {
                length = value.length;
                for (i = 0; i < length; i += 1) {
                    partial[i] = str(i, value) || 'null';
                }
                
                // Join all of the elements together, separated with commas, and
                // wrap them in brackets.
                v = partial.length === 0 ? '[]' : gap ?
                    '[\n' + gap + partial.join(',\n' + gap) + '\n' + mind + ']' :
                    '[' + partial.join(',') + ']';
                gap = mind;
                return v;
            }
            
            // If the replacer is an array, use it to select the members to be
            // stringified.
            if (rep && typeof rep === 'object') {
                length = rep.length;
                for (i = 0; i < length; i += 1) {
                    k = rep[i];
                    if (typeof k === 'string') {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            else {
                // Otherwise, iterate through all of the keys in the object.
                for (k in value) {
                    if (Object.prototype.hasOwnProperty.call(value, k)) {
                        v = str(k, value);
                        if (v) {
                            partial.push(quote(k) + (gap ? ': ' : ':') + v);
                        }
                    }
                }
            }
            
        // Join all of the member texts together, separated with commas,
        // and wrap them in braces.

        v = partial.length === 0 ? '{}' : gap ?
            '{\n' + gap + partial.join(',\n' + gap) + '\n' + mind + '}' :
            '{' + partial.join(',') + '}';
        gap = mind;
        return v;
    }
}

module.exports = function (value, replacer, space) {
    var i;
    gap = '';
    indent = '';
    
    // If the space parameter is a number, make an indent string containing that
    // many spaces.
    if (typeof space === 'number') {
        for (i = 0; i < space; i += 1) {
            indent += ' ';
        }
    }
    // If the space parameter is a string, it will be used as the indent string.
    else if (typeof space === 'string') {
        indent = space;
    }

    // If there is a replacer, it must be a function or an array.
    // Otherwise, throw an error.
    rep = replacer;
    if (replacer && typeof replacer !== 'function'
    && (typeof replacer !== 'object' || typeof replacer.length !== 'number')) {
        throw new Error('JSON.stringify');
    }
    
    // Make a fake root object containing our value under the key of ''.
    // Return the result of stringifying the value.
    return str('', {'': value});
};

},{}],"ajv":[function(require,module,exports){
'use strict';

var compileSchema = require('./compile')
  , resolve = require('./compile/resolve')
  , Cache = require('./cache')
  , SchemaObject = require('./compile/schema_obj')
  , stableStringify = require('json-stable-stringify')
  , formats = require('./compile/formats')
  , rules = require('./compile/rules')
  , v5 = require('./v5')
  , util = require('./compile/util')
  , async = require('./async')
  , co = require('co');

module.exports = Ajv;

Ajv.prototype.compileAsync = async.compile;

var customKeyword = require('./keyword');
Ajv.prototype.addKeyword = customKeyword.add;
Ajv.prototype.getKeyword = customKeyword.get;
Ajv.prototype.removeKeyword = customKeyword.remove;
Ajv.ValidationError = require('./compile/validation_error');

var META_SCHEMA_ID = 'http://json-schema.org/draft-04/schema';
var SCHEMA_URI_FORMAT = /^(?:(?:[a-z][a-z0-9+-.]*:)?\/\/)?[^\s]*$/i;
function SCHEMA_URI_FORMAT_FUNC(str) {
  return SCHEMA_URI_FORMAT.test(str);
}

var META_IGNORE_OPTIONS = [ 'removeAdditional', 'useDefaults', 'coerceTypes' ];

/**
 * Creates validator instance.
 * Usage: `Ajv(opts)`
 * @param {Object} opts optional options
 * @return {Object} ajv instance
 */
function Ajv(opts) {
  if (!(this instanceof Ajv)) return new Ajv(opts);
  var self = this;

  opts = this._opts = util.copy(opts) || {};
  this._schemas = {};
  this._refs = {};
  this._fragments = {};
  this._formats = formats(opts.format);
  this._cache = opts.cache || new Cache;
  this._loadingSchemas = {};
  this._compilations = [];
  this.RULES = rules();

  // this is done on purpose, so that methods are bound to the instance
  // (without using bind) so that they can be used without the instance
  this.validate = validate;
  this.compile = compile;
  this.addSchema = addSchema;
  this.addMetaSchema = addMetaSchema;
  this.validateSchema = validateSchema;
  this.getSchema = getSchema;
  this.removeSchema = removeSchema;
  this.addFormat = addFormat;
  this.errorsText = errorsText;

  this._addSchema = _addSchema;
  this._compile = _compile;

  opts.loopRequired = opts.loopRequired || Infinity;
  if (opts.async || opts.transpile) async.setup(opts);
  if (opts.beautify === true) opts.beautify = { indent_size: 2 };
  if (opts.errorDataPath == 'property') opts._errorDataPathProperty = true;
  this._metaOpts = getMetaSchemaOptions();

  if (opts.formats) addInitialFormats();
  addDraft4MetaSchema();
  if (opts.v5) v5.enable(this);
  if (typeof opts.meta == 'object') addMetaSchema(opts.meta);
  addInitialSchemas();


  /**
   * Validate data using schema
   * Schema will be compiled and cached (using serialized JSON as key. [json-stable-stringify](https://github.com/substack/json-stable-stringify) is used to serialize.
   * @param  {String|Object} schemaKeyRef key, ref or schema object
   * @param  {Any} data to be validated
   * @return {Boolean} validation result. Errors from the last validation will be available in `ajv.errors` (and also in compiled schema: `schema.errors`).
   */
  function validate(schemaKeyRef, data) {
    var v;
    if (typeof schemaKeyRef == 'string') {
      v = getSchema(schemaKeyRef);
      if (!v) throw new Error('no schema with key or ref "' + schemaKeyRef + '"');
    } else {
      var schemaObj = _addSchema(schemaKeyRef);
      v = schemaObj.validate || _compile(schemaObj);
    }

    var valid = v(data);
    if (v.$async === true)
      return self._opts.async == '*' ? co(valid) : valid;
    self.errors = v.errors;
    return valid;
  }


  /**
   * Create validating function for passed schema.
   * @param  {Object} schema schema object
   * @param  {Boolean} _meta true if schema is a meta-schema. Used internally to compile meta schemas of custom keywords.
   * @return {Function} validating function
   */
  function compile(schema, _meta) {
    var schemaObj = _addSchema(schema, undefined, _meta);
    return schemaObj.validate || _compile(schemaObj);
  }


  /**
   * Adds schema to the instance.
   * @param {Object|Array} schema schema or array of schemas. If array is passed, `key` and other parameters will be ignored.
   * @param {String} key Optional schema key. Can be passed to `validate` method instead of schema object or id/ref. One schema per instance can have empty `id` and `key`.
   * @param {Boolean} _skipValidation true to skip schema validation. Used internally, option validateSchema should be used instead.
   * @param {Boolean} _meta true if schema is a meta-schema. Used internally, addMetaSchema should be used instead.
   */
  function addSchema(schema, key, _skipValidation, _meta) {
    if (Array.isArray(schema)){
      for (var i=0; i<schema.length; i++) addSchema(schema[i], undefined, _skipValidation, _meta);
      return;
    }
    // can key/id have # inside?
    key = resolve.normalizeId(key || schema.id);
    checkUnique(key);
    self._schemas[key] = _addSchema(schema, _skipValidation, _meta, true);
  }


  /**
   * Add schema that will be used to validate other schemas
   * options in META_IGNORE_OPTIONS are alway set to false
   * @param {Object} schema schema object
   * @param {String} key optional schema key
   * @param {Boolean} skipValidation true to skip schema validation, can be used to override validateSchema option for meta-schema
   */
  function addMetaSchema(schema, key, skipValidation) {
    addSchema(schema, key, skipValidation, true);
  }


  /**
   * Validate schema
   * @param {Object} schema schema to validate
   * @param {Boolean} throwOrLogError pass true to throw (or log) an error if invalid
   * @return {Boolean} true if schema is valid
   */
  function validateSchema(schema, throwOrLogError) {
    var $schema = schema.$schema || self._opts.defaultMeta || defaultMeta();
    var currentUriFormat = self._formats.uri;
    self._formats.uri = typeof currentUriFormat == 'function'
                        ? SCHEMA_URI_FORMAT_FUNC
                        : SCHEMA_URI_FORMAT;
    var valid;
    try { valid = validate($schema, schema); }
    finally { self._formats.uri = currentUriFormat; }
    if (!valid && throwOrLogError) {
      var message = 'schema is invalid: ' + errorsText();
      if (self._opts.validateSchema == 'log') console.error(message);
      else throw new Error(message);
    }
    return valid;
  }


  function defaultMeta() {
    var meta = self._opts.meta;
    self._opts.defaultMeta = typeof meta == 'object'
                              ? meta.id || meta
                              : self._opts.v5
                                ? v5.META_SCHEMA_ID
                                : META_SCHEMA_ID;
    return self._opts.defaultMeta;
  }


  /**
   * Get compiled schema from the instance by `key` or `ref`.
   * @param  {String} keyRef `key` that was passed to `addSchema` or full schema reference (`schema.id` or resolved id).
   * @return {Function} schema validating function (with property `schema`).
   */
  function getSchema(keyRef) {
    var schemaObj = _getSchemaObj(keyRef);
    switch (typeof schemaObj) {
      case 'object': return schemaObj.validate || _compile(schemaObj);
      case 'string': return getSchema(schemaObj);
      case 'undefined': return _getSchemaFragment(keyRef);
    }
  }


  function _getSchemaFragment(ref) {
    var res = resolve.schema.call(self, { schema: {} }, ref);
    if (res) {
      var schema = res.schema
        , root = res.root
        , baseId = res.baseId;
      var v = compileSchema.call(self, schema, root, undefined, baseId);
      self._fragments[ref] = new SchemaObject({
        ref: ref,
        fragment: true,
        schema: schema,
        root: root,
        baseId: baseId,
        validate: v
      });
      return v;
    }
  }


  function _getSchemaObj(keyRef) {
    keyRef = resolve.normalizeId(keyRef);
    return self._schemas[keyRef] || self._refs[keyRef] || self._fragments[keyRef];
  }


  /**
   * Remove cached schema(s).
   * If no parameter is passed all schemas but meta-schemas are removed.
   * If RegExp is passed all schemas with key/id matching pattern but meta-schemas are removed.
   * Even if schema is referenced by other schemas it still can be removed as other schemas have local references.
   * @param  {String|Object|RegExp} schemaKeyRef key, ref, pattern to match key/ref or schema object
   */
  function removeSchema(schemaKeyRef) {
    if (schemaKeyRef instanceof RegExp) {
      _removeAllSchemas(self._schemas, schemaKeyRef);
      _removeAllSchemas(self._refs, schemaKeyRef);
      return;
    }
    switch (typeof schemaKeyRef) {
      case 'undefined':
        _removeAllSchemas(self._schemas);
        _removeAllSchemas(self._refs);
        self._cache.clear();
        return;
      case 'string':
        var schemaObj = _getSchemaObj(schemaKeyRef);
        if (schemaObj) self._cache.del(schemaObj.jsonStr);
        delete self._schemas[schemaKeyRef];
        delete self._refs[schemaKeyRef];
        return;
      case 'object':
        var jsonStr = stableStringify(schemaKeyRef);
        self._cache.del(jsonStr);
        var id = schemaKeyRef.id;
        if (id) {
          id = resolve.normalizeId(id);
          delete self._schemas[id];
          delete self._refs[id];
        }
    }
  }


  function _removeAllSchemas(schemas, regex) {
    for (var keyRef in schemas) {
      var schemaObj = schemas[keyRef];
      if (!schemaObj.meta && (!regex || regex.test(keyRef))) {
        self._cache.del(schemaObj.jsonStr);
        delete schemas[keyRef];
      }
    }
  }


  function _addSchema(schema, skipValidation, meta, shouldAddSchema) {
    if (typeof schema != 'object') throw new Error('schema should be object');
    var jsonStr = stableStringify(schema);
    var cached = self._cache.get(jsonStr);
    if (cached) return cached;

    shouldAddSchema = shouldAddSchema || self._opts.addUsedSchema !== false;

    var id = resolve.normalizeId(schema.id);
    if (id && shouldAddSchema) checkUnique(id);

    var willValidate = self._opts.validateSchema !== false && !skipValidation;
    var recursiveMeta;
    if (willValidate && !(recursiveMeta = schema.id && schema.id == schema.$schema))
      validateSchema(schema, true);

    var localRefs = resolve.ids.call(self, schema);

    var schemaObj = new SchemaObject({
      id: id,
      schema: schema,
      localRefs: localRefs,
      jsonStr: jsonStr,
      meta: meta
    });

    if (id[0] != '#' && shouldAddSchema) self._refs[id] = schemaObj;
    self._cache.put(jsonStr, schemaObj);

    if (willValidate && recursiveMeta) validateSchema(schema, true);

    return schemaObj;
  }


  function _compile(schemaObj, root) {
    if (schemaObj.compiling) {
      schemaObj.validate = callValidate;
      callValidate.schema = schemaObj.schema;
      callValidate.errors = null;
      callValidate.root = root ? root : callValidate;
      if (schemaObj.schema.$async === true)
        callValidate.$async = true;
      return callValidate;
    }
    schemaObj.compiling = true;

    var currentOpts;
    if (schemaObj.meta) {
      currentOpts = self._opts;
      self._opts = self._metaOpts;
    }

    var v;
    try { v = compileSchema.call(self, schemaObj.schema, root, schemaObj.localRefs); }
    finally {
      schemaObj.compiling = false;
      if (schemaObj.meta) self._opts = currentOpts;
    }

    schemaObj.validate = v;
    schemaObj.refs = v.refs;
    schemaObj.refVal = v.refVal;
    schemaObj.root = v.root;
    return v;


    function callValidate() {
      var _validate = schemaObj.validate;
      var result = _validate.apply(null, arguments);
      callValidate.errors = _validate.errors;
      return result;
    }
  }


  /**
   * Convert array of error message objects to string
   * @param  {Array<Object>} errors optional array of validation errors, if not passed errors from the instance are used.
   * @param  {Object} options optional options with properties `separator` and `dataVar`.
   * @return {String} human readable string with all errors descriptions
   */
  function errorsText(errors, options) {
    errors = errors || self.errors;
    if (!errors) return 'No errors';
    options = options || {};
    var separator = options.separator === undefined ? ', ' : options.separator;
    var dataVar = options.dataVar === undefined ? 'data' : options.dataVar;

    var text = '';
    for (var i=0; i<errors.length; i++) {
      var e = errors[i];
      if (e) text += dataVar + e.dataPath + ' ' + e.message + separator;
    }
    return text.slice(0, -separator.length);
  }


  /**
   * Add custom format
   * @param {String} name format name
   * @param {String|RegExp|Function} format string is converted to RegExp; function should return boolean (true when valid)
   */
  function addFormat(name, format) {
    if (typeof format == 'string') format = new RegExp(format);
    self._formats[name] = format;
  }


  function addDraft4MetaSchema() {
    if (self._opts.meta !== false) {
      var metaSchema = require('./refs/json-schema-draft-04.json');
      addMetaSchema(metaSchema, META_SCHEMA_ID, true);
      self._refs['http://json-schema.org/schema'] = META_SCHEMA_ID;
    }
  }


  function addInitialSchemas() {
    var optsSchemas = self._opts.schemas;
    if (!optsSchemas) return;
    if (Array.isArray(optsSchemas)) addSchema(optsSchemas);
    else for (var key in optsSchemas) addSchema(optsSchemas[key], key);
  }


  function addInitialFormats() {
    for (var name in self._opts.formats) {
      var format = self._opts.formats[name];
      addFormat(name, format);
    }
  }


  function checkUnique(id) {
    if (self._schemas[id] || self._refs[id])
      throw new Error('schema with key or id "' + id + '" already exists');
  }


  function getMetaSchemaOptions() {
    var metaOpts = util.copy(self._opts);
    for (var i=0; i<META_IGNORE_OPTIONS.length; i++)
      delete metaOpts[META_IGNORE_OPTIONS[i]];
    return metaOpts;
  }
}

},{"./async":1,"./cache":2,"./compile":6,"./compile/formats":5,"./compile/resolve":7,"./compile/rules":8,"./compile/schema_obj":9,"./compile/util":11,"./compile/validation_error":12,"./keyword":37,"./refs/json-schema-draft-04.json":38,"./v5":40,"co":47,"json-stable-stringify":48}]},{},[])("ajv")
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))

/***/ },
/* 214 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var _ = __webpack_require__(26);
var uuid = __webpack_require__(17);
var v1 = __webpack_require__(215);
var v2 = __webpack_require__(216);
var v3 = __webpack_require__(217);
var v4 = __webpack_require__(218);

/**
 * Maps the specified values using the specified mapping function and flattens
 * the results, removing nested arrays. This means that the mapping function can
 * be one-to-many.
 * @function flatMap
 * @param {Array} values The array of values to map.
 * @param {Function} fn The mapping function.
 * @returns {Array} The array of mapped values.
 */
function flatMap(values, fn) {
  return _.flatten(_.map(values, fn));
}

/**
 * Returns the maximum version number.
 * @function maxVersion
 * @param {Object} version1 The first version.
 * @param {Number} version1.major The first version's major version.
 * @param {Number} version1.minor The first version's minor version.
 * @param {Object} version2 The second version.
 * @param {Number} version2.major The second version's major version.
 * @param {Number} version2.minor The second version's minor version.
 * @returns {Object} Either version1 or version2, whichever is greater.
 */
function maxVersion(version1, version2) {
  if (version1.major > version2.major) {
    return version1;
  }

  if (version2.major > version1.major) {
    return version2;
  }

  if (version1.minor > version2.minor) {
    return version1;
  }

  return version2;
}

/**
 * Returns an array of mapping functions for the specified version. The
 * functions should be applied in sequential order, starting from index 0.
 * @function getMapFunctions
 * @param {Object} version The entity version.
 * @param {Number} version.major The "major" version number.
 * @param {Number} version.minor The "minor" version number.
 * @returns {Array} The array of mapping functions.
 */
function getMapFunctions(version) {
  var fns = [];

  if (version.major <= 1) {
    var v1From = maxVersion(version, { major: 1, minor: 0 });
    fns.push(function(entity) {
      return v1.mapToV2Entity(entity, v1From);
    });
  }

  if (version.major <= 2) {
    var v2From = maxVersion(version, { major: 2, minor: 0 });
    fns.push(function(entity) {
      return v2.mapToV3Entity(entity, v2From);
    });
  }

  if (version.major <= 3) {
    var v3From = maxVersion(version, { major: 3, minor: 0 });
    fns.push(function(entity) {
      return v3.mapToV4Entity(entity, v3From);
    });
  }

  if (version.major <= 4) {
    var v4From = maxVersion(version, { major: 4, minor: 0 });
    fns.push(function(entity) {
      return v4.mapToV5Entity(entity, v4From);
    });
  }

  return fns;
}

/**
 * Maps a collection of entities from the specified version to the current
 * runtime format.
 * @function mapEntities
 * @param {Array} entities An array of entities.
 * @param {Object} version The entity version.
 * @param {Number} version.major The "major" version number.
 * @param {Number} version.minor The "minor" version number.
 * @returns {Array} The mapped entities.
 */
function mapEntities(entities, version) {
  // First, map to the latest converter output.
  var mapFns = getMapFunctions(version);

  mapFns.forEach(function(mapFn) {
    entities = flatMap(entities, mapFn);
  });

  // Next, map to the runtime format.
  var entitiesById = _.indexBy(entities, 'id');

  return flatMap(entities, function(entity) {
    return ({
      material: mapMaterial,
      prefab: mapPrefab,
      texture2D: mapTexture
    }[entity.type] || _.identity)(entity, entitiesById);
  });
}

/**
 * Maps a material entity to the current runtime format.
 * @function mapMaterial
 * @param {Object} material The material entity to transform.
 * @returns {Object} The transformed material entity.
 */
function mapMaterial(material, entitiesById) {
  var matProps = material.properties;

  var properties = {
    name: matProps.name,
    shader: 'box3d_pbr_shader',
    enabledFeatures: {}
  };

  // Diffuse / albedo
  if (matProps.diffuse || matProps.diffuseTexture) {
    properties.enabledFeatures.albedo = true;

    _.extend(properties, mapMaterialProperties(matProps, 'diffuse',
      'diffuseFactor', 'diffuseTexture', 'albedoColor', 'albedoMap'));
  }

  // Specular
  if (matProps.specular || matProps.specularTexture) {
    properties.enabledFeatures.specular = true;

    _.extend(properties, mapMaterialProperties(matProps, 'specular',
      'specularFactor', 'specularTexture', 'specularColor', 'specularMap'));
  }

  // Reflections
  if (matProps.reflectionTexture) {
    properties.enabledFeatures.specular = true;

    _.extend(properties, mapMaterialProperties(matProps, undefined,
      'reflectionFactor', 'reflectionTexture', 'reflectivity',
      'envMapRadiance', true));
  }

  if (matProps.shininess || matProps.shininessTexture) {
    _.extend(properties, mapMaterialProperties(matProps, 'shininess', undefined,
      'shininessTexture', 'roughness', 'glossMap', true));

    setImageEncoding(matProps.shininessTexture, 'linear', entitiesById);

    if (properties.roughness) {
      // Convert phong shininess value to our 0-1 roughness value.
      // 512 is assumed to be the maximum specular power in our conversion
      properties.roughness = Math.log10(properties.roughness / 512) / 2.5 + 1.0;
      properties.roughness = Math.min(Math.max(properties.roughness, 0.0), 1.0);
      properties.roughness = 1.0 - properties.roughness;
    } else {
      // Turn off specular entirely if roughness is 1. For dielectric materials,
      // no specular is visible if the material is fully 'rough'.
      properties.enabledFeatures.specular = false;
    }
  }

  // Ambient
  if (matProps.ambientTexture) {
    properties.enabledFeatures.albedo = true;

    _.extend(properties, mapMaterialProperties(matProps, 'ambientColor',
      'ambientFactor', 'ambientTexture', undefined, 'aoMap'));
    setImageEncoding(matProps.ambientTexture, 'linear', entitiesById);
  } else if (matProps.ambientFactorTexture) {
    properties.enabledFeatures.albedo = true;

    _.extend(properties, mapMaterialProperties(matProps, 'ambientColor',
      'ambientFactor', 'ambientFactorTexture', undefined, 'aoMap'));
    setImageEncoding(matProps.ambientFactorTexture, 'linear', entitiesById);
  }

  // Emissive
  if (matProps.emissiveTexture) {
    properties.enabledFeatures.emissive = true;

    _.extend(properties, mapMaterialProperties(matProps, 'emissive', null,
      'emissiveTexture', 'emissiveColor', 'emissiveMap'));

    // Separate intensity value for emissive
    if (matProps.emissiveFactor !== undefined) {
      properties.emissiveIntensity = matProps.emissiveFactor;
    }
  } else if (matProps.emissiveFactorTexture) {
    properties.enabledFeatures.emissive = true;

    _.extend(properties, mapMaterialProperties(matProps, 'emissive', null,
      'emissiveFactorTexture', 'emissiveColor', 'emissiveMap'));

    setImageEncoding(matProps.emissiveFactorTexture, 'linear', entitiesById);

    // Separate intensity value for emissive
    if (matProps.emissiveFactor !== undefined) {
      properties.emissiveIntensity = matProps.emissiveFactor;
    }
  }

  // Transparency
  _.extend(properties, mapMaterialProperties(matProps, 'transparentColor',
    'transparencyFactor', 'transparentTexture', 'opacity', 'alphaMap', true));

  setImageEncoding(matProps.transparentTexture, 'linear', entitiesById);

  if (properties.opacity !== undefined) {
    properties.opacity = Math.max(Math.min(1.0 - properties.opacity, 1.0), 0.0);
  }

  if ((properties.opacity && properties.opacity < 0.999) ||
      properties.alphaMap) {
    properties.enabledFeatures.transparency = true;
    properties.alphaBlendMode = 'alphaTransparency';
  } else {
    delete properties.opacity;
  }

  // Normals
  if (matProps.normalMapTexture) {
    properties.enabledFeatures.normals = true;

    _.extend(properties, mapMaterialProperties(matProps, undefined,
      'bumpFactor', 'normalMapTexture', 'normalScale', 'normalMap', true));

    setImageEncoding(matProps.normalMapTexture, 'linear', entitiesById);
  }

  // Bumps
  // TODO - since artists frequently put normal maps into the bump channel
  // of their models we always interpret the texture as a normal map. Down
  // the road, we should run a sanity check on the texture to see if it's
  // really a bump map and take appropriate action.
  if (matProps.bumpTexture) {
    properties.enabledFeatures.normals = true;

    _.extend(properties, mapMaterialProperties(matProps, undefined,
      'bumpFactor', 'bumpTexture', 'normalScale', 'normalMap', true));

    setImageEncoding(matProps.bumpTexture, 'linear', entitiesById);
  }

  // Convert normal scale to vec2 since that's what three.js wants.
  if (properties.normalScale) {
    properties.normalScale = {x: properties.normalScale, y: properties.normalScale};
  }

  // Displacement
  if (matProps.displacementColorTexture !== undefined) {
    properties.enabledFeatures.displacement = true;

    _.extend(properties, mapMaterialProperties(matProps, 'displacementColor',
      'displacementFactor', 'displacementTexture', 'displacementScale',
      'displacementMap', true));

    setImageEncoding(matProps.displacementTexture, 'linear', entitiesById);
  }

  // Vector displacement
  if (matProps.vectorDisplacementColorTexture !== undefined) {
    properties.enabledFeatures.displacement = true;
    properties.useVectorDisplacement = true;

    _.extend(properties, mapMaterialProperties(matProps,
      'vectorDisplacementColor', 'vectorDisplacementFactor',
      'vectorDisplacementColorTexture', 'displacementScale',
      'displacementMap'));

    setImageEncoding(matProps.vectorDisplacementColorTexture, 'linear', entitiesById);
  }

  material.properties = properties;

  return material;
}

/**
 * Maps a prefab entity to the current runtime format.
 * @function mapPrefab
 * @param {Object} prefab The prefab entity to transform.
 * @returns {Array} The transformed prefab entity and a new root node.
 */
function mapPrefab(prefab) {
  var rootObjectId = uuid.v4();

  var rootObject = {
    type: 'node',
    id: rootObjectId,
    parentAssetId: prefab.id,
    sid: rootObjectId,
    children: prefab.children,
    properties: {
      name: (prefab.properties.name || 'Prefab') + '_root'
    }
  };

  delete prefab.children;

  prefab.properties.rootObjectId = rootObjectId;

  return [prefab, rootObject];
}

/**
 * Given a texture ID, find the image that it references and set its encoding
 * to the one given. This should be replaced later when we have accurate colorspace
 * and usage info coming through the converter.
 * @method setImageEncoding
 * @private
 * @param {String} textureId  The ID of the texture that we're interested in.
 * @param {String} encoding Name of encoding to set image to ('linear', 'srgb', etc.)
 * @param {Object} entityMap  Map of all entities, keyed by ID
 */
function setImageEncoding(textureId, encoding, entityMap) {
  var texture = entityMap[textureId];
  if (texture) {
    var image = entityMap[texture.properties.imageId];
    if (image) {
      image.properties.encoding = encoding;
    }
  }
}

/**
 * Map the specified set of material properties to the current runtime format.
 * @function mapMaterialProperties
 * @param {Object} srcProperties The original material properties.
 * @param {String} srcColorName The old name of the color property.
 * @param {String} srcFactorName The old name of the factor property.
 * @param {String} srcTextureName The old name of the texture property.
 * @param {String} dstColorName The new name of the color property.
 * @param {String} dstTextureName The new name of the texture property.
 * @returns {Object} The new material properties.
 */
function mapMaterialProperties(
  srcProperties,
  srcColorName,
  srcFactorName,
  srcTextureName,
  dstColorName,
  dstTextureName,
  scalar
) {
  var dstProperties = {};

  if (srcProperties.hasOwnProperty(srcTextureName)) {
    dstProperties[dstTextureName] = srcProperties[srcTextureName];
  }

  if (dstColorName) {
    var factor = srcProperties[srcFactorName] !== undefined ?
      srcProperties[srcFactorName] : 1;

    if (srcProperties.hasOwnProperty(srcColorName)) {
      if (scalar) {
        // In case that the output is scalar but the input isn't, just take an
        // average.
        if (srcProperties[srcColorName] instanceof Object) {
          dstProperties[dstColorName] = (srcProperties[srcColorName].r +
            srcProperties[srcColorName].g + srcProperties[srcColorName].b) / 3.0 * factor;
        } else {
          dstProperties[dstColorName] = srcProperties[srcColorName] * factor;
        }
      } else {
        dstProperties[dstColorName] = {
          r: srcProperties[srcColorName].r * factor,
          g: srcProperties[srcColorName].g * factor,
          b: srcProperties[srcColorName].b * factor
        };
      }
      // Temp hack until we have access to texture blending info here. When a texture is assigned
      // and the colour is black, we obviously don't want to multiply them together. So, we'll just
      // assume the colour is white for now.
      if (dstProperties[dstColorName].r === 0
        && dstProperties[dstColorName].g === 0
        && dstProperties[dstColorName].b === 0
        && dstProperties[dstTextureName]) {
        dstProperties[dstColorName] = scalar ? 1 : {r: 1, g: 1, b: 1};
      }
    } else {
      dstProperties[dstColorName] = scalar ? 1 : {r: 1, g: 1, b: 1};
    }
  }

  return dstProperties;
}

/**
 * Map the texture entity to the current runtime format.
 * @function mapTexture
 * @param {Object} texture The texture entity to map.
 * @returns {Object} The mapped texture entity.
 */
function mapTexture(texture) {
  var textureProps = texture.properties;
  var properties = { name: textureProps.name, imageId: textureProps.imageId };

  if (textureProps.hasOwnProperty('wrapModeU')) {
    properties.uMapping = textureProps.wrapModeU === 'repeat' ?
      'wrap' : 'clamp';
  }

  if (textureProps.hasOwnProperty('wrapModeV')) {
    properties.vMapping = textureProps.wrapModeV === 'repeat' ?
      'wrap' : 'clamp';
  }

  if (textureProps.hasOwnProperty('wrapModeV')) {
    properties.vMapping = textureProps.wrapModeV === 'repeat' ?
      'wrap' : 'clamp';
  }

  texture.properties = properties;

  return texture;
}

module.exports = {
  mapEntities: mapEntities
};


/***/ },
/* 215 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var _ = __webpack_require__(26);

/**
 * Map "entity.payload" to "entity.properties". This applies to all v1 entities.
 * @function mapPayloadToProperties
 * @param {Object} entity The v1 entity to map.
 * @returns {Object} The mapped entity.
 */
function mapPayloadToProperties(entity) {
  if (entity.payload) {
    entity.properties = entity.payload;
    delete entity.payload;
  }

  return entity;
}

/**
 * Map a v1 entity to v2.
 * @function mapToV2Entity
 * @param {Object} entity The v1 entity to map.
 * @returns {Object|Array} The v2 entity (or entities).
 */
function mapToV2Entity(entity) {
  entity = mapPayloadToProperties(entity);

  return ({
    material: mapToV2Material
  }[entity.type] || _.identity)(entity);
}

/**
 * Map a v1 material to v2.
 * @function mapToV2Material
 * @param {Object} entity The material entity to map.
 * @returns {Object} The mapped material entity.
 */
function mapToV2Material(entity) {
  // Remove "nested" properties: material.properties.properties. Move these
  // properties into the first level of properties.
  if (entity.properties && entity.properties.properties) {
    _.each(entity.properties.properties, function(value, name) {
      entity.properties[name] = value;
    });

    delete entity.properties.properties;
  }

  return entity;
}

module.exports = {
  mapToV2Entity: mapToV2Entity
};



/***/ },
/* 216 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var _ = __webpack_require__(26);
var uuid = __webpack_require__(17);

/**
 * Returns the basename of a filename (i.e., the final element in the path).
 * @function basename
 * @param {String} filename The filename.
 * @returns {String} The basename of the filename.
 */
function basename(filename) {
  var tokens = filename.split(new RegExp(/\\|\//));
  return tokens.length === 0 ? filename : tokens[tokens.length - 1];
}

/**
 * Map top-level "name" to "sid" and make "name" a property.
 * @function mapNameToSid
 * @param {Object} entity The entity to map.
 * @returns {Object} The mapped entity.
 */
function mapNameToSid(entity) {
  if (entity.name) {
    entity.sid = entity.name;

    if (!entity.properties) {
      entity.properties = {};
    }

    entity.properties.name = entity.name;
    delete entity.name;
  }

  return entity;
}

/**
 * Map a v2 entity to v3.
 * @function mapToV3Entity
 * @param {Object} entity The v2 entity to map.
 * @returns {Object|Array} The v3 entity (or entities).
 */
function mapToV3Entity(entity) {
  entity = mapNameToSid(entity);

  return ({
    texture2D: mapToV3Texture2d
  }[entity.type] || _.identity)(entity);
}

/**
 * Map a v2 texture2D entity to a v3 texture2D entity and a document entity.
 * @function mapToV3Texture2d
 * @param {Object} entity The v2 texture2D entity to map.
 * @returns {Array} An array containing a v3 texture2D entity and a document
 * entity.
 */
function mapToV3Texture2d(entity) {
  var sid = basename(entity.properties.filename);

  var document = {
    type: 'document',
    id: uuid.v4(),
    sid: sid,
    properties: {
      name: sid,
      filename: entity.properties.filename
    }
  };

  entity.properties.imageId = document.id + '#' + sid;
  delete entity.properties.filename;

  return [entity, document];
}

module.exports = {
  mapToV3Entity: mapToV3Entity
};



/***/ },
/* 217 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var _ = __webpack_require__(26);
var uuid = __webpack_require__(17);

/**
 * Map a v3 entity to v4.
 * @function mapToV4Entity
 * @param {Object} entity The v3 entity to map.
 * @returns {Object|Array} The v4 entity (or entities).
 */
function mapToV4Entity(entity) {
  return ({
    meshGeometry: mapToV4MeshGeometry
  }[entity.type] || _.identity)(entity);
}

/**
 * Map a v3 meshGeometry entity to a v4 meshGeometry entity and a buffer entity.
 * @function mapToV4MeshGeometry
 * @param {Object} entity The v3 meshGeometry entity to map.
 * @returns {Array} An array containing a v4 meshGeometry entity and a buffer
 * entity.
 */
function mapToV4MeshGeometry(entity) {
  var buffer = {
    type: 'buffer',
    id: uuid.v4(),
    sid: entity.sid + '-buffer',
    properties: {
      name: entity.sid + '-buffer',
      src: 'geometry.bin',
      accessors: {}
    }
  };

  // Add an accessor to the buffer for each attribute.
  _.each(entity.properties.attributes, function(attribute, name) {
    buffer.properties.accessors[name] = {
      type: attribute.type,
      componentType: attribute.componentType,
      byteOffset: attribute.byteOffset,
      byteStride: 0,
      count: attribute.count
    };

    attribute.accessorId = buffer.id + '#' + name;

    delete attribute.type;
    delete attribute.componentType;
    delete attribute.byteOffset;
    delete attribute.byteStride;
    delete attribute.count;
  });

  // Add an accessor to the buffer for "indices".
  buffer.properties.accessors.indices = {
    type: entity.properties.indices.type,
    componentType: entity.properties.indices.componentType,
    byteOffset: entity.properties.indices.byteOffset,
    byteStride: 0,
    count: entity.properties.indices.count
  };

  entity.properties.indices = buffer.id + '#indices';

  return [entity, buffer];
}

module.exports = {
  mapToV4Entity: mapToV4Entity
};



/***/ },
/* 218 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';

var _ = __webpack_require__(26);

/**
 * Map a v4 entity to v5.
 * @function mapToV5Entity
 * @param {Object} entity The v4 entity to map.
 * @param {Object} version The incoming entity version.
 * @param {Number} version.major The major version.
 * @param {Number} version.minor The minor version.
 * @returns {Object|Array} The v5 entity (or entities).
 */
function mapToV5Entity(entity, version) {
  return ({
    image: mapToV5Image
  }[entity.type] || _.identity)(entity, version);
}

/**
 * Map a v4 image entity to a v5 image entity.
 * @function mapToV5Image
 * @param {Object} entity The v4 image entity to map.
 * @param {Object} version The incoming entity version.
 * @param {Number} version.major The major version.
 * @param {Number} version.minor The minor version.
 * @returns {Object} The mapped image entity.
 */
function mapToV5Image(entity, version) {
  if (version.minor < 3 && entity.hasOwnProperty('representations')) {
    entity.representations = _.filter(entity.representations, function(representation) {
      return representation.width <= 4096 && representation.height <= 4096;
    });
  }

  return entity;
}

module.exports = {
  mapToV5Entity: mapToV5Entity
};


/***/ },
/* 219 */
/***/ function(module, exports) {

module.exports = function(it){
  if(typeof it != 'function')throw TypeError(it + ' is not a function!');
  return it;
};

/***/ },
/* 220 */
/***/ function(module, exports, __webpack_require__) {

// 22.1.3.31 Array.prototype[@@unscopables]
var UNSCOPABLES = __webpack_require__(177)('unscopables')
  , ArrayProto  = Array.prototype;
if(ArrayProto[UNSCOPABLES] == undefined)__webpack_require__(54)(ArrayProto, UNSCOPABLES, {});
module.exports = function(key){
  ArrayProto[UNSCOPABLES][key] = true;
};

/***/ },
/* 221 */
/***/ function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(41);
module.exports = function(it){
  if(!isObject(it))throw TypeError(it + ' is not an object!');
  return it;
};

/***/ },
/* 222 */
/***/ function(module, exports, __webpack_require__) {

// 0 -> Array#forEach
// 1 -> Array#map
// 2 -> Array#filter
// 3 -> Array#some
// 4 -> Array#every
// 5 -> Array#find
// 6 -> Array#findIndex
var ctx      = __webpack_require__(174)
  , IObject  = __webpack_require__(229)
  , toObject = __webpack_require__(237)
  , toLength = __webpack_require__(236)
  , asc      = __webpack_require__(224);
module.exports = function(TYPE, $create){
  var IS_MAP        = TYPE == 1
    , IS_FILTER     = TYPE == 2
    , IS_SOME       = TYPE == 3
    , IS_EVERY      = TYPE == 4
    , IS_FIND_INDEX = TYPE == 6
    , NO_HOLES      = TYPE == 5 || IS_FIND_INDEX
    , create        = $create || asc;
  return function($this, callbackfn, that){
    var O      = toObject($this)
      , self   = IObject(O)
      , f      = ctx(callbackfn, that, 3)
      , length = toLength(self.length)
      , index  = 0
      , result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined
      , val, res;
    for(;length > index; index++)if(NO_HOLES || index in self){
      val = self[index];
      res = f(val, index, O);
      if(TYPE){
        if(IS_MAP)result[index] = res;            // map
        else if(res)switch(TYPE){
          case 3: return true;                    // some
          case 5: return val;                     // find
          case 6: return index;                   // findIndex
          case 2: result.push(val);               // filter
        } else if(IS_EVERY)return false;          // every
      }
    }
    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;
  };
};

/***/ },
/* 223 */
/***/ function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(41)
  , isArray  = __webpack_require__(230)
  , SPECIES  = __webpack_require__(177)('species');

module.exports = function(original){
  var C;
  if(isArray(original)){
    C = original.constructor;
    // cross-realm fallback
    if(typeof C == 'function' && (C === Array || isArray(C.prototype)))C = undefined;
    if(isObject(C)){
      C = C[SPECIES];
      if(C === null)C = undefined;
    }
  } return C === undefined ? Array : C;
};

/***/ },
/* 224 */
/***/ function(module, exports, __webpack_require__) {

// 9.4.2.3 ArraySpeciesCreate(originalArray, length)
var speciesConstructor = __webpack_require__(223);

module.exports = function(original, length){
  return new (speciesConstructor(original))(length);
};

/***/ },
/* 225 */
/***/ function(module, exports) {

// 7.2.1 RequireObjectCoercible(argument)
module.exports = function(it){
  if(it == undefined)throw TypeError("Can't call method on  " + it);
  return it;
};

/***/ },
/* 226 */
/***/ function(module, exports, __webpack_require__) {

var isObject = __webpack_require__(41)
  , document = __webpack_require__(25).document
  // in old IE typeof document.createElement is 'object'
  , is = isObject(document) && isObject(document.createElement);
module.exports = function(it){
  return is ? document.createElement(it) : {};
};

/***/ },
/* 227 */
/***/ function(module, exports) {

var hasOwnProperty = {}.hasOwnProperty;
module.exports = function(it, key){
  return hasOwnProperty.call(it, key);
};

/***/ },
/* 228 */
/***/ function(module, exports, __webpack_require__) {

module.exports = !__webpack_require__(52) && !__webpack_require__(175)(function(){
  return Object.defineProperty(__webpack_require__(226)('div'), 'a', {get: function(){ return 7; }}).a != 7;
});

/***/ },
/* 229 */
/***/ function(module, exports, __webpack_require__) {

// fallback for non-array-like ES3 and non-enumerable old V8 strings
var cof = __webpack_require__(173);
module.exports = Object('z').propertyIsEnumerable(0) ? Object : function(it){
  return cof(it) == 'String' ? it.split('') : Object(it);
};

/***/ },
/* 230 */
/***/ function(module, exports, __webpack_require__) {

// 7.2.2 IsArray(argument)
var cof = __webpack_require__(173);
module.exports = Array.isArray || function isArray(arg){
  return cof(arg) == 'Array';
};

/***/ },
/* 231 */
/***/ function(module, exports, __webpack_require__) {

var anObject       = __webpack_require__(221)
  , IE8_DOM_DEFINE = __webpack_require__(228)
  , toPrimitive    = __webpack_require__(238)
  , dP             = Object.defineProperty;

exports.f = __webpack_require__(52) ? Object.defineProperty : function defineProperty(O, P, Attributes){
  anObject(O);
  P = toPrimitive(P, true);
  anObject(Attributes);
  if(IE8_DOM_DEFINE)try {
    return dP(O, P, Attributes);
  } catch(e){ /* empty */ }
  if('get' in Attributes || 'set' in Attributes)throw TypeError('Accessors not supported!');
  if('value' in Attributes)O[P] = Attributes.value;
  return O;
};

/***/ },
/* 232 */
/***/ function(module, exports) {

module.exports = function(bitmap, value){
  return {
    enumerable  : !(bitmap & 1),
    configurable: !(bitmap & 2),
    writable    : !(bitmap & 4),
    value       : value
  };
};

/***/ },
/* 233 */
/***/ function(module, exports, __webpack_require__) {

var global    = __webpack_require__(25)
  , hide      = __webpack_require__(54)
  , has       = __webpack_require__(227)
  , SRC       = __webpack_require__(176)('src')
  , TO_STRING = 'toString'
  , $toString = Function[TO_STRING]
  , TPL       = ('' + $toString).split(TO_STRING);

__webpack_require__(24).inspectSource = function(it){
  return $toString.call(it);
};

(module.exports = function(O, key, val, safe){
  var isFunction = typeof val == 'function';
  if(isFunction)has(val, 'name') || hide(val, 'name', key);
  if(O[key] === val)return;
  if(isFunction)has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));
  if(O === global){
    O[key] = val;
  } else {
    if(!safe){
      delete O[key];
      hide(O, key, val);
    } else {
      if(O[key])O[key] = val;
      else hide(O, key, val);
    }
  }
// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative
})(Function.prototype, TO_STRING, function toString(){
  return typeof this == 'function' && this[SRC] || $toString.call(this);
});

/***/ },
/* 234 */
/***/ function(module, exports, __webpack_require__) {

var global = __webpack_require__(25)
  , SHARED = '__core-js_shared__'
  , store  = global[SHARED] || (global[SHARED] = {});
module.exports = function(key){
  return store[key] || (store[key] = {});
};

/***/ },
/* 235 */
/***/ function(module, exports) {

// 7.1.4 ToInteger
var ceil  = Math.ceil
  , floor = Math.floor;
module.exports = function(it){
  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);
};

/***/ },
/* 236 */
/***/ function(module, exports, __webpack_require__) {

// 7.1.15 ToLength
var toInteger = __webpack_require__(235)
  , min       = Math.min;
module.exports = function(it){
  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991
};

/***/ },
/* 237 */
/***/ function(module, exports, __webpack_require__) {

// 7.1.13 ToObject(argument)
var defined = __webpack_require__(225);
module.exports = function(it){
  return Object(defined(it));
};

/***/ },
/* 238 */
/***/ function(module, exports, __webpack_require__) {

// 7.1.1 ToPrimitive(input [, PreferredType])
var isObject = __webpack_require__(41);
// instead of the ES6 spec version, we didn't implement @@toPrimitive case
// and the second argument - flag - preferred type is a string
module.exports = function(it, S){
  if(!isObject(it))return it;
  var fn, val;
  if(S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  if(typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it)))return val;
  if(!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it)))return val;
  throw TypeError("Can't convert object to primitive value");
};

/***/ },
/* 239 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
'use strict';
// 22.1.3.8 Array.prototype.find(predicate, thisArg = undefined)
var $export = __webpack_require__(53)
  , $find   = __webpack_require__(222)(5)
  , KEY     = 'find'
  , forced  = true;
// Shouldn't skip holes
if(KEY in [])Array(1)[KEY](function(){ forced = false; });
$export($export.P + $export.F * forced, 'Array', {
  find: function find(callbackfn/*, that = undefined */){
    return $find(this, callbackfn, arguments.length > 1 ? arguments[1] : undefined);
  }
});
__webpack_require__(220)(KEY);

/***/ },
/* 240 */
/***/ function(module, exports, __webpack_require__) {

// 20.2.2.21 Math.log10(x)
var $export = __webpack_require__(53);

$export($export.S, 'Math', {
  log10: function log10(x){
    return Math.log(x) / Math.LN10;
  }
});

/***/ },
/* 241 */
/***/ function(module, exports, __webpack_require__) {

// 20.2.2.22 Math.log2(x)
var $export = __webpack_require__(53);

$export($export.S, 'Math', {
  log2: function log2(x){
    return Math.log(x) / Math.LN2;
  }
});

/***/ },
/* 242 */
/***/ function(module, exports, __webpack_require__) {

var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
(function (root, definition) {
    "use strict";
    if (true) {
        !(__WEBPACK_AMD_DEFINE_FACTORY__ = (definition), __WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ? (__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) : __WEBPACK_AMD_DEFINE_FACTORY__), __WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof module === 'object' && module.exports) {
        module.exports = definition();
    } else {
        root.log = definition();
    }
}(this, function () {
    "use strict";
    var noop = function() {};
    var undefinedType = "undefined";

    function realMethod(methodName) {
        if (typeof console === undefinedType) {
            return false; // We can't build a real method without a console to log to
        } else if (console[methodName] !== undefined) {
            return bindMethod(console, methodName);
        } else if (console.log !== undefined) {
            return bindMethod(console, 'log');
        } else {
            return noop;
        }
    }

    function bindMethod(obj, methodName) {
        var method = obj[methodName];
        if (typeof method.bind === 'function') {
            return method.bind(obj);
        } else {
            try {
                return Function.prototype.bind.call(method, obj);
            } catch (e) {
                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
                return function() {
                    return Function.prototype.apply.apply(method, [obj, arguments]);
                };
            }
        }
    }

    // these private functions always need `this` to be set properly

    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
        return function () {
            if (typeof console !== undefinedType) {
                replaceLoggingMethods.call(this, level, loggerName);
                this[methodName].apply(this, arguments);
            }
        };
    }

    function replaceLoggingMethods(level, loggerName) {
        /*jshint validthis:true */
        for (var i = 0; i < logMethods.length; i++) {
            var methodName = logMethods[i];
            this[methodName] = (i < level) ?
                noop :
                this.methodFactory(methodName, level, loggerName);
        }
    }

    function defaultMethodFactory(methodName, level, loggerName) {
        /*jshint validthis:true */
        return realMethod(methodName) ||
               enableLoggingWhenConsoleArrives.apply(this, arguments);
    }

    var logMethods = [
        "trace",
        "debug",
        "info",
        "warn",
        "error"
    ];

    function Logger(name, defaultLevel, factory) {
      var self = this;
      var currentLevel;
      var storageKey = "loglevel";
      if (name) {
        storageKey += ":" + name;
      }

      function persistLevelIfPossible(levelNum) {
          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

          // Use localStorage if available
          try {
              window.localStorage[storageKey] = levelName;
              return;
          } catch (ignore) {}

          // Use session cookie as fallback
          try {
              window.document.cookie =
                encodeURIComponent(storageKey) + "=" + levelName + ";";
          } catch (ignore) {}
      }

      function getPersistedLevel() {
          var storedLevel;

          try {
              storedLevel = window.localStorage[storageKey];
          } catch (ignore) {}

          if (typeof storedLevel === undefinedType) {
              try {
                  var cookie = window.document.cookie;
                  var location = cookie.indexOf(
                      encodeURIComponent(storageKey) + "=");
                  if (location) {
                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
                  }
              } catch (ignore) {}
          }

          // If the stored level is not valid, treat it as if nothing was stored.
          if (self.levels[storedLevel] === undefined) {
              storedLevel = undefined;
          }

          return storedLevel;
      }

      /*
       *
       * Public API
       *
       */

      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
          "ERROR": 4, "SILENT": 5};

      self.methodFactory = factory || defaultMethodFactory;

      self.getLevel = function () {
          return currentLevel;
      };

      self.setLevel = function (level, persist) {
          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
              level = self.levels[level.toUpperCase()];
          }
          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
              currentLevel = level;
              if (persist !== false) {  // defaults to true
                  persistLevelIfPossible(level);
              }
              replaceLoggingMethods.call(self, level, name);
              if (typeof console === undefinedType && level < self.levels.SILENT) {
                  return "No console available for logging";
              }
          } else {
              throw "log.setLevel() called with invalid level: " + level;
          }
      };

      self.setDefaultLevel = function (level) {
          if (!getPersistedLevel()) {
              self.setLevel(level, false);
          }
      };

      self.enableAll = function(persist) {
          self.setLevel(self.levels.TRACE, persist);
      };

      self.disableAll = function(persist) {
          self.setLevel(self.levels.SILENT, persist);
      };

      // Initialize with the right level
      var initialLevel = getPersistedLevel();
      if (initialLevel == null) {
          initialLevel = defaultLevel == null ? "WARN" : defaultLevel;
      }
      self.setLevel(initialLevel, false);
    }

    /*
     *
     * Package-level API
     *
     */

    var defaultLogger = new Logger();

    var _loggersByName = {};
    defaultLogger.getLogger = function getLogger(name) {
        if (typeof name !== "string" || name === "") {
          throw new TypeError("You must supply a name when creating a logger.");
        }

        var logger = _loggersByName[name];
        if (!logger) {
          logger = _loggersByName[name] = new Logger(
            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
        }
        return logger;
    };

    // Grab the current global log variable in case of overwrite
    var _log = (typeof window !== undefinedType) ? window.log : undefined;
    defaultLogger.noConflict = function() {
        if (typeof window !== undefinedType &&
               window.log === defaultLogger) {
            window.log = _log;
        }

        return defaultLogger;
    };

    return defaultLogger;
}));


/***/ },
/* 243 */
/***/ function(module, exports, __webpack_require__) {

/* WEBPACK VAR INJECTION */(function(process) {// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.

// resolves . and .. elements in a path array with directory names there
// must be no slashes, empty elements, or device names (c:\) in the array
// (so also no leading and trailing slashes - it does not distinguish
// relative and absolute paths)
function normalizeArray(parts, allowAboveRoot) {
  // if the path tries to go above the root, `up` ends up > 0
  var up = 0;
  for (var i = parts.length - 1; i >= 0; i--) {
    var last = parts[i];
    if (last === '.') {
      parts.splice(i, 1);
    } else if (last === '..') {
      parts.splice(i, 1);
      up++;
    } else if (up) {
      parts.splice(i, 1);
      up--;
    }
  }

  // if the path is allowed to go above the root, restore leading ..s
  if (allowAboveRoot) {
    for (; up--; up) {
      parts.unshift('..');
    }
  }

  return parts;
}

// Split a filename into [root, dir, basename, ext], unix version
// 'root' is just a slash, or nothing.
var splitPathRe =
    /^(\/?|)([\s\S]*?)((?:\.{1,2}|[^\/]+?|)(\.[^.\/]*|))(?:[\/]*)$/;
var splitPath = function(filename) {
  return splitPathRe.exec(filename).slice(1);
};

// path.resolve([from ...], to)
// posix version
exports.resolve = function() {
  var resolvedPath = '',
      resolvedAbsolute = false;

  for (var i = arguments.length - 1; i >= -1 && !resolvedAbsolute; i--) {
    var path = (i >= 0) ? arguments[i] : process.cwd();

    // Skip empty and invalid entries
    if (typeof path !== 'string') {
      throw new TypeError('Arguments to path.resolve must be strings');
    } else if (!path) {
      continue;
    }

    resolvedPath = path + '/' + resolvedPath;
    resolvedAbsolute = path.charAt(0) === '/';
  }

  // At this point the path should be resolved to a full absolute path, but
  // handle relative paths to be safe (might happen when process.cwd() fails)

  // Normalize the path
  resolvedPath = normalizeArray(filter(resolvedPath.split('/'), function(p) {
    return !!p;
  }), !resolvedAbsolute).join('/');

  return ((resolvedAbsolute ? '/' : '') + resolvedPath) || '.';
};

// path.normalize(path)
// posix version
exports.normalize = function(path) {
  var isAbsolute = exports.isAbsolute(path),
      trailingSlash = substr(path, -1) === '/';

  // Normalize the path
  path = normalizeArray(filter(path.split('/'), function(p) {
    return !!p;
  }), !isAbsolute).join('/');

  if (!path && !isAbsolute) {
    path = '.';
  }
  if (path && trailingSlash) {
    path += '/';
  }

  return (isAbsolute ? '/' : '') + path;
};

// posix version
exports.isAbsolute = function(path) {
  return path.charAt(0) === '/';
};

// posix version
exports.join = function() {
  var paths = Array.prototype.slice.call(arguments, 0);
  return exports.normalize(filter(paths, function(p, index) {
    if (typeof p !== 'string') {
      throw new TypeError('Arguments to path.join must be strings');
    }
    return p;
  }).join('/'));
};


// path.relative(from, to)
// posix version
exports.relative = function(from, to) {
  from = exports.resolve(from).substr(1);
  to = exports.resolve(to).substr(1);

  function trim(arr) {
    var start = 0;
    for (; start < arr.length; start++) {
      if (arr[start] !== '') break;
    }

    var end = arr.length - 1;
    for (; end >= 0; end--) {
      if (arr[end] !== '') break;
    }

    if (start > end) return [];
    return arr.slice(start, end - start + 1);
  }

  var fromParts = trim(from.split('/'));
  var toParts = trim(to.split('/'));

  var length = Math.min(fromParts.length, toParts.length);
  var samePartsLength = length;
  for (var i = 0; i < length; i++) {
    if (fromParts[i] !== toParts[i]) {
      samePartsLength = i;
      break;
    }
  }

  var outputParts = [];
  for (var i = samePartsLength; i < fromParts.length; i++) {
    outputParts.push('..');
  }

  outputParts = outputParts.concat(toParts.slice(samePartsLength));

  return outputParts.join('/');
};

exports.sep = '/';
exports.delimiter = ':';

exports.dirname = function(path) {
  var result = splitPath(path),
      root = result[0],
      dir = result[1];

  if (!root && !dir) {
    // No dirname whatsoever
    return '.';
  }

  if (dir) {
    // It has a dirname, strip trailing slash
    dir = dir.substr(0, dir.length - 1);
  }

  return root + dir;
};


exports.basename = function(path, ext) {
  var f = splitPath(path)[2];
  // TODO: make this comparison case-insensitive on windows?
  if (ext && f.substr(-1 * ext.length) === ext) {
    f = f.substr(0, f.length - ext.length);
  }
  return f;
};


exports.extname = function(path) {
  return splitPath(path)[3];
};

function filter (xs, f) {
    if (xs.filter) return xs.filter(f);
    var res = [];
    for (var i = 0; i < xs.length; i++) {
        if (f(xs[i], i, xs)) res.push(xs[i]);
    }
    return res;
}

// String.prototype.substr - negative index don't work in IE8
var substr = 'ab'.substr(-1) === 'b'
    ? function (str, start, len) { return str.substr(start, len) }
    : function (str, start, len) {
        if (start < 0) start = str.length + start;
        return str.substr(start, len);
    }
;

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(244)))

/***/ },
/* 244 */
/***/ function(module, exports) {

// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout () {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
} ())
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch(e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch(e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }


}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e){
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e){
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }



}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while(len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () { return '/' };
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function() { return 0; };


/***/ },
/* 245 */
/***/ function(module, exports, __webpack_require__) {

// stats.js - http://github.com/mrdoob/stats.js
(function(f,e){ true?module.exports=e():"function"===typeof define&&define.amd?define(e):f.Stats=e()})(this,function(){var f=function(){function e(a){c.appendChild(a.dom);return a}function u(a){for(var d=0;d<c.children.length;d++)c.children[d].style.display=d===a?"block":"none";l=a}var l=0,c=document.createElement("div");c.style.cssText="position:fixed;top:0;left:0;cursor:pointer;opacity:0.9;z-index:10000";c.addEventListener("click",function(a){a.preventDefault();
u(++l%c.children.length)},!1);var k=(performance||Date).now(),g=k,a=0,r=e(new f.Panel("FPS","#0ff","#002")),h=e(new f.Panel("MS","#0f0","#020"));if(self.performance&&self.performance.memory)var t=e(new f.Panel("MB","#f08","#201"));u(0);return{REVISION:16,dom:c,addPanel:e,showPanel:u,begin:function(){k=(performance||Date).now()},end:function(){a++;var c=(performance||Date).now();h.update(c-k,200);if(c>g+1E3&&(r.update(1E3*a/(c-g),100),g=c,a=0,t)){var d=performance.memory;t.update(d.usedJSHeapSize/
1048576,d.jsHeapSizeLimit/1048576)}return c},update:function(){k=this.end()},domElement:c,setMode:u}};f.Panel=function(e,f,l){var c=Infinity,k=0,g=Math.round,a=g(window.devicePixelRatio||1),r=80*a,h=48*a,t=3*a,v=2*a,d=3*a,m=15*a,n=74*a,p=30*a,q=document.createElement("canvas");q.width=r;q.height=h;q.style.cssText="width:80px;height:48px";var b=q.getContext("2d");b.font="bold "+9*a+"px Helvetica,Arial,sans-serif";b.textBaseline="top";b.fillStyle=l;b.fillRect(0,0,r,h);b.fillStyle=f;b.fillText(e,t,v);
b.fillRect(d,m,n,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d,m,n,p);return{dom:q,update:function(h,w){c=Math.min(c,h);k=Math.max(k,h);b.fillStyle=l;b.globalAlpha=1;b.fillRect(0,0,r,m);b.fillStyle=f;b.fillText(g(h)+" "+e+" ("+g(c)+"-"+g(k)+")",t,v);b.drawImage(q,d+a,m,n-a,p,d,m,n-a,p);b.fillRect(d+n-a,m,a,p);b.fillStyle=l;b.globalAlpha=.9;b.fillRect(d+n-a,m,a,g((1-h/w)*p))}}};return f});


/***/ },
/* 246 */
/***/ function(module, exports, __webpack_require__) {

// Unique ID creation requires a high quality random # generator.  We feature
// detect to determine the best RNG source, normalizing to a function that
// returns 128-bits of randomness, since that's what's usually required
var rng = __webpack_require__(179);
var bytesToUuid = __webpack_require__(178);

// **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html

// random #'s we need to init node and clockseq
var _seedBytes = rng();

// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
var _nodeId = [
  _seedBytes[0] | 0x01,
  _seedBytes[1], _seedBytes[2], _seedBytes[3], _seedBytes[4], _seedBytes[5]
];

// Per 4.2.2, randomize (14 bit) clockseq
var _clockseq = (_seedBytes[6] << 8 | _seedBytes[7]) & 0x3fff;

// Previous uuid creation time
var _lastMSecs = 0, _lastNSecs = 0;

// See https://github.com/broofa/node-uuid for API details
function v1(options, buf, offset) {
  var i = buf && offset || 0;
  var b = buf || [];

  options = options || {};

  var clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq;

  // UUID timestamps are 100 nano-second units since the Gregorian epoch,
  // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
  // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
  // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
  var msecs = options.msecs !== undefined ? options.msecs : new Date().getTime();

  // Per 4.2.1.2, use count of uuid's generated during the current clock
  // cycle to simulate higher resolution clock
  var nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1;

  // Time since last uuid creation (in msecs)
  var dt = (msecs - _lastMSecs) + (nsecs - _lastNSecs)/10000;

  // Per 4.2.1.2, Bump clockseq on clock regression
  if (dt < 0 && options.clockseq === undefined) {
    clockseq = clockseq + 1 & 0x3fff;
  }

  // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
  // time interval
  if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
    nsecs = 0;
  }

  // Per 4.2.1.2 Throw error if too many uuids are requested
  if (nsecs >= 10000) {
    throw new Error('uuid.v1(): Can\'t create more than 10M uuids/sec');
  }

  _lastMSecs = msecs;
  _lastNSecs = nsecs;
  _clockseq = clockseq;

  // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
  msecs += 12219292800000;

  // `time_low`
  var tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
  b[i++] = tl >>> 24 & 0xff;
  b[i++] = tl >>> 16 & 0xff;
  b[i++] = tl >>> 8 & 0xff;
  b[i++] = tl & 0xff;

  // `time_mid`
  var tmh = (msecs / 0x100000000 * 10000) & 0xfffffff;
  b[i++] = tmh >>> 8 & 0xff;
  b[i++] = tmh & 0xff;

  // `time_high_and_version`
  b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
  b[i++] = tmh >>> 16 & 0xff;

  // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
  b[i++] = clockseq >>> 8 | 0x80;

  // `clock_seq_low`
  b[i++] = clockseq & 0xff;

  // `node`
  var node = options.node || _nodeId;
  for (var n = 0; n < 6; ++n) {
    b[i + n] = node[n];
  }

  return buf ? buf : bytesToUuid(b);
}

module.exports = v1;


/***/ },
/* 247 */
/***/ function(module, exports, __webpack_require__) {

var rng = __webpack_require__(179);
var bytesToUuid = __webpack_require__(178);

function v4(options, buf, offset) {
  var i = buf && offset || 0;

  if (typeof(options) == 'string') {
    buf = options == 'binary' ? new Array(16) : null;
    options = null;
  }
  options = options || {};

  var rnds = options.random || (options.rng || rng)();

  // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
  rnds[6] = (rnds[6] & 0x0f) | 0x40;
  rnds[8] = (rnds[8] & 0x3f) | 0x80;

  // Copy bytes to buffer, if provided
  if (buf) {
    for (var ii = 0; ii < 16; ++ii) {
      buf[i + ii] = rnds[ii];
    }
  }

  return buf || bytesToUuid(rnds);
}

module.exports = v4;


/***/ },
/* 248 */
/***/ function(module, exports, __webpack_require__) {

var map = {
	"./AudioListener.ts": 68,
	"./AudioSource.ts": 69,
	"./BoundingBoxRenderer.ts": 70,
	"./CubeMapCapture.ts": 71,
	"./Curve.ts": 72,
	"./DebugConsoleDisplay.ts": 73,
	"./DebugPerformance.ts": 74,
	"./DebugTextureViewer.ts": 75,
	"./DynamicOptimizer.ts": 76,
	"./EventHandler.ts": 77,
	"./Exploder.ts": 78,
	"./FreeCamera.ts": 79,
	"./Fullscreen.ts": 80,
	"./GamepadInput.ts": 81,
	"./InputController.ts": 82,
	"./KeyframeAnimation.ts": 83,
	"./LightEnvironment.ts": 84,
	"./LookAtTarget.ts": 85,
	"./MaterialCapture.ts": 86,
	"./NormalMapGenerator.ts": 87,
	"./ObjectAnimator.ts": 88,
	"./ObjectPicker.ts": 89,
	"./OrbitCameraController.ts": 90,
	"./PanoramaToCubeMap.ts": 91,
	"./PreviewAxisRotation.ts": 92,
	"./PreviewCameraFocus.ts": 93,
	"./ReflectionCapturePlane.ts": 94,
	"./RenderModes.ts": 95,
	"./RenderView.ts": 45,
	"./Renderer.ts": 96,
	"./Rotate.ts": 97,
	"./SimplexNoiseGenerator.ts": 98,
	"./Skybox.ts": 99,
	"./TextRenderer.ts": 100,
	"./VrCameraController.ts": 101,
	"./VrHandController.ts": 46,
	"./VrHandControllerAnimator.ts": 102,
	"./VrPresenter.ts": 103,
	"./VrRenderView.ts": 104
};
function webpackContext(req) {
	return __webpack_require__(webpackContextResolve(req));
};
function webpackContextResolve(req) {
	var id = map[req];
	if(!(id + 1)) // check for number
		throw new Error("Cannot find module '" + req + "'.");
	return id;
};
webpackContext.keys = function webpackContextKeys() {
	return Object.keys(map);
};
webpackContext.resolve = webpackContextResolve;
module.exports = webpackContext;
webpackContext.id = 248;


/***/ },
/* 249 */
/***/ function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {"use strict";
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
var THREE = __webpack_require__(1);
__webpack_require__(182);
__webpack_require__(184);
__webpack_require__(183);
// Export THREE as an additional global. Do we really need to do this? maybe
// we shouldn't and allow the user to set window.THREE to Box3D.THREE if they
// need it?
global.THREE = THREE;
__export(__webpack_require__(181));

/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__(42)))

/***/ }
/******/ ]);
});
//# sourceMappingURL=box3d-runtime.js.map